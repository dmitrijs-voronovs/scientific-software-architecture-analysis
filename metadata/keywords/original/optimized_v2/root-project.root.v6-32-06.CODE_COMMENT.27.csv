quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,/// Returns true if basic block \p BB is suggested to be size-optimized based on; /// the profile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h:62,optimiz,optimized,62,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h,1,['optimiz'],['optimized']
Performance,/// Returns true if function \p F is suggested to be size-optimized based on the; /// profile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h:58,optimiz,optimized,58,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h,1,['optimiz'],['optimized']
Performance,"/// Returns true if is legal to hoist or sink this instruction disregarding the; /// possible introduction of faults. Reasoning about potential faulting; /// instructions is the responsibility of the caller since it is challenging to; /// do efficiently from within this routine.; /// \p TargetExecutesOncePerLoop is true only when it is guaranteed that the; /// target executes at most once per execution of the loop body. This is used; /// to assess the legality of duplicating atomic loads. Generally, this is; /// true when moving out of loop and not true when moving into loops.; /// If \p ORE is set use it to emit optimization remarks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:487,load,loads,487,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,2,"['load', 'optimiz']","['loads', 'optimization']"
Performance,"/// Returns true if it is able to pattern match an addressing mode.; /// It returns the operands which make up the maximal addressing mode it can; /// match by reference.; ///; /// Parent is the parent node of the addr operand that is being matched. It; /// is always a load, store, atomic node, or null. It is only null when; /// checking memory operands for inline asm nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:270,load,load,270,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['load'],['load']
Performance,/// Returns true if it is beneficial to convert a load of a constant; /// to just the constant itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:50,load,load,50,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,7,['load'],['load']
Performance,/// Returns true if it is illegal to fold a load across this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:44,load,load,44,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['load'],['load']
Performance,"/// Returns true if it's safe to use load / store of the specified type to; /// expand memcpy / memset inline.; ///; /// This is mostly true for all types except for some special cases. For; /// example, on X86 targets without SSE2 f64 load / store are done with fldl /; /// fstpl which also does type conversion. Note the specified type doesn't; /// have to be legal as the hook is used before type legalization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:37,load,load,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],['load']
Performance,"/// Returns true if it's safe to use load / store of the; /// specified type to expand memcpy / memset inline. This is mostly true; /// for all types except for some special cases. For example, on X86; /// targets without SSE2 f64 load / store are done with fldl / fstpl which; /// also does type conversion. Note the specified type doesn't have to be; /// legal as the hook is used before type legalization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:37,load,load,37,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,2,['load'],['load']
Performance,/// Returns true if machine basic block \p MBB is suggested to be size-optimized; /// based on the profile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h:71,optimiz,optimized,71,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h,2,['optimiz'],['optimized']
Performance,/// Returns true if machine function \p MF is suggested to be size-optimized; /// based on the profile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h:67,optimiz,optimized,67,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h,1,['optimiz'],['optimized']
Performance,"/// Returns true if the 'true' and 'false' blocks (along with their common; /// predecessor) forms a valid triangle shape for ifcvt. If 'FalseBranch' is; /// true, it checks if 'true' block's false branch branches to the 'false' block; /// rather than the other way around. It also returns the number of instructions; /// that the ifcvt would need to duplicate if performed in 'Dups'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:364,perform,performed,364,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['perform'],['performed']
Performance,/// Returns true if the 'true' block (along with its predecessor) forms a valid; /// simple shape for ifcvt. It also returns the number of instructions that the; /// ifcvt would need to duplicate if performed in Dups.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:199,perform,performed,199,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['perform'],['performed']
Performance,/// Returns true if the LLT is a scalable vector. Must only be called on; /// vector types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:33,scalab,scalable,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,1,['scalab'],['scalable']
Performance,"/// Returns true if the LLT is a scalable vector. Returns false otherwise,; /// even if the LLT is not a vector type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:33,scalab,scalable,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,1,['scalab'],['scalable']
Performance,"/// Returns true if the addressing mode representing by AM is legal; /// for the Thumb1 target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h:102,load,load,102,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.h,1,['load'],['load']
Performance,/// Returns true if the analysis manager has an empty results cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:62,cache,cache,62,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['cache']
Performance,/// Returns true if the current cycle plus remaning latency is greater than; /// the critical path in the scheduling region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,latency,latency,52,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['latency'],['latency']
Performance,/// Returns true if the definition of this global may be replaced by a; /// differently optimized variant of the same source level function at link; /// time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:88,optimiz,optimized,88,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['optimiz'],['optimized']
Performance,/// Returns true if the given block should be optimized for size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h:46,optimiz,optimized,46,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,1,['optimiz'],['optimized']
Performance,"/// Returns true if the given increment is a Constant known to be equal to the; /// access size performed by a NEON load/store. This means the ""[rN]!"" form can; /// be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:96,perform,performed,96,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,2,"['load', 'perform']","['load', 'performed']"
Performance,"/// Returns true if the instruction \p MI may alias \p Other.; /// This function uses multiple strategies to detect aliasing, whereas; /// aliasIsKnownForLoadStore just looks at the addresses of load/stores and is; /// tries to reason about base/index/offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h:195,load,load,195,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,1,['load'],['load']
Performance,"/// Returns true if the instruction has no behavior (specified or otherwise); /// that is based on the value loaded from memory or the value of any; /// non-address register operands.; ///; /// For example, if the latency of the instruction is dependent on the; /// particular bits set in any of the registers *or* any of the bits loaded; /// from memory.; ///; /// Instructions are considered data invariant even if they set EFLAGS.; ///; /// A classical example of something that is inherently not data invariant is; /// an indirect jump -- the destination is loaded into icache based on the; /// bits set in the jump destination register.; ///; /// FIXME: This should become part of our instruction tables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:109,load,loaded,109,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,4,"['latency', 'load']","['latency', 'loaded']"
Performance,/// Returns true if the instruction has no behavior (specified or otherwise); /// that is based on the value of any of its register operands; ///; /// Instructions are considered data invariant even if they set EFLAGS.; ///; /// A classical example of something that is inherently not data invariant is; /// an indirect jump -- the destination is loaded into icache based on the; /// bits set in the jump destination register.; ///; /// FIXME: This should become part of our instruction tables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:347,load,loaded,347,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,1,['load'],['loaded']
Performance,"/// Returns true if the loop is annotated parallel.; ///; /// A parallel loop can be assumed to not contain any dependencies between; /// iterations by the compiler. That is, any loop-carried dependency checking; /// can be skipped completely when parallelizing the loop on the target; /// machine. Thus, if the parallel loop information originates from the; /// programmer, e.g. via the OpenMP parallel for pragma, it is the; /// programmer's responsibility to ensure there are no loop-carried; /// dependencies. The final execution order of the instructions across; /// iterations is not guaranteed, thus, the end result might or might not; /// implement actual concurrent execution of instructions across multiple; /// iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:664,concurren,concurrent,664,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,1,['concurren'],['concurrent']
Performance,"/// Returns true if the model was loaded successfully, false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h:34,load,loaded,34,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,1,['load'],['loaded']
Performance,/// Returns true if the register operand can be folded with a load or store; /// into a frame index. Does so by checking the InlineAsm::Flag immediate; /// operand at OpId - 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:62,load,load,62,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['load'],['load']
Performance,/// Returns true if the specified SDep is equivalent except for latency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:64,latency,latency,64,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,2,['latency'],['latency']
Performance,/// Returns true if the specified base+offset is a legal indexed addressing; /// mode for this target. \p MI is the load or store instruction that is being; /// considered for transformation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:116,load,load,116,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,/// Returns true if the specified node is a non-extending and unindexed load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:72,load,load,72,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['load'],['load']
Performance,/// Returns true if the specified node is a non-extending load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:58,load,load,58,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['load'],['load']
Performance,/// Returns true if the specified node is an unindexed load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:55,load,load,55,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['load'],['load']
Performance,"/// Returns true if the target can instruction select the specified FP; /// immediate natively. If false, the legalizer will materialize the FP; /// immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:164,load,load,164,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,"/// Returns true if the target can instruction select the; /// specified FP immediate natively. If false, the legalizer will; /// materialize the FP immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:164,load,load,164,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['load'],['load']
Performance,/// Returns true if the target machine supports masked load operation; /// for the given \p DataType and kind of access to \p Ptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:55,load,load,55,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['load'],['load']
Performance,"/// Returns true if the two given memory operations should be scheduled; /// adjacent. Note that you have to add:; /// DAG->addMutation(createLoadClusterDAGMutation(DAG->TII, DAG->TRI));; /// or; /// DAG->addMutation(createStoreClusterDAGMutation(DAG->TII, DAG->TRI));; /// to TargetPassConfig::createMachineScheduler() to have an effect.; ///; /// \p BaseOps1 and \p BaseOps2 are memory operands of two memory operations.; /// \p Offset1 and \p Offset2 are the byte offsets for the memory; /// operations.; /// \p OffsetIsScalable1 and \p OffsetIsScalable2 indicate if the offset is; /// scaled by a runtime quantity.; /// \p ClusterSize is the number of operations in the resulting load/store; /// cluster if this hook returns true.; /// \p NumBytes is the number of bytes that will be loaded from all the; /// clustered loads if this hook returns true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:684,load,load,684,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,3,['load'],"['load', 'loaded', 'loads']"
Performance,"/// Returns true if the uses of an interleaved load by the; /// extractelement instructions in \p Extracts can be replaced by uses of the; /// shufflevector instructions in \p Shuffles instead. If so, the necessary; /// replacements are also performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:47,load,load,47,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,2,"['load', 'perform']","['load', 'performed']"
Performance,/// Returns true if there are DominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or DT is nullptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:52,queue,queued,52,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,1,['queue'],['queued']
Performance,/// Returns true if there are PostDominatorTree updates queued.; /// Returns false under Eager UpdateStrategy or PDT is nullptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:56,queue,queued,56,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,1,['queue'],['queued']
Performance,/// Returns true if there was a problem loading the preprocessed; /// entity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:40,load,loading,40,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['load'],['loading']
Performance,"/// Returns true if this LEA uses base and index registers, and the base; /// register is known to be inefficient for the subtarget.; // TODO: use a variant scheduling class to model the latency profile; // of LEA instructions, and implement this logic as a scheduling predicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:187,latency,latency,187,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,1,['latency'],['latency']
Performance,/// Returns true if this builtin does not perform the side-effects; /// of its arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Builtins.h:42,perform,perform,42,interpreter/llvm-project/clang/include/clang/Basic/Builtins.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Builtins.h,1,['perform'],['perform']
Performance,"/// Returns true if this function does not have to be handled.; /// General intent for this predicate is to provide an optimization; /// for functions that do not need this attribute inference at all; /// (say, for functions that already have the attribute).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:119,optimiz,optimization,119,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['optimiz'],['optimization']
Performance,"/// Returns true if this function needs a local user-space stack pointer.; /// Unlike a machine stack pointer, the wasm user stack pointer is a global; /// variable, so it is loaded into a register in the prolog.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp:175,load,loaded,175,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFrameLowering.cpp,1,['load'],['loaded']
Performance,"/// Returns true if this global's definition will be the one chosen by the; /// linker.; ///; /// NB! Ideally this should not be used at the IR level at all. If you're; /// interested in optimization constraints implied by the linker's ability to; /// choose an implementation, prefer using \c hasExactDefinition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:187,optimiz,optimization,187,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['optimiz'],['optimization']
Performance,"/// Returns true if this instruction has the same cost (or less) than a move; /// instruction. This is useful during certain types of optimizations; /// (e.g., remat during two-address conversion or machine licm); /// where we would like to remat or hoist the instruction, but not if it costs; /// more than moving the instruction into the appropriate register. Note, we; /// are not marking copies from and to the same register class with this flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:134,optimiz,optimizations,134,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['optimiz'],['optimizations']
Performance,"/// Returns true if this instruction has the same cost (or less) than a; /// move instruction. This is useful during certain types of optimizations; /// (e.g., remat during two-address conversion or machine licm) where we would; /// like to remat or hoist the instruction, but not if it costs more than; /// moving the instruction into the appropriate register. Note, we are not; /// marking copies from and to the same register class with this flag.; ///; /// This method could be called by interface TargetInstrInfo::isAsCheapAsAMove; /// for different subtargets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h:134,optimiz,optimizations,134,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,1,['optimiz'],['optimizations']
Performance,/// Returns true if this struct contains a scalable vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:43,scalab,scalable,43,interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,1,['scalab'],['scalable']
Performance,"/// Returns true if this struct contains homogeneous scalable vector types.; /// Note that the definition of homogeneous scalable vector type is not; /// recursive here. That means the following structure will return false; /// when calling this function.; /// {{<vscale x 2 x i32>, <vscale x 4 x i64>},; /// {<vscale x 2 x i32>, <vscale x 4 x i64>}}",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:53,scalab,scalable,53,interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,2,['scalab'],['scalable']
Performance,"/// Returns true if this value's address is not significant in this module.; /// This attribute is intended to be used only by the code generator and LTO; /// to allow the linker to decide whether the global needs to be in the symbol; /// table. It should probably not be used in optimizations, as the value may; /// have uses outside the module; use hasGlobalUnnamedAddr() instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:280,optimiz,optimizations,280,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['optimiz'],['optimizations']
Performance,"/// Returns true if virtual dispatch is performed.; /// If the member access is fully qualified, (i.e. X::f()), virtual; /// dispatching is not performed. In -fapple-kext mode qualified; /// calls to virtual method will still go through the vtable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:40,perform,performed,40,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,2,['perform'],['performed']
Performance,/// Returns true if we are performing any kind of LTO.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:27,perform,performing,27,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['perform'],['performing']
Performance,"/// Returns true if we should use a direct load into vector instruction; /// (such as lxsd or lfd), instead of a load into gpr + direct move sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:43,load,load,43,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['load'],['load']
Performance,/// Returns true iff the optimization remark holds a valid regular; /// expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:25,optimiz,optimization,25,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,1,['optimiz'],['optimization']
Performance,/// Returns true when the rule has a source selection requirement that has; /// to be fulfilled before refactoring can be performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:122,perform,performed,122,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,1,['perform'],['performed']
Performance,"/// Returns true, if metadata on \p BI allows us to optimize branching into \p; /// TakenSucc via injection of invariant conditions. The branch should be not; /// enough and not previously unswitched, the information about this comes from; /// the metadata.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:52,optimiz,optimize,52,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['optimiz'],['optimize']
Performance,"/// Returns true, if predicate described by ( \p Pred, \p LHS, \p RHS ); /// succeeding into blocks ( \p IfTrue, \p IfFalse) can be optimized by; /// injecting a loop-invariant condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:132,optimiz,optimized,132,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['optimiz'],['optimized']
Performance,/// Returns whether or not generating a interleaved load/store intrinsic for; /// this type will be legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:52,load,load,52,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['load'],['load']
Performance,/// Returns whether the given function is an empty C++ destructor and can; /// therefore be eliminated.; /// Note that we assume that other optimization passes have already simplified; /// the code so we simply check for 'ret'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:140,optimiz,optimization,140,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['optimiz'],['optimization']
Performance,/// Returns whether the given load byte size is amenable to inlined; /// optimization patterns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:30,load,load,30,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,2,"['load', 'optimiz']","['load', 'optimization']"
Performance,/// Returns whether the given record has hidden LTO visibility and therefore; /// may participate in (single-module) CFI and whole-program vtable; /// optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:151,optimiz,optimization,151,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['optimiz'],['optimization']
Performance,/// Returns whether the given record has public LTO visibility (regardless of; /// -lto-whole-program-visibility) and therefore may not participate in; /// (single-module) CFI and whole-program vtable optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:201,optimiz,optimization,201,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['optimiz'],['optimization']
Performance,/// Returns whether the instruction is a paired load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:48,load,load,48,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,/// Returns whether the instruction is a pre-indexed load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:53,load,load,53,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,/// Returns whether the instruction is a pre-indexed load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:53,load,load,53,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,"/// Returns whether the ivar backing the property is an IBOutlet that; /// has its value set by nib loading code without retaining the value.; ///; /// On macOS, if there is no setter, the nib-loading code sets the ivar; /// directly, without retaining the value,; ///; /// On iOS and its derivatives, the nib-loading code will call; /// -setValue:forKey:, which retains the value before directly setting the ivar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:100,load,loading,100,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,3,['load'],['loading']
Performance,"/// Returns whether the object performed allocations.; ///; /// If APValues are constructed via placement new, \c needsCleanup(); /// indicates whether the destructor must be called in order to correctly; /// free all allocated memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/APValue.h:31,perform,performed,31,interpreter/llvm-project/clang/include/clang/AST/APValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/APValue.h,1,['perform'],['performed']
Performance,"/// Returns whether the records `Loc1` and `Loc2` are equal.; ///; /// Values for `Loc1` are retrieved from `Env1`, and values for `Loc2` are; /// retrieved from `Env2`. A convenience overload retrieves values for `Loc1`; /// and `Loc2` from the same environment.; ///; /// This performs a deep comparison, i.e. it compares every field (including; /// synthetic fields) and recurses on fields of record type. Fields of reference; /// type compare equal if they refer to the same storage location.; ///; /// Note on how to interpret the result:; /// - If this returns true, the records are guaranteed to be equal at runtime.; /// - If this returns false, the records may still be equal at runtime; our; /// analysis merely cannot guarantee that they will be equal.; ///; /// Requirements:; ///; /// `Src` and `Dst` must have the same canonical unqualified type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/RecordOps.h:279,perform,performs,279,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/RecordOps.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/RecordOps.h,1,['perform'],['performs']
Performance,/// Returns whether these results arose from performing a; /// lookup into a class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:45,perform,performing,45,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['perform'],['performing']
Performance,/// Returns whether we should perform a type checked load when loading a; /// virtual function for virtual calls to members of RD. This is generally; /// true when both vcall CFI and whole-program-vtables are enabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:30,perform,perform,30,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,3,"['load', 'perform']","['load', 'loading', 'perform']"
Performance,"/// Reuses previously-computed dividend or remainder from the current BB if; /// operands and operation are identical. Otherwise calls insertFastDivAndRem to; /// perform the optimization and caches the resulting dividend and remainder.; /// If no replacement can be generated, nullptr is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:163,perform,perform,163,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,3,"['cache', 'optimiz', 'perform']","['caches', 'optimization', 'perform']"
Performance,/// Reverse iterate over the cached postorder blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:29,cache,cached,29,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,2,['cache'],['cached']
Performance,/// Reverse iterator end-point to traverse all loaded modules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:47,load,loaded,47,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,/// Reverse iterator to traverse all loaded modules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:37,load,loaded,37,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,/// Reverse map from instruction to the objects it is the earliest escape for.; /// This is used for cache invalidation purposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:101,cache,cache,101,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['cache'],['cache']
Performance,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:566,queue,queues,566,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['queue'],['queues']
Performance,"/// Rewrite as many loads as possible given a single store.; ///; /// When there is only a single store, we can use the domtree to trivially; /// replace all of the dominated loads with the stored value. Do so, and return; /// true if this has successfully promoted the alloca entirely. If this returns; /// false there were some loads which were not dominated by the single store; /// and thus must be phi-ed with undef. We fall back to the standard alloca; /// promotion algorithm in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:20,load,loads,20,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,3,['load'],['loads']
Performance,/// Rewrite for the base load/store of a chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:25,load,load,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,/// Rewrite for the other load/stores of a chain according to the new \p; /// Base.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:26,load,load,26,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,"/// Rewrite image intrinsics to use register layouts expected by the subtarget.; ///; /// Depending on the subtarget, load/store with 16-bit element data need to be; /// rewritten to use the low half of 32-bit registers, or directly use a packed; /// layout. 16-bit addresses should also sometimes be packed into 32-bit; /// registers.; ///; /// We don't want to directly select image instructions just yet, but also want; /// to exposes all register repacking to the legalizer/combiners. We also don't; /// want a selected instruction entering RegBankSelect. In order to avoid; /// defining a multitude of intermediate image instructions, directly hack on; /// the intrinsic's arguments. In cases like a16 addresses, this requires; /// padding now unnecessary arguments with $noreg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:118,load,load,118,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['load'],['load']
Performance,/// Rewrite load/store according to the common chains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:12,load,load,12,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,/// Rewrite load/store instructions in \p BucketChain according to; /// preparation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:12,load,load,12,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,1,['load'],['load']
Performance,/// Rewrite loads and stores through a pointer and all pointers derived from; /// it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:12,load,loads,12,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['load'],['loads']
Performance,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:654,optimiz,optimization,654,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['optimiz'],['optimization']
Performance,/// Rewrites the kernel block in-place to adhere to the given schedule.; /// KernelRewriter holds all of the state required to perform the rewriting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:127,perform,perform,127,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['perform'],['perform']
Performance,/// Run - perform scheduling.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:10,perform,perform,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,2,['perform'],['perform']
Performance,/// Run a bisection iteration to improve the optimization goal; /// \returns the total number of moved FunctionNodes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h:45,optimiz,optimization,45,interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,1,['optimiz'],['optimization']
Performance,/// Run all OpenMP optimizations on the underlying SCC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:19,optimiz,optimizations,19,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['optimiz'],['optimizations']
Performance,/// Run checkers for load/store of a location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h:21,load,load,21,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,1,['load'],['load']
Performance,"/// Run checkers for post-visiting Stmts.; ///; /// The notification is performed for every explored CFGElement, which does; /// not include the control flow statements such as IfStmt.; ///; /// \sa runCheckersForBranchCondition, runCheckersForPreStmt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h:72,perform,performed,72,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,1,['perform'],['performed']
Performance,"/// Run instruction simplification across each instruction in the function.; ///; /// Instruction simplification has useful constraints in some contexts:; /// - It will never introduce *new* instructions.; /// - There is no need to iterate to a fixed point.; ///; /// Many passes use instruction simplification as a library facility, but it may; /// also be useful (in tests and other contexts) to have access to this very; /// restricted transform at a pass granularity. However, for a much more; /// powerful and comprehensive peephole optimization engine, see the; /// `instcombine` pass instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h:538,optimiz,optimization,538,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h,1,['optimiz'],['optimization']
Performance,/// Run recursive graph partitioning that optimizes a given objective.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h:42,optimiz,optimizes,42,interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,1,['optimiz'],['optimizes']
Performance,/// Run the algorithm and return an optimized ordering of nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:36,optimiz,optimized,36,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['optimiz'],['optimized']
Performance,/// Run the analysis pass and create our proxy result object.; ///; /// This doesn't do any interesting work; it is primarily used to insert our; /// proxy result object into the outer analysis cache so that we can proxy; /// invalidation to the inner analysis manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:194,cache,cache,194,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['cache']
Performance,"/// Run the pass over the function.; ///; /// This will lower all of the expect intrinsic calls in this function into; /// branch weight metadata. That metadata will subsequently feed the analysis; /// of the probabilities and frequencies of the CFG. After running this pass,; /// no more expect intrinsics remain, allowing the rest of the optimizer to; /// ignore them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerExpectIntrinsic.h:340,optimiz,optimizer,340,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerExpectIntrinsic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerExpectIntrinsic.h,1,['optimiz'],['optimizer']
Performance,"/// Run the pass over the function.; ///; /// This will lower all remaining 'objectsize' and 'is.constant'`; /// intrinsic calls in this function, even when the argument has no known; /// size or is not a constant respectively. The resulting constant is; /// propagated and conditional branches are resolved where possible.; /// This complements the Instruction Simplification and; /// Instruction Combination passes of the optimized pass chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerConstantIntrinsics.h:424,optimiz,optimized,424,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerConstantIntrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LowerConstantIntrinsics.h,1,['optimiz'],['optimized']
Performance,/// Runs (and deletes) the tool on 'Code' with the -fsyntax-only flag and; /// with additional other flags.; ///; /// \param ToolAction The action to run over the code.; /// \param Code C++ code.; /// \param Args Additional flags to pass on.; /// \param FileName The file name which 'Code' will be mapped as.; /// \param ToolName The name of the binary running the tool. Standard library; /// header paths will be resolved relative to this.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; ///; /// \return - True if 'ToolAction' was successfully executed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:500,load,loading,500,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,1,['load'],['loading']
Performance,/// Runs (and deletes) the tool on 'Code' with the -fsyntax-only flag.; ///; /// \param ToolAction The action to run over the code.; /// \param Code C++ code.; /// \param FileName The file name which 'Code' will be mapped as.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; ///; /// \return - True if 'ToolAction' was successfully executed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:285,load,loading,285,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,1,['load'],['loading']
Performance,/// Runs middle-end LTO optimizations on \p Mod.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTOBackend.h:24,optimiz,optimizations,24,interpreter/llvm-project/llvm/include/llvm/LTO/LTOBackend.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTOBackend.h,1,['optimiz'],['optimizations']
Performance,"/// Runs the LTO pipeline. This function calls the supplied AddStream; /// function to add native object files to the link.; ///; /// The Cache parameter is optional. If supplied, it will be used to cache; /// native object files and add them to the link.; ///; /// The client will receive at most one callback (via either AddStream or; /// Cache) for each task identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h:138,Cache,Cache,138,interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,3,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"/// Runs the vectorizer on one equivalence class, i.e. one set of loads/stores; /// in the same BB with the same value for getUnderlyingObject() etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:66,load,loads,66,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['load'],['loads']
Performance,"/// SCALAR_TO_VECTOR(VAL) - This represents the operation of loading a; /// scalar value into element 0 of the resultant vector type. The top; /// elements 1 to N-1 of the N-element vector are undefined. The type; /// of the operand must match the vector element type, except when they; /// are integer types. In this case the operand is allowed to be wider; /// than the vector element type, and is implicitly truncated to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:61,load,loading,61,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['load'],['loading']
Performance,"/// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to; /// sign extend a small value in a large integer register (e.g. sign; /// extending the low 8 bits of a 32-bit register to fill the top 24 bits; /// with the 7th bit). The size of the smaller type is indicated by the 1th; /// operand, a ValueType node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:49,perform,performs,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['perform'],['performs']
Performance,/// SO_Linker - Search as a call to dlsym(dlopen(NULL)) would when; /// DynamicLibrary::getPermanentLibrary(NULL) has been called or; /// search the list of explcitly loaded symbols if not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:167,load,loaded,167,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['load'],['loaded']
Performance,/// SO_LoadOrder - Or this in to search libraries in the ordered loaded.; /// The default bahaviour is to search loaded libraries in reverse.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:65,load,loaded,65,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,2,['load'],['loaded']
Performance,"/// SO_LoadedFirst - Search all loaded libraries, then as SO_Linker would.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:32,load,loaded,32,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['load'],['loaded']
Performance,"/// SO_LoadedLast - Search as SO_Linker would, then loaded libraries.; /// Only useful to search if libraries with RTLD_LOCAL have been added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:52,load,loaded,52,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['load'],['loaded']
Performance,"/// STEP_VECTOR(IMM) - Returns a scalable vector whose lanes are comprised; /// of a linear sequence of unsigned values starting from 0 with a step of; /// IMM, where IMM must be a TargetConstant with type equal to the vector; /// element type. The arithmetic is performed modulo the bitwidth of the; /// element.; ///; /// The operation does not support returning fixed-width vectors or; /// non-constant operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:33,scalab,scalable,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,"['perform', 'scalab']","['performed', 'scalable']"
Performance,/// STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or; /// unsigned integer. These have the same semantics as fptosi and fptoui; /// in IR.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:187,optimiz,optimizations,187,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,['optimiz'],"['optimizations', 'optimized']"
Performance,"/// STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used; /// for floating-point operands only. STRICT_FSETCC performs a quiet; /// comparison operation, while STRICT_FSETCCS performs a signaling; /// comparison operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:124,perform,performs,124,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,['perform'],['performs']
Performance,/// STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to; /// a floating point value. These have the same semantics as sitofp and; /// uitofp in IR.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:187,optimiz,optimizations,187,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,['optimiz'],"['optimizations', 'optimized']"
Performance,/// S_LAZY_DYLIB_SYMBOL_POINTERS - Section with lazy symbol pointers to; /// lazy loaded dylibs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:82,load,loaded,82,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,1,['load'],['loaded']
Performance,"/// Same as \c CompilerInvocation, but with copy-on-write optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h:58,optimiz,optimization,58,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,1,['optimiz'],['optimization']
Performance,"/// Same as the previous version except it allows folding of any load and; /// store from / to any address, not just from a specific stack slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:65,load,load,65,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['load'],['load']
Performance,"/// SampleProfileReaderExtBinaryBase/SampleProfileWriterExtBinaryBase defines; /// the basic structure of the extensible binary format.; /// The format is organized in sections except the magic and version number; /// at the beginning. There is a section table before all the sections, and; /// each entry in the table describes the entry type, start, size and; /// attributes. The format in each section is defined by the section itself.; ///; /// It is easy to add a new section while maintaining the backward; /// compatibility of the profile. Nothing extra needs to be done. If we want; /// to extend an existing section, like add cache misses information in; /// addition to the sample count in the profile body, we can add a new section; /// with the extension and retire the existing section, and we could choose; /// to keep the parser of the old section if we want the reader to be able; /// to read both new and old format profile.; ///; /// SampleProfileReaderExtBinary/SampleProfileWriterExtBinary define the; /// commonly used sections of a profile in extensible binary format. It is; /// possible to define other types of profile inherited from; /// SampleProfileReaderExtBinaryBase/SampleProfileWriterExtBinaryBase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h:635,cache,cache,635,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,1,['cache'],['cache']
Performance,"/// Saves strings in the provided stable storage and returns a StringRef with a; /// stable character pointer. Saving the same string yields the same StringRef.; ///; /// Compared to StringSaver, it does more work but avoids saving the same string; /// multiple times.; ///; /// Compared to StringPool, it performs fewer allocations but doesn't support; /// refcounting/deletion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/StringSaver.h:306,perform,performs,306,interpreter/llvm-project/llvm/include/llvm/Support/StringSaver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/StringSaver.h,1,['perform'],['performs']
Performance,/// Says whether we should use fixed width or scalable vectorization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:46,scalab,scalable,46,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['scalab'],['scalable']
Performance,"/// Scalar ops always have equal or better analysis/performance/power than; /// the vector equivalent, so this always makes sense if the scalar op is; /// supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:52,perform,performance,52,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['perform'],['performance']
Performance,/// Scaling factor for (scaled or unscaled) load or store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:44,load,load,44,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:60,load,load,60,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,8,"['Load', 'load', 'perform']","['Load', 'load', 'performing']"
Performance,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:383,load,load,383,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,5,['load'],['load']
Performance,"/// Scan for shared objects which are not yet loaded. They are a our symbol; /// resolution candidate sources.; /// NOTE: We only scan not loaded shared objects.; /// \param[in] searchSystemLibraries - whether to decent to standard system; /// locations for shared objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:46,load,loaded,46,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,2,['load'],['loaded']
Performance,/// Scan the function for assumptions and add them to the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:58,cache,cache,58,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['cache'],['cache']
Performance,/// Scan the function for interleaved load candidates and execute the; /// replacement if applicable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:38,load,load,38,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['load'],['load']
Performance,"/// Scan the functions in the specified CFG and resync the; /// callgraph with the call sites found in it. This is used after; /// FunctionPasses have potentially munged the callgraph, and can be used after; /// CallGraphSCC passes to verify that they correctly updated the callgraph.; ///; /// This function returns true if it devirtualized an existing function call,; /// meaning it turned an indirect call into a direct call. This happens when; /// a function pass like GVN optimizes away stuff feeding the indirect call.; /// This never happens in checking mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:477,optimiz,optimizes,477,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,1,['optimiz'],['optimizes']
Performance,/// Scan the instructions looking for a load/store that can be combined with the; /// current instruction into a wider equivalent or a load/store pair.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,2,['load'],['load']
Performance,"/// ScheduleNodeBottomUp - Add the node to the schedule. Decrement the pending; /// count of its predecessors. If a predecessor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:180,queue,queue,180,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['queue'],['queue']
Performance,"/// ScheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:175,queue,queue,175,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['queue'],['queue']
Performance,/// ScopeCache - Cache scopes to reduce malloc traffic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:17,Cache,Cache,17,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['Cache'],['Cache']
Performance,"/// Search for a SHL(x, [<=MaxAmount]) subtree in the queue, return the one of; /// lowest weight and remove it from the queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:54,queue,queue,54,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,2,['queue'],['queue']
Performance,"/// Searches through the library for the symbol \p symbolName. If it is; /// found, the address of that symbol is returned. If not, NULL is returned.; /// Note that NULL will also be returned if the library failed to load.; /// Use isValid() to distinguish these cases if it is important.; /// Note that this will \e not search symbols explicitly registered by; /// AddSymbol().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:217,load,load,217,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['load'],['load']
Performance,"/// See Queue::add.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/FIFOQueue.cxx:8,Queue,Queue,8,roofit/multiprocess/src/FIFOQueue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/FIFOQueue.cxx,2,['Queue'],['Queue']
Performance,"/// See if we can lower a memchr call into an optimized form. If so, return; /// true and lower it. Otherwise return false, and it will be lowered like a; /// normal call.; /// The caller already checked that \p I calls the appropriate LibFunc with a; /// correct prototype.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:46,optimiz,optimized,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['optimiz'],['optimized']
Performance,"/// See if we can lower a memcmp/bcmp call into an optimized form. If so, return; /// true and lower it. Otherwise return false, and it will be lowered like a; /// normal call.; /// The caller already checked that \p I calls the appropriate LibFunc with a; /// correct prototype.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:51,optimiz,optimized,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['optimiz'],['optimized']
Performance,"/// See if we can lower a mempcpy call into an optimized form. If so, return; /// true and lower it. Otherwise return false, and it will be lowered like a; /// normal call.; /// The caller already checked that \p I calls the appropriate LibFunc with a; /// correct prototype.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:47,optimiz,optimized,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['optimiz'],['optimized']
Performance,"/// See if we can lower a strcmp call into an optimized form. If so, return; /// true and lower it, otherwise return false and it will be lowered like a; /// normal call.; /// The caller already checked that \p I calls the appropriate LibFunc with a; /// correct prototype.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:46,optimiz,optimized,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['optimiz'],['optimized']
Performance,"/// See if we can lower a strcpy call into an optimized form. If so, return; /// true and lower it, otherwise return false and it will be lowered like a; /// normal call.; /// The caller already checked that \p I calls the appropriate LibFunc with a; /// correct prototype.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:46,optimiz,optimized,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['optimiz'],['optimized']
Performance,"/// See if we can lower a strlen call into an optimized form. If so, return; /// true and lower it, otherwise return false and it will be lowered like a; /// normal call.; /// The caller already checked that \p I calls the appropriate LibFunc with a; /// correct prototype.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:46,optimiz,optimized,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['optimiz'],['optimized']
Performance,"/// See if we can lower a strnlen call into an optimized form. If so, return; /// true and lower it, otherwise return false and it will be lowered like a; /// normal call.; /// The caller already checked that \p I calls the appropriate LibFunc with a; /// correct prototype.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:47,optimiz,optimized,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['optimiz'],['optimized']
Performance,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:64,load,loaded,64,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,10,"['load', 'perform']","['load', 'loaded', 'loads', 'perform']"
Performance,"/// Select the best block from a worklist.; ///; /// This looks through the provided worklist as a list of candidate basic; /// blocks and select the most profitable one to place. The definition of; /// profitable only really makes sense in the context of a loop. This returns; /// the most frequently visited block in the worklist, which in the case of; /// a loop, is the one most desirable to be physically close to the rest of the; /// loop body in order to improve i-cache behavior.; ///; /// \returns The best block found, or null if none are viable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:472,cache,cache,472,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['cache'],['cache']
Performance,"/// SelectInlineAsmMemoryOperand - Implement addressing mode selection for; /// inline asm expressions. It is always correct to compute the value into; /// a register. The case of adding a (possibly relocatable) constant to a; /// register can be improved, but it is wrong to substitute Reg+Reg for; /// Reg in an asm, because the load or store opcode would have to change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:331,load,load,331,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['load'],['load']
Performance,"/// SelectMVE_VLD - Select MVE interleaving load intrinsics. NumVecs; /// should be 2 or 4. The opcode array specifies the instructions; /// used for 8, 16 and 32-bit lane sizes respectively, and each; /// pointer points to a set of NumVecs sub-opcodes used for the; /// different stages (e.g. VLD20 versus VLD21) of each load family.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:44,load,load,44,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,2,['load'],['load']
Performance,/// SelectMVE_WB - Select MVE writeback load/store intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['load'],['load']
Performance,"/// SelectVLD - Select NEON load intrinsics. NumVecs should be; /// 1, 2, 3 or 4. The opcode arrays specify the instructions used for; /// loads of D registers and even subregs and odd subregs of Q registers.; /// For NumVecs <= 2, QOpcodes1 is not used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:28,load,load,28,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,2,['load'],"['load', 'loads']"
Performance,"/// SelectVLDDup - Select NEON load-duplicate intrinsics. NumVecs; /// should be 1, 2, 3 or 4. The opcode array specifies the instructions used; /// for loading D registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:31,load,load-duplicate,31,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,2,['load'],"['load-duplicate', 'loading']"
Performance,"/// SelectVLDSTLane - Select NEON load/store lane intrinsics. NumVecs should; /// be 2, 3 or 4. The opcode arrays specify the instructions used for; /// load/store of D registers and Q registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:34,load,load,34,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,2,['load'],['load']
Performance,"/// Selected optimizations for which we should enable missed optimization; /// remarks. Transformation passes whose name matches the contained (optional); /// regular expression (and support this feature), will emit a diagnostic; /// whenever they tried but failed to perform a transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:13,optimiz,optimizations,13,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,3,"['optimiz', 'perform']","['optimization', 'optimizations', 'perform']"
Performance,"/// Selected optimizations for which we should enable optimization analyses.; /// Transformation passes whose name matches the contained (optional) regular; /// expression (and support this feature), will emit a diagnostic whenever; /// they want to explain why they decided to apply or not apply a given; /// transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:13,optimiz,optimizations,13,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,2,['optimiz'],"['optimization', 'optimizations']"
Performance,"/// Selected optimizations for which we should enable optimization remarks.; /// Transformation passes whose name matches the contained (optional) regular; /// expression (and support this feature), will emit a diagnostic whenever; /// they perform a transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:13,optimiz,optimizations,13,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,3,"['optimiz', 'perform']","['optimization', 'optimizations', 'perform']"
Performance,"/// Semantic checking for initializer lists.; ///; /// The InitListChecker class contains a set of routines that each; /// handle the initialization of a certain kind of entity, e.g.,; /// arrays, vectors, struct/union types, scalars, etc. The; /// InitListChecker itself performs a recursive walk of the subobject; /// structure of the type to be initialized, while stepping through; /// the initializer list one element at a time. The IList and Index; /// parameters to each of the Check* routines contain the active; /// (syntactic) initializer list and the index into that initializer; /// list that represents the current initializer. Each routine is; /// responsible for moving that Index forward as it consumes elements.; ///; /// Each Check* routine also has a StructuredList/StructuredIndex; /// arguments, which contains the current ""structured"" (semantic); /// initializer list and the index into that initializer list where we; /// are copying initializers as we map them over to the semantic; /// list. Once we have completed our recursive walk of the subobject; /// structure, we will have constructed a full semantic initializer; /// list.; ///; /// C99 designators cause changes in the initializer list traversal,; /// because they make the initialization ""jump"" into a specific; /// subobject and then continue the initialization from that; /// point. CheckDesignatedInitializer() recursively steps into the; /// designated subobject and manages backing out the recursion to; /// initialize the subobjects after the one designated.; ///; /// If an initializer list contains any designators, we build a placeholder; /// structured list even in 'verify only' mode, so that we can track which; /// elements need 'empty' initializtion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:272,perform,performs,272,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performs']
Performance,/// Send a SimpleRemoteEPC message.; ///; /// This function may be called concurrently. Subclasses should implement; /// locking if required for the underlying transport.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h:74,concurren,concurrently,74,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,1,['concurren'],['concurrently']
Performance,"/// Send interprocessor user interrupt. Can be executed only if; /// CR4.UINT = IA32_UINT_TT[0] = 1, the logical processor is in 64-bit mode,; /// and software is not executing inside an enclave; otherwise, it causes an; /// invalid-opcode exception. May be executed at any privilege level, all of; /// its memory accesses are performed with supervisor privilege.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> SENDUIPI </c> instruction; ///; /// \param __a; /// Index of user-interrupt target table entry in user-interrupt target; /// table.; ///; /// \code{.operation}; /// IF __a > UITTSZ; /// GP (0); /// FI; /// tempUITTE := MEM[UITTADDR + (a<<4)]; /// // tempUITTE must be valid, and can't have any reserved bit set; /// IF (tempUITTE.V == 0 OR tempUITTE[7:1] != 0); /// GP (0); /// FI; /// tempUPID := MEM[tempUITTE.UPIDADDR] // under lock; /// // tempUPID can't have any reserved bit set; /// IF (tempUPID[15:2] != 0 OR tempUPID[31:24] != 0); /// GP (0) // release lock; /// FI; /// tempUPID.PIR[tempUITTE.UV] := 1;; /// IF (tempUPID.SN == 0 AND tempUPID.ON == 0); /// tempUPID.ON := 1; /// sendNotify := 1; /// ELSE; /// sendNotify := 0; /// FI; /// MEM[tempUITTE.UPIDADDR] := tempUPID // release lock; /// IF sendNotify == 1; /// IF IA32_APIC_BASE[10] == 1 // local APIC is in x2APIC mode; /// // send ordinary IPI with vector tempUPID.NV to 32-bit physical APIC; /// // ID tempUPID.NDST; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST); /// ELSE; /// // send ordinary IPI with vector tempUPID.NV to 8-bit physical APIC; /// // ID tempUPID.NDST[15:8]; /// SendOrdinaryIPI(tempUPID.NV, tempUPID.NDST[15:8]); /// FI; /// FI; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:327,perform,performed,327,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,1,['perform'],['performed']
Performance,"/// Serialized encoding of SourceLocations without context.; /// Optimized to have small unsigned values (=> small after VBR encoding).; ///; // Macro locations have the top bit set, we rotate by one so it is the low bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/SourceLocationEncoding.h:65,Optimiz,Optimized,65,interpreter/llvm-project/clang/include/clang/Serialization/SourceLocationEncoding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/SourceLocationEncoding.h,1,['Optimiz'],['Optimized']
Performance,"/// Serialized encoding of a sequence of SourceLocations.; ///; /// Optimized to produce small values when locations with the sequence are; /// similar. Each element can be delta-encoded against the last nonzero element.; ///; /// Sequences should be started by creating a SourceLocationSequence::State,; /// and then passed around as SourceLocationSequence*. Example:; ///; /// // establishes a sequence; /// void EmitTopLevelThing() {; /// SourceLocationSequence::State Seq;; /// EmitContainedThing(Seq);; /// EmitRecursiveThing(Seq);; /// }; ///; /// // optionally part of a sequence; /// void EmitContainedThing(SourceLocationSequence *Seq = nullptr) {; /// Record.push_back(SourceLocationEncoding::encode(SomeLoc, Seq));; /// }; ///; /// // establishes a sequence if there isn't one already; /// void EmitRecursiveThing(SourceLocationSequence *ParentSeq = nullptr) {; /// SourceLocationSequence::State Seq(ParentSeq);; /// Record.push_back(SourceLocationEncoding::encode(SomeLoc, Seq));; /// EmitRecursiveThing(Seq);; /// }; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/SourceLocationEncoding.h:68,Optimiz,Optimized,68,interpreter/llvm-project/clang/include/clang/Serialization/SourceLocationEncoding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/SourceLocationEncoding.h,1,['Optimiz'],['Optimized']
Performance,"/// Set CC_PRINT_INTERNAL_STAT mode, which causes the driver to dump internal; /// performance report to CC_PRINT_INTERNAL_STAT_FILE or to stdout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:83,perform,performance,83,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['perform'],['performance']
Performance,"/// Set CC_PRINT_PROC_STAT mode, which causes the driver to dump; /// performance report to CC_PRINT_PROC_STAT_FILE or to stdout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:70,perform,performance,70,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['perform'],['performance']
Performance,"/// Set a CompileFunctionCreator.; ///; /// If this method is not called, a default creation function wil be used; /// that will construct a basic IR compile function that is compatible with; /// the selected number of threads (SimpleCompiler for '0' compile threads,; /// ConcurrentIRCompiler otherwise).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h:273,Concurren,ConcurrentIRCompiler,273,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,1,['Concurren'],['ConcurrentIRCompiler']
Performance,/// Set a MacroDirective that was loaded from a PCH file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:34,load,loaded,34,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['load'],['loaded']
Performance,"/// Set a marker on instructions that denotes where we should create and emit; /// heap alloc site labels. This waits until after instruction selection and; /// optimizations to create the label, so it should still work if the; /// instruction is removed or duplicated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:161,optimiz,optimizations,161,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['optimiz'],['optimizations']
Performance,/// Set a setup function to be run just before the PlatformSetupFunction is; /// run.; ///; /// This can be used to customize the LLJIT instance before the platform is; /// set up. E.g. By installing a debugger support plugin before the platform; /// is set up (when the ORC runtime is loaded) we enable debugging of the; /// runtime itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h:286,load,loaded,286,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,1,['load'],['loaded']
Performance,/// Set a value. Return the old value. Waits for concurrent \a; /// loadOrGenerate() calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:49,concurren,concurrent,49,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,2,"['concurren', 'load']","['concurrent', 'loadOrGenerate']"
Performance,/// Set alignment flags based on whether or not the Frame Index is aligned.; /// Utilized when computing flags for address computation when selecting; /// load and store instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:155,load,load,155,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['load']
Performance,/// Set if a code hotness metric should be included in optimization; /// diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:55,optimiz,optimization,55,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,1,['optimiz'],['optimization']
Performance,"/// Set list of helper expressions, required for proper codegen of the clause.; /// These expressions represent LHS expression in the final reduction; /// expression performed by the reduction clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:166,perform,performed,166,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,2,['perform'],['performed']
Performance,"/// Set list of helper expressions, required for proper codegen of the clause.; /// These expressions represent RHS expression in the final reduction; /// expression performed by the reduction clause. Also, variables in these; /// expressions are used for proper initialization of reduction copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:166,perform,performed,166,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,2,['perform'],['performed']
Performance,"/// Set list of helper expressions, required for proper codegen of the; /// clause. These expressions represent LHS expression in the final; /// reduction expression performed by the reduction clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:166,perform,performed,166,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,"/// Set list of helper expressions, required for proper codegen of the; /// clause. These expressions represent RHS expression in the final; /// reduction expression performed by the reduction clause.; /// Also, variables in these expressions are used for proper initialization of; /// reduction copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:166,perform,performed,166,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,"/// Set list of helper expressions, required for proper codegen of the; /// clause. These expressions represent destination expression in the final; /// assignment statement performed by the copyin clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:174,perform,performed,174,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,"/// Set list of helper expressions, required for proper codegen of the; /// clause. These expressions represent destination expression in the final; /// assignment statement performed by the copyprivate clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:174,perform,performed,174,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,"/// Set list of helper expressions, required for proper codegen of the; /// clause. These expressions represent original variables (for arrays, single; /// array element) in the final assignment statement performed by the; /// lastprivate clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:205,perform,performed,205,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,"/// Set list of helper expressions, required for proper codegen of the; /// clause. These expressions represent private variables (for arrays, single; /// array element) in the final assignment statement performed by the; /// lastprivate clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:204,perform,performed,204,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,"/// Set list of helper expressions, required for proper codegen of the; /// clause. These expressions represent source expression in the final; /// assignment statement performed by the copyin clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:169,perform,performed,169,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,"/// Set list of helper expressions, required for proper codegen of the; /// clause. These expressions represent source expression in the final; /// assignment statement performed by the copyprivate clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:169,perform,performed,169,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,/// Set of globals with eagerly copied metadata that may require remapping.; /// This remapping is performed after metadata linking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:99,perform,performed,99,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['perform'],['performed']
Performance,"/// Set of module map files we've already loaded, and a flag indicating; /// whether they were valid or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:42,load,loaded,42,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['load'],['loaded']
Performance,/// Set of value handles used to erase values from the cache on deletion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,cache,cache,55,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['cache'],['cache']
Performance,"/// Set only for preambles which end with an active; /// \#pragma clang assume_nonnull begin.; ///; /// When the preamble is loaded into the main file,; /// `PragmaAssumeNonNullLoc` will be set to this to; /// replay the unterminated assume_nonnull.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:125,load,loaded,125,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['load'],['loaded']
Performance,/// Set the LLVM CodeGen optimization level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h:25,optimiz,optimization,25,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h,1,['optimiz'],['optimization']
Performance,/// Set the base address to use for the GSYM file.; ///; /// Setting the base address to use for the GSYM file. Object files typically; /// get loaded from a base address when the OS loads them into memory. Using; /// GSYM files for symbolication becomes easier if the base address in the; /// GSYM header is the same address as it allows addresses to be easily slid; /// and allows symbolication without needing to find the original base; /// address in the original object file.; ///; /// \param Addr The address to use as the base address of the GSYM file; /// when it is saved to disk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:144,load,loaded,144,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,2,['load'],"['loaded', 'loads']"
Performance,"/// Set the default strategy.; /// The strategy is a parameter used only by Minuit and Minuit2.; /// Possible values are:; /// - `strat = 0` : rough approximation of Hessian using the gradient. Avoid computing the full Hessian matrix; /// - `strat = 1` (default and recommended one) - Use Hessian approximation but compute full Hessian at the end of minimization if needed.; /// - `strat = 2` Perform several full Hessian computations during the minimization. Slower and not always working better than `strat=1`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h:393,Perform,Perform,393,math/mathcore/inc/Math/MinimizerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h,1,['Perform'],['Perform']
Performance,"/// Set the desired order for executing tasks of a Job in Priority queue mode.; ///; /// Only useful in Priority queue mode, in FIFO mode this doesn't do anything.; ///; /// Translates the desired order to priorities. Because workers will start; /// stealing work immediately after it has been queued, the desired order; /// cannot be guaranteed -- hence ""suggest"" -- because the first queued task; /// will possibly be taken before higher priority tasks have been sent to; /// the queue.; ///; /// \param[in] job_id Job ID to set task order for.; /// \param[in] task_order Task IDs in the desired order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Config.cxx:67,queue,queue,67,roofit/multiprocess/src/Config.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Config.cxx,5,['queue'],"['queue', 'queued']"
Performance,"/// Set the desired order for executing tasks of a Job.; ///; /// See Config::Queue::suggestTaskOrder.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/PriorityQueue.cxx:78,Queue,Queue,78,roofit/multiprocess/src/PriorityQueue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/PriorityQueue.cxx,1,['Queue'],['Queue']
Performance,"/// Set the entry count for this function.; ///; /// Entry count is the number of times this function was executed based on; /// pgo data. \p Imports points to a set of GUIDs that needs to; /// be imported by the function for sample PGO, to enable the same inlines as; /// the profiled optimized binary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:286,optimiz,optimized,286,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['optimiz'],['optimized']
Performance,"/// Set the features to the default for the given CPU and TuneCPU, with ano; /// appended feature string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:58,Tune,TuneCPU,58,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,1,['Tune'],['TuneCPU']
Performance,"/// Set the globally-visible declarations associated with the given; /// identifier.; ///; /// If the AST reader is currently in a state where the given declaration IDs; /// cannot safely be resolved, they are queued until it is safe to resolve; /// them.; ///; /// \param II an IdentifierInfo that refers to one or more globally-visible; /// declarations.; ///; /// \param DeclIDs the set of declaration IDs with the name @p II that are; /// visible at global scope.; ///; /// \param Decls if non-null, this vector will be populated with the set of; /// deserialized declarations. These declarations will not be pushed into; /// scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:210,queue,queued,210,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['queue'],['queued']
Performance,/// Set the hash to use for module cache paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:35,cache,cache,35,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['cache'],['cache']
Performance,/// Set the minimum hotness value a diagnostic needs in order to be; /// included in optimization diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:85,optimiz,optimization,85,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,1,['optimiz'],['optimization']
Performance,/// Set the mode to strip TBAA metadata on load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:43,load,load,43,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,1,['load'],['load']
Performance,"/// Set the name of the current thread. Setting a thread's name can; /// be helpful for enabling useful diagnostics under a debugger or when; /// logging. The level of support for setting a thread's name varies; /// wildly across operating systems, and we only make a best effort to; /// perform the operation on supported platforms. No indication of success; /// or failure is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:288,perform,perform,288,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,1,['perform'],['perform']
Performance,/// Set the new optimization limit and reset the counter. Passing; /// OptBisect::Disabled disables the limiting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h:16,optimiz,optimization,16,interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,1,['optimiz'],['optimization']
Performance,"/// Set the number of compile threads to use.; ///; /// If set to zero, compilation will be performed on the execution thread when; /// JITing in-process. If set to any other number N, a thread pool of N; /// threads will be created for compilation.; ///; /// If this method is not called, behavior will be as if it were called with; /// a zero argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h:92,perform,performed,92,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,1,['perform'],['performed']
Performance,/// Set the object which can disable optional passes and individual; /// optimizations at compile time.; ///; /// The lifetime of the object must be guaranteed to extend as long as the; /// LLVMContext is used by compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:73,optimiz,optimizations,73,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,2,['optimiz'],['optimizations']
Performance,/// Set the path to the module cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:31,cache,cache,31,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['cache'],['cache']
Performance,"/// Set the priority for Job tasks in Priority queue mode.; ///; /// Only useful in Priority queue mode, in FIFO mode this doesn't do anything.; /// A higher value means a higher priority.; ///; /// \param[in] job_id Job ID to set task order for.; /// \param[in] task_priorities Task priority values, where vector index equals task ID.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Config.cxx:47,queue,queue,47,roofit/multiprocess/src/Config.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Config.cxx,2,['queue'],['queue']
Performance,"/// Set the priority for Job tasks.; ///; /// See Config::Queue::setTaskPriorities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/PriorityQueue.cxx:58,Queue,Queue,58,roofit/multiprocess/src/PriorityQueue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/PriorityQueue.cxx,1,['Queue'],['Queue']
Performance,/// Set the target's preferred function alignment. This should be set if; /// there is a performance benefit to higher-than-minimum alignment,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:89,perform,performance,89,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['performance']
Performance,"/// Set the value of a particular slot.; ///; /// This method is thread-safe as long as concurrent calls access different slots (i.e. pass a different; /// argument) and no thread accesses slot `i` via the arrow operator, so mixing usage of SetAtSlot; /// with usage of the arrow operator can be dangerous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:88,concurren,concurrent,88,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['concurren'],['concurrent']
Performance,"/// Set the variable that might be used for the named return value; /// optimization. The return statement must have storage for it,; /// which is the case if and only if hasNRVOCandidate() is true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h:72,optimiz,optimization,72,interpreter/llvm-project/clang/include/clang/AST/Stmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h,1,['optimiz'],['optimization']
Performance,"/// Set up a new query.; /// If it matches the old query, we can keep the cached answer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:74,cache,cached,74,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['cache'],['cached']
Performance,"/// Set up to perform a fixed scan.; /// \param[in] nBins Number of points to scan.; /// \param[in] xMin Lower limit of range to be scanned.; /// \param[in] xMax Upper limit of range to be scanned.; /// \param[in] scanLog Run in logarithmic steps along x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverter.h:14,perform,perform,14,roofit/roostats/inc/RooStats/HypoTestInverter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverter.h,1,['perform'],['perform']
Performance,"/// Set weights for \p UnrolledLoop and \p RemainderLoop based on weights for; /// \p OrigLoop and the following distribution of \p OrigLoop iteration among \p; /// UnrolledLoop and \p RemainderLoop. \p UnrolledLoop receives weights that; /// reflect TC/UF iterations, and \p RemainderLoop receives weights that reflect; /// the remaining TC%UF iterations.; ///; /// Note that \p OrigLoop may be equal to either \p UnrolledLoop or \p; /// RemainderLoop in which case weights for \p OrigLoop are updated accordingly.; /// Note also behavior is undefined if \p UnrolledLoop and \p RemainderLoop are; /// equal. \p UF must be greater than zero.; /// If \p OrigLoop has no profile info associated nothing happens.; ///; /// This utility may be useful for such optimizations as unroller and; /// vectorizer as it's typical transformation for them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:756,optimiz,optimizations,756,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,1,['optimiz'],['optimizations']
Performance,"/// Set whether opaque pointers are enabled. The method may be called multiple; /// times, but only with the same value. Note that creating a pointer type or; /// otherwise querying the opaque pointer mode performs an implicit set to; /// the default value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:206,perform,performs,206,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,1,['perform'],['performs']
Performance,/// Set-up method to add to the consumer the set of namespaces to use; /// in performing corrections to nested name specifiers. This method also; /// implicitly adds all of the known classes in the current AST context to the; /// to the consumer for correcting nested name specifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h:78,perform,performing,78,interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h,1,['perform'],['performing']
Performance,"/// SetJmp implies future control flow change upon calling the corresponding; /// LongJmp.; /// Instead of using the 'return' instruction, the long jump fixes the stack and; /// performs an indirect branch. To do so it uses the registers that were stored; /// in the jump buffer (when calling SetJmp).; /// In case the shadow stack is enabled we need to fix it as well, because some; /// return addresses will be skipped.; /// The function will save the SSP for future fixing in the function; /// emitLongJmpShadowStackFix.; /// \sa emitLongJmpShadowStackFix; /// \param [in] MI The temporary Machine Instruction for the builtin.; /// \param [in] MBB The Machine Basic Block that will be modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:178,perform,performs,178,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['performs']
Performance,"/// Sets a diagnostic to be performed. The diagnostic is given; /// four (additional) arguments:; /// %0 - 0 if the entity was private, 1 if protected; /// %1 - the DeclarationName of the entity; /// %2 - the TypeDecl type of the naming class; /// %3 - the TypeDecl type of the declaring class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h:28,perform,performed,28,interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DelayedDiagnostic.h,1,['perform'],['performed']
Performance,"/// Sets the CloneToNewContextOnEmit flag (false by default).; ///; /// When set, IR modules added to this layer will be cloned on to a new; /// context before emit is called. This can be used by clients who want; /// to load all IR using one LLVMContext (to save memory via type and; /// constant uniquing), but want to move Modules to fresh contexts before; /// compiling them to enable concurrent compilation.; /// Single threaded clients, or clients who load every module on a new; /// context, need not set this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h:221,load,load,221,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Layer.h,3,"['concurren', 'load']","['concurrent', 'load']"
Performance,"/// Sets the current floating point environment. The first operand is a token; /// chain, the second is a pointer to memory, where FP environment is loaded; /// from. The result is a token chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:149,load,loaded,149,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['load'],['loaded']
Performance,/// Sets the latency for this edge.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:13,latency,latency,13,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['latency'],['latency']
Performance,/// Sets the linkage to the value determined by global summary-based; /// optimization. Will be applied in the ThinLTO backends.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:74,optimiz,optimization,74,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['optimiz'],['optimization']
Performance,/// Sets the optimized use for a MemoryDef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:13,optimiz,optimized,13,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['optimiz'],['optimized']
Performance,/// Sets the ordering constraint and the synchronization scope ID of this load; /// instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:74,load,load,74,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['load'],['load']
Performance,/// Sets the ordering constraint of this load instruction. May not be Release; /// or AcquireRelease.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:41,load,load,41,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['load'],['load']
Performance,/// Sets the pre-compiled object cache. The ownership of the ObjectCache is; /// not changed. Supported by MCJIT but not the interpreter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:33,cache,cache,33,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['cache'],['cache']
Performance,/// Sets the synchronization scope ID of this load instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:46,load,load,46,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['load'],['load']
Performance,"/// Sets the user interrupt flag (UIF). Its effect takes place immediately; a; /// user interrupt may be delivered on the instruction boundary following; /// STUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of STI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> STUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 1; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:441,load,loads,441,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,1,['load'],['loads']
Performance,/// Setup optimization remarks that output directly to a raw_ostream.; /// \p OS is managed by the caller and should be open for writing as long as \p; /// Context is streaming remarks to it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMRemarkStreamer.h:10,optimiz,optimization,10,interpreter/llvm-project/llvm/include/llvm/IR/LLVMRemarkStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMRemarkStreamer.h,1,['optimiz'],['optimization']
Performance,/// Setup optimization remarks that output to a file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMRemarkStreamer.h:10,optimiz,optimization,10,interpreter/llvm-project/llvm/include/llvm/IR/LLVMRemarkStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMRemarkStreamer.h,1,['optimiz'],['optimization']
Performance,/// Setup optimization remarks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h:10,optimiz,optimization,10,interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,1,['optimiz'],['optimization']
Performance,/// Shared code to optimize strlen+wcslen and strnlen+wcsnlen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:19,optimiz,optimize,19,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,1,['optimiz'],['optimize']
Performance,/// Should the Select Optimization pass be enabled and ran.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,Optimiz,Optimization,22,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['Optimiz'],['Optimization']
Performance,"/// Should the Select Optimization pass treat the given instruction like a; /// select, potentially converting it to a conditional branch. This can; /// include select-like instructions like or(zext(c), x) that can be converted; /// to selects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,Optimiz,Optimization,22,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['Optimiz'],['Optimization']
Performance,/// Show frontend performance metrics and statistics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h:18,perform,performance,18,interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,1,['perform'],['performance']
Performance,/// ShuffleVectorInst specialization to compute vector information.; ///; /// \param SVI ShuffleVectorInst to operate on; /// \param Result Result of the computation; ///; /// Compute the left and the right side vector information and merge them by; /// applying the shuffle operation. This function also ensures that the left; /// and right side have compatible loads. This means that all loads are with; /// in the same basic block and are based on the same pointer.; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:363,load,loads,363,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,2,['load'],['loads']
Performance,"/// Signals a non-empty I/O work queue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:33,queue,queue,33,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,1,['queue'],['queue']
Performance,"/// Similar to CreateLiveInRegister, except value maybe loaded from a stack; /// slot rather than passed in a register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h:56,load,loaded,56,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,1,['load'],['loaded']
Performance,"/// Similar to \c O2 but tries to optimize for small code size instead of; /// fast execution without triggering significant incremental execution; /// time slowdowns.; ///; /// The logic here is exactly the same as \c O2, but with code size and; /// execution time metrics swapped.; ///; /// A consequence of the different core goal is that this should in general; /// produce substantially smaller executables that still run in; /// a reasonable amount of time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:34,optimiz,optimize,34,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,1,['optimiz'],['optimize']
Performance,"/// Similar to createAddRecFromPHI, but with the additional flexibility of; /// suggesting runtime overflow checks in case casts are encountered.; /// If successful, the analysis records that for this loop, \p SymbolicPHI,; /// which is the UnknownSCEV currently representing the PHI, can be rewritten; /// into an AddRec, assuming some predicates; The function then returns the; /// AddRec and the predicates as a pair, and caches this pair in; /// PredicatedSCEVRewrites.; /// If the analysis is not successful, a mapping from the \p SymbolicPHI to; /// itself (with no predicates) is recorded, and a nullptr with an empty; /// predicates vector is returned as a pair.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:425,cache,caches,425,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['cache'],['caches']
Performance,"/// Similar to getBackedgeTakenCount, except it will add a set of; /// SCEV predicates to Predicates that are required to be true in order for; /// the answer to be correct. Predicates can be checked with run-time; /// checks and can be used to perform loop versioning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:245,perform,perform,245,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['perform'],['perform']
Performance,"/// Similar to loads, nodes corresponding to constrained FP intrinsics are; /// bunched up and emitted when necessary. These can be moved across each; /// other and any (normal) memory operation (load or store), but not across; /// calls or instructions having unspecified side effects. As a special; /// case, constrained FP intrinsics using fpexcept.strict may not be deleted; /// even if otherwise unused, so they need to be chained before any; /// terminator instruction (like PendingExports). We track the latter; /// set of nodes in a separate list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:15,load,loads,15,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,2,['load'],"['load', 'loads']"
Performance,/// Similar to the 16-bit case but for instructions that take a 34-bit; /// displacement field (prefixed loads/stores).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,load,loads,105,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['loads']
Performance,"/// Simple compile functor: Takes a single IR module and returns an ObjectFile.; /// This compiler supports a single compilation thread and LLVMContext only.; /// For multithreaded compilation, use ConcurrentIRCompiler below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/CompileUtils.h:198,Concurren,ConcurrentIRCompiler,198,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/CompileUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/CompileUtils.h,1,['Concurren'],['ConcurrentIRCompiler']
Performance,/// Simplify one loop and queue further loops for simplification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:26,queue,queue,26,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['queue'],['queue']
Performance,"/// Single linked list of all memory instructions (e.g. load, store, call); /// in the block - until the end of the scheduling region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:56,load,load,56,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['load']
Performance,"/// Sink addressing mode computation immediate before MemoryInst if doing so; /// can be done without increasing register pressure. The need for the; /// register pressure constraint means this can end up being an all or nothing; /// decision for all uses of the same addressing computation.; ///; /// Load and Store Instructions often have addressing modes that can do; /// significant amounts of computation. As such, instruction selection will try; /// to get the load or store to do as much computation as possible for the; /// program. The problem is that isel can only see within a single block. As; /// such, we sink as much legal addressing mode work into the block as possible.; ///; /// This method is used to optimize both load/store and inline asms with memory; /// operands. It's also used to sink addressing computations feeding into cold; /// call sites into their (cold) basic block.; ///; /// The motivation for handling sinking into cold blocks is that doing so can; /// both enable other address mode sinking (by satisfying the register pressure; /// constraint above), and reduce register pressure globally (by removing the; /// addressing mode computation from the fast path entirely.).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:302,Load,Load,302,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,4,"['Load', 'load', 'optimiz']","['Load', 'load', 'optimize']"
Performance,"/// Size examples:; ///; /// Type SizeInBits StoreSizeInBits AllocSizeInBits[*]; /// ---- ---------- --------------- ---------------; /// i1 1 8 8; /// i8 8 8 8; /// i19 19 24 32; /// i32 32 32 32; /// i100 100 104 128; /// i128 128 128 128; /// Float 32 32 32; /// Double 64 64 64; /// X86_FP80 80 80 96; ///; /// [*] The alloc size depends on the alignment, and thus on the target.; /// These values are for x86-32 linux.; /// Returns the number of bits necessary to hold the specified type.; ///; /// If Ty is a scalable vector type, the scalable property will be set and; /// the runtime size will be a positive integer multiple of the base size.; ///; /// For example, returns 36 for i36 and 80 for x86_fp80. The type passed must; /// have a size (Type::isSized() must return true).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:515,scalab,scalable,515,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,2,['scalab'],['scalable']
Performance,/// Size of Debug info before optimizing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:30,optimiz,optimizing,30,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,1,['optimiz'],['optimizing']
Performance,"/// SkipExtensionForVMULL - For a node that is a SIGN_EXTEND, ZERO_EXTEND,; /// ANY_EXTEND, extending load, or BUILD_VECTOR with extended elements, return; /// the unextended value. The unextended vector should be 64 bits so that it can; /// be used as an operand to a VMULL instruction. If the original vector size; /// before extension is less than 64 bits we add a an extension to resize; /// the vector to 64 bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:102,load,load,102,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['load']
Performance,"/// SkipLoadExtensionForVMULL - return a load of the original vector size that; /// does not do any sign/zero extension. If the original vector is less; /// than 64 bits, an appropriate extension will be added after the load to; /// reach a total size of 64 bits. We have to add the extension separately; /// because ARM does not have a sign/zero extending load for vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:41,load,load,41,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,3,['load'],['load']
Performance,"/// Slice \p Inc according to the information contained within this slice.; /// This is cached, so if called multiple times for the same \p BB & \p Inc; /// pair, it returns the same Sliced value as well.; ///; /// Note this *intentionally* does not return the same value for, say,; /// [%bb.0, %0] & [%bb.1, %0] as:; /// - It could cause issues with dominance (e.g. if bb.1 is seen first, then; /// the value in bb.1 may not be reachable from bb.0 if it's its; /// predecessor.); /// - We also want to make our extract instructions as local as possible so; /// the DAG has better chances of folding them out. Duplicating them like; /// that is beneficial in that regard.; ///; /// This is both a minor optimization to avoid creating duplicate; /// instructions, but also a requirement for correctness. It is not forbidden; /// for a PHI node to have the same [BB, Val] pair multiple times. If we; /// returned a new value each time, those previously identical pairs would all; /// have different incoming values (from the same block) and it'd cause a ""PHI; /// node has multiple entries for the same basic block with different incoming; /// values!"" verifier error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:88,cache,cached,88,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,2,"['cache', 'optimiz']","['cached', 'optimization']"
Performance,"/// Small helper that resolves and caches file paths. This helps reduce the; /// number of calls to realpath which is expensive. We assume the input are; /// files, and cache the realpath of their parent. This way we can quickly; /// resolve different files under the same path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h:35,cache,caches,35,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h,2,['cache'],"['cache', 'caches']"
Performance,/// SmallPtrSet - This class implements a set which is optimized for holding; /// SmallSize or less elements. This internally rounds up SmallSize to the next; /// power of two if it is not already a power of two. See the comments above; /// SmallPtrSetImplBase for details of the algorithm.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:55,optimiz,optimized,55,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,1,['optimiz'],['optimized']
Performance,"/// SmallPtrSetImplBase - This is the common code shared among all the; /// SmallPtrSet<>'s, which is almost everything. SmallPtrSet has two modes, one; /// for small and one for large sets.; ///; /// Small sets use an array of pointers allocated in the SmallPtrSet object,; /// which is treated as a simple array of pointers. When a pointer is added to; /// the set, the array is scanned to see if the element already exists, if not; /// the element is 'pushed back' onto the array. If we run out of space in the; /// array, we grow into the 'large set' case. SmallSet should be used when the; /// sets are often small. In this case, no memory allocation is used, and only; /// light-weight and cache-efficient scanning is used.; ///; /// Large sets use a classic exponentially-probed hash table. Empty buckets are; /// represented with an illegal pointer value (-1) to allow null pointers to be; /// inserted. Tombstones are represented with another illegal pointer value; /// (-2), to allow deletion. The hash table is resized when the table is 3/4 or; /// more. When this happens, the table is doubled in size.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:696,cache,cache-efficient,696,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,1,['cache'],['cache-efficient']
Performance,"/// SmallSet - This maintains a set of unique values, optimizing for the case; /// when the set is small (less than N). In this case, the set can be; /// maintained with no mallocs. If the set gets large, we expand to using an; /// std::set to maintain reasonable lookup times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h:54,optimiz,optimizing,54,interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,1,['optimiz'],['optimizing']
Performance,"/// Smart pointer class that efficiently represents Objective-C method; /// names.; ///; /// This class will either point to an IdentifierInfo or a; /// MultiKeywordSelector (which is private). This enables us to optimize; /// selectors that take no arguments and selectors that take 1 argument, which; /// accounts for 78% of all selectors in Cocoa.h.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:213,optimiz,optimize,213,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['optimiz'],['optimize']
Performance,"/// Some HW prefetchers can handle accesses up to a certain constant stride.; /// Sometimes prefetching is beneficial even below the HW prefetcher limit,; /// and the arguments provided are meant to serve as a basis for deciding this; /// for a particular loop.; ///; /// \param NumMemAccesses Number of memory accesses in the loop.; /// \param NumStridedMemAccesses Number of the memory accesses that; /// ScalarEvolution could find a known stride; /// for.; /// \param NumPrefetches Number of software prefetches that will be; /// emitted as determined by the addresses; /// involved and the cache line size.; /// \param HasCall True if the loop contains a call.; ///; /// \return This is the minimum stride in bytes where it makes sense to start; /// adding SW prefetches. The default is 1, i.e. prefetch with any; /// stride.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:594,cache,cache,594,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['cache'],['cache']
Performance,"/// Some target cannot handle a variable insertion index for the; /// INSERT_VECTOR_ELT instruction. In this case, it; /// is necessary to spill the vector being inserted into to memory, perform; /// the insert there, and then read the result back.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:187,perform,perform,187,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['perform'],['perform']
Performance,"/// Some targets cannot handle a variable; /// insertion index for the INSERT_VECTOR_ELT instruction. In this case, it; /// is necessary to spill the vector being inserted into to memory, perform; /// the insert there, and then read the result back.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:188,perform,perform,188,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['perform'],['perform']
Performance,"/// Some targets prefer to split a conditional branch like:; /// \code; /// %0 = icmp ne i32 %a, 0; /// %1 = icmp ne i32 %b, 0; /// %or.cond = or i1 %0, %1; /// br i1 %or.cond, label %TrueBB, label %FalseBB; /// \endcode; /// into multiple branch instructions like:; /// \code; /// bb1:; /// %0 = icmp ne i32 %a, 0; /// br i1 %0, label %TrueBB, label %bb2; /// bb2:; /// %1 = icmp ne i32 %b, 0; /// br i1 %1, label %TrueBB, label %FalseBB; /// \endcode; /// This usually allows instruction selection to do even further optimizations; /// and combine the compare with the branch instruction. Currently this is; /// applied for targets which have ""cheap"" jump instructions.; ///; /// FIXME: Remove the (equivalent?) implementation in SelectionDAG.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:519,optimiz,optimizations,519,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimizations']
Performance,"/// Sometimes (i.e. load/stores) the operand may be followed immediately by; /// either this.; /// ::= '(', register, ')'; /// handle it before we iterate so we don't get tripped up by the lack of; /// a comma.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:20,load,load,20,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['load'],['load']
Performance,/// Sort loads into increasing pointers offsets to allow greater clustering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:9,load,loads,9,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['loads']
Performance,/// Sort the LoopCosts vector by decreasing cache cost.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:44,cache,cache,44,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['cache'],['cache']
Performance,"/// Sort the NonLocalDepInfo cache, given a certain number of elements in the; /// array that are already properly ordered.; ///; /// This is optimized for the case when only a few entries are added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:29,cache,cache,29,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,2,"['cache', 'optimiz']","['cache', 'optimized']"
Performance,/// Sorting functions for the Available queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:40,queue,queue,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,2,['queue'],['queue']
Performance,"/// SparseBitVector is an implementation of a bitvector that is sparse by only; /// storing the elements that have non-zero bits set. In order to make this; /// fast for the most common cases, SparseBitVector is implemented as a linked; /// list of SparseBitVectorElements. We maintain a pointer to the last; /// SparseBitVectorElement accessed (in the form of a list iterator), in order; /// to make multiple in-order test/set constant time after the first one is; /// executed. Note that using vectors to store SparseBitVectorElement's does; /// not work out very well because it causes insertion in the middle to take; /// enormous amounts of time with a large amount of bits. Other structures that; /// have better worst cases for insertion in the middle (various balanced trees,; /// etc) do not perform as well in practice as a linked list with this iterator; /// kept up to date. They are also significantly more memory intensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:801,perform,perform,801,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,1,['perform'],['perform']
Performance,"/// SparseSet - Fast set implementation for objects that can be identified by; /// small unsigned keys.; ///; /// SparseSet allocates memory proportional to the size of the key universe, so; /// it is not recommended for building composite data structures. It is useful; /// for algorithms that require a single set with fast operations.; ///; /// Compared to DenseSet and DenseMap, SparseSet provides constant-time fast; /// clear() and iteration as fast as a vector. The find(), insert(), and; /// erase() operations are all constant time, and typically faster than a hash; /// table. The iteration order doesn't depend on numerical key values, it only; /// depends on the order of insert() and erase() operations. When no elements; /// have been erased, the iteration order is the insertion order.; ///; /// Compared to BitVector, SparseSet<unsigned> uses 8x-40x more memory, but; /// offers constant-time clear() and size() operations as well as fast; /// iteration independent on the size of the universe.; ///; /// SparseSet contains a dense vector holding all the objects and a sparse; /// array holding indexes into the dense vector. Most of the memory is used by; /// the sparse array which is the size of the key universe. The SparseT; /// template parameter provides a space/speed tradeoff for sets holding many; /// elements.; ///; /// When SparseT is uint32_t, find() only touches 2 cache lines, but the sparse; /// array uses 4 x Universe bytes.; ///; /// When SparseT is uint8_t (the default), find() touches up to 2+[N/256] cache; /// lines, but the sparse array is 4x smaller. N is the number of elements in; /// the set.; ///; /// For sets that may grow to thousands of elements, SparseT should be set to; /// uint16_t or uint32_t.; ///; /// @tparam ValueT The type of objects in the set.; /// @tparam KeyFunctorT A functor that computes an unsigned index from KeyT.; /// @tparam SparseT An unsigned integer type. See above.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h:1396,cache,cache,1396,interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseSet.h,2,['cache'],['cache']
Performance,"/// Special case for BumpPtrAllocator which has an empty Deallocate(); /// function.; ///; /// There is no need to traverse the free list, pulling all the objects into; /// cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Recycler.h:173,cache,cache,173,interpreter/llvm-project/llvm/include/llvm/Support/Recycler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Recycler.h,1,['cache'],['cache']
Performance,"/// Special case for BumpPtrAllocator which has an empty Deallocate(); /// function.; ///; /// There is no need to traverse the free lists, pulling all the objects into; /// cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h:174,cache,cache,174,interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ArrayRecycler.h,1,['cache'],['cache']
Performance,/// Special case for MatMul lowering. Prevents scalar loads of row-major; /// vectors Lowers to vector reduction add instead of sequential add if; /// reassocation is enabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:54,load,loads,54,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['load'],['loads']
Performance,/// Specialized handlers for optimization remarks.; /// Note that these handlers only accept remarks and they always handle; /// them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:29,optimiz,optimization,29,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,1,['optimiz'],['optimization']
Performance,/// Specifies the kind of module that has been loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:47,load,loaded,47,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,1,['load'],['loaded']
Performance,/// Specifies whether (or how) name lookup is being performed for a; /// redeclaration (vs. a reference).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:52,perform,performed,52,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performed']
Performance,/// Specify if the library is an OS library but not shared cache eligible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h:59,cache,cache,59,interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,1,['cache'],['cache']
Performance,"/// Specify the latency in cpu cycles for a particular scheduling class and def; /// index. -1 indicates an invalid latency. Heuristics would typically consider; /// an instruction with invalid latency to have infinite latency. Also identify; /// the WriteResources of this def. When the operand expands to a sequence of; /// writes, this ID is the last write in the sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:16,latency,latency,16,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,4,['latency'],['latency']
Performance,"/// Specify the number of cycles allowed after instruction issue before a; /// particular use operand reads its registers. This effectively reduces the; /// write's latency. Here we allow negative cycles for corner cases where; /// latency increases. This rule only applies when the entry's WriteResource; /// matches the write's WriteResource.; ///; /// MCReadAdvanceEntries are sorted first by operand index (UseIdx), then by; /// WriteResourceIdx.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:165,latency,latency,165,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,2,['latency'],['latency']
Performance,"/// Specify the point at which code-completion will be performed.; ///; /// \param File the file in which code completion should occur. If; /// this file is included multiple times, code-completion will; /// perform completion the first time it is included. If NULL, this; /// function clears out the code-completion point.; ///; /// \param Line the line at which code completion should occur; /// (1-based).; ///; /// \param Column the column at which code completion should occur; /// (1-based).; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:55,perform,performed,55,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,2,['perform'],"['perform', 'performed']"
Performance,/// Specify whether this is a volatile load or not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:39,load,load,39,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['load'],['load']
Performance,"/// Speculate a conditional basic block flattening the CFG.; ///; /// Note that this is a very risky transform currently. Speculating; /// instructions like this is most often not desirable. Instead, there is an MI; /// pass which can do it with full awareness of the resource constraints.; /// However, some cases are ""obvious"" and we should do directly. An example of; /// this is speculating a single, reasonably cheap instruction.; ///; /// There is only one distinct advantage to flattening the CFG at the IR level:; /// it makes very common but simplistic optimizations such as are common in; /// instcombine and the DAG combiner more powerful by removing CFG edges and; /// modeling their effects with easier to reason about SSA value graphs.; ///; ///; /// An illustration of this transform is turning this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// br i1 %cmp, label %EndBB, label %ThenBB; /// ThenBB:; /// %sub = sub %x, %y; /// br label BB2; /// EndBB:; /// %phi = phi [ %sub, %ThenBB ], [ 0, %EndBB ]; /// ...; /// \endcode; ///; /// Into this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// %sub = sub %x, %y; /// %cond = select i1 %cmp, 0, %sub; /// ...; /// \endcode; ///; /// \returns true if the conditional block is removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:562,optimiz,optimizations,562,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['optimiz'],['optimizations']
Performance,/// Split a vector load into 2 loads of half the vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h:19,load,load,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,2,['load'],"['load', 'loads']"
Performance,/// Split critical edges found during the previous; /// iteration that may enable further optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:90,optimiz,optimization,90,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['optimiz'],['optimization']
Performance,/// Split critical edges where necessary for good coalescer performance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:60,perform,performance,60,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,1,['perform'],['performance']
Performance,"/// Split the 64-bit value \p LHS into two 32-bit components, and perform the; /// binary operation \p Opc to it with the corresponding constant operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:66,perform,perform,66,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['perform'],['perform']
Performance,"/// Splits block B at the given index which must be greater than zero.; /// If SplitIndex == B.getSize() then this function is a no-op and returns B.; /// If SplitIndex < B.getSize() then this function returns a new block; /// covering the range [ 0, SplitIndex ), and B is modified to cover the range; /// [ SplitIndex, B.size() ).; ///; /// The optional Cache parameter can be used to speed up repeated calls to; /// splitBlock for a single block. If the value is None the cache will be; /// treated as uninitialized and splitBlock will populate it. Otherwise it; /// is assumed to contain the list of Symbols pointing at B, sorted in; /// descending order of offset.; ///; /// Notes:; ///; /// 1. splitBlock must be used with care. Splitting a block may cause; /// incoming edges to become invalid if the edge target subexpression; /// points outside the bounds of the newly split target block (E.g. an; /// edge 'S + 10 : Pointer64' where S points to a newly split block; /// whose size is less than 10). No attempt is made to detect invalidation; /// of incoming edges, as in general this requires context that the; /// LinkGraph does not have. Clients are responsible for ensuring that; /// splitBlock is not used in a way that invalidates edges.; ///; /// 2. The newly introduced block will have a new ordinal which will be; /// higher than any other ordinals in the section. Clients are responsible; /// for re-assigning block ordinals to restore a compatible order if; /// needed.; ///; /// 3. The cache is not automatically updated if new symbols are introduced; /// between calls to splitBlock. Any newly introduced symbols may be; /// added to the cache manually (descending offset order must be; /// preserved), or the cache can be set to None and rebuilt by; /// splitBlock on the next call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:356,Cache,Cache,356,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,5,"['Cache', 'cache']","['Cache', 'cache']"
Performance,/// Splits the chain into subchains where it's safe to hoist loads up to the; /// beginning of the sub-chain and it's safe to sink loads up to the end of; /// the sub-chain. Discards any length-1 subchains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:61,load,loads,61,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,2,['load'],['loads']
Performance,"/// Stack of backtrack positions, allowing nested backtracks.; ///; /// The EnableBacktrackAtThisPos() method pushes a position to; /// indicate where CachedLexPos should be set when the BackTrack() method is; /// invoked (at which point the last position is popped).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:151,Cache,CachedLexPos,151,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['Cache'],['CachedLexPos']
Performance,/// StackOffset holds a fixed and a scalable offset in bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h:36,scalab,scalable,36,interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,1,['scalab'],['scalable']
Performance,/// StackSlotColoring - This pass performs stack coloring and merging.; /// It merges disjoint allocas to reduce the stack size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:34,perform,performs,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,/// StackSlotColoring - This pass performs stack slot coloring.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:34,perform,performs,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,"/// Stage 3: Assuming validate() returned true, perform the; /// replacement.; /// @param BackedgeTakenCount The backedge-taken count of L.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp:48,perform,perform,48,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopRerollPass.cpp,1,['perform'],['perform']
Performance,"/// Start building a new switch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source.; /// Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...).; /// The jitting phase is skipped if the `jit` parameter is `false` (unsafe, use with care).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:115,perform,perform,115,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['perform'],['perform']
Performance,"/// Starting from `fNextFileIndex`, opens the next `fNSlots` files. Calls `LoadStructure()` on the opened files.; /// The very first file is already available from the constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx:75,Load,LoadStructure,75,tree/dataframe/inc/ROOT/RNTupleDS.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx,1,['Load'],['LoadStructure']
Performance,"/// Starting search directory iterator that the cached search was performed; /// from. If there is a hit and this value doesn't match the current query,; /// the cache has to be ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:48,cache,cached,48,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,3,"['cache', 'perform']","['cache', 'cached', 'performed']"
Performance,"/// Starts building a BVH with the given primitive data. The build algorithm is multi-threaded,; /// and runs on the given thread pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/mini_tree_builder.h:80,multi-thread,multi-threaded,80,geom/geom/inc/bvh/v2/mini_tree_builder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/mini_tree_builder.h,1,['multi-thread'],['multi-threaded']
Performance,/// State of the stream error flags.; /// Sometimes it is not known to the checker what error flags are set.; /// This is indicated by setting more than one flag to true.; /// This is an optimization to avoid state splits.; /// A stream can either be in FEOF or FERROR but not both at the same time.; /// Multiple flags are set to handle the corresponding states together.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:187,optimiz,optimization,187,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['optimiz'],['optimization']
Performance,"/// State that this declaration context has had externally visible; /// storage added since the last lookup. In this case, \c LookupPtr's; /// invariant may not hold and needs to be fixed before we perform; /// another lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:198,perform,perform,198,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['perform'],['perform']
Performance,"/// Step backwards through a basic block, looking; /// for an instruction which writes a register within; /// a maximum of INSTR_DISTANCE_THRESHOLD instruction latency cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:160,latency,latency,160,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,1,['latency'],['latency']
Performance,"/// Stepping through CacheLineStep<T> values in a vector<T> brings you to a new cache line.; /// Useful to avoid false sharing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:21,Cache,CacheLineStep,21,tree/dataframe/inc/ROOT/RDF/Utils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx,2,"['Cache', 'cache']","['CacheLineStep', 'cache']"
Performance,/// StepsLeft - The remaining number of evaluation steps we're permitted; /// to perform. This is essentially a limit for the number of statements; /// we will evaluate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:81,perform,perform,81,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['perform'],['perform']
Performance,"/// Storage and load of ASTUnits, cached access, and providing searchability; /// are the concerns of ASTUnitStorage class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:16,load,load,16,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,2,"['cache', 'load']","['cached', 'load']"
Performance,/// Store Linker Optimization Hint information (LOH).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h:17,Optimiz,Optimization,17,interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,1,['Optimiz'],['Optimization']
Performance,/// Store a value. Waits for concurrent \a loadOrGenerate() calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:29,concurren,concurrent,29,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,2,"['concurren', 'load']","['concurrent', 'loadOrGenerate']"
Performance,"/// Stores the declarations from the local translation unit.; /// Note, we pre-compute the local declarations at parse time as an; /// optimization to make sure we do not deserialize everything from disk.; /// The local declaration to all declarations ratio might be very small when; /// working with a PCH file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:135,optimiz,optimization,135,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,1,['optimiz'],['optimization']
Performance,"/// Storing a reference to the type cache here makes it a lot easier; /// to build natural-feeling, target-specific IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h:36,cache,cache,36,interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h,1,['cache'],['cache']
Performance,/// StringLiteralParser - This decodes string escape characters and performs; /// wide string analysis and Translation Phase #6 (concatenation of string; /// literals) (C99 5.1.1.2p1).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h:68,perform,performs,68,interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h,1,['perform'],['performs']
Performance,/// Structs for dyld chained fixups.; /// dyld_chained_fixups_header is the data pointed to by LC_DYLD_CHAINED_FIXUPS; /// load command.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:123,load,load,123,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,1,['load'],['load']
Performance,"/// Structure with information about how a bitfield should be accessed.; ///; /// Often we layout a sequence of bitfields as a contiguous sequence of bits.; /// When the AST record layout does this, we represent it in the LLVM IR's type; /// as either a sequence of i8 members or a byte array to reserve the number of; /// bytes touched without forcing any particular alignment beyond the basic; /// character alignment.; ///; /// Then accessing a particular bitfield involves converting this byte array; /// into a single integer of that size (i24 or i40 -- may not be power-of-two; /// size), loading it, and shifting and masking to extract the particular; /// subsequence of bits which make up that particular bitfield. This structure; /// encodes the information used to construct the extraction code sequences.; /// The CGRecordLayout also has a field index which encodes which byte-sequence; /// this bitfield falls within. Let's assume the following C struct:; ///; /// struct S {; /// char a, b, c;; /// unsigned bits : 3;; /// unsigned more_bits : 4;; /// unsigned still_more_bits : 7;; /// };; ///; /// This will end up as the following LLVM type. The first array is the; /// bitfield, and the second is the padding out to a 4-byte alignment.; ///; /// %t = type { i8, i8, i8, i8, i8, [3 x i8] }; ///; /// When generating code to access more_bits, we'll generate something; /// essentially like this:; ///; /// define i32 @foo(%t* %base) {; /// %0 = gep %t* %base, i32 0, i32 3; /// %2 = load i8* %1; /// %3 = lshr i8 %2, 3; /// %4 = and i8 %3, 15; /// %5 = zext i8 %4 to i32; /// ret i32 %i; /// }; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayout.h:595,load,loading,595,interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGRecordLayout.h,2,['load'],"['load', 'loading']"
Performance,"/// Subclasses of GCStrategy are made available for use during compilation by; /// adding them to the global GCRegistry. This can done either within the; /// LLVM source tree or via a loadable plugin. An example registeration; /// would be:; /// static GCRegistry::Add<CustomGC> X(""custom-name"",; /// ""my custom supper fancy gc strategy"");; ///; /// Note that to use a custom GCMetadataPrinter, you must also; /// register your GCMetadataPrinter subclass with the; /// GCMetadataPrinterRegistery as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GCStrategy.h:184,load,loadable,184,interpreter/llvm-project/llvm/include/llvm/IR/GCStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GCStrategy.h,1,['load'],['loadable']
Performance,"/// Submit a number of read events and wait for completion. Events are submitted in batches if; /// the number of events is larger than the submission queue depth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RIoUring.hxx:151,queue,queue,151,io/io/inc/ROOT/RIoUring.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RIoUring.hxx,1,['queue'],['queue']
Performance,"/// Submit updates to all available trees. It will also; /// 1. discard duplicated updates,; /// 2. remove invalid updates. (Invalid updates means deletion of an edge that; /// still exists or insertion of an edge that does not exist.); /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.; /// 3. It is only legal to submit updates to an edge in the order CFG changes; /// are made. The order you submit updates on different edges is not; /// restricted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:317,queue,queues,317,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,1,['queue'],['queues']
Performance,"/// Subroutine of CommitSealedPageVImpl, used to perform a vector write of the (multi-)range of pages; /// contained in `batch`. The locators for the written pages are appended to `locators`.; /// This procedure also updates some internal metrics of the page sink, hence it's not const.; /// `batch` gets reset to size 0 after the writing is done (but its begin and end are not updated).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:49,perform,perform,49,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,1,['perform'],['perform']
Performance,/// Substitute a slow code sequence with a faster one by; /// evaluating instruction combining pattern.; /// The prototype of such a pattern is MUl + ADD -> MADD. Performs instruction; /// combining based on machine trace metrics. Only combine a sequence of; /// instructions when this neither lengthens the critical path nor increases; /// resource pressure. When optimizing for codesize always combine when the new; /// sequence is shorter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:163,Perform,Performs,163,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,2,"['Perform', 'optimiz']","['Performs', 'optimizing']"
Performance,"/// Substitute template arguments into the default template argument for; /// the given non-type template parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the non-type template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; ///; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:188,perform,performing,188,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['perform'],['performing']
Performance,"/// Substitute template arguments into the default template argument for; /// the given template template parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the template template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; ///; /// \param QualifierLoc Will be set to the nested-name-specifier (with; /// source-location information) that precedes the template name.; ///; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:188,perform,performing,188,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['perform'],['performing']
Performance,"/// Substitute template arguments into the default template argument for; /// the given template type parameter.; ///; /// \param SemaRef the semantic analysis object for which we are performing; /// the substitution.; ///; /// \param Template the template that we are synthesizing template arguments; /// for.; ///; /// \param TemplateLoc the location of the template name that started the; /// template-id we are checking.; ///; /// \param RAngleLoc the location of the right angle bracket ('>') that; /// terminates the template-id.; ///; /// \param Param the template template parameter whose default we are; /// substituting into.; ///; /// \param Converted the list of template arguments provided for template; /// parameters that precede \p Param in the template parameter list.; /// \returns the substituted template argument, or NULL if an error occurred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:184,perform,performing,184,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['perform'],['performing']
Performance,"/// Substitute type arguments from an object type for the Objective-C type; /// parameters used in the subject type.; ///; /// This operation combines the computation of type arguments for; /// substitution (\c Type::getObjCSubstitutions) with the actual process of; /// substitution (\c QualType::substObjCTypeArgs) for the convenience of; /// callers that need to perform a single substitution in isolation.; ///; /// \param objectType The type of the object whose member type we're; /// substituting into. For example, this might be the receiver of a message; /// or the base of a property access.; ///; /// \param dc The declaration context from which the subject type was; /// retrieved, which indicates (for example) which type parameters should; /// be substituted.; ///; /// \param context The context in which the subject type was written.; ///; /// \returns the subject type after replacing all of the Objective-C type; /// parameters with their corresponding arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:366,perform,perform,366,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['perform'],['perform']
Performance,/// Sum of the sizes of the cached binaries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h:28,cache,cached,28,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,1,['cache'],['cached']
Performance,/// SumLinkWeights - Cached sum of the weights of all links + ThresHold.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp:21,Cache,Cached,21,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.cpp,1,['Cache'],['Cached']
Performance,"/// Summarizes cluster-level information that are necessary to load a certain page.; /// Used by LoadPageImpl().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:63,load,load,63,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,2,"['Load', 'load']","['LoadPageImpl', 'load']"
Performance,"/// Summary of how a function affects memory in the program.; ///; /// Loads from constant globals are not considered memory accesses for this; /// interface. Also, functions may freely modify stack space local to their; /// invocation without having to report it through these interfaces.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h:71,Load,Loads,71,interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ModRef.h,1,['Load'],['Loads']
Performance,"/// Summary string representation. This StringRef points to BC module; /// string table and is valid until module data is stored in memory.; /// This is guaranteed to happen until runThinLTOBackend function is; /// called, so it is safe to use this field during thin link. This field; /// is only valid if summary index was loaded from BC file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:324,load,loaded,324,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['load'],['loaded']
Performance,"/// Support structure for SCC passes to communicate updates the call graph back; /// to the CGSCC pass manager infrastructure.; ///; /// The CGSCC pass manager runs SCC passes which are allowed to update the call; /// graph and SCC structures. This means the structure the pass manager works; /// on is mutating underneath it. In order to support that, there needs to be; /// careful communication about the precise nature and ramifications of these; /// updates to the pass management infrastructure.; ///; /// All SCC passes will have to accept a reference to the management layer's; /// update result struct and use it to reflect the results of any CG updates; /// performed.; ///; /// Passes which do not change the call graph structure in any way can just; /// ignore this argument to their run method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:668,perform,performed,668,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['perform'],['performed']
Performance,/// Switch analysis and optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h:24,optimiz,optimization,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,1,['optimiz'],['optimization']
Performance,/// Synchronized with respect to all concurrently executing threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:37,concurren,concurrently,37,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,1,['concurren'],['concurrently']
Performance,"/// SynthMsgSendStretCallExpr - This routine translates message expression; /// into a call to objc_msgSend_stret() entry point. Tricky part is that; /// nil check on receiver must be performed before calling objc_msgSend_stret.; /// MsgSendStretFlavor - function declaration objc_msgSend_stret(...); /// msgSendType - function type of objc_msgSend_stret(...); /// returnType - Result type of the method being synthesized.; /// ArgTypes - type of the arguments passed to objc_msgSend_stret, starting with receiver type.; /// MsgExprs - list of argument expressions being passed to objc_msgSend_stret,; /// starting with receiver.; /// Method - Method being rewritten.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:184,perform,performed,184,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,1,['perform'],['performed']
Performance,/// TCEToolChain - A tool chain using the llvm bitcode tools to perform; /// all subcommands. See http://tce.cs.tut.fi for our peculiar target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.h:64,perform,perform,64,interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.h,1,['perform'],['perform']
Performance,/// TCEToolChain - A tool chain using the llvm bitcode tools to perform; /// all subcommands. See http://tce.cs.tut.fi for our peculiar target.; /// Currently does not support anything else but compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.cpp:64,perform,perform,64,interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/TCE.cpp,1,['perform'],['perform']
Performance,"/// TClass checksum cached from the descriptor after a call to `ConnectPageSource()`. Only set; /// for classes with dictionaries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:20,cache,cached,20,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['cache'],['cached']
Performance,"/// TFormLeafInfo overload: Update (and propagate) cached information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:51,cache,cached,51,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,1,['cache'],['cached']
Performance,"/// TMVA::RSofieReader class for reading external Machine Learning models; /// in ONNX files, Keras .h5 files or PyTorch .pt files; /// and performing the inference using SOFIE; /// It is reccomended to use ONNX if possible since there is a larger support for; /// model operators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RSofieReader.hxx:140,perform,performing,140,tmva/tmva/inc/TMVA/RSofieReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RSofieReader.hxx,1,['perform'],['performing']
Performance,"/// TVirtualRefProxy overload: Update (and propagate) cached information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TRefProxy.h:54,cache,cached,54,tree/treeplayer/inc/TRefProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TRefProxy.h,1,['cache'],['cached']
Performance,"/// Table to cache MD5 values of sample contexts corresponding to; /// readSampleContextFromTable(), used to index into Profiles or; /// FuncOffsetTable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h:13,cache,cache,13,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,1,['cache'],['cache']
Performance,/// Tag - Cache tag is changed when any of the underlying LiveIntervalUnions; /// change.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:10,Cache,Cache,10,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,1,['Cache'],['Cache']
Performance,/// TailCallReturnAddrDelta - The number of bytes by which return address; /// stack slot is moved as the result of tail call optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h:126,optimiz,optimization,126,interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h,1,['optimiz'],['optimization']
Performance,/// Take the resulting completion string.; ///; /// This operation can only be performed once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:79,perform,performed,79,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['perform'],['performed']
Performance,"/// Takes a memcpy and a call that it depends on,; /// and checks for the possibility of a call slot optimization by having; /// the call write its result directly into the destination of the memcpy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:101,optimiz,optimization,101,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['optimiz'],['optimization']
Performance,/// Takes a sequence of \p Rules and group them based on the predicates; /// they share. \p MatcherStorage is used as a memory container; /// for the group that are created as part of this process.; ///; /// What this optimization does looks like if GroupT = GroupMatcher:; /// Output without optimization:; /// \verbatim; /// # R1; /// # predicate A; /// # predicate B; /// ...; /// # R2; /// # predicate A // <-- effectively this is going to be checked twice.; /// // Once in R1 and once in R2.; /// # predicate C; /// \endverbatim; /// Output with optimization:; /// \verbatim; /// # Group1_2; /// # predicate A // <-- Check is now shared.; /// # R1; /// # predicate B; /// # R2; /// # predicate C; /// \endverbatim,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:218,optimiz,optimization,218,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,3,['optimiz'],['optimization']
Performance,"/// Takes the read lock for the descriptor. Multiple threads can take the lock concurrently.; /// The underlying `std::shared_mutex`, however, is neither read nor write recursive:; /// within one thread, only one lock (shared or exclusive) must be acquired at the same time. This requires special; /// care in sections protected by `GetSharedDescriptorGuard()` and `GetExclDescriptorGuard()` especially to avoid; /// that the locks are acquired indirectly (e.g. by a call to `GetNEntries()`). As a general guideline, no other; /// method of the page source should be called (directly or indirectly) in a guarded section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:79,concurren,concurrently,79,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['concurren'],['concurrently']
Performance,/// Target-specific DAG combine function for NEON load/store intrinsics; /// to merge base address updates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:50,load,load,50,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['load']
Performance,"/// TargetInstrInfo overrides.; /// If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:90,load,load,90,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,3,['load'],"['load', 'loaded', 'loading']"
Performance,"/// Targets can specify ISD nodes that they would like PerformDAGCombine; /// callbacks for by calling setTargetDAGCombine(), which sets a bit in this; /// array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:55,Perform,PerformDAGCombine,55,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Perform'],['PerformDAGCombine']
Performance,/// Targets should invoke this method for each target independent node that; /// they want to provide a custom DAG combiner for by implementing the; /// PerformDAGCombine virtual method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:153,Perform,PerformDAGCombine,153,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Perform'],['PerformDAGCombine']
Performance,/// Tell that a new AST was loaded successfully.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:28,load,loaded,28,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['load'],['loaded']
Performance,/// Temporary cache of DBG_VALUEs to be entered into the Transfers collection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:14,cache,cache,14,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['cache'],['cache']
Performance,/// Temporary flag to test global copy optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:39,optimiz,optimization,39,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['optimiz'],['optimization']
Performance,"/// Test changing queueType after a Queue has already been built; this should not be allowed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Queue.cxx:18,queue,queueType,18,roofit/multiprocess/test/test_Queue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Queue.cxx,2,"['Queue', 'queue']","['Queue', 'queueType']"
Performance,"/// Test if A and B will obviously have the same value.; ///; /// This includes recognizing that %t0 and %t1 will have the same; /// value in code like this:; /// \code; /// %t0 = getelementptr \@a, 0, 3; /// store i32 0, i32* %t0; /// %t1 = getelementptr \@a, 0, 3; /// %t2 = load i32* %t1; /// \endcode; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:277,load,load,277,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['load'],['load']
Performance,/// Test if V is always a pointer to allocated and suitably aligned memory for; /// a simple load or store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:93,load,load,93,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['load'],['load']
Performance,/// Test if a DataLayout if compatible with the CodeGen for this target.; ///; /// The LLVM Module owns a DataLayout that is used for the target independent; /// optimizations and code generation. This hook provides a target specific; /// check on the validity of this DataLayout.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h:162,optimiz,optimizations,162,interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,1,['optimiz'],['optimizations']
Performance,/// Test if given that the input instruction is in the tail call position if the; /// return type or any attributes of the function will inhibit tail call; /// optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:160,optimiz,optimization,160,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,1,['optimiz'],['optimization']
Performance,"/// Test if given that the input instruction is in the tail call position, if; /// there is an attribute mismatch between the caller and the callee that will; /// inhibit tail call optimizations.; /// \p AllowDifferingSizes is an output parameter which, if forming a tail call; /// is permitted, determines whether it's permitted only if the size of the; /// caller's and callee's return types match exactly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:181,optimiz,optimizations,181,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,1,['optimiz'],['optimizations']
Performance,/// Test if the VectorInfo can be part of an interleaved load with the; /// specified factor.; ///; /// \param Factor of the interleave; /// \param DL Targets Datalayout; ///; /// \returns true if this is possible and false if not,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:57,load,load,57,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['load'],['load']
Performance,"/// Test if the given EVT has zero size, this will fail if called on a; /// scalable type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:76,scalab,scalable,76,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,1,['scalab'],['scalable']
Performance,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:57,optimiz,optimized,57,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,2,['optimiz'],['optimized']
Performance,/// Test if the given module looks interesting to run ARC optimization; /// on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:58,optimiz,optimization,58,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,1,['optimiz'],['optimization']
Performance,"/// Test that things still work when hash lookup for elements; /// is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testWorkspace.cxx:70,perform,performed,70,roofit/roofitcore/test/testWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testWorkspace.cxx,1,['perform'],['performed']
Performance,"/// Test whether a shuffle mask is equivalent within each sub-lane.; ///; /// This checks a shuffle mask to see if it is performing the same; /// lane-relative shuffle in each sub-lane. This trivially implies; /// that it is also not lane-crossing. It may however involve a blend from the; /// same lane of a second vector.; ///; /// The specific repeated shuffle mask is populated in \p RepeatedMask, as it is; /// non-trivial to compute in the face of undef lanes. The representation is; /// suitable for use with existing 128-bit shuffles as entries from the second; /// vector have been remapped to [LaneSize, 2*LaneSize).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:121,perform,performing,121,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['performing']
Performance,/// Test whether all analyses are preserved (and none are abandoned).; ///; /// This is used primarily to optimize for the common case of a transformation; /// which makes no changes to the IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:106,optimiz,optimize,106,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['optimiz'],['optimize']
Performance,"/// Test whether an argument type which is to be passed indirectly (on the; /// stack) would have the equivalent layout if it was expanded into separate; /// arguments. If so, we prefer to do the latter to avoid inhibiting; /// optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:228,optimiz,optimizations,228,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['optimiz'],['optimizations']
Performance,/// Test whether the given alloca partition's integer operations can be; /// widened to promotable ones.; ///; /// This is a quick test to check whether we can rewrite the integer loads and; /// stores to a particular alloca into wider loads and stores and be able to; /// promote the resulting alloca.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:180,load,loads,180,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,2,['load'],['loads']
Performance,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:278,load,loads,278,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['load'],['loads']
Performance,/// Test whether the given instruction can autorelease any pointer or cause an; /// autoreleasepool pop.; ///; /// This means that it *could* interrupt the RV optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:159,optimiz,optimization,159,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,1,['optimiz'],['optimization']
Performance,"/// Test whether this block is used as something other than the target of a; /// terminator, exception-handling target, jump table, or IR blockaddress.; /// For example, its address might be loaded into a register, or; /// stored in some branch table that isn't part of MachineJumpTableInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:191,load,loaded,191,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['load'],['loaded']
Performance,/// Tests if the function is both available and a candidate for optimized code; /// generation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:64,optimiz,optimized,64,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,1,['optimiz'],['optimized']
Performance,/// Tests if this call site must be tail call optimized. Only a CallInst can; /// be tail call optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:46,optimiz,optimized,46,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,4,['optimiz'],['optimized']
Performance,"/// Textual identifier for the remark (single-word, camel-case). Can be used; /// by external tools reading the output file for optimization remarks to; /// identify the remark.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:128,optimiz,optimization,128,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,"/// The ""on"" or ""off"" argument passed by \#pragma optimize, that denotes; /// whether the optimizations in the list passed to the pragma should be; /// turned off or on. This boolean is true by default because command line; /// options are honored when `#pragma optimize("""", on)`.; /// (i.e. `ModifyFnAttributeMSPragmaOptimze()` does nothing)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:50,optimiz,optimize,50,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,3,['optimiz'],"['optimizations', 'optimize']"
Performance,"/// The (vector) operation should be implemented by widening the input; /// vector and ignoring the lanes added by doing so. For example <2 x i8> is; /// rarely legal, but you might perform an <8 x i8> and then only look at; /// the first two results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h:182,perform,perform,182,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h,2,['perform'],['perform']
Performance,"/// The AESDEC128KL performs 10 rounds of AES to decrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESDEC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := (HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES128Decrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,perform,performs,20,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,2,"['Load', 'perform']","['Load', 'performs']"
Performance,"/// The AESDEC256KL performs 10 rounds of AES to decrypt the __idata using; /// the 256-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESDEC256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h]; /// IllegalHandle := (HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES256); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES256Decrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,perform,performs,20,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,1,['perform'],['performs']
Performance,"/// The AESENC128KL performs 10 rounds of AES to encrypt the __idata using; /// the 128-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC128KL </c> instructions.; ///; /// \code{.operation}; /// Handle[383:0] := MEM[__h+383:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[383:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[383:256] ||; /// HandleKeyType (Handle[383:0]) != HANDLE_KEY_TYPE_AES128 ); /// IF (IllegalHandle); /// ZF := 1; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate384 (Handle[383:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// ELSE; /// MEM[__odata+127:__odata] := AES128Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,perform,performs,20,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,2,"['Load', 'perform']","['Load', 'performs']"
Performance,"/// The AESENC256KL performs 14 rounds of AES to encrypt the __idata using; /// the 256-bit key in the handle from the __h. It stores the result in the; /// __odata. And return the affected ZF flag status.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> AESENC256KL </c> instructions.; ///; /// \code{.operation}; /// Handle[511:0] := MEM[__h+511:__h] // Load is not guaranteed to be atomic.; /// IllegalHandle := ( HandleReservedBitSet (Handle[511:0]) ||; /// (Handle[127:0] AND (CPL > 0)) ||; /// Handle[255:128] ||; /// HandleKeyType (Handle[511:0]) != HANDLE_KEY_TYPE_AES256 ); /// IF (IllegalHandle); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// (UnwrappedKey, Authentic) := UnwrapKeyAndAuthenticate512 (Handle[511:0], IWKey); /// IF (Authentic == 0); /// ZF := 1; /// MEM[__odata+127:__odata] := 0; /// ELSE; /// MEM[__odata+127:__odata] := AES256Encrypt (__idata[127:0], UnwrappedKey); /// ZF := 0; /// FI; /// FI; /// dst := ZF; /// OF := 0; /// SF := 0; /// AF := 0; /// PF := 0; /// CF := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:20,perform,performs,20,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,2,"['Load', 'perform']","['Load', 'performs']"
Performance,"/// The APFixedPoint class works similarly to APInt/APSInt in that it is a; /// functional replacement for a scaled integer. It supports a wide range of; /// semantics including the one used by fixed point types proposed in ISO/IEC; /// JTC1 SC22 WG14 N1169. The class carries the value and semantics of; /// a fixed point, and provides different operations that would normally be; /// performed on fixed point types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h:386,perform,performed,386,interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,1,['perform'],['performed']
Performance,"/// The API notes manager helps find API notes associated with declarations.; ///; /// API notes are externally-provided annotations for declarations that can; /// introduce new attributes (covering availability, nullability of; /// parameters/results, and so on) for specific declarations without directly; /// modifying the headers that contain those declarations.; ///; /// The API notes manager is responsible for finding and loading the; /// external API notes files that correspond to a given header. Its primary; /// operation is \c findAPINotes(), which finds the API notes reader that; /// provides information about the declarations at that location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h:430,load,loading,430,interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,1,['load'],['loading']
Performance,/// The AST consumer that received information about the translation; /// unit as it was parsed or loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:99,load,loaded,99,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['load'],['loaded']
Performance,"/// The AddressRanges class helps normalize address range collections.; /// This class keeps a sorted vector of AddressRange objects and can perform; /// insertions and searches efficiently. Intersecting([100,200), [150,300)); /// and adjacent([100,200), [200,300)) address ranges are combined during; /// insertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h:141,perform,perform,141,interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,1,['perform'],['perform']
Performance,"/// The AddressRangesBase class presents the base functionality for the; /// normalized address ranges collection. This class keeps a sorted vector; /// of AddressRange-like objects and can perform searches efficiently.; /// The address ranges are always sorted and never contain any invalid,; /// empty or intersected address ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h:190,perform,perform,190,interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,1,['perform'],['perform']
Performance,/// The BFS queue type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:12,queue,queue,12,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['queue'],['queue']
Performance,/// The Decl IDs for the Sema/Lexical DeclContext of a Decl that has; /// been loaded but its DeclContext was not set yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:79,load,loaded,79,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,/// The DefinitionData pointers that we faked up for class definitions; /// that we needed but hadn't loaded yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:102,load,loaded,102,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// The DeltaTree class is a multiway search tree (BTree) structure with some; /// fancy features. B-Trees are generally more memory and cache efficient; /// than binary trees, because they store multiple keys/values in each node.; ///; /// DeltaTree implements a key/value mapping from FileIndex to Delta, allowing; /// fast lookup by FileIndex. However, an added (important) bonus is that it; /// can also efficiently tell us the full accumulated delta for a specific; /// file offset as well, without traversing the whole tree.; ///; /// The nodes of the tree are made up of instances of two classes:; /// DeltaTreeNode and DeltaTreeInteriorNode. The later subclasses the; /// former and adds children pointers. Each node knows the full delta of all; /// entries (recursively) contained inside of it, which allows us to get the; /// full delta implied by a whole subtree in constant time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:137,cache,cache,137,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,1,['cache'],['cache']
Performance,"/// The FileID's of the cached query.; ///; /// If these match up with a subsequent query, the result can be reused.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:24,cache,cached,24,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['cache'],['cached']
Performance,"/// The GSYM header.; ///; /// The GSYM header is found at the start of a stand alone GSYM file, or as; /// the first bytes in a section when GSYM is contained in a section of an; /// executable file (ELF, mach-o, COFF).; ///; /// The structure is encoded exactly as it appears in the structure definition; /// with no gaps between members. Alignment should not change from system to; /// system as the members were laid out so that they shouldn't align; /// differently on different architectures.; ///; /// When endianness of the system loading a GSYM file matches, the file can; /// be mmap'ed in and a pointer to the header can be cast to the first bytes; /// of the file (stand alone GSYM file) or section data (GSYM in a section).; /// When endianness is swapped, the Header::decode() function should be used to; /// decode the header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h:539,load,loading,539,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h,1,['load'],['loading']
Performance,"/// The I/O thread calls RPageSource::LoadClusters() asynchronously. The thread is mostly waiting for the; /// data to arrive (blocked by the kernel) and therefore can safely run in addition to the application; /// main threads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:38,Load,LoadClusters,38,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,1,['Load'],['LoadClusters']
Performance,/// The ID number of the controlling macro.; ///; /// This ID number will be non-zero when there is a controlling; /// macro whose IdentifierInfo may not yet have been loaded from; /// external storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:168,load,loaded,168,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['load'],['loaded']
Performance,/// The IR value (currently basic block) that the optimization operates on.; /// This is currently used to provide run-time hotness information with PGO.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:50,optimiz,optimization,50,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,/// The IsBeforeInTranslationUnitCache is a mapping from FileID pairs; /// to cache results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:78,cache,cache,78,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['cache'],['cache']
Performance,/// The L1 cache is write through so does not need to be bypassed. There is no; /// bypass control for the L2 cache at the isa level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:11,cache,cache,11,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,2,['cache'],['cache']
Performance,/// The Load Instruction used to Load the entry. LI is null if the pointer; /// of the load instruction does not point on to the entry,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:8,Load,Load,8,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,3,"['Load', 'load']","['Load', 'load']"
Performance,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:171,optimiz,optimizations,171,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,4,"['optimiz', 'perform']","['optimization', 'optimizations', 'performed']"
Performance,/// The OptimizationRemarkEmitter available for this compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:8,Optimiz,OptimizationRemarkEmitter,8,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['Optimiz'],['OptimizationRemarkEmitter']
Performance,"/// The RCIdentity root of a value \p V is a dominating value U for which; /// retaining or releasing U is equivalent to retaining or releasing V. In other; /// words, ARC operations on \p V are equivalent to ARC operations on \p U.; ///; /// We use this in the ARC optimizer to make it easier to match up ARC; /// operations by always mapping ARC operations to RCIdentityRoots instead of; /// pointers themselves.; ///; /// The two ways that we see RCIdentical values in ObjC are via:; ///; /// 1. PointerCasts; /// 2. Forwarding Calls that return their argument verbatim.; ///; /// Thus this function strips off pointer casts and forwarding calls. *NOTE*; /// This implies that two RCIdentical values must alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:266,optimiz,optimizer,266,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,1,['optimiz'],['optimizer']
Performance,"/// The SP register is moved in steps of 'MaxImmU16' towards the top of the; /// frame. During these steps, it may be necessary to re-load registers.; /// IfNeededLDAWSP emits the necessary LDAWSP instructions to move the SP only; /// as far as to make 'OffsetFromTop' reachable using an LDAWSP_lru6.; /// \param OffsetFromTop the spill offset from the top of the frame.; /// \param [in,out] RemainingAdj the current SP offset from the top of the; /// frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp:134,load,load,134,interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreFrameLowering.cpp,1,['load'],['load']
Performance,/// The ScalableErrorAsWarning is a temporary measure to suppress errors from; /// using the wrong interface on a scalable vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/TypeSize.cpp:8,Scalab,ScalableErrorAsWarning,8,interpreter/llvm-project/llvm/lib/Support/TypeSize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/TypeSize.cpp,2,"['Scalab', 'scalab']","['ScalableErrorAsWarning', 'scalable']"
Performance,"/// The VE backend uses a two-staged process to lower and legalize vector; /// instructions:; //; /// 1. VP and standard vector SDNodes are lowered to SDNodes of the VVP_* layer.; //; // All VVP nodes have a mask and an Active Vector Length (AVL) parameter.; // The AVL parameters refers to the element position in the vector the VVP; // node operates on.; //; //; // 2. The VVP SDNodes are legalized. The AVL in a legal VVP node refers to; // chunks of 64bit. We track this by wrapping the AVL in a LEGALAVL node.; //; // The AVL mechanism in the VE architecture always refers to chunks of; // 64bit, regardless of the actual element type vector instructions are; // operating on. For vector types v256.32 or v256.64 nothing needs to be; // legalized since each element occupies a 64bit chunk - there is no; // difference between counting 64bit chunks or element positions. However,; // all vector types with > 256 elements store more than one logical element; // per 64bit chunk and need to be transformed.; // However legalization is performed, the resulting legal VVP SDNodes will; // have a LEGALAVL node as their AVL operand. The LEGALAVL nodes wraps; // around an AVL that refers to 64 bit chunks just as the architecture; // demands - that is, the wrapped AVL is the correct setting for the VL; // register for this VVP operation to get the desired behavior.; //; /// AVL Functions {; // The AVL operand position of this node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h:1037,perform,performed,1037,interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VECustomDAG.h,1,['perform'],['performed']
Performance,/// The VFS that is used by clang consumes the \c CachedFileSystemEntry using; /// this subclass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp:50,Cache,CachedFileSystemEntry,50,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningFilesystem.cpp,1,['Cache'],['CachedFileSystemEntry']
Performance,"/// The __builtin_clz* and __builtin_ctz* built-in; /// functions are specified to have undefined results for zero inputs, but; /// on targets that support these operations in a way that provides; /// well-defined results for zero without loss of performance, it is a good; /// idea to avoid optimizing based on that undef behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:247,perform,performance,247,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,2,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,/// The action to perform upon a completion request.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LineEditor/LineEditor.h:18,perform,perform,18,interpreter/llvm-project/llvm/include/llvm/LineEditor/LineEditor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LineEditor/LineEditor.h,1,['perform'],['perform']
Performance,/// The actual class performing the per-loop work.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:21,perform,performing,21,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['perform'],['performing']
Performance,/// The adjustment that we need to apply to get the operand latency from the; /// operand cycle returned by the itinerary data for pre-ISel operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:60,latency,latency,60,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,1,['latency'],['latency']
Performance,/// The alignment requirement of the queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp:37,queue,queue,37,interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,1,['queue'],['queue']
Performance,"/// The amount that a frame offset needs to be adjusted to; /// have the actual offset from the stack/frame pointer. The exact usage of; /// this is target-dependent, but it is typically used to adjust between; /// SP-relative and FP-relative offsets. E.G., if objects are accessed via; /// SP then OffsetAdjustment is zero; if FP is used, OffsetAdjustment is set; /// to the distance between the initial SP and the value in FP. For many; /// targets, this value is only used when generating debug info (via; /// TargetRegisterInfo::getFrameIndexReference); when generating code, the; /// corresponding adjustments are performed directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:619,perform,performed,619,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['perform'],['performed']
Performance,/// The argument is semantically a load from this l-value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h:35,load,load,35,interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,1,['load'],['load']
Performance,/// The assumption cache analysis is used to compute the minimum type size in; /// which a reduction can be computed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:19,cache,cache,19,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['cache'],['cache']
Performance,"/// The await_suspend call performed by co_await is essentially asynchronous; /// to the execution of the coroutine. Inlining it normally into an unsplit; /// coroutine can cause miscompilation because the coroutine CFG misrepresents; /// the true control flow of the program: things that happen in the; /// await_suspend are not guaranteed to happen prior to the resumption of the; /// coroutine, and things that happen after the resumption of the coroutine; /// (including its exit and the potential deallocation of the coroutine frame); /// are not guaranteed to happen only after the end of await_suspend.; ///; /// See https://github.com/llvm/llvm-project/issues/56301 and; /// https://reviews.llvm.org/D157070 for the example and the full discussion.; ///; /// The short-term solution to this problem is to mark the call as uninlinable.; /// But we don't want to do this if the call is known to be trivial, which is; /// very common.; ///; /// The long-term solution may introduce patterns like:; ///; /// call @llvm.coro.await_suspend(ptr %awaiter, ptr %handle,; /// ptr @awaitSuspendFn); ///; /// Then it is much easier to perform the safety analysis in the middle end.; /// If it is safe to inline the call to awaitSuspend, we can replace it in the; /// CoroEarly pass. Otherwise we could replace it in the CoroSplit pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:27,perform,performed,27,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,2,['perform'],"['perform', 'performed']"
Performance,/// The backing storage for cached contents.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:28,cache,cached,28,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cached']
Performance,/// The backing storage for cached entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:28,cache,cached,28,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cached']
Performance,/// The cache of PCM files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:8,cache,cache,8,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,1,['cache'],['cache']
Performance,"/// The cache of clusters around the currently active cluster",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:8,cache,cache,8,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,1,['cache'],['cache']
Performance,/// The cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:8,cache,cache,8,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['cache'],['cache']
Performance,"/// The cached file size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx:8,cache,cached,8,io/io/inc/ROOT/RRawFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx,1,['cache'],['cached']
Performance,/// The cached gain of moving a \p FunctionNode from the left bucket to the; /// right bucket,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h:8,cache,cached,8,interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,1,['cache'],['cached']
Performance,/// The cached gain of moving a \p FunctionNode from the right bucket to the; /// left bucket,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h:8,cache,cached,8,interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,1,['cache'],['cached']
Performance,/// The cached properties of a type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:8,cache,cached,8,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['cache'],['cached']
Performance,"/// The candidate callsite being analyzed. Please do not use this to do; /// analysis in the caller function; we want the inline cost query to be; /// easily cacheable. Instead, use the cover function paramHasAttr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:158,cache,cacheable,158,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['cache'],['cacheable']
Performance,"/// The chain of AST files, in the order in which we started to load; /// them (this order isn't really useful for anything).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:64,load,load,64,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['load']
Performance,"/// The class's unary functions performing the gif test according to the ETestType provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GoFTest.h:32,perform,performing,32,math/mathcore/inc/Math/GoFTest.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GoFTest.h,1,['perform'],['performing']
Performance,/// The client can handle an AST file that cannot load because it's; /// compiled configuration doesn't match that of the context it was; /// loaded into.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:50,load,load,50,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,2,['load'],"['load', 'loaded']"
Performance,/// The client can handle an AST file that cannot load because it; /// is missing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:50,load,load,50,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['load']
Performance,/// The client can handle an AST file that cannot load because it; /// is out-of-date relative to its input files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:50,load,load,50,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['load']
Performance,/// The client can handle an AST file that cannot load because it; /// was built with a different version of Clang.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:50,load,load,50,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['load']
Performance,/// The client can't handle any AST loading failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:36,load,loading,36,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loading']
Performance,"/// The cluster IDs can be empty if the corresponding page list is not loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:71,load,loaded,71,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,1,['load'],['loaded']
Performance,/// The combiner's goal may differ based on which pattern it is attempting; /// to optimize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:83,optimiz,optimize,83,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,1,['optimiz'],['optimize']
Performance,/// The content cache and the characteristic of the file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:16,cache,cache,16,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['cache'],['cache']
Performance,"/// The control block, which contains all of the information that needs to; /// be validated prior to committing to loading the API notes file.; ///; /// \sa control_block",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h:116,load,loading,116,interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/APINotes/APINotesFormat.h,1,['load'],['loading']
Performance,"/// The control block, which contains all of the; /// information that needs to be validated prior to committing; /// to loading the AST file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:121,load,loading,121,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['load'],['loading']
Performance,"/// The conventional meaning of this method; an ObjCMethodFamily.; /// This is not serialized; instead, it is computed on demand and; /// cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:138,cache,cached,138,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['cache'],['cached']
Performance,"/// The conversions that would be performed on an lvalue of type T2 when; /// binding a reference of type T1 to it, as determined when evaluating; /// whether T1 is reference-compatible with T2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:34,perform,performed,34,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performed']
Performance,"/// The core of the Dsymutil Dwarf linking logic.; ///; /// The link of the dwarf information from the object files will be; /// driven by DWARFLinker. DwarfLinkerForBinary reads DebugMap objects; /// and pass information to the DWARFLinker. DWARFLinker; /// optimizes DWARF taking into account valid relocations.; /// Finally, optimized DWARF is passed to DwarfLinkerForBinary through; /// DWARFEmitter interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:259,optimiz,optimizes,259,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,2,['optimiz'],"['optimized', 'optimizes']"
Performance,/// The cost calculation for Load/Store instruction \p I with uniform pointer -; /// Load: scalar load + broadcast.; /// Store: scalar store + (loop invariant value stored? 0 : extract of last; /// element),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:29,Load,Load,29,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,3,"['Load', 'load']","['Load', 'load']"
Performance,/// The cost threshold for the unrolled loop when optimizing for size (set; /// to UINT_MAX to disable).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:50,optimiz,optimizing,50,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['optimiz'],['optimizing']
Performance,"/// The cost threshold for the unrolled loop when optimizing for size, like; /// OptSizeThreshold, but used for partial/runtime unrolling (set to; /// UINT_MAX to disable).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:50,optimiz,optimizing,50,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['optimiz'],['optimizing']
Performance,"/// The current array initialization index, if we're performing array; /// initialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:53,perform,performing,53,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['perform'],['performing']
Performance,"/// The current expression occurs within a braced-init-list within; /// an unevaluated operand. This is mostly like a regular unevaluated; /// context, except that we still instantiate constexpr functions that are; /// referenced here so that we can perform narrowing checks correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:250,perform,perform,250,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['perform']
Performance,/// The current implementation of ELFDebugObject replicates the approach used in; /// RuntimeDyld: It patches executable and data section headers in the given; /// object buffer with load-addresses of their corresponding sections in target; /// memory.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp:183,load,load-addresses,183,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/DebugObjectManagerPlugin.cpp,1,['load'],['load-addresses']
Performance,"/// The current index stack. We use a simple unsigned stack because; /// we assume that placeholders will be relatively sparse in the; /// initializer, but we cache the index values we find just in case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp:159,cache,cache,159,interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,1,['cache'],['cache']
Performance,"/// The default constructor sets the pass options to create canonical IR,; /// rather than optimal IR. That is, by default we bypass transformations that; /// are likely to improve performance but make analysis for other passes more; /// difficult.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:181,perform,performance,181,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,1,['perform'],['performance']
Performance,"/// The default method filter, which is used to filter out the methods on which; /// the check should not be performed.; ///; /// Checks for the init, dealloc, and any other functions that might be allowed; /// to perform direct instance variable assignment based on their name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp:109,perform,performed,109,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DirectIvarAssignment.cpp,2,['perform'],"['perform', 'performed']"
Performance,"/// The default value for MaxUsesToExplore argument. It's relatively small to; /// keep the cost of analysis reasonable for clients like BasicAliasAnalysis,; /// where the results can't be cached.; /// TODO: we should probably introduce a caching CaptureTracking analysis and; /// use it where possible. The caching version can use much higher limit or; /// don't have this cap at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:189,cache,cached,189,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,1,['cache'],['cached']
Performance,/// The depth of template parameters for which deduction is being; /// performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:71,perform,performed,71,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['perform'],['performed']
Performance,/// The diagnostic client that performs the actual formatting; /// of error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:31,perform,performs,31,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,1,['perform'],['performs']
Performance,"/// The diagnostic state for the parent file. This is strictly redundant,; /// as looking up the DecomposedIncludedLoc for the FileID in the Files; /// map would give us this, but we cache it here for performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:183,cache,cache,183,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,2,"['cache', 'perform']","['cache', 'performance']"
Performance,/// The directories used to load prebuilt module files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h:28,load,load,28,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,1,['load'],['load']
Performance,/// The directory entry which should be used for the cached framework.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:53,cache,cached,53,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['cache'],['cached']
Performance,/// The directory used for the module cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h:38,cache,cache,38,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,1,['cache'],['cache']
Performance,/// The distinct types of work performed by the work loop in; /// analyzeContextInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:31,perform,performed,31,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['perform'],['performed']
Performance,/// The distinct types of work performed by the work loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h:31,perform,performed,31,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,1,['perform'],['performed']
Performance,/// The driver translated arguments. Note that toolchains may perform their; /// own argument translation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h:62,perform,perform,62,interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,1,['perform'],['perform']
Performance,/// The edge sequence object.; ///; /// This typically exists entirely within the node but is exposed as; /// a separate type because a node doesn't initially have edges. An explicit; /// population step is required to produce this sequence at first and it is; /// then cached in the node. It is also used to represent edges entering the; /// graph from outside the module to model the graph's roots.; ///; /// The sequence itself both iterable and indexable. The indexes remain; /// stable even as the sequence mutates (including removal).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:270,cache,cached,270,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['cache'],['cached']
Performance,"/// The element quantity of this vector. The meaning of this value depends; /// on the type of vector:; /// - For FixedVectorType = <ElementQuantity x ty>, there are; /// exactly ElementQuantity elements in this vector.; /// - For ScalableVectorType = <vscale x ElementQuantity x ty>,; /// there are vscale * ElementQuantity elements in this vector, where; /// vscale is a runtime-constant integer greater than 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:231,Scalab,ScalableVectorType,231,interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,1,['Scalab'],['ScalableVectorType']
Performance,"/// The expiration for a file. When a file hasn't been accessed for Expiration; /// seconds, it is removed from the cache. A value of 0 disables the; /// expiration-based pruning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:116,cache,cache,116,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,1,['cache'],['cache']
Performance,/// The fast path of loading shadows.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:21,load,loading,21,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['load'],['loading']
Performance,"/// The file does not contain base relocations and must be loaded at its; /// preferred base. If this cannot be done, the loader will error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:59,load,loaded,59,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,2,['load'],"['loaded', 'loader']"
Performance,"/// The file system to be used during the scan.; /// This is either \c FS passed in the constructor (when performing canonical; /// preprocessing), or \c DepFS (when performing dependency directives scan).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:106,perform,performing,106,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,2,['perform'],['performing']
Performance,"/// The file that we're performing code-completion for, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:24,perform,performing,24,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['perform'],['performing']
Performance,/// The files specified here are linked in to the module before optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:64,optimiz,optimizations,64,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,1,['optimiz'],['optimizations']
Performance,"/// The fixpoint analysis framework that orchestrates the attribute deduction.; ///; /// The Attributor provides a general abstract analysis framework (guided; /// fixpoint iteration) as well as helper functions for the deduction of; /// (LLVM-IR) attributes. However, also other code properties can be deduced,; /// propagated, and ultimately manifested through the Attributor framework. This; /// is particularly useful if these properties interact with attributes and a; /// co-scheduled deduction allows to improve the solution. Even if not, thus if; /// attributes/properties are completely isolated, they should use the; /// Attributor framework to reduce the number of fixpoint iteration frameworks; /// in the code base. Note that the Attributor design makes sure that isolated; /// attributes are not impacted, in any way, by others derived at the same time; /// if there is no cross-reasoning performed.; ///; /// The public facing interface of the Attributor is kept simple and basically; /// allows abstract attributes to one thing, query abstract attributes; /// in-flight. There are two reasons to do this:; /// a) The optimistic state of one abstract attribute can justify an; /// optimistic state of another, allowing to framework to end up with an; /// optimistic (=best possible) fixpoint instead of one based solely on; /// information in the IR.; /// b) This avoids reimplementing various kinds of lookups, e.g., to check; /// for existing IR attributes, in favor of a single lookups interface; /// provided by an abstract attribute subclass.; ///; /// NOTE: The mechanics of adding a new ""concrete"" abstract attribute are; /// described in the file comment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:903,perform,performed,903,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['perform'],['performed']
Performance,"/// The flag enables call site info production. It is used only for debug; /// info, and it is restricted only to optimized code. This can be used for; /// something else, so that should be controlled in the frontend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:114,optimiz,optimized,114,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['optimiz'],['optimized']
Performance,"/// The following callbacks deal with tasks, which normally represent the; /// entire optimization and code generation pipeline for what will become a; /// single native object file. Each task has a unique identifier between 0 and; /// getMaxTasks()-1, which is supplied to the callback via the Task parameter.; /// A task represents the entire pipeline for ThinLTO and regular; /// (non-parallel) LTO, but a parallel code generation task will be split into; /// N tasks before code generation, where N is the parallelism level.; ///; /// LTO may decide to stop processing a task at any time, for example if the; /// module is empty or if a module hook (see below) returns false. For this; /// reason, the client should not expect to receive exactly getMaxTasks(); /// native object files.; /// A module hook may be used by a linker to perform actions during the LTO; /// pipeline. For example, a linker may use this function to implement; /// -save-temps. If this function returns false, any further processing for; /// that task is aborted.; ///; /// Module hooks must be thread safe with respect to the linker's internal; /// data structures. A module hook will never be called concurrently from; /// multiple threads with the same task ID, or the same module.; ///; /// Note that in out-of-process backend scenarios, none of the hooks will be; /// called for ThinLTO tasks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:86,optimiz,optimization,86,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,3,"['concurren', 'optimiz', 'perform']","['concurrently', 'optimization', 'perform']"
Performance,"/// The following functions fetch a debuginfod artifact to a file in a local; /// cache and return the cached file path. They first search the local cache,; /// followed by the debuginfod servers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp:82,cache,cache,82,interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp,3,['cache'],"['cache', 'cached']"
Performance,/// The frontend action to perform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h:27,perform,perform,27,interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,1,['perform'],['perform']
Performance,/// The function for which this cache is handling assumptions.; ///; /// We track this to lazily populate our assumptions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:32,cache,cache,32,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['cache'],['cache']
Performance,/// The function has Scalable Vector or Scalable Predicate register argument; /// or return type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.h:21,Scalab,Scalable,21,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.h,2,['Scalab'],['Scalable']
Performance,/// The function-level optimization remark emitter. Used to emit remarks; /// whenever manipulating the DAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:23,optimiz,optimization,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['optimiz'],['optimization']
Performance,"/// The generation number of each identifier, which keeps track of; /// the last time we loaded information about this identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:89,load,loaded,89,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,/// The generation number of the last time we loaded data from the; /// global method pool for this selector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:46,load,loaded,46,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// The given basic block lies in the current EH scope, but may be a; /// target of a potentially scope-crossing jump; get a stable handle; /// to which we can perform this jump later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:160,perform,perform,160,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,2,['perform'],['perform']
Performance,/// The global cache shared between worker threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:15,cache,cache,15,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cache']
Performance,/// The global file system cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:27,cache,cache,27,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,1,['cache'],['cache']
Performance,"/// The global module index, if loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:32,load,loaded,32,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// The goal of this function is to remove redundant calls to the SVE ptrue; /// intrinsic in each basic block within the given functions.; ///; /// SVE ptrues have two representations in LLVM IR:; /// - a logical representation -- an arbitrary-width scalable vector of i1s,; /// i.e. <vscale x N x i1>.; /// - a physical representation (svbool, <vscale x 16 x i1>) -- a 16-element; /// scalable vector of i1s, i.e. <vscale x 16 x i1>.; ///; /// The SVE ptrue intrinsic is used to create a logical representation of an SVE; /// predicate. Suppose that we have two SVE ptrue intrinsic calls: P1 and P2. If; /// P1 creates a logical SVE predicate that is at least as wide as the logical; /// SVE predicate created by P2, then all of the bits that are true in the; /// physical representation of P2 are necessarily also true in the physical; /// representation of P1. P1 'encompasses' P2, therefore, the intrinsic call to; /// P2 is redundant and can be replaced by an SVE reinterpret of P1 via; /// convert.{to,from}.svbool.; ///; /// Currently, this pass only coalesces calls to SVE ptrue intrinsics; /// if they match the following conditions:; ///; /// - the call to the intrinsic uses either the SV_ALL or SV_POW2 patterns.; /// SV_ALL indicates that all bits of the predicate vector are to be set to; /// true. SV_POW2 indicates that all bits of the predicate vector up to the; /// largest power-of-two are to be set to true.; /// - the result of the call to the intrinsic is not promoted to a wider; /// predicate. In this case, keeping the extra ptrue leads to better codegen; /// -- coalescing here would create an irreducible chain of SVE reinterprets; /// via convert.{to,from}.svbool.; ///; /// EXAMPLE:; ///; /// %1 = <vscale x 8 x i1> ptrue(i32 SV_ALL); /// ; Logical: <1, 1, 1, 1, 1, 1, 1, 1>; /// ; Physical: <1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0>; /// ...; ///; /// %2 = <vscale x 4 x i1> ptrue(i32 SV_ALL); /// ; Logical: <1, 1, 1, 1>; /// ; Physical: <1, 0, 0, 0, 1, 0, 0, 0,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp:251,scalab,scalable,251,interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,2,['scalab'],['scalable']
Performance,/// The goal of this scheduling strategy is to maximize ILP for a single wave; /// (i.e. latency hiding).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h:89,latency,latency,89,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.h,1,['latency'],['latency']
Performance,"/// The group of interleaved loads/stores sharing the same stride and; /// close to each other.; ///; /// Each member in this group has an index starting from 0, and the largest; /// index should be less than interleaved factor, which is equal to the absolute; /// value of the access's stride.; ///; /// E.g. An interleaved load group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// a = A[i]; // Member of index 0; /// b = A[i+1]; // Member of index 1; /// d = A[i+3]; // Member of index 3; /// ...; /// }; ///; /// An interleaved store group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// ...; /// A[i] = a; // Member of index 0; /// A[i+1] = b; // Member of index 1; /// A[i+2] = c; // Member of index 2; /// A[i+3] = d; // Member of index 3; /// }; ///; /// Note: the interleaved load group could have gaps (missing members), but; /// the interleaved store group doesn't allow gaps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:29,load,loads,29,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,3,['load'],"['load', 'loads']"
Performance,/// The hash used for module cache paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:29,cache,cache,29,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['cache'],['cache']
Performance,"/// The hash value for SDVTList is fixed, so cache it to avoid; /// hash calculation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:45,cache,cache,45,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['cache'],['cache']
Performance,"/// The head of the queue. A singly-linked list. The order here should; /// be consistent with the earlier sort, i.e. the elements should be; /// monotonically descending in size and otherwise in the original order.; ///; /// We remove the queue from the array as soon as this is empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp:20,queue,queue,20,interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,2,['queue'],['queue']
Performance,/// The implementation of the Cache-Directed Sort (CDSort) algorithm for; /// ordering functions represented by a call graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:30,Cache,Cache-Directed,30,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['Cache'],['Cache-Directed']
Performance,/// The index LC_DATA_IN_CODE load command if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:30,load,load,30,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The index LC_DYLD_CHAINED_FIXUPS load command if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:37,load,load,37,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The index LC_DYLD_EXPORTS_TRIE load command if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:35,load,load,35,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The index LC_DYSYMTAB load command if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:26,load,load,26,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The index LC_FUNCTION_STARTS load command if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:33,load,load,33,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The index of LC_CODE_SIGNATURE load command if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:35,load,load,35,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The index of LC_DYLD_INFO or LC_DYLD_INFO_ONLY load command if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:51,load,load,51,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The index of LC_DYLIB_CODE_SIGN_DRS load command if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:40,load,load,40,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The index of LC_LINKER_OPTIMIZATIN_HINT load command if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:44,load,load,44,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The index of LC_SYMTAB load command if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:27,load,load,27,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The index of the LC_SEGMENT or LC_SEGMENT_64 load command; /// corresponding to the __TEXT segment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:49,load,load,49,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The information cache that holds pre-processed (LLVM-IR) information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:20,cache,cache,20,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['cache'],['cache']
Performance,/// The inline asm string to insert between calls and RetainRV calls to make; /// the optimization work on targets which need it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:86,optimiz,optimization,86,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['optimiz'],['optimization']
Performance,"/// The inliner pass for the new pass manager.; ///; /// This pass wires together the inlining utilities and the inline cost; /// analysis into a CGSCC pass. It considers every call in every function in; /// the SCC and tries to inline if profitable. It can be tuned with a number of; /// parameters to control what cost model is used and what tradeoffs are made; /// when making the decision.; ///; /// It should be noted that the legacy inliners do considerably more than this; /// inliner pass does. They provide logic for manually merging allocas, and; /// doing considerable DCE including the DCE of dead functions. This pass makes; /// every attempt to be simpler. DCE of functions requires complex reasoning; /// about comdat groups, etc. Instead, it is expected that other more focused; /// passes be composed to achieve the same end result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Inliner.h:261,tune,tuned,261,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Inliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Inliner.h,1,['tune'],['tuned']
Performance,"/// The inner sink, responsible for actually performing I/O.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx:45,perform,performing,45,tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,1,['perform'],['performing']
Performance,/// The input file info that has been loaded from an AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:38,load,loaded,38,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,1,['load'],['loaded']
Performance,/// The input file infos that have been loaded from this AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:40,load,loaded,40,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,1,['load'],['loaded']
Performance,"/// The input file that has been loaded from this AST file, along with; /// bools indicating whether this was an overridden buffer or if it was; /// out-of-date or not-found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:33,load,loaded,33,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,1,['load'],['loaded']
Performance,/// The input files that have been loaded from this AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:35,load,loaded,35,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,1,['load'],['loaded']
Performance,/// The instructions inserted by other CodeGenPrepare optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:54,optimiz,optimizations,54,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimizations']
Performance,/// The instructions removed here will be freed after completing; /// optimizeBlock() for all blocks as we need to keep track of the; /// removed instructions during promotion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:70,optimiz,optimizeBlock,70,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimizeBlock']
Performance,"/// The interleave (swizzle) element size in bytes required by the; /// code for private memory. This must be 2, 4, 8 or 16. This value; /// is provided to the finalizer when it is invoked and is recorded; /// here. The hardware will interleave the memory requests of each; /// lane of a wavefront by this element size to ensure each; /// work-item gets a distinct memory location. Therefore, the; /// finalizer ensures that all load and store operations done to; /// private memory do not exceed this size. For example, if the; /// element size is 4 (32-bits or dword) and a 64-bit value must be; /// loaded, the finalizer will generate two 32-bit loads. This; /// ensures that the interleaving will get the work-item; /// specific dword for both halves of the 64-bit value. If it just; /// did a 64-bit load then it would get one dword which belonged to; /// its own work-item, but the second dword would belong to the; /// adjacent lane work-item since the interleaving is in dwords.; ///; /// The value used must match the value that the runtime configures; /// the GPU flat scratch (SH_STATIC_MEM_CONFIG.ELEMENT_SIZE). This; /// is generally DWORD.; ///; /// uSE VALUES FROM THE AMD_ELEMENT_BYTE_SIZE_T ENUM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:429,load,load,429,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,4,['load'],"['load', 'loaded', 'loads']"
Performance,"/// The interval (in seconds) between pruning operations.; ///; /// This operation is expensive, because it requires Clang to walk through; /// the directory structure of the module cache, stat()'ing and removing; /// files.; ///; /// The default value is large, e.g., the operation runs once a week.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h:182,cache,cache,182,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,1,['cache'],['cache']
Performance,/// The kind of bridging performed by the Objective-C bridge cast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h:25,perform,performed,25,interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h,1,['perform'],['performed']
Performance,/// The kind of conversion being performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:33,perform,performed,33,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performed']
Performance,"/// The kind of evaluation to perform on values of a particular; /// type. Basically, is the code in CGExprScalar, CGExprComplex, or; /// CGExprAgg?; ///; /// TODO: should vectors maybe be split out into their own thing?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:30,perform,perform,30,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['perform'],['perform']
Performance,/// The kind of initialization being performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:37,perform,performed,37,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,2,['perform'],['performed']
Performance,/// The kind of template instantiation we are performing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:46,perform,performing,46,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,/// The kind of template substitution being performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h:44,perform,performed,44,interpreter/llvm-project/clang/include/clang/Sema/Template.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h,1,['perform'],['performed']
Performance,"/// The kind of translation unit we are processing.; ///; /// When we're processing a complete translation unit, Sema will perform; /// end-of-translation-unit semantic tasks (such as creating; /// initializers for tentative definitions in C) once parsing has; /// completed. Modules and precompiled headers perform different kinds of; /// checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:123,perform,perform,123,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['perform'],['perform']
Performance,/// The kinds of rewrite we perform on overload candidates. Note that the; /// values here are chosen to serve as both bitflags and as a rank (lower; /// values are preferred by overload resolution).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:28,perform,perform,28,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['perform'],['perform']
Performance,"/// The last cluster from which a page got loaded. Points into fClusterPool->fPool",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx:43,load,loaded,43,tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageDaos.hxx,2,['load'],['loaded']
Performance,/// The limit (threshold) value for number of loaded ASTs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:46,load,loaded,46,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['load'],['loaded']
Performance,"/// The linkage type of the associated global value.; ///; /// One use is to flag values that have local linkage types and need to; /// have module identifier appended before placing into the combined; /// index, to disambiguate from other values with the same name.; /// In the future this will be used to update and optimize linkage; /// types based on global summary-based analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:318,optimiz,optimize,318,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['optimiz'],['optimize']
Performance,/// The list of Modules that we are JIT'ing from. We use a SmallVector to; /// optimize for the case where there is only one module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:79,optimiz,optimize,79,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['optimiz'],['optimize']
Performance,/// The list of additional prebuilt module files to load before; /// processing the input.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h:52,load,load,52,interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,1,['load'],['load']
Performance,"/// The list of module files that both we and the global module index; /// know about.; ///; /// Either the global index or the module manager may have modules that the; /// other does not know about, because the global index can be out-of-date; /// (in which case the module manager could have modules it does not) and; /// this particular translation unit might not have loaded all of the modules; /// known to the global index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:373,load,loaded,373,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,/// The list of module map files to load before processing the input.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h:36,load,load,36,interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,1,['load'],['load']
Performance,/// The list of plugins to load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h:27,load,load,27,interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,1,['load'],['load']
Performance,"/// The list of return statements that occur within the function or; /// block, if there is any chance of applying the named return value; /// optimization, or if we need to infer a return type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:143,optimiz,optimization,143,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,1,['optimiz'],['optimization']
Performance,"/// The list of transformations to be performed for every entry",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx:38,perform,performed,38,tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx,1,['perform'],['performed']
Performance,/// The local cache is used by the worker thread to cache file system queries; /// locally instead of querying the global cache every time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:14,cache,cache,14,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,3,['cache'],['cache']
Performance,"/// The location of the bind info inside the binary is described by; /// LC_DYLD_INFO load command. Dyld binds an image during the loading process,; /// if the image requires any pointers to be initialized to symbols in other; /// images. The bind information is a stream of byte sized opcodes whose; /// symbolic names start with BIND_OPCODE_. Conceptually the bind information is; /// a table of tuples: <seg-index, seg-offset, type, symbol-library-ordinal,; /// symbol-name, addend> The opcodes are a compressed way to encode the table by; /// only encoding when a column changes. In addition simple patterns like for; /// runs of pointers initialized to the same value can be encoded in a few; /// bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:86,load,load,86,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,2,['load'],"['load', 'loading']"
Performance,"/// The location of the closing brace ('}') that completes; /// the lambda.; ///; /// The location of the brace is also available by looking up the; /// function call operator in the lambda class. However, it is; /// stored here to improve the performance of getSourceRange(), and; /// to avoid having to deserialize the function call operator from a; /// module file just to determine the source range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:244,perform,performance,244,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['perform'],['performance']
Performance,"/// The location of the export info inside the binary is described by; /// LC_DYLD_INFO load command. The symbols exported by a dylib are encoded in a; /// trie. This is a compact representation that factors out common prefixes. It; /// also reduces LINKEDIT pages in RAM because it encodes all information (name,; /// address, flags) in one small, contiguous range. The export area is a stream; /// of nodes. The first node sequentially is the start node for the trie. Nodes; /// for a symbol start with a uleb128 that is the length of the exported symbol; /// information for the string so far. If there is no exported symbol, the node; /// starts with a zero byte. If there is exported info, it follows the length.; /// First is a uleb128 containing flags. Normally, it is followed by; /// a uleb128 encoded offset which is location of the content named; /// by the symbol from the mach_header for the image. If the flags; /// is EXPORT_SYMBOL_FLAGS_REEXPORT, then following the flags is; /// a uleb128 encoded library ordinal, then a zero terminated; /// UTF8 string. If the string is zero length, then the symbol; /// is re-export from the specified dylib with the same name.; /// If the flags is EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER, then following; /// the flags is two uleb128s: the stub offset and the resolver offset.; /// The stub is used by non-lazy pointers. The resolver is used; /// by lazy pointers and must be called to get the actual address to use.; /// After the optional exported symbol information is a byte of; /// how many edges (0-255) that this node has leaving it,; /// followed by each edge.; /// Each edge is a zero terminated UTF8 of the addition chars; /// in the symbol, followed by a uleb128 offset for the node that; /// edge points to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:88,load,load,88,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,"/// The location of the lazy bind info inside the binary is described by; /// LC_DYLD_INFO load command. Some uses of external symbols do not need to be; /// bound immediately. Instead they can be lazily bound on first use. The; /// lazy_bind contains a stream of BIND opcodes to bind all lazy symbols. Normal; /// use is that dyld ignores the lazy_bind section when loading an image.; /// Instead the static linker arranged for the lazy pointer to initially point; /// to a helper function which pushes the offset into the lazy_bind area for the; /// symbol needing to be bound, then jumps to dyld which simply adds the offset; /// to lazy_bind_off to get the information on what to bind.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:91,load,load,91,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,2,['load'],"['load', 'loading']"
Performance,"/// The location of the rebase info inside the binary is described by; /// LC_DYLD_INFO load command. Dyld rebases an image whenever dyld loads it at; /// an address different from its preferred address. The rebase information is; /// a stream of byte sized opcodes whose symbolic names start with; /// REBASE_OPCODE_. Conceptually the rebase information is a table of tuples:; /// <seg-index, seg-offset, type>; /// The opcodes are a compressed way to encode the table by only; /// encoding when a column changes. In addition simple patterns; /// like ""every n'th offset for m times"" can be encoded in a few; /// bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:88,load,load,88,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,2,['load'],"['load', 'loads']"
Performance,/// The location of the string table inside the binary is described by LC_SYMTAB; /// load command.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:86,load,load,86,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The location of the symbol table inside the binary is described by LC_SYMTAB; /// load command.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:86,load,load,86,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,"/// The location of the weak bind info inside the binary is described by; /// LC_DYLD_INFO load command. Some C++ programs require dyld to unique symbols; /// so that all images in the process use the same copy of some code/data. This; /// step is done after binding. The content of the weak_bind info is an opcode; /// stream like the bind_info. But it is sorted alphabetically by symbol name.; /// This enable dyld to walk all images with weak binding information in order; /// and look for collisions. If there are no collisions, dyld does no updating.; /// That means that some fixups are also encoded in the bind_info. For; /// instance, all calls to ""operator new"" are first bound to libstdc++.dylib; /// using the information in bind_info. Then if some image overrides operator; /// new that is detected when the weak_bind information is processed and the; /// call to operator new is then rebound.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:91,load,load,91,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['load'],['load']
Performance,/// The main ARC optimization pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,optimiz,optimization,17,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['optimiz'],['optimization']
Performance,"/// The maximum alignment for instructions.; ///; /// This is the greatest alignment value supported by load, store, and alloca; /// instructions, and global values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h:104,load,load,104,interpreter/llvm-project/llvm/include/llvm/IR/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h,1,['load'],['load']
Performance,"/// The maximum alignment, same as in llvm::Value. We duplicate them here; /// because that allows us not to duplicate the constants in clang code,; /// which we must to since we can't directly use the llvm constants.; /// The value is verified against llvm here: lib/CodeGen/CGDecl.cpp; ///; /// This is the greatest alignment value supported by load, store, and alloca; /// instructions, and global values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:347,load,load,347,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['load'],['load']
Performance,"/// The maximum number of files in the cache directory. A value of 0 disables; /// the number of files based pruning.; ///; /// This defaults to 1000000 because with that many files there are; /// diminishing returns on the effectiveness of the cache. Some systems have a; /// limit on total number of files, and some also limit the number of files; /// per directory, such as Linux ext4, with the default setting (block size is; /// 4096 and large_dir disabled), there is a per-directory entry limit of; /// 508*510*floor(4096/(40+8))~=20M for average filename length of 40.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:39,cache,cache,39,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,2,['cache'],['cache']
Performance,/// The maximum size for the cache directory in bytes. A value over the amount; /// of available space on the disk will be reduced to the amount of available; /// space. A value of 0 disables the absolute size-based pruning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:29,cache,cache,29,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,1,['cache'],['cache']
Performance,"/// The maximum size that the sum of all page buffers used for writing into a persistent sink are allowed to use.; /// If set to zero, RNTuple will auto-adjust the budget based on the value of fApproxZippedClusterSize.; /// If set manually, the size needs to be large enough to hold all initial page buffers.; /// The total amount of memory for writing is larger, e.g. for the additional compressed buffers etc.; /// Use RNTupleModel::EstimateWriteMemoryUsage() for the total estimated memory use for writing.; /// The default values are tuned for a total write memory of around 300 MB per fill context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:538,tune,tuned,538,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,1,['tune'],['tuned']
Performance,/// The maximum unweighted length of a path from an arbitrary node to the; /// given node in which each edge has latency 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:113,latency,latency,113,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['latency'],['latency']
Performance,/// The maximum unweighted length of a path from the given node to an; /// arbitrary node in which each edge has latency 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:113,latency,latency,113,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['latency'],['latency']
Performance,"/// The minimum function alignment (used when optimizing for size, and to; /// prevent explicitly provided alignment from leading to incorrect code).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:46,optimiz,optimizing,46,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['optimiz'],['optimizing']
Performance,"/// The minimum hotness value a diagnostic needs in order to be included in; /// optimization diagnostics.; ///; /// The threshold is an Optional value, which maps to one of the 3 states:; /// 1). 0 => threshold disabled. All emarks will be printed.; /// 2). positive int => manual threshold by user. Remarks with hotness exceed; /// threshold will be printed.; /// 3). None => 'auto' threshold by user. The actual value is not; /// available at command line, but will be synced with; /// hotness threhold from profile summary during; /// compilation.; ///; /// State 1 and 2 are considered as terminal states. State transition is; /// only allowed from 3 to 2, when the threshold is first synced with profile; /// summary. This ensures that the threshold is set only once and stays; /// constant.; ///; /// If threshold option is not specified, it is disabled (0) by default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:81,optimiz,optimization,81,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,1,['optimiz'],['optimization']
Performance,"/// The minimum hotness value a diagnostic needs in order to be included in; /// optimization diagnostics.; ///; /// The threshold is an Optional value, which maps to one of the 3 states:; /// 1. 0 => threshold disabled. All emarks will be printed.; /// 2. positive int => manual threshold by user. Remarks with hotness exceed; /// threshold will be printed.; /// 3. None => 'auto' threshold by user. The actual value is not; /// available at command line, but will be synced with; /// hotness threhold from profile summary during; /// compilation.; ///; /// If threshold option is not specified, it is disabled by default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:81,optimiz,optimization,81,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['optimiz'],['optimization']
Performance,"/// The minimum hotness value a diagnostic needs in order to be included in; /// optimization diagnostics.; ///; /// The threshold is an Optional value, which maps to one of the 3 states:; /// 1. 0 => threshold disabled. All remarks will be printed.; /// 2. positive int => manual threshold by user. Remarks with hotness exceed; /// threshold will be printed.; /// 3. None => 'auto' threshold by user. The actual value is not; /// available at command line, but will be synced with; /// hotness threshold from profile summary during; /// compilation.; ///; /// If threshold option is not specified, it is disabled by default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:81,optimiz,optimization,81,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,1,['optimiz'],['optimization']
Performance,/// The minimum size of anything currently in this queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp:51,queue,queue,51,interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,1,['queue'],['queue']
Performance,/// The module file had already been loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:37,load,loaded,37,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,/// The module file was just loaded in response to this call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:29,load,loaded,29,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,"/// The module inliner pass for the new pass manager.; ///; /// This pass wires together the inlining utilities and the inline cost; /// analysis into a module pass. Different from SCC inliner, it considers every; /// call in every function in the whole module and tries to inline if; /// profitable. With this module level inliner, it is possible to evaluate more; /// heuristics in the module level such like PriorityInlineOrder. It can be; /// tuned with a number of parameters to control what cost model is used and; /// what tradeoffs are made when making the decision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/ModuleInliner.h:447,tune,tuned,447,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/ModuleInliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/ModuleInliner.h,1,['tune'],['tuned']
Performance,/// The module map file had already been loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:41,load,loaded,41,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['load'],['loaded']
Performance,/// The module map file was loaded by this invocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:28,load,loaded,28,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['load'],['loaded']
Performance,"/// The module that the main source file is associated with (the module; /// named LangOpts::CurrentModule, if we've loaded it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:117,load,loaded,117,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['load'],['loaded']
Performance,"/// The most common way to add histograms to channels is to have them; /// stored in ROOT files and to give HistFactory the location of these; /// files. This means providing the path to the ROOT file and the path; /// and name of the histogram within that file. When providing these; /// in a script, HistFactory doesn't load the histogram from the file; /// right away. Instead, once all such histograms have been supplied,; /// one should run this method to open all ROOT files and to copy and; /// save all necessary histograms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Measurement.cxx:322,load,load,322,roofit/histfactory/src/Measurement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Measurement.cxx,1,['load'],['load']
Performance,/// The name of the file to which the backend should save YAML optimization; /// records.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:63,optimiz,optimization,63,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,1,['optimiz'],['optimization']
Performance,"/// The name of the node hierarchy. Not actually sensitive to IsReader,; /// but useful to cache here anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp:91,cache,cache,91,interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangASTPropertiesEmitter.cpp,1,['cache'],['cache']
Performance,"/// The nested-name-specifier that precedes the member name, if any.; /// FIXME: This could be in principle store as a trailing object.; /// However the performance impact of doing so should be investigated first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:153,perform,performance,153,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['perform'],['performance']
Performance,/// The next I+1 words do not contain a value of object pointer type.; /// This is simply an optimized version of BLOCK_LAYOUT_BYTES for; /// when the required skip quantity is a multiple of the pointer size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:93,optimiz,optimized,93,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['optimiz'],['optimized']
Performance,/// The next import in the list of imports local to the translation; /// unit being parsed (not loaded from an AST file).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:96,load,loaded,96,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['load'],['loaded']
Performance,"/// The next import in the list of imports local to the translation; /// unit being parsed (not loaded from an AST file).; ///; /// Includes a bit that indicates whether we have source-location information; /// for each identifier in the module name.; ///; /// When the bit is false, we only have a single source location for the; /// end of the import declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:96,load,loaded,96,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['load'],['loaded']
Performance,"/// The ntuple descriptor in the page source is protected by a read-write lock. We don't expose that to the; /// users of RNTupleReader::GetDescriptor(). Instead, if descriptor information is needed, we clone the; /// descriptor. Using the descriptor's generation number, we know if the cached descriptor is stale.; /// Retrieving descriptor data from an RNTupleReader is supposed to be for testing and information purposes,; /// not on a hot code path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:287,cache,cached,287,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,1,['cache'],['cached']
Performance,/// The number of bytes by which return address stack slot is moved as the; /// result of tail call optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMachineFunction.h:100,optimiz,optimization,100,interpreter/llvm-project/llvm/lib/Target/M68k/M68kMachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kMachineFunction.h,1,['optimiz'],['optimization']
Performance,"/// The number of bytes that we will initially skip when entering the; /// main file, along with a flag that indicates whether skipping this number; /// of bytes will place the lexer at the start of a line.; ///; /// This is used when loading a precompiled preamble.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:235,load,loading,235,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['load'],['loading']
Performance,"/// The number of call arguments that were explicitly provided,; /// to be used while performing partial ordering of function templates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:86,perform,performing,86,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['perform'],['performing']
Performance,"/// The number of expansions that this pack expansion will; /// generate when substituted (+1), which is expected to be able to; /// hold at least 1024 according to [implimits]. However, as this limit; /// is somewhat easy to hit with template metaprogramming we'd prefer to; /// keep it as large as possible. At the moment it has been left as a; /// non-bitfield since this type safely fits in 64 bits as an unsigned, so; /// there is no reason to introduce the performance impact of a bitfield.; ///; /// This field will only have a non-zero value when some of the parameter; /// packs that occur within the pattern have been substituted but others; /// have not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:463,perform,performance,463,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['perform'],['performance']
Performance,/// The number of heap allocations performed so far in this evaluation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:35,perform,performed,35,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['perform'],['performed']
Performance,/// The number of identifier lookups we performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h:40,perform,performed,40,interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,1,['perform'],['performed']
Performance,"/// The number of template arguments in the type-constraints, which is; /// expected to be able to hold at least 1024 according to [implimits].; /// However as this limit is somewhat easy to hit with template; /// metaprogramming we'd prefer to keep it as large as possible.; /// At the moment it has been left as a non-bitfield since this type; /// safely fits in 64 bits as an unsigned, so there is no reason to; /// introduce the performance impact of a bitfield.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:433,perform,performance,433,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['perform'],['performance']
Performance,"/// The number of template arguments named in this class template; /// specialization, which is expected to be able to hold at least 1024; /// according to [implimits]. However, as this limit is somewhat easy to; /// hit with template metaprogramming we'd prefer to keep it as large; /// as possible. At the moment it has been left as a non-bitfield since; /// this type safely fits in 64 bits as an unsigned, so there is no reason; /// to introduce the performance impact of a bitfield.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:454,perform,performance,454,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,2,['perform'],['performance']
Performance,/// The operands of each instruction in each lane Operands[op_index][lane].; /// Note: This helps avoid the replication of the code that performs the; /// reordering of operands during buildTree_rec() and vectorizeTree().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:137,perform,performs,137,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['perform'],['performs']
Performance,/// The operation that this node performs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:33,perform,performs,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['perform'],['performs']
Performance,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:8,optimiz,optimization,8,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,6,"['optimiz', 'perform']","['optimization', 'optimizations', 'performed']"
Performance,/// The optimization remark emitter for the pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h:8,optimiz,optimization,8,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h,1,['optimiz'],['optimization']
Performance,/// The optimizer may remove labels. If there is an interest; /// to preserve label info in such situation then append it to; /// the list of retained nodes of the DISubprogram.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp:8,optimiz,optimizer,8,interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,1,['optimiz'],['optimizer']
Performance,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar. If so, build an expression referencing; /// that ivar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Perform,Perform,106,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Perform'],['Perform']
Performance,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar.; ///; /// Ideally, most of this would be done by lookup, but there's; /// actually quite a lot of extra work involved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:106,Perform,Perform,106,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Perform'],['Perform']
Performance,/// The pass transforms load/store <256 x i32> to AMX load/store intrinsics; /// or split the data to two <128 x i32>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:24,load,load,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,2,['load'],['load']
Performance,/// The path to the module cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:27,cache,cache,27,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['cache'],['cache']
Performance,"/// The paths that we can legally cache back from, but that aren't; /// necessarily the result of the Phi optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:34,cache,cache,34,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"/// The position of the cached token that CachingLex() should; /// ""lex"" next.; ///; /// If it points beyond the CachedTokens vector, it means that a normal; /// Lex() should be invoked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:24,cache,cached,24,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,2,"['Cache', 'cache']","['CachedTokens', 'cached']"
Performance,/// The possible cache levels,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:17,cache,cache,17,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['cache'],['cache']
Performance,"/// The pragma clang optimize location (if the pragma state is ""off"").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:21,optimiz,optimize,21,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['optimiz'],['optimize']
Performance,/// The preferred function alignment (used when alignment unspecified and; /// optimizing for speed).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:79,optimiz,optimizing,79,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['optimiz'],['optimizing']
Performance,/// The preprocessor that will be loading the source file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:34,load,loading,34,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loading']
Performance,/// The primary action that this stage performs on instruction IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/Stage.h:39,perform,performs,39,interpreter/llvm-project/llvm/include/llvm/MCA/Stages/Stage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/Stage.h,1,['perform'],['performs']
Performance,/// The profile size based optimization pass for memory intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/PGOInstrumentation.h:27,optimiz,optimization,27,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/PGOInstrumentation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/PGOInstrumentation.h,1,['optimiz'],['optimization']
Performance,"/// The public entry point for a pass plugin.; ///; /// When a plugin is loaded by the driver, it will call this entry point to; /// obtain information about this plugin and about how to register its passes.; /// This function needs to be implemented by the plugin, see the example below:; ///; /// ```; /// extern ""C"" ::llvm::PassPluginLibraryInfo LLVM_ATTRIBUTE_WEAK; /// llvmGetPassPluginInfo() {; /// return {; /// LLVM_PLUGIN_API_VERSION, ""MyPlugin"", ""v0.1"", [](PassBuilder &PB) { ... }; /// };; /// }; /// ```",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h:73,load,loaded,73,interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,1,['load'],['loaded']
Performance,"/// The queue of implicit template instantiations that are required; /// and must be performed within the current local scope.; ///; /// This queue is only used for member functions of local classes in; /// templates, which must be instantiated in the same scope as their; /// enclosing function, so that they can reference function-local; /// types, static variables, enumerators, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:8,queue,queue,8,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,3,"['perform', 'queue']","['performed', 'queue']"
Performance,/// The queue of implicit template instantiations that are required; /// but have not yet been performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:8,queue,queue,8,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['perform', 'queue']","['performed', 'queue']"
Performance,/// The regex that filters the passes that should be saved to the optimization; /// records.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:66,optimiz,optimization,66,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,1,['optimiz'],['optimization']
Performance,/// The resolved value of the UUID as an APValue. Computed on demand and; /// cached.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:78,cache,cached,78,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['cache'],['cached']
Performance,/// The rewriter used to perform the various code; /// modifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:25,perform,perform,25,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,1,['perform'],['perform']
Performance,"/// The same load multiple times. This should have a better score than; /// `ScoreSplat` because it in x86 for a 2-lane vector we can represent it; /// with `movddup (%reg), xmm0` which has a throughput of 0.5 versus 0.5 for; /// a vector load and 1.0 for a broadcast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:13,load,load,13,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,"['load', 'throughput']","['load', 'throughput']"
Performance,"/// The scratch address space does not need the global memory cache; /// to be flushed as all memory operations by the same thread are; /// sequentially consistent, and no other thread can access scratch; /// memory.; /// Other address spaces do not have a cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:62,cache,cache,62,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,12,['cache'],['cache']
Performance,"/// The scratch address space does not need the global memory caches; /// to be bypassed as all memory operations by the same thread are; /// sequentially consistent, and no other thread can access scratch; /// memory.; /// Other address spaces do not have a cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:62,cache,caches,62,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,14,['cache'],"['cache', 'caches']"
Performance,/// The set of Decls that have been loaded but their DeclContexts are; /// not set yet.; ///; /// The DeclContexts for these Decls will be set once recursive loading has; /// been completed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:36,load,loaded,36,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,2,['load'],"['loaded', 'loading']"
Performance,"/// The set of NamedDecls that have been loaded, but are members of a; /// context that has been merged into another context where the corresponding; /// declaration is either missing or has not yet been loaded.; ///; /// We will check whether the corresponding declaration is in fact missing; /// once recursing loading has been completed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:41,load,loaded,41,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,3,['load'],"['loaded', 'loading']"
Performance,"/// The set of Objective-C class definitions that have already been; /// loaded, for which we will need to check for categories whenever a new; /// module is loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:73,load,loaded,73,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,2,['load'],['loaded']
Performance,/// The set of cached code-completion results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:15,cache,cached,15,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['cache'],['cached']
Performance,"/// The set of diagnostics produced when failing to parse, e.g. due; /// to failure to load the PCH.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:87,load,load,87,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['load'],['load']
Performance,/// The set of identifiers that were read while the AST reader was; /// (recursively) loading declarations.; ///; /// The declarations on the identifier chain for these identifiers will be; /// loaded once the recursive loading has completed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:86,load,loading,86,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,3,['load'],"['loaded', 'loading']"
Performance,"/// The set of preprocessed entities in this record that have been; /// loaded from external sources.; ///; /// The entries in this vector are loaded lazily from the external source,; /// and are referenced by the iterator using negative indices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:72,load,loaded,72,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,2,['load'],['loaded']
Performance,/// The signed 21-bit delta from the fixup to the target.; ///; /// Typically used to load a pointers at a PC-relative offset of +/- 1Mb. The; /// target must be 32-bit aligned.; ///; /// Fixup expression:; ///; /// Fixup <- (Target - Fixup) >> 2 : int19; ///; /// Errors:; /// - The result of the unshifted part of the fixup expression must be; /// 32-bit aligned otherwise an alignment error will be returned.; /// - The result of the fixup expression must fit into an int19 or an; /// out-of-range error will be returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h:86,load,load,86,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/aarch64.h,1,['load'],['load']
Performance,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:48,cache,cache,48,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,3,['cache'],"['cache', 'cached']"
Performance,/// The size of a line in the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:30,cache,cache,30,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,1,['cache'],['cache']
Performance,/// The size of the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:20,cache,cache,20,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,1,['cache'],['cache']
Performance,"/// The size of the inline storage of an RVec.; /// Our policy is to allocate at least 8 elements (or more if they all fit into one cacheline); /// unless the size of the buffer with 8 elements would be over a certain maximum size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:132,cache,cacheline,132,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['cache'],['cacheline']
Performance,/// The slot lookup function. Returns a pointer to a cacheable structure; /// that contains (among other things) the IMP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:53,cache,cacheable,53,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['cache'],['cacheable']
Performance,/// The specialized remark streamer used by LLVM's OptimizationRemarkEmitter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:51,Optimiz,OptimizationRemarkEmitter,51,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,1,['Optimiz'],['OptimizationRemarkEmitter']
Performance,"/// The specified global has only one non-null value stored into it. If there; /// are uses of the loaded value that would trap if the loaded value is; /// dynamically null, then we know that they cannot be reachable with a null; /// optimize away the load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:99,load,loaded,99,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,4,"['load', 'optimiz']","['load', 'loaded', 'optimize']"
Performance,"/// The specified machine instr operand is a vreg, and that vreg is; /// being provided by the specified load instruction. If possible, try to; /// fold the load as an operand to the instruction, returning true if; /// possible.; ///; /// This method should be implemented by targets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:105,load,load,105,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,2,['load'],['load']
Performance,"/// The specified machine instr operand is a vreg, and that; /// vreg is being provided by the specified load instruction. If possible,; /// try to fold the load as an operand to the instruction, returning true if; /// possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:105,load,load,105,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,['load'],['load']
Performance,"/// The specified machine instr operand is a vreg, and that; /// vreg is being provided by the specified load instruction. If possible,; /// try to fold the load as an operand to the instruction, returning true if; /// successful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:105,load,load,105,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,2,['load'],['load']
Performance,"/// The specified value has been assigned to a stack; /// location. Load or store it there, with appropriate extension; /// if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:68,Load,Load,68,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,1,['Load'],['Load']
Performance,"/// The staging area is relevant for chains of files, i.e. when fFileNames is not empty. In this case,; /// files are opened in the background in batches of size `fNSlots` and kept in the staging area.; /// The first file (chains or no chains) is always opened on construction in order to process the schema.; /// For all subsequent files, the corresponding page sources in the staging area only executed `LoadStructure()`,; /// i.e. they should have a compressed buffer of the meta-data available.; /// Concretely:; /// 1. We open the first file on construction to read the schema and then move the corresponding page source; /// in the staging area.; /// 2. On `Initialize()`, we start the I/O background thread, which in turn opens the first batch of files.; /// 3. At the beginning of `GetEntryRanges()`, we; /// a) wait for the I/O thread to finish,; /// b) call `PrepareNextRanges()` in the main thread to move the page sources from the staging area; /// into `fNextRanges`; this will also call `Attach()` on the page sources (i.e., deserialize the meta-data),; /// and; /// c) trigger staging of the next batch of files in the I/O background thread.; /// 4. On `Finalize()`, the I/O background thread is stopped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx:406,Load,LoadStructure,406,tree/dataframe/inc/ROOT/RNTupleDS.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RNTupleDS.hxx,1,['Load'],['LoadStructure']
Performance,"/// The starting offset of the latest batch of loaded SLocEntries.; ///; /// This is LoadedSLocEntryTable.back().Offset, except that that entry might; /// not have been loaded, so that value would be unknown.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:47,load,loaded,47,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,3,"['Load', 'load']","['LoadedSLocEntryTable', 'loaded']"
Performance,"/// The synchronization scope ID of this load instruction. Not quite enough; /// room in SubClassData for everything, so synchronization scope ID gets its; /// own field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:41,load,load,41,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['load'],['load']
Performance,"/// The table of SLocEntries that are loaded from other modules.; ///; /// Negative FileIDs are indexes into this table. To get from ID to an index,; /// use (-ID - 2).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:38,load,loaded,38,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,"/// The target data for the platform for which execution is being performed.; ///; /// Note: the DataLayout is LLVMContext specific because it has an; /// internal cache based on type pointers. It makes unsafe to reuse the; /// ExecutionEngine across context, we don't enforce this rule but undefined; /// behavior can occurs if the user tries to do it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:66,perform,performed,66,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,2,"['cache', 'perform']","['cache', 'performed']"
Performance,"/// The template (or partial specialization) in which we are; /// performing the instantiation, for substitutions of prior template; /// arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:66,perform,performing,66,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,/// The template parameter depth for which we're performing deduction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:49,perform,performing,49,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['perform'],['performing']
Performance,"/// The time (in seconds) after which an unused module file will be; /// considered unused and will, therefore, be pruned.; ///; /// When the module cache is pruned, any module file that has not been; /// accessed in this many seconds will be removed. The default value is; /// large, e.g., a month, to avoid forcing infrequently-used modules to be; /// regenerated often.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h:149,cache,cache,149,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,1,['cache'],['cache']
Performance,"/// The time associated with this edge. Often this is just the value of the; /// Latency field of the predecessor, however advanced models may provide; /// additional information about specific edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:81,Latency,Latency,81,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['Latency'],['Latency']
Performance,/// The time in seconds when the build session started.; ///; /// This time is used by other optimizations in header search and module; /// loading.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h:93,optimiz,optimizations,93,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,2,"['load', 'optimiz']","['loading', 'optimizations']"
Performance,"/// The type is cleaned up just by freeing its memory. I.e. the destructor performs a no-op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:75,perform,performs,75,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['perform'],['performs']
Performance,"/// The type of a non-macro completion result, stored as a unique; /// integer used by the string map of cached completion types.; ///; /// This value will be zero if the type is not known, or a unique value; /// determined by the formatted type string. Se \c CachedCompletionTypes; /// for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:105,cache,cached,105,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,2,"['Cache', 'cache']","['CachedCompletionTypes', 'cached']"
Performance,/// The type of load/store indexing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:16,load,load,16,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,/// The type of redirection to perform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h:31,perform,perform,31,interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,1,['perform'],['perform']
Performance,/// The type-property cache. This is templated so as to be; /// instantiated at an internal type to prevent unnecessary symbol; /// leakage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:22,cache,cache,22,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['cache'],['cache']
Performance,/// The underlying cached entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:19,cache,cached,19,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cached']
Performance,"/// The user may write code that uses allocas outside of the declared lifetime; /// zone. This can happen when the user returns a reference to a local; /// data-structure. We can detect these cases and decide not to optimize the; /// code. If this flag is enabled, we try to save the user. This option; /// is treated as overriding LifetimeStartOnFirstUse below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:216,optimiz,optimize,216,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['optimiz'],['optimize']
Performance,/// The working directory to use for making relative paths absolute before; /// using them for cache lookups.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:95,cache,cache,95,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cache']
Performance,"/// There are 4 scenarios we can use the InlineAdvisor:; /// - Default - use manual heuristics.; ///; /// - Release mode, the expected mode for production, day to day deployments.; /// In this mode, when building the compiler, we also compile a pre-trained ML; /// model to native code, and link it as a static library. This mode has low; /// overhead and no additional dependencies for the compiler runtime.; ///; /// - Development mode, for training new models.; /// In this mode, we trade off runtime performance for flexibility. This mode; /// requires the TFLite library, and evaluates models dynamically. This mode; /// also permits generating training logs, for offline training.; ///; /// - Dynamically load an advisor via a plugin (PluginInlineAdvisorAnalysis)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:504,perform,performance,504,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,2,"['load', 'perform']","['load', 'performance']"
Performance,"/// These are Functions that contain BlockAddresses which refer a different; /// Function. When parsing the different Function, queue Functions that refer; /// to the different Function. Those Functions must be materialized in order; /// to resolve their BlockAddress constants before the different Function; /// gets moved into another Module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:128,queue,queue,128,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['queue'],['queue']
Performance,/// These are IR-level optimization flags that may be propagated to SDNodes.; /// TODO: This data structure should be shared by the IR optimizer and the; /// the backend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:23,optimiz,optimization,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,2,['optimiz'],"['optimization', 'optimizer']"
Performance,/// These are basic blocks forward-referenced by block addresses. They are; /// inserted lazily into functions when they're loaded. The basic block ID is; /// its index into the vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:124,load,loaded,124,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['load'],['loaded']
Performance,/// These ivars serve as a cache used in the getLineNumber; /// method which is used to speedup getLineNumber calls to nearby locations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:27,cache,cache,27,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['cache'],['cache']
Performance,/// These metadata affects the other optimization passes by making assertions; /// or constraints.; /// Values that carry different expectations should be considered different.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:37,optimiz,optimization,37,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,1,['optimiz'],['optimization']
Performance,"/// These reductions have relaxed evaluation order semantics, and have a; /// single vector operand. The order of evaluation is unspecified. For; /// pow-of-2 vectors, one valid legalizer expansion is to use a tree; /// reduction, i.e.:; /// For RES = VECREDUCE_FADD <8 x f16> SRC_VEC; /// PART_RDX = FADD SRC_VEC[0:3], SRC_VEC[4:7]; /// PART_RDX2 = FADD PART_RDX[0:1], PART_RDX[2:3]; /// RES = FADD PART_RDX2[0], PART_RDX2[1]; /// For non-pow-2 vectors, this can be computed by extracting each element; /// and performing the operation as if it were scalarized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:512,perform,performing,512,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['perform'],['performing']
Performance,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:232,perform,perform,232,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,1,['perform'],['perform']
Performance,"/// This analysis looks for other loads and stores with invariant.group; /// metadata and the same pointer operand. Returns Unknown if it does not; /// find anything, and Def if it can be assumed that 2 instructions load or; /// store the same value and NonLocal which indicate that non-local Def was; /// found, which can be retrieved by calling getNonLocalPointerDependency; /// with the same queried instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:34,load,loads,34,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,2,['load'],"['load', 'loads']"
Performance,/// This assigns and keeps a per-bb relative ordering of load/store; /// instructions in the block that directly load or store an alloca.; ///; /// This functionality is important because it avoids scanning large basic; /// blocks multiple times when promoting many allocas in the same block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:57,load,load,57,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,2,['load'],['load']
Performance,"/// This attempts to load the specified file as a header map. If it doesn't; /// look like a HeaderMap, it gives up and returns null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderMap.h:21,load,load,21,interpreter/llvm-project/clang/include/clang/Lex/HeaderMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderMap.h,1,['load'],['load']
Performance,"/// This bit is set when the basic block contains a function call; /// or implicit destructor that is attributed as 'noreturn'. In that case,; /// control cannot technically ever proceed past this block. All such blocks; /// will have a single immediate successor: the exit block. This allows them; /// to be easily reached from the exit block and using this bit quickly; /// recognized without scanning the contents of the block.; ///; /// Optimization Note: This bit could be profitably folded with Terminator's; /// storage if the memory usage of CFGBlock becomes an issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CFG.h:441,Optimiz,Optimization,441,interpreter/llvm-project/clang/include/clang/Analysis/CFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CFG.h,1,['Optimiz'],['Optimization']
Performance,"/// This builder is only a wrapper around all the other builders, which selects the best builder; /// depending on the desired BVH quality and whether a multi-threaded build is desired.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/default_builder.h:153,multi-thread,multi-threaded,153,geom/geom/inc/bvh/v2/default_builder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/default_builder.h,1,['multi-thread'],['multi-threaded']
Performance,/// This cache is designed to be self-updating and so it should never be; /// invalidated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:9,cache,cache,9,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['cache'],['cache']
Performance,"/// This call is a pre-C++17 elidable constructor that we failed to elide; /// because we failed to compute the target region into which; /// this constructor would have been ultimately elided. Analysis that; /// we perform in this case is still correct but it behaves differently,; /// as if copy elision is disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h:216,perform,perform,216,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,1,['perform'],['perform']
Performance,"/// This callback is invoked whenever the next top-down instruction to be; /// scheduled cannot issue in the current cycle, either because of latency; /// or resource conflicts. This should increment the internal state of the; /// hazard recognizer so that previously ""Hazard"" instructions will now not; /// be hazards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:142,latency,latency,142,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,1,['latency'],['latency']
Performance,/// This callback is used to inspect load/store SDNode.; /// The default implementation does nothing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:37,load,load,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,/// This callback is used to inspect load/store instructions and add; /// target-specific MachineMemOperand flags to them. The default; /// implementation does nothing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:37,load,load,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,"/// This callback is used to prepare for a volatile or atomic load.; /// It takes a chain node as input and returns the chain for the load itself.; ///; /// Having a callback like this is necessary for targets like SystemZ,; /// which allows a CPU to reuse the result of a previous load indefinitely,; /// even if a cache-coherent store is performed by another CPU. The default; /// implementation does nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:62,load,load,62,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,5,"['cache', 'load', 'perform']","['cache-coherent', 'load', 'performed']"
Performance,"/// This checks if the source of this function has drifted since this binary was; /// profiled previously.; /// For now, we are piggy backing on what PGO does to; /// detect this with instrumented profiles. PGO emits an hash of the IR and; /// checks if the hash has changed. Advanced basic block layout is usually done; /// on top of PGO optimized binaries and hence this check works well in; /// practice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h:339,optimiz,optimized,339,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,1,['optimiz'],['optimized']
Performance,"/// This class allows to keep track on instructions with implicit control flow.; /// These are instructions that may not pass execution to their successors. For; /// example, throwing calls and guards do not always do this. If we need to know; /// for sure that some instruction is guaranteed to execute if the given block; /// is reached, then we need to make sure that there is no implicit control flow; /// instruction (ICFI) preceding it. For example, this check is required if we; /// perform PRE moving non-speculable instruction to other place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:490,perform,perform,490,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,1,['perform'],['perform']
Performance,"/// This class define an interface similar to the LTOCodeGenerator, but adapted; /// for ThinLTO processing.; /// The ThinLTOCodeGenerator is not intended to be reuse for multiple; /// compilation: the model is that the client adds modules to the generator and; /// ask to perform the ThinLTO optimizations / codegen, and finally destroys the; /// codegenerator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:273,perform,perform,273,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,2,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"/// This class does all the work for a given function. Store and Load; /// instructions store and load corresponding shadow and origin; /// values. Most instructions propagate shadow from arguments to their; /// return values. Certain instructions (most importantly, BranchInst); /// test their argument shadow and print reports (with a runtime call) if it's; /// non-zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:65,Load,Load,65,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,2,"['Load', 'load']","['Load', 'load']"
Performance,"/// This class handles loading and caching of source files into memory.; ///; /// This object owns the MemoryBuffer objects for all of the loaded; /// files and assigns unique FileID's for each unique \#include chain.; ///; /// The SourceManager can be queried for information about SourceLocation; /// objects, turning them into either spelling or expansion locations. Spelling; /// locations represent where the bytes corresponding to a token came from and; /// expansion locations represent where the location is in the user's view. In; /// the case of a macro expansion, for example, the spelling location indicates; /// where the expanded token came from and the expansion location specifies; /// where it was expanded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:23,load,loading,23,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,2,['load'],"['loaded', 'loading']"
Performance,"/// This class holds necessary information to represent an interleaved; /// access group and supports utilities to lower the group into; /// X86-specific instructions/intrinsics.; /// E.g. A group of interleaving access loads (Factor = 2; accessing every; /// other element); /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; /// %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:220,load,loads,220,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,2,['load'],"['load', 'loads']"
Performance,/// This class implements a mechanism to disable passes and individual; /// optimizations at compile time based on a command line option; /// (-opt-bisect-limit) in order to perform a bisecting search for; /// optimization-related problems.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h:76,optimiz,optimizations,76,interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,3,"['optimiz', 'perform']","['optimization-related', 'optimizations', 'perform']"
Performance,"/// This class implements a resolution-based interface to LLVM's LTO; /// functionality. It supports regular LTO, parallel LTO code generation and; /// ThinLTO. You can use it from a linker in the following way:; /// - Set hooks and code generation options (see lto::Config struct defined in; /// Config.h), and use the lto::Config object to create an lto::LTO object.; /// - Create lto::InputFile objects using lto::InputFile::create(), then use; /// the symbols() function to enumerate its symbols and compute a resolution; /// for each symbol (see SymbolResolution below).; /// - After the linker has visited each input file (and each regular object; /// file) and computed a resolution for each symbol, take each lto::InputFile; /// and pass it and an array of symbol resolutions to the add() function.; /// - Call the getMaxTasks() function to get an upper bound on the number of; /// native object files that LTO may add to the link.; /// - Call the run() function. This function will use the supplied AddStream; /// and Cache functions to add up to getMaxTasks() native object files to; /// the link.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h:1027,Cache,Cache,1027,interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,1,['Cache'],['Cache']
Performance,"/// This class implements simplifications for calls to fortified library; /// functions (__st*cpy_chk, __memcpy_chk, __memmove_chk, __memset_chk), to,; /// when possible, replace them with their non-checking counterparts.; /// Other optimizations can also be done, but it's possible to disable them and; /// only simplify needless use of the checking versions (when the object size; /// is unknown) by passing true for OnlyLowerUnknownSize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:233,optimiz,optimizations,233,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,1,['optimiz'],['optimizations']
Performance,/// This class initializes machine functions by applying the state loaded from; /// a MIR file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h:67,load,loaded,67,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h,1,['load'],['loaded']
Performance,"/// This class is a batch walker of all MemoryUse's in the program, and points; /// their defining access at the thing that actually clobbers them. Because it; /// is a batch walker that touches everything, it does not operate like the; /// other walkers. This walker is basically performing a top-down SSA renaming; /// pass, where the version stack is used as the cache. This enables it to be; /// significantly more time and memory efficient than using the regular walker,; /// which is walking bottom-up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:281,perform,performing,281,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,2,"['cache', 'perform']","['cache', 'performing']"
Performance,"/// This class is a local cache, that caches the 'stat' and 'open' calls to the; /// underlying real file system.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:26,cache,cache,26,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,2,['cache'],"['cache', 'caches']"
Performance,"/// This class is a shared cache, that caches the 'stat' and 'open' calls to the; /// underlying real file system, and the scanned preprocessor directives of; /// files.; ///; /// It is sharded based on the hash of the key to reduce the lock contention for; /// the worker threads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:27,cache,cache,27,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,2,['cache'],"['cache', 'caches']"
Performance,"/// This class is a wrapper to associative container MapT<KeyT, ValueT> using; /// the hash value of the original key as the new key. This greatly improves the; /// performance of insert and query operations especially when hash values of; /// keys are available a priori, and reduces memory usage if KeyT has a large; /// size.; /// All keys with the same hash value are considered equivalent (i.e. hash; /// collision is silently ignored). Given such feature this class should only be; /// used where it does not affect compilation correctness, for example, when; /// loading a sample profile. The original key is not stored, so if the user; /// needs to preserve it, it should be stored in the mapped type.; /// Assuming the hashing algorithm is uniform, we use the formula; /// 1 - Permute(n, k) / n ^ k where n is the universe size and k is number of; /// elements chosen at random to calculate the probability of collision. With; /// 1,000,000 entries the probability is negligible:; /// 1 - (2^64)!/((2^64-1000000)!*(2^64)^1000000) ~= 3*10^-8.; /// Source: https://en.wikipedia.org/wiki/Birthday_problem; ///; /// \param MapT The underlying associative container type.; /// \param KeyT The original key type, which requires the implementation of; /// llvm::hash_value(KeyT).; /// \param ValueT The original mapped type, which has the same requirement as; /// the underlying container.; /// \param MapTArgs Additional template parameters passed to the underlying; /// container.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/HashKeyMap.h:165,perform,performance,165,interpreter/llvm-project/llvm/include/llvm/ProfileData/HashKeyMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/HashKeyMap.h,2,"['load', 'perform']","['loading', 'performance']"
Performance,"/// This class is basically a combination of TimeRegion and Timer. It allows; /// you to declare a new timer, AND specify the region to time, all in one; /// statement. All timers with the same name are merged. This is primarily; /// used for debugging and for hunting performance problems.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Timer.h:269,perform,performance,269,interpreter/llvm-project/llvm/include/llvm/Support/Timer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Timer.h,1,['perform'],['performance']
Performance,"/// This class is used for tools that requires cross translation; /// unit capability.; ///; /// This class can load definitions from external AST sources.; /// The loaded definition will be merged back to the original AST using the; /// AST Importer.; /// In order to use this class, an index file is required that describes; /// the locations of the AST files for each definition.; ///; /// Note that this class also implements caching.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:112,load,load,112,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,2,['load'],"['load', 'loaded']"
Performance,"/// This class is used to build a byte array containing overlapping bit sets. By; /// loading from indexed offsets into the byte array and applying a mask, a; /// program can test bits from the bit set with a relatively short instruction; /// sequence. For example, suppose we have 15 bit sets to lay out:; ///; /// A (16 bits), B (15 bits), C (14 bits), D (13 bits), E (12 bits),; /// F (11 bits), G (10 bits), H (9 bits), I (7 bits), J (6 bits), K (5 bits),; /// L (4 bits), M (3 bits), N (2 bits), O (1 bit); ///; /// These bits can be laid out in a 16-byte array like this:; ///; /// Byte Offset; /// 0123456789ABCDEF; /// Bit; /// 7 HHHHHHHHHIIIIIII; /// 6 GGGGGGGGGGJJJJJJ; /// 5 FFFFFFFFFFFKKKKK; /// 4 EEEEEEEEEEEELLLL; /// 3 DDDDDDDDDDDDDMMM; /// 2 CCCCCCCCCCCCCCNN; /// 1 BBBBBBBBBBBBBBBO; /// 0 AAAAAAAAAAAAAAAA; ///; /// For example, to test bit X of A, we evaluate ((bits[X] & 1) != 0), or to; /// test bit X of I, we evaluate ((bits[9 + X] & 0x80) != 0). This can be done; /// in 1-2 machine instructions on x86, or 4-6 instructions on ARM.; ///; /// This is a byte array, rather than (say) a 2-byte array or a 4-byte array,; /// because for one thing it gives us better packing (the more bins there are,; /// the less evenly they will be filled), and for another, the instruction; /// sequences can be slightly shorter, both on x86 and ARM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:86,load,loading,86,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h,1,['load'],['loading']
Performance,/// This class is used to represent ISD::LOAD nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:41,LOAD,LOAD,41,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['LOAD'],['LOAD']
Performance,"/// This class is used to represent a candidate for loop fusion. When it is; /// constructed, it checks the conditions for loop fusion to ensure that it; /// represents a valid candidate. It caches several parts of a loop that are; /// used throughout loop fusion (e.g., loop preheader, loop header, etc) instead; /// of continually querying the underlying Loop to retrieve these values. It is; /// assumed these will not change throughout loop fusion.; ///; /// The invalidate method should be used to indicate that the FusionCandidate is; /// no longer a valid candidate for fusion. Similarly, the isValid() method can; /// be used to ensure that the FusionCandidate is still valid for fusion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:191,cache,caches,191,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['cache'],['caches']
Performance,"/// This class keeps track of the SPI_SP_INPUT_ADDR config register, which; /// tells the hardware which interpolation parameters to load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h:133,load,load,133,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,1,['load'],['load']
Performance,"/// This class provides a portable interface to dynamic libraries which also; /// might be known as shared libraries, shared objects, dynamic shared; /// objects, or dynamic link libraries. Regardless of the terminology or the; /// operating system interface, this class provides a portable interface that; /// allows dynamic libraries to be loaded and searched for externally; /// defined symbols. This is typically used to provide ""plug-in"" support.; /// It also allows for symbols to be defined which don't live in any library,; /// but rather the main program itself, useful on Windows where the main; /// executable cannot be searched.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:342,load,loaded,342,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['load'],['loaded']
Performance,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:835,Optimiz,Optimized,835,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,2,"['Optimiz', 'optimiz']","['Optimized', 'optimized']"
Performance,/// This class represents an item in the work list. The type defines what kind; /// of work needs to be performed when processing the current item. Everything; /// but the Type and Die fields are optional based on the type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:104,perform,performed,104,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['perform'],['performed']
Performance,/// This class represents an item in the work list. The type defines what kind; /// of work needs to be performed when processing the current item. The flags; /// and info fields are optional based on the type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h:104,perform,performed,104,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,1,['perform'],['performed']
Performance,"/// This class represents the value of vscale, as used when defining the length; /// of a scalable vector or returned by the llvm.vscale() intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:90,scalab,scalable,90,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,1,['scalab'],['scalable']
Performance,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:554,cache,caches,554,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['cache'],['caches']
Performance,"/// This class wraps an output stream for a file. Most clients should just be; /// able to return an instance of this base class from the stream callback, but; /// if a client needs to perform some action after the stream is written to,; /// that can be done by deriving from this class and overriding the destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h:185,perform,perform,185,interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,1,['perform'],['perform']
Performance,"/// This combine tries do what performExtractVectorEltCombine does in SDAG.; /// Rewrite for pairwise fadd pattern; /// (s32 (g_extract_vector_elt; /// (g_fadd (vXs32 Other); /// (g_vector_shuffle (vXs32 Other) undef <1,X,...> )) 0)); /// ->; /// (s32 (g_fadd (g_extract_vector_elt (vXs32 Other) 0); /// (g_extract_vector_elt (vXs32 Other) 1))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp:31,perform,performExtractVectorEltCombine,31,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,1,['perform'],['performExtractVectorEltCombine']
Performance,"/// This does the promotion.; ///; /// Insts is a list of loads and stores to promote, and Name is the basename; /// for the PHIs to insert. After this is complete, the loads and stores are; /// removed from the code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:58,load,loads,58,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,2,['load'],['loads']
Performance,/// This enumerates the LLVM full LTO or ThinLTO optimization phases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:49,optimiz,optimization,49,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,1,['optimiz'],['optimization']
Performance,"/// This example fills a histogram concurrently, from several threads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/v7/concurrentfill.cxx:35,concurren,concurrently,35,tutorials/v7/concurrentfill.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/v7/concurrentfill.cxx,1,['concurren'],['concurrently']
Performance,"/// This field is used to track resource units that are used (i.e. selected); /// by other groups other than the one associated with this strategy object.; ///; /// In LLVM processor resource groups are allowed to partially (or fully); /// overlap. That means, a same unit may be visible to multiple groups.; /// This field keeps track of uses that have originated from outside of; /// this group. The idea is to bias the selection strategy, so that resources; /// that haven't been used by other groups get prioritized.; ///; /// The end goal is to (try to) keep the resource distribution as much uniform; /// as possible. By construction, this mask only tracks one-level of resource; /// usage. Therefore, this strategy is expected to be less accurate when same; /// units are used multiple times by other groups within a single round of; /// select.; ///; /// Note: an LRU selector would have a better accuracy at the cost of being; /// slightly more expensive (mostly in terms of runtime cost). Methods; /// 'select' and 'used', are always in the hot execution path of llvm-mca.; /// Therefore, a slow implementation of 'select' would have a negative impact; /// on the overall performance of the tool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:1182,perform,performance,1182,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['perform'],['performance']
Performance,/// This function checks if the instruction or bundle of instructions; /// has load from stack slot and returns frameindex and machine memory; /// operand of that instruction if true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:79,load,load,79,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['load'],['load']
Performance,"/// This function closes the dynamic library at the given path, using the; /// library close operation of the host operating system, and there is no; /// guarantee if or when this will cause the library to be unloaded.; ///; /// This function should be called only if the library was loaded using the; /// getLibrary() function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:284,load,loaded,284,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['load'],['loaded']
Performance,"/// This function copies from Fragment, which is a sequence of bytes; /// within Tok's contents (which begin at TokBegin) into ResultPtr.; /// Performs widening for multi-byte characters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:143,Perform,Performs,143,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['Perform'],['Performs']
Performance,"/// This function determines if the speficied instruction has the same; /// ""special"" characteristics as the current one. This means that opcode; /// specific details are the same. As a common example, if we are comparing; /// loads, then hasSameSpecialState would compare the alignments (among; /// other things).; /// @returns true if the specific instruction has the same opcde specific; /// characteristics as the current one. Determine if one instruction has the; /// same state as another.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:227,load,loads,227,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['load'],['loads']
Performance,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the load at DepLI.; ///; /// On success, it returns the offset into DepLI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:61,Load,LoadPtr,61,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,2,"['Load', 'load']","['LoadPtr', 'load']"
Performance,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the memory intrinsic at DepMI.; ///; /// On success, it returns the offset into DepMI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:61,Load,LoadPtr,61,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,1,['Load'],['LoadPtr']
Performance,"/// This function determines whether a value for the pointer LoadPtr can be; /// extracted from the store at DepSI.; ///; /// On success, it returns the offset into DepSI that extraction would start.; /// On failure, it returns -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:61,Load,LoadPtr,61,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,1,['Load'],['LoadPtr']
Performance,"/// This function inlines the called function into the basic; /// block of the caller. This returns false if it is not possible to inline; /// this call. The program is still in a well defined state if this occurs; /// though.; ///; /// Note that this only does one level of inlining. For example, if the; /// instruction 'call B' is inlined, and 'B' calls 'C', then the call to 'C' now; /// exists in the instruction stream. Similarly this will inline a recursive; /// function by one level.; ///; /// Note that while this routine is allowed to cleanup and optimize the; /// *inlined* code to minimize the actual inserted code, it must not delete; /// code in the caller as users of this routine may have pointers to; /// instructions in the caller that need to remain stable.; ///; /// If ForwardVarArgsTo is passed, inlining a function with varargs is allowed; /// and all varargs at the callsite will be passed to any calls to; /// ForwardVarArgsTo. The caller of InlineFunction has to make sure any varargs; /// are only used by ForwardVarArgsTo.; ///; /// The callee's function attributes are merged into the callers' if; /// MergeAttributes is set to true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:558,optimiz,optimize,558,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,1,['optimiz'],['optimize']
Performance,"/// This function is called when we have a memdep query of a load that ends up; /// being a clobbering memory write (store, memset, memcpy, memmove). This; /// means that the write *may* provide bits used by the load but we can't be; /// sure because the pointers don't must-alias.; ///; /// Check this case to see if there is anything more we can do before we give; /// up. This returns -1 if we have to give up, or a byte number in the stored; /// value of the piece that feeds the load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:61,load,load,61,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,3,['load'],['load']
Performance,/// This function is called when we have a; /// memdep query of a load that ends up being a clobbering mem intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:66,load,load,66,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,1,['load'],['load']
Performance,/// This function is called when we have a; /// memdep query of a load that ends up being a clobbering store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:66,load,load,66,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,1,['load'],['load']
Performance,/// This function is called when we have a; /// memdep query of a load that ends up being clobbered by another load. See if; /// the other load can feed into the second load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:66,load,load,66,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,4,['load'],['load']
Performance,/// This function is the main interface to the MIR serialization format parser.; ///; /// It reads in a MIR file and returns a MIR parser that can parse the embedded; /// LLVM IR module and initialize the machine functions by parsing the machine; /// function's state.; ///; /// \param Filename - The name of the file to parse.; /// \param Error - Error result info.; /// \param Context - Context which will be used for the parsed LLVM IR module.; /// \param ProcessIRFunction - function to run on every IR function or stub; /// loaded from the MIR file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h:529,load,loaded,529,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRParser/MIRParser.h,1,['load'],['loaded']
Performance,"/// This function is used to do simplification of a CFG. For example, it; /// adjusts branches to branches to eliminate the extra hop, it eliminates; /// unreachable basic blocks, and does other peephole optimization of the CFG.; /// It returns true if a modification was made, possibly deleting the basic; /// block that was pointed to. LoopHeaders is an optional input parameter; /// providing the set of loop headers that SimplifyCFG should not eliminate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:204,optimiz,optimization,204,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,1,['optimiz'],['optimization']
Performance,"/// This function loads a definition from an external AST file.; ///; /// A definition with the same declaration will be looked up in the; /// index file which should be in the \p CrossTUDir directory, called; /// \p IndexName. In case the declaration is found in the index the; /// corresponding AST will be loaded. If the number of TUs imported; /// reaches \p CTULoadTreshold, no loading is performed.; ///; /// \return Returns a pointer to the ASTUnit that contains the definition of; /// the looked up name or an Error.; /// The returned pointer is never a nullptr.; ///; /// Note that the AST files should also be in the \p CrossTUDir.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:18,load,loads,18,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,4,"['load', 'perform']","['loaded', 'loading', 'loads', 'performed']"
Performance,"/// This function loads a function or variable definition from an; /// external AST file and merges it into the original AST.; ///; /// This method should only be used on functions that have no definitions or; /// variables that have no initializer in; /// the current translation unit. A function definition with the same; /// declaration will be looked up in the index file which should be in the; /// \p CrossTUDir directory, called \p IndexName. In case the declaration is; /// found in the index the corresponding AST will be loaded and the; /// definition will be merged into the original AST using the AST Importer.; ///; /// \return The declaration with the definition will be returned.; /// If no suitable definition is found in the index file or multiple; /// definitions found error will be returned.; ///; /// Note that the AST files should also be in the \p CrossTUDir.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:18,load,loads,18,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,2,['load'],"['loaded', 'loads']"
Performance,"/// This function loads the dynamic library at the given path, using the; /// library load operation from the host operating system. The library; /// instance will be closed when closeLibrary is called or global destructors; /// are run, but there is no guarantee when the library will be unloaded.; ///; /// This returns a valid DynamicLibrary instance on success and an invalid; /// instance on failure (see isValid()). \p *Err will only be modified if the; /// library fails to load.; ///; /// It is safe to call this function multiple times for the same library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:18,load,loads,18,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,3,['load'],"['load', 'loads']"
Performance,"/// This function must be overridden in the derived class to pass on constant term optimization configuration; /// to the function to be minimized. For a RooAbsArg, this would be RooAbsArg::constOptimizeTestStatistic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.h:83,optimiz,optimization,83,roofit/roofitcore/src/RooAbsMinimizerFcn.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsMinimizerFcn.h,1,['optimiz'],['optimization']
Performance,"/// This function performs both a legality check and profitability check at; /// the same time since it is convenient to do so. It iterates through all; /// blocks that will be cloned, and keeps track of the duplication cost. It; /// also returns false if it is illegal to clone some required block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:18,perform,performs,18,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,1,['perform'],['performs']
Performance,/// This function permanently loads the dynamic library at the given path.; /// Use this instead of getPermanentLibrary() when you won't need to get; /// symbols from the library itself.; ///; /// It is safe to call this function multiple times for the same library.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:30,load,loads,30,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['load'],['loads']
Performance,"/// This function permanently loads the dynamic library at the given path; /// using the library load operation from the host operating system. The; /// library instance will only be closed when global destructors run, and; /// there is no guarantee when the library will be unloaded.; ///; /// This returns a valid DynamicLibrary instance on success and an invalid; /// instance on failure (see isValid()). \p *errMsg will only be modified if; /// the library fails to load.; ///; /// It is safe to call this function multiple times for the same library.; /// Open a dynamic library permanently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:30,load,loads,30,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,3,['load'],"['load', 'loads']"
Performance,"/// This function returns an estimate for VL to be used in VL based terms; /// of the cost model. For fixed length vectors, this is simply the; /// vector length. For scalable vectors, we return results consistent; /// with getVScaleForTuning under the assumption that clients are also; /// using that when comparing costs between scalar and vector representation.; /// This does unfortunately mean that we can both undershoot and overshot; /// the true cost significantly if getVScaleForTuning is wildly off for the; /// actual target hardware.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h:167,scalab,scalable,167,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetTransformInfo.h,1,['scalab'],['scalable']
Performance,"/// This function takes the specified global variable, and transforms the; /// program as if it always contained the result of the specified malloc.; /// Because it is always the result of the specified malloc, there is no reason; /// to actually DO the malloc. Instead, turn the malloc into a global, and any; /// loads of GV as uses of the new global.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:315,load,loads,315,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['load'],['loads']
Performance,/// This function will attempt to load XRay trace records from the provided; /// DataExtractor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:34,load,load,34,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,1,['load'],['load']
Performance,/// This function will attempt to load XRay trace records from the provided; /// |Filename|.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:34,load,load,34,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,1,['load'],['load']
Performance,"/// This function will attempt to load an XRay Profiling Mode profile from the; /// provided |Filename|.; ///; /// For any errors encountered in the loading of the profile data from; /// |Filename|, this function will return an Error condition appropriately.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:34,load,load,34,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,2,['load'],"['load', 'loading']"
Performance,"/// This helper fills TH1Ds for which no axes were specified by buffering the fill values to pick good axes limits.; ///; /// TH1Ds have an automatic mechanism to pick good limits based on the first N entries they were filled with, but; /// that does not work in multi-thread event loops as it might yield histograms with incompatible binning in each; /// thread, making it impossible to merge the per-thread results.; /// Instead, this helper delays the decision on the axes limits until all threads have done processing, synchronizing; /// the decision on the limits as part of the merge operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:263,multi-thread,multi-thread,263,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['multi-thread'],['multi-thread']
Performance,/// This helper function of SimplifySetCC tries to optimize the comparison when; /// either operand of the SetCC node is a bitwise-and instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:51,optimiz,optimize,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['optimiz'],['optimize']
Performance,"/// This holds the working set of currently open ranges. For fast; /// access, this is done both as a set of VarLocIDs, and a map of; /// DebugVariable to recent VarLocID. Note that a DBG_VALUE ends all; /// previous open ranges for the same variable. In addition, we keep; /// two different maps (Vars/EntryValuesBackupVars), so erase/insert; /// methods act differently depending on whether a VarLoc is primary; /// location or backup one. In the case the VarLoc is backup location; /// we will erase/insert from the EntryValuesBackupVars map, otherwise; /// we perform the operation on the Vars.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:564,perform,perform,564,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['perform'],['perform']
Performance,"/// This hook must be implemented to check whether the return values; /// described by \p Outs can fit into the return registers. If false; /// is returned, an sret-demotion is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:177,perform,performed,177,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,1,['perform'],['performed']
Performance,"/// This hook should be implemented to check whether the return values; /// described by the Outs array can fit into the return registers. If false; /// is returned, an sret-demotion is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:186,perform,performed,186,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['performed']
Performance,"/// This implementation of LoopSafetyInfo use ImplicitControlFlowTracking to; /// give precise answers on ""may throw"" queries. This implementation uses cache; /// that should be invalidated by calling the methods insertInstructionTo and; /// removeInstruction whenever we modify a basic block's contents by adding or; /// removing instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:152,cache,cache,152,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['cache'],['cache']
Performance,"/// This indicates the Type object that represents; /// this TypeDecl. It is a cache maintained by; /// ASTContext::getTypedefType, ASTContext::getTagDeclType, and; /// ASTContext::getTemplateTypeParmType, and TemplateTypeParmDecl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:79,cache,cache,79,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['cache'],['cache']
Performance,"/// This instruction constructs a fixed permutation of two; /// input vectors.; ///; /// For each element of the result vector, the shuffle mask selects an element; /// from one of the input vectors to copy to the result. Non-negative elements; /// in the mask represent an index into the concatenated pair of input vectors.; /// PoisonMaskElem (-1) specifies that the result element is poison.; ///; /// For scalable vectors, all the elements of the mask must be 0 or -1. This; /// requirement may be relaxed in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:409,scalab,scalable,409,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['scalab'],['scalable']
Performance,"/// This instruction implements an extending load to FP stack slots.; /// This corresponds to the X86::FLD32m / X86::FLD64m. It takes a chain; /// operand, and ptr to load from. The memory VT specifies the type to; /// load from.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:45,load,load,45,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,3,['load'],['load']
Performance,"/// This interface returns a list of dependent libraries in the form:; /// lib libA.so libB.so libC.so. The first library is the library we are; /// searching dependencies for.; /// Note: In order to speed up the search, we display the dependencies of the; /// libraries which are not yet loaded. For instance, if libB.so was already; /// loaded the list would contain: lib libA.so libC.so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:289,load,loaded,289,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['load'],['loaded']
Performance,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs an intermediate calculation for the next four; /// SHA512 message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg1_epi64(__m256i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG1 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s0(qword):; /// 	RETURN ROR64(qword,1) ^ ROR64(qword, 8) ^ SHR64(qword, 7); /// }; /// W[4] := __B.qword[0]; /// W[3] := __A.qword[3]; /// W[2] := __A.qword[2]; /// W[1] := __A.qword[1]; /// W[0] := __A.qword[0]; /// dst.qword[3] := W[3] + s0(W[4]); /// dst.qword[2] := W[2] + s0(W[3]); /// dst.qword[1] := W[1] + s0(W[2]); /// dst.qword[0] := W[0] + s0(W[1]); /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:96,perform,performs,96,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,1,['perform'],['performs']
Performance,"/// This intrinisc is one of the two SHA512 message scheduling instructions.; /// The intrinsic performs the final calculation for the next four SHA512; /// message qwords. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512msg2_epi64(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512MSG2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE s1(qword) {; /// 	RETURN ROR64(qword,19) ^ ROR64(qword, 61) ^ SHR64(qword, 6); /// }; /// W[14] := __B.qword[2]; /// W[15] := __B.qword[3]; /// W[16] := __A.qword[0] + s1(W[14]); /// W[17] := __A.qword[1] + s1(W[15]); /// W[18] := __A.qword[2] + s1(W[16]); /// W[19] := __A.qword[3] + s1(W[17]); /// dst.qword[3] := W[19]; /// dst.qword[2] := W[18]; /// dst.qword[1] := W[17]; /// dst.qword[0] := W[16]; /// dst[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:96,perform,performs,96,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,1,['perform'],['performs']
Performance,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs an initial calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg1_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG1 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32 - count)); /// 	RETURN dest; /// }; /// DEFINE P1(x) {; /// 	RETURN x ^ ROL32(x, 15) ^ ROL32(x, 23); /// }; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[2] := __C.dword[2]; /// W[3] := __C.dword[3]; /// W[7] := __A.dword[0]; /// W[8] := __A.dword[1]; /// W[9] := __A.dword[2]; /// W[10] := __A.dword[3]; /// W[13] := __B.dword[0]; /// W[14] := __B.dword[1]; /// W[15] := __B.dword[2]; /// TMP0 := W[7] ^ W[0] ^ ROL32(W[13], 15); /// TMP1 := W[8] ^ W[1] ^ ROL32(W[14], 15); /// TMP2 := W[9] ^ W[2] ^ ROL32(W[15], 15); /// TMP3 := W[10] ^ W[3]; /// dst.dword[0] := P1(TMP0); /// dst.dword[1] := P1(TMP1); /// dst.dword[2] := P1(TMP2); /// dst.dword[3] := P1(TMP3); /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:91,perform,performs,91,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,1,['perform'],['performs']
Performance,"/// This intrinisc is one of the two SM3 message scheduling intrinsics. The; /// intrinsic performs the final calculation for the next four SM3 message; /// words. The calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3msg2_epi32(__m128i __A, __m128i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM3MSG2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// WTMP[0] := __A.dword[0]; /// WTMP[1] := __A.dword[1]; /// WTMP[2] := __A.dword[2]; /// WTMP[3] := __A.dword[3]; /// W[3] := __B.dword[0]; /// W[4] := __B.dword[1]; /// W[5] := __B.dword[2]; /// W[6] := __B.dword[3]; /// W[10] := __C.dword[0]; /// W[11] := __C.dword[1]; /// W[12] := __C.dword[2]; /// W[13] := __C.dword[3]; /// W[16] := ROL32(W[3], 7) ^ W[10] ^ WTMP[0]; /// W[17] := ROL32(W[4], 7) ^ W[11] ^ WTMP[1]; /// W[18] := ROL32(W[5], 7) ^ W[12] ^ WTMP[2]; /// W[19] := ROL32(W[6], 7) ^ W[13] ^ WTMP[3]; /// W[19] := W[19] ^ ROL32(W[16], 6) ^ ROL32(W[16], 15) ^ ROL32(W[16], 30); /// dst.dword[0] := W[16]; /// dst.dword[1] := W[17]; /// dst.dword[2] := W[18]; /// dst.dword[3] := W[19]; /// dst[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:91,perform,performs,91,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,1,['perform'],['performs']
Performance,"/// This intrinisc performs four rounds of SM4 encryption. The intrinisc; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm4rnds4_epi32(__m128i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4RNDS4 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_RND(dword) {; /// 	tmp := dword; /// 	tmp := tmp ^ ROL32(dword, 2); /// 	tmp := tmp ^ ROL32(dword, 10); /// 	tmp := tmp ^ ROL32(dword, 18); /// 	tmp := tmp ^ ROL32(dword, 24); /// RETURN tmp; /// }; /// DEFINE T_RND(dword) {; /// 	RETURN L_RND(lower_t(dword)); /// }; /// DEFINE F_RND(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_RND(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_RND(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_RND(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_RND(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_RND(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,perform,performs,19,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,1,['perform'],['performs']
Performance,"/// This intrinisc performs four rounds of SM4 encryption. The intrinisc; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sm4rnds4_epi32(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4RNDS4 instruction.; ///; /// \param __A; /// A 256-bit vector of [8 x int].; /// \param __B; /// A 256-bit vector of [8 x int].; /// \returns; /// A 256-bit vector of [8 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_RND(dword) {; /// 	tmp := dword; /// 	tmp := tmp ^ ROL32(dword, 2); /// 	tmp := tmp ^ ROL32(dword, 10); /// 	tmp := tmp ^ ROL32(dword, 18); /// 	tmp := tmp ^ ROL32(dword, 24); /// RETURN tmp; /// }; /// DEFINE T_RND(dword) {; /// 	RETURN L_RND(lower_t(dword)); /// }; /// DEFINE F_RND(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_RND(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_RND(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_RND(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_RND(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_RND(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,perform,performs,19,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,1,['perform'],['performs']
Performance,"/// This intrinisc performs two rounds of SHA512 operation using initial SHA512; /// state (C,D,G,H) from \a __A, an initial SHA512 state (A,B,E,F) from; /// \a __A, and a pre-computed sum of the next two round message qwords and; /// the corresponding round constants from \a __C (only the two lower qwords; /// of the third operand). The updated SHA512 state (A,B,E,F) is written to; /// \a __A, and \a __A can be used as the updated state (C,D,G,H) in later; /// rounds.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sha512rnds2_epi64(__m256i __A, __m256i __B, __m128i __C); /// \endcode; ///; /// This intrinsic corresponds to the \c VSHA512RNDS2 instruction.; ///; /// \param __A; /// A 256-bit vector of [4 x long long].; /// \param __B; /// A 256-bit vector of [4 x long long].; /// \param __C; /// A 128-bit vector of [2 x long long].; /// \returns; /// A 256-bit vector of [4 x long long].; ///; /// \code{.operation}; /// DEFINE ROR64(qword, n) {; /// 	count := n % 64; /// 	dest := (qword >> count) | (qword << (64 - count)); /// 	RETURN dest; /// }; /// DEFINE SHR64(qword, n) {; /// 	RETURN qword >> n; /// }; /// DEFINE cap_sigma0(qword) {; /// 	RETURN ROR64(qword,28) ^ ROR64(qword, 34) ^ ROR64(qword, 39); /// }; /// DEFINE cap_sigma1(qword) {; /// 	RETURN ROR64(qword,14) ^ ROR64(qword, 18) ^ ROR64(qword, 41); /// }; /// DEFINE MAJ(a,b,c) {; /// 	RETURN (a & b) ^ (a & c) ^ (b & c); /// }; /// DEFINE CH(e,f,g) {; /// 	RETURN (e & f) ^ (g & ~e); /// }; /// A[0] := __B.qword[3]; /// B[0] := __B.qword[2]; /// C[0] := __C.qword[3]; /// D[0] := __C.qword[2]; /// E[0] := __B.qword[1]; /// F[0] := __B.qword[0]; /// G[0] := __C.qword[1]; /// H[0] := __C.qword[0]; /// WK[0]:= __A.qword[0]; /// WK[1]:= __A.qword[1]; /// FOR i := 0 to 1:; /// 	A[i+1] := CH(E[i], F[i], G[i]) +; /// 	cap_sigma1(E[i]) + WK[i] + H[i] +; /// 	MAJ(A[i], B[i], C[i]) +; /// 	cap_sigma0(A[i]); /// 	B[i+1] := A[i]; /// 	C[i+1] := B[i]; /// 	D[i+1] := C[i]; /// 	E[i+1] := CH(E[i], F[i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h:19,perform,performs,19,interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sha512intrin.h,1,['perform'],['performs']
Performance,"/// This intrinsic performs four rounds of SM4 key expansion. The intrinsic; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm4key4_epi32(__m128i __A, __m128i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4KEY4 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE SBOX_BYTE(dword, i) {; /// 	RETURN sbox[dword.byte[i]]; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_KEY(dword) {; /// 	RETURN dword ^ ROL32(dword, 13) ^ ROL32(dword, 23); /// }; /// DEFINE T_KEY(dword) {; /// 	RETURN L_KEY(lower_t(dword)); /// }; /// DEFINE F_KEY(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_KEY(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 0; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_KEY(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_KEY(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_KEY(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_KEY(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:128] := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,perform,performs,19,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,1,['perform'],['performs']
Performance,"/// This intrinsic performs four rounds of SM4 key expansion. The intrinsic; /// operates on independent 128-bit lanes. The calculated results are; /// stored in \a dst.; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_sm4key4_epi32(__m256i __A, __m256i __B); /// \endcode; ///; /// This intrinsic corresponds to the \c VSM4KEY4 instruction.; ///; /// \param __A; /// A 256-bit vector of [8 x int].; /// \param __B; /// A 256-bit vector of [8 x int].; /// \returns; /// A 256-bit vector of [8 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE SBOX_BYTE(dword, i) {; /// 	RETURN sbox[dword.byte[i]]; /// }; /// DEFINE lower_t(dword) {; /// 	tmp.byte[0] := SBOX_BYTE(dword, 0); /// 	tmp.byte[1] := SBOX_BYTE(dword, 1); /// 	tmp.byte[2] := SBOX_BYTE(dword, 2); /// 	tmp.byte[3] := SBOX_BYTE(dword, 3); /// 	RETURN tmp; /// }; /// DEFINE L_KEY(dword) {; /// 	RETURN dword ^ ROL32(dword, 13) ^ ROL32(dword, 23); /// }; /// DEFINE T_KEY(dword) {; /// 	RETURN L_KEY(lower_t(dword)); /// }; /// DEFINE F_KEY(X0, X1, X2, X3, round_key) {; /// 	RETURN X0 ^ T_KEY(X1 ^ X2 ^ X3 ^ round_key); /// }; /// FOR i:= 0 to 1; /// 	P[0] := __B.xmm[i].dword[0]; /// 	P[1] := __B.xmm[i].dword[1]; /// 	P[2] := __B.xmm[i].dword[2]; /// 	P[3] := __B.xmm[i].dword[3]; /// 	C[0] := F_KEY(P[0], P[1], P[2], P[3], __A.xmm[i].dword[0]); /// 	C[1] := F_KEY(P[1], P[2], P[3], C[0], __A.xmm[i].dword[1]); /// 	C[2] := F_KEY(P[2], P[3], C[0], C[1], __A.xmm[i].dword[2]); /// 	C[3] := F_KEY(P[3], C[0], C[1], C[2], __A.xmm[i].dword[3]); /// 	DEST.xmm[i].dword[0] := C[0]; /// 	DEST.xmm[i].dword[1] := C[1]; /// 	DEST.xmm[i].dword[2] := C[2]; /// 	DEST.xmm[i].dword[3] := C[3]; /// ENDFOR; /// DEST[MAX:256] := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h:19,perform,performs,19,interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm4intrin.h,1,['perform'],['performs']
Performance,"/// This intrinsic performs two rounds of SM3 operation using initial SM3 state; /// (C, D, G, H) from \a __A, an initial SM3 states (A, B, E, F); /// from \a __B and a pre-computed words from the \a __C. \a __A with; /// initial SM3 state of (C, D, G, H) assumes input of non-rotated left; /// variables from previous state. The updated SM3 state (A, B, E, F) is; /// written to \a __A. The \a imm8 should contain the even round number; /// for the first of the two rounds computed by this instruction. The; /// computation masks the \a imm8 value by AND’ing it with 0x3E so that only; /// even round numbers from 0 through 62 are used for this operation. The; /// calculated results are stored in \a dst.; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sm3rnds2_epi32(__m128i __A, __m128i __B, __m128i __C, const int; /// imm8) \endcode; ///; /// This intrinsic corresponds to the \c VSM3RNDS2 instruction.; ///; /// \param __A; /// A 128-bit vector of [4 x int].; /// \param __B; /// A 128-bit vector of [4 x int].; /// \param __C; /// A 128-bit vector of [4 x int].; /// \param imm8; /// A 8-bit constant integer.; /// \returns; /// A 128-bit vector of [4 x int].; ///; /// \code{.operation}; /// DEFINE ROL32(dword, n) {; /// 	count := n % 32; /// 	dest := (dword << count) | (dword >> (32-count)); /// 	RETURN dest; /// }; /// DEFINE P0(dword) {; /// 	RETURN dword ^ ROL32(dword, 9) ^ ROL32(dword, 17); /// }; /// DEFINE FF(x,y,z, round){; /// 	IF round < 16; /// 		RETURN (x ^ y ^ z); /// 	ELSE; /// 		RETURN (x & y) | (x & z) | (y & z); /// 	FI; /// }; /// DEFINE GG(x, y, z, round){; /// IF round < 16; /// 	RETURN (x ^ y ^ z); /// ELSE; /// 	RETURN (x & y) | (~x & z); /// FI; /// }; /// A[0] := __B.dword[3]; /// B[0] := __B.dword[2]; /// C[0] := __A.dword[3]; /// D[0] := __A.dword[2]; /// E[0] := __B.dword[1]; /// F[0] := __B.dword[0]; /// G[0] := __A.dword[1]; /// H[0] := __A.dword[0]; /// W[0] := __C.dword[0]; /// W[1] := __C.dword[1]; /// W[4] := __C.dword[2]; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h:19,perform,performs,19,interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/sm3intrin.h,1,['perform'],['performs']
Performance,/// This inverts a canonicalization in IR that replaces a variable select arm; /// with an identity constant. Codegen improves if we re-use the variable; /// operand rather than load a constant. This can also be converted into a; /// masked vector operation if the target supports it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:178,load,load,178,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,"/// This is a 'bitvector' (really, a variable-sized bit array), optimized for; /// the case when the array is small. It contains one pointer-sized field, which; /// is directly used as a plain collection of bits when possible, or as a; /// pointer to a larger heap-allocated array when necessary. This allows normal; /// ""small"" cases to be fast without losing generality for large inputs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h:64,optimiz,optimized,64,interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h,1,['optimiz'],['optimized']
Performance,"/// This is a 'vector' (really, a variable-sized array), optimized; /// for the case when the array is small. It contains some number of elements; /// in-place, which allows it to avoid heap allocation when the actual number of; /// elements is below that threshold. This allows normal ""small"" cases to be; /// fast without losing generality for large inputs.; ///; /// \note; /// In the absence of a well-motivated choice for the number of inlined; /// elements \p N, it is recommended to use \c SmallVector<T> (that is,; /// omitting the \p N). This will choose a default number of inlined elements; /// reasonable for allocation on the stack (for example, trying to keep \c; /// sizeof(SmallVector<T>) around 64 bytes).; ///; /// \warning This does not attempt to be exception safe.; ///; /// \see https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:57,optimiz,optimized,57,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['optimiz'],['optimized']
Performance,/// This is a cache for expressions that got folded to a different existing; /// SCEV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:14,cache,cache,14,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['cache'],['cache']
Performance,/// This is a cache of the values we have analyzed so far.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:14,cache,cache,14,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['cache'],['cache']
Performance,/// This is a cache to record whether a SCEV contains any scAddRecExpr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:14,cache,cache,14,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['cache'],['cache']
Performance,"/// This is a dependence on the specified instruction which clobbers the; /// desired value. The pointer member of the MemDepResult pair holds the; /// instruction that clobbers the memory. For example, this occurs when we; /// see a may-aliased store to the memory location we care about.; ///; /// There are several cases that may be interesting here:; /// 1. Loads are clobbered by may-alias stores.; /// 2. Loads are considered clobbered by partially-aliased loads. The; /// client may choose to analyze deeper into these cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:362,Load,Loads,362,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,3,"['Load', 'load']","['Loads', 'loads']"
Performance,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:263,load,load,263,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,7,['load'],"['load', 'loaded', 'loading', 'loads']"
Performance,"/// This is a generic driver to narrow down miscompilations, either in an; /// optimization or a code generator.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:79,optimiz,optimization,79,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['optimiz'],['optimization']
Performance,/// This is a helper function for `castTo` method. Implies not to be used; /// separately.; /// Performs a conversion case and a promotion-conversion case for signeds; /// of a cast operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h:96,Perform,Performs,96,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,1,['Perform'],['Performs']
Performance,/// This is a helper function for `castTo` method. Implies not to be used; /// separately.; /// Performs a promotion for unsigneds only.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h:96,Perform,Performs,96,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,1,['Perform'],['Performs']
Performance,/// This is a helper function for `castTo` method. Implies not to be used; /// separately.; /// Performs a truncation case of a cast operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h:96,Perform,Performs,96,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,1,['Perform'],['Performs']
Performance,"/// This is a helper function for `getConstantValFromConstArrayInitializer`.; ///; /// Return an array of offsets from nested ElementRegions and a root base; /// region. The array is never empty and a base region is never null.; ///; /// E.g. for `Element{Element{Element{VarRegion},1},2},3}` returns { 3, 2, 1 }.; /// This represents an access through indirection: `arr[1][2][3];`; ///; /// \param ER The given (possibly nested) ElementRegion.; ///; /// \note The result array is in the reverse order of indirection expression:; /// arr[1][2][3] -> { 3, 2, 1 }. This helps to provide complexity O(n), where n; /// is a number of indirections. It may not affect performance in real-life; /// code, though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:662,perform,performance,662,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['perform'],['performance']
Performance,/// This is a helper function for mergeConsecutiveStores. It is used for; /// store chains that are composed entirely of loaded values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:121,load,loaded,121,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loaded']
Performance,/// This is a helper function for visitAND and visitZERO_EXTEND. Returns; /// true if the (and (load x) c) pattern matches an extload. ExtVT returns; /// the type of the loaded value to be extended.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:96,load,load,96,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],"['load', 'loaded']"
Performance,"/// This is a little filter, which returns true if an addressing computation; /// involving I might be folded into a load/store accessing it.; /// This doesn't need to be perfect, but needs to accept at least; /// the set of instructions that MatchOperationAddr can.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:117,load,load,117,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['load'],['load']
Performance,/// This is a scope of some OpenMP directive with; /// order clause which specifies concurrent,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Scope.h:84,concurren,concurrent,84,interpreter/llvm-project/clang/include/clang/Sema/Scope.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Scope.h,1,['concurren'],['concurrent']
Performance,"/// This is a simple memory manager which implements the methods called by; /// the RuntimeDyld class to allocate memory for section-based loading of; /// objects, usually those generated by the MCJIT execution engine.; ///; /// This memory manager allocates all section memory as read-write. The; /// RuntimeDyld will copy JITed section memory into these allocated blocks; /// and perform any necessary linking and relocations.; ///; /// Any client using this memory manager MUST ensure that section-specific; /// page permissions have been applied before attempting to execute functions; /// in the JITed object. Permissions can be applied either by calling; /// MCJIT::finalizeObject or by calling SectionMemoryManager::finalizeMemory; /// directly. Clients of MCJIT should call MCJIT::finalizeObject.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h:139,load,loading,139,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,2,"['load', 'perform']","['loading', 'perform']"
Performance,"/// This is a used by the pre-regalloc scheduler to determine (in conjunction; /// with areLoadsFromSameBasePtr) if two loads should be scheduled together.; /// On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:120,load,loads,120,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,7,"['cache', 'load']","['cache', 'load', 'loading', 'loads']"
Performance,"/// This is all of the cached information for one basic block. It contains; /// the per-value lattice elements, as well as a separate set for; /// overdefined values to reduce memory usage. Additionally pointers; /// dereferenced in the block are cached for nullability queries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:23,cache,cached,23,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,2,['cache'],['cached']
Performance,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:43,throughput,throughput,43,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,4,"['optimiz', 'throughput']","['optimizations', 'throughput']"
Performance,/// This is an entry in the NonLocalDepInfo cache.; ///; /// For each BasicBlock (the BB entry) it keeps a MemDepResult.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:44,cache,cache,44,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['cache'],['cache']
Performance,/// This is called after a .mir file was loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:41,load,loaded,41,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['load'],['loaded']
Performance,/// This is called for each AST file loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:37,load,loaded,37,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:60,load,load,60,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,5,"['load', 'optimiz']","['load', 'loaded', 'optimize']"
Performance,/// This is ctor variant allows a pass to build an optimization remark; /// from an existing remark.; ///; /// This is useful when a transformation pass (e.g LV) wants to emit a remark; /// (\p Orig) generated by one of its analyses (e.g. LAA) as its own analysis; /// remark. The string \p Prepend will be emitted before the original; /// message.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:51,optimiz,optimization,51,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,2,['optimiz'],['optimization']
Performance,/// This is intended to be equivalent to selectAddrModeXRO in; /// AArch64ISelDAGtoDAG. It's used for selecting X register offset loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:130,load,loads,130,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['load'],['loads']
Performance,/// This is just a convenience method to make client code smaller for a; /// common case. It also correctly performs the comparison without the; /// potential for an assertion from getZExtValue().; /// Determine if the value is one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h:108,perform,performs,108,interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,1,['perform'],['performs']
Performance,/// This is just a convenience method to make client code smaller for a; /// common code. It also correctly performs the comparison without the; /// potential for an assertion from getZExtValue().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h:108,perform,performs,108,interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,1,['perform'],['performs']
Performance,/// This is normally called from the main scheduler loop but may also be invoked; /// by the scheduling strategy to perform additional code motion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:116,perform,perform,116,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['perform'],['perform']
Performance,"/// This is not as easy as it might seem because we have to worry about making; /// copies of global variables and functions, and making their (initializers and; /// references, respectively) refer to the right globals.; ///; /// Cloning un-materialized modules is not currently supported, so any; /// modules initialized via lazy loading should be materialized before cloning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:331,load,loading,331,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,1,['load'],['loading']
Performance,/// This is part of the update interface to inform the cache; /// that a block has been deleted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:55,cache,cache,55,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,2,['cache'],['cache']
Performance,/// This is part of the update interface to remove information related to this; /// value from the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:99,cache,cache,99,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['cache'],['cache']
Performance,"/// This is the AA result object for the basic, local, and stateless alias; /// analysis. It implements the AA query interface in an entirely stateless; /// manner. As one consequence, it is never invalidated due to IR changes.; /// While it does retain some storage, that is used as an optimization and not; /// to preserve information from query to query. However it does retain handles; /// to various other analyses and must be recomputed when those analyses are.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h:287,optimiz,optimization,287,interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BasicAliasAnalysis.h,1,['optimiz'],['optimization']
Performance,"/// This is the biggest offset to the stack pointer we can encode in aarch64; /// instructions (without using a separate calculation and a temp register).; /// Note that the exception here are vector stores/loads which cannot encode any; /// displacements (see estimateRSStackSizeLimit(), isAArch64FrameOffsetLegal()).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:207,load,loads,207,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['load'],['loads']
Performance,/// This is the cache kept by LazyValueInfo which; /// maintains information about queries across the clients' queries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:16,cache,cache,16,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['cache'],['cache']
Performance,/// This is the instruction we keep for each cached access that we have for; /// an instruction.; ///; /// The pointer is an owning pointer and the bool indicates whether we have; /// any dirty bits in the set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:45,cache,cached,45,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['cache'],['cached']
Performance,"/// This is the pointer that the intrinsic is loading from or storing to.; /// If this is non-null, then analysis/optimization passes can assume that; /// this intrinsic is functionally equivalent to a load/store from this; /// pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:46,load,loading,46,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,3,"['load', 'optimiz']","['load', 'loading', 'optimization']"
Performance,"/// This is the pointer to an array of tokens that the macro is; /// defined to, with arguments expanded for function-like macros. If this is; /// a token stream, these are the tokens we are returning. This points into; /// the macro definition we are lexing from, a cache buffer that is owned by; /// the preprocessor, or some other buffer that we may or may not own; /// (depending on OwnsTokens).; /// Note that if it points into Preprocessor's cache buffer, the Preprocessor; /// may update the pointer as needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenLexer.h:267,cache,cache,267,interpreter/llvm-project/clang/include/clang/Lex/TokenLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenLexer.h,2,['cache'],['cache']
Performance,"/// This is the query interface to determine the lattice value for the; /// specified Value* at the specified instruction using only information; /// from assumes/guards and range metadata. Unlike getValueInBlock(), no; /// recursive query is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:243,perform,performed,243,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['perform'],['performed']
Performance,"/// This is the resource with the greatest queue, which the; /// scheduler tries to avoid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:43,queue,queue,43,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,1,['queue'],['queue']
Performance,"/// This is the type of a file cache. To request an item from the cache, pass a; /// unique string as the Key. For hits, the cached file will be added to the; /// link and this function will return AddStreamFn(). For misses, the cache will; /// return a stream callback which must be called at most once to produce; /// content for the stream. The file stream produced by the stream callback will; /// add the file to the link after the stream is written to. ModuleName is the; /// unique module identifier for the bitcode module the cache is being checked; /// for.; ///; /// Clients generally look like this:; ///; /// if (AddStreamFn AddStream = Cache(Task, Key, ModuleName)); /// ProduceContent(AddStream);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h:31,cache,cache,31,interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,6,"['Cache', 'cache']","['Cache', 'cache', 'cached']"
Performance,/// This is the update interface to inform the cache that an edge from; /// PredBB to OldSucc has been threaded to be from PredBB to NewSucc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:47,cache,cache,47,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['cache'],['cache']
Performance,"/// This is used by foldLoadsRecursive() to capture a Root Load node which is; /// of type or(load, load) and recursively build the wide load. Also capture the; /// shift amount, zero extend type and loadSize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:59,Load,Load,59,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,5,"['Load', 'load']","['Load', 'load', 'loadSize']"
Performance,/// This is used by the pre-regalloc scheduler to determine if two loads are; /// loading from the same base address. It should only return true if the base; /// pointers are the same and the only differences between the two addresses; /// are the offset. It also returns the offsets by reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:67,load,loads,67,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,['load'],"['loading', 'loads']"
Performance,"/// This is used for computing addresses like this:; ///; /// ldr x1, [x2, x3, lsl #3]; ///; /// Where x2 is the base register, and x3 is an offset register. The shift-left; /// is a constant value specific to this load instruction. That is, we'll never; /// see anything other than a 3 here (which corresponds to the size of the; /// element being loaded.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:215,load,load,215,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,2,['load'],"['load', 'loaded']"
Performance,"/// This is used to represent a portion of an LLVM function in a low-level; /// Data Dependence DAG representation suitable for instruction selection.; /// This DAG is constructed as the first step of instruction selection in order; /// to allow implementation of machine specific optimizations; /// and code simplifications.; ///; /// The representation used by the SelectionDAG is a target-independent; /// representation, which has some similarities to the GCC RTL representation,; /// but is significantly more simple, powerful, and is a graph form instead of a; /// linear form.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:281,optimiz,optimizations,281,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['optimiz'],['optimizations']
Performance,"/// This lowering tries to look for G_PTR_ADD instructions and then converts; /// them to a standard G_ADD with a COPY on the source.; ///; /// The motivation behind this is to expose the add semantics to the imported; /// tablegen patterns. We shouldn't need to check for uses being loads/stores,; /// because the selector works bottom up, uses before defs. By the time we; /// end up trying to select a G_PTR_ADD, we should have already attempted to; /// fold this into addressing modes and were therefore unsuccessful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:284,load,loads,284,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['load'],['loads']
Performance,/// This map keeps cache of llvm::Types and maps clang::Type to; /// corresponding llvm::Type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h:19,cache,cache,19,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h,1,['cache'],['cache']
Performance,"/// This map stores the cached results of doing a pointer lookup at the; /// bottom of a block.; ///; /// The key of this map is the pointer+isload bit, the value is a list of; /// <bb->result> mappings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:24,cache,cached,24,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['cache'],['cached']
Performance,"/// This method allocates a block of memory that is suitable for loading; /// dynamically generated code (e.g. JIT). An attempt to allocate; /// \p NumBytes bytes of virtual memory is made.; /// \p NearBlock may point to an existing allocation in which case; /// an attempt is made to allocate more memory near the existing block.; /// The actual allocated address is not guaranteed to be near the requested; /// address.; /// \p Flags is used to set the initial protection flags for the block; /// of the memory.; /// \p EC [out] returns an object describing any error that occurs.; ///; /// This method may allocate more than the number of bytes requested. The; /// actual number of bytes allocated is indicated in the returned; /// MemoryBlock.; ///; /// The start of the allocated block must be aligned with the; /// system allocation granularity (64K on Windows, page size on Linux).; /// If the address following \p NearBlock is not so aligned, it will be; /// rounded up to the next allocation granularity boundary.; ///; /// \r a non-null MemoryBlock if the function was successful,; /// otherwise a null MemoryBlock is with \p EC describing the error.; ///; /// Allocate mapped memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h:65,load,loading,65,interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,1,['load'],['loading']
Performance,"/// This method checks the availability of the load/store buffers.; ///; /// Returns LSU_AVAILABLE if there are enough load/store queue entries to; /// accomodate instruction IR. By default, LSU_AVAILABLE is returned if IR is; /// not a memory operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:47,load,load,47,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,3,"['load', 'queue']","['load', 'queue']"
Performance,"/// This method clones the current Program and performs a series of cleanups; /// intended to get rid of extra cruft on the module. If the; /// MayModifySemantics argument is true, then the cleanups is allowed to; /// modify how the code behaves.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:47,perform,performs,47,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['perform'],['performs']
Performance,"/// This method is called after an object has been loaded into memory but; /// before relocations are applied to the loaded sections. The object load; /// may have been initiated by MCJIT to resolve an external symbol for another; /// object that is being finalized. In that case, the object about which; /// the memory manager is being notified will be finalized immediately after; /// the memory manager returns from this call.; ///; /// Memory managers which are preparing code for execution in an external; /// address space can use this call to remap the section addresses for the; /// newly loaded object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h:51,load,loaded,51,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h,4,['load'],"['load', 'loaded']"
Performance,/// This method is called after an object has been loaded into memory but; /// before relocations are applied to the loaded sections.; ///; /// Memory managers which are preparing code for execution in an external; /// address space can use this call to remap the section addresses for the; /// newly loaded object.; ///; /// For clients that do not need access to an ExecutionEngine instance this; /// method should be preferred to its cousin; /// MCJITMemoryManager::notifyObjectLoaded as this method is compatible with; /// ORC JIT stacks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:51,load,loaded,51,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,3,['load'],['loaded']
Performance,/// This method is called by the ExecuteStage at the end of each cycle to; /// identify bottlenecks caused by data dependencies. Vector RegDeps is; /// populated by instructions that were not issued because of unsolved; /// register dependencies. Vector MemDeps is populated by instructions that; /// were not issued because of unsolved memory dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:88,bottleneck,bottlenecks,88,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['bottleneck'],['bottlenecks']
Performance,"/// This method is called when object loading is complete and section page; /// permissions can be applied. It is up to the memory manager implementation; /// to decide whether or not to act on this method. The memory manager will; /// typically allocate all sections as read-write and then apply specific; /// permissions when this method is called. Code sections cannot be executed; /// until this function has been called. In addition, any cache coherency; /// operations needed to reliably use the memory are also performed.; ///; /// Returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:38,load,loading,38,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,3,"['cache', 'load', 'perform']","['cache', 'loading', 'performed']"
Performance,"/// This method is similar to getUnderlyingObject except that it can; /// look through phi and select instructions and return multiple objects.; ///; /// If LoopInfo is passed, loop phis are further analyzed. If a pointer; /// accesses different objects in each iteration, we don't look through the; /// phi node. E.g. consider this loop nest:; ///; /// int **A;; /// for (i); /// for (j) {; /// A[i][j] = A[i-1][j] * B[j]; /// }; ///; /// This is transformed by Load-PRE to stash away A[i] for the next iteration; /// of the outer loop:; ///; /// Curr = A[0]; // Prev_0; /// for (i: 1..N) {; /// Prev = Curr; // Prev = PHI (Prev_0, Curr); /// Curr = A[i];; /// for (j: 0..N) {; /// Curr[j] = Prev[j] * B[j]; /// }; /// }; ///; /// Since A[i] and A[i-1] are independent pointers, getUnderlyingObjects; /// should not assume that Curr and Prev share the same underlying object thus; /// it shouldn't look through the phi above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:463,Load,Load-PRE,463,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['Load'],['Load-PRE']
Performance,"/// This method is typically called in contexts where we can't generate; /// side-effects, like in __builtin_dynamic_object_size. When finding; /// expressions, only choose those that have either already been emitted or can; /// be loaded without side-effects.; ///; /// - \p FAMDecl: the \p Decl for the flexible array member. It may not be; /// within the top-level struct.; /// - \p CountDecl: must be within the same non-anonymous struct as \p FAMDecl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:232,load,loaded,232,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['load'],['loaded']
Performance,/// This method is used when -debug is specified to verify that cache arrays; /// are properly kept sorted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:64,cache,cache,64,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['cache'],['cache']
Performance,"/// This method must be implemented by targets that; /// set the M_CONVERTIBLE_TO_3_ADDR flag. When this flag is set, the target; /// may be able to convert a two-address instruction into a true; /// three-address instruction on demand. This allows the X86 target (for; /// example) to convert ADD and SHL instructions into LEA instructions if they; /// would require register copies due to two-addressness.; ///; /// This method returns a null pointer if the transformation cannot be; /// performed, otherwise it returns the new instruction.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:490,perform,performed,490,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['perform'],['performed']
Performance,"/// This method must be implemented by targets that; /// set the M_CONVERTIBLE_TO_3_ADDR flag. When this flag is set, the target; /// may be able to convert a two-address instruction into one or more true; /// three-address instructions on demand. This allows the X86 target (for; /// example) to convert ADD and SHL instructions into LEA instructions if they; /// would require register copies due to two-addressness.; ///; /// This method returns a null pointer if the transformation cannot be; /// performed, otherwise it returns the last new instruction.; ///; /// If \p LIS is not nullptr, the LiveIntervals info should be updated for; /// replacing \p MI with new instructions, even though this function does not; /// remove MI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:501,perform,performed,501,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['perform'],['performed']
Performance,/// This method returns the constant pool value that will be loaded by LD.; /// NOTE: You must check for implicit extensions of the constant by LD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:61,load,loaded,61,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['loaded']
Performance,"/// This method will be invoked for all target nodes and for any; /// target-independent nodes that the target has registered with invoke it; /// for.; ///; /// The semantics are as follows:; /// Return Value:; /// SDValue.Val == 0 - No change was made; /// SDValue.Val == N - N was replaced, is dead, and is already handled.; /// otherwise - N should be replaced by the returned Operand.; ///; /// In addition, methods provided by DAGCombinerInfo may be used to perform; /// more complex transformations.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:463,perform,perform,463,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['perform']
Performance,"/// This module hook is called after linking (regular LTO) or loading; /// (ThinLTO) the module, before modifying it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:62,load,loading,62,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['load'],['loading']
Performance,/// This module hook is called after optimization is complete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:37,optimiz,optimization,37,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['optimiz'],['optimization']
Performance,"/// This occurrence is an exact match and can be renamed automatically.; ///; /// Note:; /// Symbol occurrences in macro arguments that expand to different; /// declarations get marked as exact matches, and thus the renaming engine; /// will rename them e.g.:; ///; /// \code; /// #define MACRO(x) x + ns::x; /// int foo(int var) {; /// return MACRO(var); // var is renamed automatically here when; /// // either var or ns::var is renamed.; /// };; /// \endcode; ///; /// The user will have to fix their code manually after performing such a; /// rename.; /// FIXME: The rename verifier should notify user about this issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolOccurrences.h:524,perform,performing,524,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolOccurrences.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Rename/SymbolOccurrences.h,1,['perform'],['performing']
Performance,"/// This optimization identifies DIV instructions in a BB that can be; /// profitably bypassed and carried out with a shorter, faster divide.; ///; /// This optimization may add basic blocks immediately after BB; for obvious; /// reasons, you shouldn't pass those blocks to bypassSlowDivision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h:9,optimiz,optimization,9,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h,2,['optimiz'],['optimization']
Performance,"/// This optimization identifies DIV instructions that can be; /// profitably bypassed and carried out with a shorter, faster divide.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:9,optimiz,optimization,9,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimization']
Performance,"/// This optimization identifies DIV/REM instructions in a BB that can be; /// profitably bypassed and carried out with a shorter, faster divide.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:9,optimiz,optimization,9,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,1,['optimiz'],['optimization']
Performance,/// This overload provides a more efficient implementation of; /// FindAvailableLoadedValue() for the case where we are not interested in; /// finding the closest clobbering instruction if no available load is found.; /// This overload cannot be used to scan across multiple blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:202,load,load,202,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,1,['load'],['load']
Performance,"/// This pair is used when caching information for a block.; ///; /// If the pointer is null, the cache value is not a full query that starts; /// at the specified block. If non-null, the bool indicates whether or not; /// the contents of the block was skipped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:98,cache,cache,98,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['cache'],['cache']
Performance,/// This pass applies profiling information to insert cache prefetches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:54,cache,cache,54,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h,1,['cache'],['cache']
Performance,/// This pass combines interleaved loads into a pattern detectable by; /// InterleavedAccessPass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:35,load,loads,35,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['load'],['loads']
Performance,"/// This pass computes, caches, and vends lazy value constraint information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:24,cache,caches,24,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,1,['cache'],['caches']
Performance,"/// This pass lowers the \@llvm.load.relative and \@llvm.objc.* intrinsics to; /// instructions. This is unsafe to do earlier because a pass may combine the; /// constant initializer into the load, which may result in an overflowing; /// evaluation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:32,load,load,32,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,2,['load'],['load']
Performance,/// This pass optimizes arithmetic based on knowledge that is only used by; /// a reduction sequence and is therefore safe to reassociate in interesting; /// ways.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:14,optimiz,optimizes,14,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h,1,['optimiz'],['optimizes']
Performance,/// This pass perform post-ra machine sink for COPY instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,perform,perform,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['perform']
Performance,/// This pass performs function-level constant propagation and merging.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SCCP.h:14,perform,performs,14,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SCCP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SCCP.h,1,['perform'],['performs']
Performance,/// This pass performs instruction combining using trace metrics to estimate; /// critical-path and resource depth.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,perform,performs,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,/// This pass performs loop invariant code motion on machine instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,perform,performs,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,/// This pass performs loop invariant code motion on machine instructions.; /// This variant works before register allocation. \see MachineLICMID.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,perform,performs,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,/// This pass performs outlining on machine instructions directly before; /// printing assembly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,perform,performs,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,/// This pass performs software pipelining on machine instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,perform,performs,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,/// This pass performs the global (interprocedural) stack safety analysis (new; /// pass manager).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:14,perform,performs,14,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,1,['perform'],['performs']
Performance,/// This pass performs the global (interprocedural) stack safety analysis; /// (legacy pass manager).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:14,perform,performs,14,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,1,['perform'],['performs']
Performance,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:9,perform,performs,9,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['perform'],['performs']
Performance,"/// This performs an expansion of the integer result for a fixed point; /// multiplication. The default expansion performs rounding down towards; /// negative infinity, though targets that do care about rounding should specify; /// a target hook for rounding and provide their own expansion or lowering of; /// fixed point multiplication to be consistent with rounding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:9,perform,performs,9,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,2,['perform'],['performs']
Performance,"/// This performs customized parsing of pass name with parameters.; ///; /// We do not need parametrization of passes in textual pipeline very often,; /// yet on a rare occasion ability to specify parameters right there can be; /// useful.; ///; /// \p Name - parameterized specification of a pass from a textual pipeline; /// is a string in a form of :; /// PassName '<' parameter-list '>'; ///; /// Parameter list is being parsed by the parser callable argument, \p Parser,; /// It takes a string-ref of parameters and returns either StringError or a; /// parameter list in a form of a custom parameters type, all wrapped into; /// Expected<> template class.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:9,perform,performs,9,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,1,['perform'],['performs']
Performance,/// This performs the main chunk of the work of cloning the loops for; /// the partitions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:9,perform,performs,9,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['perform'],['performs']
Performance,"/// This placement form of operator new[] uses the ASTContext's allocator for; /// obtaining memory.; ///; /// We intentionally avoid using a nothrow specification here so that the calls; /// to this operator will not perform a null check on the result -- the; /// underlying allocator never returns null pointers.; ///; /// Usage looks like this (assuming there's an ASTContext 'Context' in scope):; /// @code; /// // Default alignment (8); /// char *data = new (Context) char[10];; /// // Specific alignment; /// char *data = new (Context, 4) char[10];; /// @endcode; /// Memory allocated through this placement new[] operator does not need to be; /// explicitly freed, as ASTContext will free all of this memory when it gets; /// destroyed. Please note that you cannot use delete on the pointer.; ///; /// @param Bytes The number of bytes to allocate. Calculated by the compiler.; /// @param C The ASTContext that provides the allocator.; /// @param Alignment The alignment of the allocated memory (if the underlying; /// allocator supports it).; /// @return The allocated memory. Could be nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:218,perform,perform,218,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['perform'],['perform']
Performance,/// This producer encapsulates the logic for loading a File-backed; /// RecordProducer hidden behind a DataExtractor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h:45,load,loading,45,interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FDRRecordProducer.h,1,['load'],['loading']
Performance,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:179,perform,perform,179,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,1,['perform'],['perform']
Performance,"/// This record is the information kept for each (value, is load) pair.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:60,load,load,60,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['load'],['load']
Performance,"/// This represents '#pragma omp loop' directive.; ///; /// \code; /// #pragma omp loop private(a,b) binding(parallel) order(concurrent); /// \endcode; /// In this example directive '#pragma omp loop' has; /// clauses 'private' with the variables 'a' and 'b', 'binding' with; /// modifier 'parallel' and 'order(concurrent).; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:125,concurren,concurrent,125,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,2,['concurren'],['concurrent']
Performance,"/// This represents '#pragma omp parallel loop' directive.; ///; /// \code; /// #pragma omp parallel loop private(a,b) order(concurrent); /// \endcode; /// In this example directive '#pragma omp parallel loop' has; /// clauses 'private' with the variables 'a' and 'b', and order(concurrent).; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:125,concurren,concurrent,125,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,2,['concurren'],['concurrent']
Performance,"/// This represents '#pragma omp target parallel loop' directive.; ///; /// \code; /// #pragma omp target parallel loop private(a,b) order(concurrent); /// \endcode; /// In this example directive '#pragma omp target parallel loop' has; /// clauses 'private' with the variables 'a' and 'b', and order(concurrent).; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:139,concurren,concurrent,139,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,2,['concurren'],['concurrent']
Performance,"/// This represents '#pragma omp target teams loop' directive.; ///; /// \code; /// #pragma omp target teams loop private(a,b) order(concurrent); /// \endcode; /// In this example directive '#pragma omp target teams loop' has; /// clauses 'private' with the variables 'a' and 'b', and order(concurrent).; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:133,concurren,concurrent,133,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,2,['concurren'],['concurrent']
Performance,"/// This represents '#pragma omp teams loop' directive.; ///; /// \code; /// #pragma omp teams loop private(a,b) order(concurrent); /// \endcode; /// In this example directive '#pragma omp teams loop' has; /// clauses 'private' with the variables 'a' and 'b', and order(concurrent).; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:119,concurren,concurrent,119,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,2,['concurren'],['concurrent']
Performance,/// This represents 'order' clause in the '#pragma omp ...' directive.; ///; /// \code; /// #pragma omp simd order(concurrent); /// \endcode; /// In this example directive '#pragma omp parallel' has simple 'order'; /// clause with kind 'concurrent'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:115,concurren,concurrent,115,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,2,['concurren'],['concurrent']
Performance,/// This represents 'safelen' clause in the '#pragma omp ...'; /// directive.; ///; /// \code; /// #pragma omp simd safelen(4); /// \endcode; /// In this example directive '#pragma omp simd' has clause 'safelen'; /// with single expression '4'.; /// If the safelen clause is used then no two iterations executed; /// concurrently with SIMD instructions can have a greater distance; /// in the logical iteration space than its value. The parameter of; /// the safelen clause must be a constant positive integer expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:317,concurren,concurrently,317,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['concurren'],['concurrently']
Performance,/// This represents 'simdlen' clause in the '#pragma omp ...'; /// directive.; ///; /// \code; /// #pragma omp simd simdlen(4); /// \endcode; /// In this example directive '#pragma omp simd' has clause 'simdlen'; /// with single expression '4'.; /// If the 'simdlen' clause is used then it specifies the preferred number of; /// iterations to be executed concurrently. The parameter of the 'simdlen'; /// clause must be a constant positive integer expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:355,concurren,concurrently,355,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['concurren'],['concurrently']
Performance,"/// This represents a section on a Mach-O system (used by Mac OS X). On a Mac; /// system, these are also described in /usr/include/mach-o/loader.h.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSectionMachO.h:139,load,loader,139,interpreter/llvm-project/llvm/include/llvm/MC/MCSectionMachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSectionMachO.h,1,['load'],['loader']
Performance,"/// This represents the last location of a ""#pragma clang optimize off""; /// directive if such a directive has not been closed by an ""on"" yet. If; /// optimizations are currently ""on"", this is set to an invalid location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:58,optimiz,optimize,58,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['optimiz'],"['optimizations', 'optimize']"
Performance,"/// This struct is equivalent to codeview::PublicSym32, but it has been; /// optimized for size to speed up bulk serialization and sorting operations; /// during PDB writing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/GSIStreamBuilder.h:77,optimiz,optimized,77,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/GSIStreamBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/GSIStreamBuilder.h,1,['optimiz'],['optimized']
Performance,"/// This struct pack the shape and tile data together for user. We suggest; /// initializing the struct as early as possible, because compiler depends; /// on the shape information to do configure. The constant value is preferred; /// for optimization by compiler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:239,optimiz,optimization,239,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h,1,['optimiz'],['optimization']
Performance,"/// This struct represents the registers (physical or virtual); /// that a particular set of values is assigned, and the type information about; /// the value. The most common situation is to represent one value at a time,; /// but struct or array values are handled element-wise as multiple values. The; /// splitting of aggregates is performed recursively, so that we never have; /// aggregate-typed registers. The values at this point do not necessarily have; /// legal types, so each value may require one or more registers of some legal; /// type.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:336,perform,performed,336,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,1,['perform'],['performed']
Performance,"/// This structure is used to memoize nodes, automatically performing; /// CSE with existing nodes when a duplicate is requested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:59,perform,performing,59,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['perform'],['performing']
Performance,/// This structure is used to record entries in our framework cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:62,cache,cache,62,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['cache'],['cache']
Performance,/// This subclass accepts loads from stacks and constant loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:26,load,loads,26,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,2,['load'],['loads']
Performance,"/// This test shows how push-pull is unsuited for load balancing; messages are just sent to the first available pull; /// socket without any dynamic load balancing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx:50,load,load,50,roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx,2,['load'],['load']
Performance,"/// This test tries to see whether push-pull can be made to work as a bit of a load balancer, using a low HWM at the; /// receiver",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx:79,load,load,79,roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ_load_balancing.cxx,1,['load'],['load']
Performance,/// This type defines the callback to add a pre-existing file (e.g. in a cache).; ///; /// Buffer callbacks must be thread safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h:73,cache,cache,73,interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,1,['cache'],['cache']
Performance,"/// This type represents a sample identifier, to be used in conjunction with RDataFrame features such as; /// \ref ROOT::RDF::RInterface< Proxied, DS_t >::DefinePerSample ""DefinePerSample()"" and per-sample callbacks.; ///; /// When the input data comes from a TTree, the string representation of RSampleInfo (which is returned by AsString(); /// and that can be queried e.g. with Contains()) is of the form ""<filename>/<treename>"".; ///; /// In multi-thread runs, different tasks might process different entry ranges of the same sample,; /// so RSampleInfo also provides methods to inspect which part of a sample is being taken into consideration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx:445,multi-thread,multi-thread,445,tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx,1,['multi-thread'],['multi-thread']
Performance,"/// This virtual key function only exists to limit the emission of debug info; /// describing the Sema class. GCC and Clang only emit debug info for a class; /// with a vtable when the vtable is emitted. Sema is final and not; /// polymorphic, but the debug info size savings are so significant that it is; /// worth adding a vtable just to take advantage of this optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:364,optimiz,optimization,364,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['optimiz'],['optimization']
Performance,"/// This visitor recursively visits a SCEV expression and re-writes it.; /// The result from each visit is cached, so it will return the same; /// SCEV for the same input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:107,cache,cached,107,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,1,['cache'],['cached']
Performance,/// This would only be true if optimization are enabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:31,optimiz,optimization,31,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,1,['optimiz'],['optimization']
Performance,/// Three-way bool to track a cached value. Unknown is possible if this node; /// has an unexpanded parameter pack below it that may affect this cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h:30,cache,cached,30,interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,2,['cache'],"['cache', 'cached']"
Performance,/// Threshold to use when the caller is optimized for minsize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:40,optimiz,optimized,40,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,1,['optimiz'],['optimized']
Performance,/// Threshold to use when the caller is optimized for size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:40,optimiz,optimized,40,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,1,['optimiz'],['optimized']
Performance,"/// Thresholds to tune inline cost analysis. The inline cost analysis decides; /// the condition to apply a threshold and applies it. Otherwise,; /// DefaultThreshold is used. If a threshold is Optional, it is applied only; /// when it has a valid value. Typically, users of inline cost analysis; /// obtain an InlineParams object through one of the \c getInlineParams methods; /// and pass it to \c getInlineCost. Some specialized versions of inliner; /// (such as the pre-inliner) might have custom logic to compute \c InlineParams; /// object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:18,tune,tune,18,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,1,['tune'],['tune']
Performance,"/// To avoid stack clash, allocation is performed by block and each block is; /// probed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:40,perform,performed,40,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['perform'],['performed']
Performance,"/// To facilitate writing xml, when not; /// specified, files and paths default; /// to these cached values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/RooStats/HistFactory/ConfigParser.h:94,cache,cached,94,roofit/histfactory/inc/RooStats/HistFactory/ConfigParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/RooStats/HistFactory/ConfigParser.h,1,['cache'],['cached']
Performance,"/// To mitigate LVI, every instruction that performs a load can be followed by; /// an LFENCE instruction to squash any potential mis-speculation. There are; /// some instructions that require additional considerations, and may requre; /// manual mitigation. For more details, see:; /// https://software.intel.com/security-software-guidance/insights/deep-dive-load-value-injection; ///; /// Returns `true` if a mitigation was applied or warning was emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:44,perform,performs,44,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,3,"['load', 'perform']","['load', 'load-value-injection', 'performs']"
Performance,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:770,cache,cached,770,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['cache'],['cached']
Performance,"/// Top-level driver for each loop: find store->load forwarding; /// candidates, add run-time checks and perform transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:48,load,load,48,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,2,"['load', 'perform']","['load', 'perform']"
Performance,/// Toplevel function to check the return type based on the target calling; /// convention. \return True if the return value of \p MF can be returned; /// without performing sret demotion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:163,perform,performing,163,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,1,['perform'],['performing']
Performance,/// Total byte size of inlined functions. This is the total number of bytes; /// for the top inline functions within concrete functions. This can help; /// tune the inline settings when compiling to match user expectations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:156,tune,tune,156,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,1,['tune'],['tune']
Performance,"/// Total size of modules, in bits, currently loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:46,load,loaded,46,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// Trace the predicate state through a call.; ///; /// There are several layers of this needed to handle the full complexity of; /// calls.; ///; /// First, we need to send the predicate state into the called function. We do; /// this by merging it into the high bits of the stack pointer.; ///; /// For tail calls, this is all we need to do.; ///; /// For calls where we might return and resume the control flow, we need to; /// extract the predicate state from the high bits of the stack pointer after; /// control returns from the called function.; ///; /// We also need to verify that we intended to return to this location in the; /// code. An attacker might arrange for the processor to mispredict the return; /// to this valid but incorrect return address in the program rather than the; /// correct one. See the paper on this attack, called ""ret2spec"" by the; /// researchers, here:; /// https://christian-rossow.de/publications/ret2spec-ccs2018.pdf; ///; /// The way we verify that we returned to the correct location is by preserving; /// the expected return address across the call. One technique involves taking; /// advantage of the red-zone to load the return address from `8(%rsp)` where it; /// was left by the RET instruction when it popped `%rsp`. Alternatively, we can; /// directly save the address into a register that will be preserved across the; /// call. We compare this intended return address against the address; /// immediately following the call (the observed return address). If these; /// mismatch, we have detected misspeculation and can poison our predicate; /// state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1159,load,load,1159,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['load'],['load']
Performance,"/// Trace the predicate state through each of the blocks in the function,; /// hardening everything necessary along the way.; ///; /// We call this routine once the initial predicate state has been established; /// for each basic block in the function in the SSA updater. This routine traces; /// it through the instructions within each basic block, and for non-returning; /// blocks informs the SSA updater about the final state that lives out of the; /// block. Along the way, it hardens any vulnerable instruction using the; /// currently valid predicate state. We have to do these two things together; /// because the SSA updater only works across blocks. Within a block, we track; /// the current predicate state directly and update it as it changes.; ///; /// This operates in two passes over each block. First, we analyze the loads in; /// the block to determine which strategy will be used to harden them: hardening; /// the address or hardening the loaded value when loaded into a register; /// amenable to hardening. We have to process these first because the two; /// strategies may interact -- later hardening may change what strategy we wish; /// to use. We also will analyze data dependencies between loads and avoid; /// hardening those loads that are data dependent on a load with a hardened; /// address. We also skip hardening loads already behind an LFENCE as that is; /// sufficient to harden them against misspeculation.; ///; /// Second, we actively trace the predicate state through the block, applying; /// the hardening steps we determined necessary in the first pass as we go.; ///; /// These two passes are applied to each basic block. We operate one block at a; /// time to simplify reasoning about reachability and sequencing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:833,load,loads,833,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,7,['load'],"['load', 'loaded', 'loads']"
Performance,/// Track if the list of predicates was manipulated by one of the optimization; /// methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:66,optimiz,optimization,66,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,1,['optimiz'],['optimization']
Performance,/// Track the execution mode when codegening directives within a target; /// region. The appropriate mode (SPMD/NON-SPMD) is set on entry to the; /// target region and used by containing directives such as 'parallel'; /// to emit optimized code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h:230,optimiz,optimized,230,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h,1,['optimiz'],['optimized']
Performance,/// Track the top-level decls which appeared in an ASTUnit which was loaded; /// from a source file.; //; // FIXME: This is just an optimization hack to avoid deserializing large parts; // of a PCH file when using the Index library on an ASTUnit loaded from; // source. In the long term we should make the Index library use efficient and; // more scalable search mechanisms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:69,load,loaded,69,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,4,"['load', 'optimiz', 'scalab']","['loaded', 'optimization', 'scalable']"
Performance,/// Track whether the main file was loaded from an AST or not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:36,load,loaded,36,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['load'],['loaded']
Performance,/// Track whether this PCM is known to be good (either built or; /// successfully imported by a CompilerInstance/ASTReader using this; /// cache).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h:139,cache,cache,139,interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h,1,['cache'],['cache']
Performance,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:291,load,loaded,291,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['load'],['loaded']
Performance,/// Tracks register operand latency in cycles.; ///; /// A read may be dependent on more than one write. This occurs when some; /// writes only partially update the register associated to this read.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:28,latency,latency,28,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['latency'],['latency']
Performance,/// Tracks the state we can represent the loads in the given sequence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:42,load,loads,42,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['loads']
Performance,"/// Tracks whether the accesses may be on different cycle iterations.; ///; /// When interpret ""Value"" pointer equality as value equality we need to make; /// sure that the ""Value"" is not part of a cycle. Otherwise, two uses could; /// come from different ""iterations"" of a cycle and see different values for; /// the same ""Value"" pointer.; ///; /// The following example shows the problem:; /// %p = phi(%alloca1, %addr2); /// %l = load %ptr; /// %addr1 = gep, %alloca2, 0, %l; /// %addr2 = gep %alloca2, 0, (%l + 1); /// alias(%p, %addr1) -> MayAlias !; /// store %l, ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:433,load,load,433,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['load'],['load']
Performance,/// Transform (zext icmp) to bitwise / integer operations in order to; /// eliminate it.; ///; /// \param ICI The icmp of the (zext icmp) pair we are interested in.; /// \parem CI The zext of the (zext icmp) pair we are interested in.; ///; /// \return null if the transformation cannot be performed. If the; /// transformation can be performed the new instruction that replaces the; /// (zext icmp) pair will be returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:290,perform,performed,290,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,2,['perform'],['performed']
Performance,/// Transform a load and a deinterleave intrinsic into target specific; /// instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,1,['load'],['load']
Performance,/// Transform an interleaved load into target specific intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:29,load,load,29,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,1,['load'],['load']
Performance,"/// Transform physical registers into virtual registers, and generate load; /// operations for argument places on the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp:70,load,load,70,interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,1,['load'],['load']
Performance,"/// Transform the given list of expressions.; ///; /// This routine transforms a list of expressions by invoking; /// \c TransformExpr() for each subexpression. However, it also provides; /// support for variadic templates by expanding any pack expansions (if the; /// derived class permits such expansion) along the way. When pack expansions; /// are present, the number of outputs may not equal the number of inputs.; ///; /// \param Inputs The set of expressions to be transformed.; ///; /// \param NumInputs The number of expressions in \c Inputs.; ///; /// \param IsCall If \c true, then this transform is being performed on; /// function-call arguments, and any arguments that should be dropped, will; /// be.; ///; /// \param Outputs The transformed input expressions will be added to this; /// vector.; ///; /// \param ArgChanged If non-NULL, will be set \c true if any argument changed; /// due to transformation.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:617,perform,performed,617,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performed']
Performance,/// Transforms a template type parameter type by performing; /// substitution of the corresponding template type argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:49,perform,performing,49,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['perform'],['performing']
Performance,/// Translate an LLVM load instruction into generic IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h:22,load,load,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,1,['load'],['load']
Performance,/// Tries to detect a compilation database location and load it.; ///; /// Looks for a compilation database in all parent paths of file 'SourceFile'; /// by calling loadFromDirectory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:56,load,load,56,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,2,['load'],"['load', 'loadFromDirectory']"
Performance,/// Tries to detect a compilation database location and load it.; ///; /// Looks for a compilation database in directory 'SourceDir' and all; /// its parent paths by calling loadFromDirectory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:56,load,load,56,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,2,['load'],"['load', 'loadFromDirectory']"
Performance,"/// Tries to find the page corresponding to column and index in the cache. If the page is found, its reference; /// counter is increased",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx:68,cache,cache,68,tree/ntuple/v7/inc/ROOT/RPagePool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx,1,['cache'],['cache']
Performance,"/// Tries to hide the latency of runtime calls that involve host to; /// device memory transfers by splitting them into their ""issue"" and ""wait""; /// versions. The ""issue"" is moved upwards as much as possible. The ""wait"" is; /// moved downards as much as possible. The ""issue"" issues the memory transfer; /// asynchronously, returning a handle. The ""wait"" waits in the returned; /// handle for the memory transfer to finish.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:22,latency,latency,22,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['latency'],['latency']
Performance,/// Tries to load options from configuration files.; ///; /// \returns true if error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:13,load,load,13,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['load'],['load']
Performance,/// Tries to load options from default configuration files (deduced from; /// executable filename).; ///; /// \returns true if error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:13,load,load,13,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['load'],['load']
Performance,"/// Trigger a recomputation of the cached weight sums. Meant for use by RooFit; /// dataset converter functions such as the NumPy converter functions; /// implemented as pythonizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx:35,cache,cached,35,roofit/roofitcore/src/RooVectorDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx,1,['cache'],['cached']
Performance,"/// Trigger the invalidation of some other analysis pass if not already; /// handled and return whether it was in fact invalidated.; ///; /// This is expected to be called from within a given analysis result's \c; /// invalidate method to trigger a depth-first walk of all inter-analysis; /// dependencies. The same \p IR unit and \p PA passed to that result's \c; /// invalidate method should in turn be provided to this routine.; ///; /// The first time this is called for a given analysis pass, it will call; /// the corresponding result's \c invalidate method. Subsequent calls will; /// use a cache of the results of that initial call. It is an error to form; /// cyclic dependencies between analysis results.; ///; /// This returns true if the given analysis's result is invalid. Any; /// dependecies on it will become invalid as a result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:598,cache,cache,598,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['cache']
Performance,/// True if comments are already loaded from ExternalASTSource.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:33,load,loaded,33,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['load'],['loaded']
Performance,"/// True if loads don't alias with stores.; ///; /// By default, the LS unit assumes that loads and stores don't alias with; /// eachother. If this field is set to false, then loads are always assumed to; /// alias with stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:12,load,loads,12,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,3,['load'],['loads']
Performance,/// True if optimizing for code size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:12,optimiz,optimizing,12,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,1,['optimiz'],['optimizing']
Performance,/// True if the cache (i.e. the bitfields here starting with; /// 'Cache') is valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:16,cache,cache,16,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,/// True if the call must be tail call optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:39,optimiz,optimized,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,1,['optimiz'],['optimized']
Performance,/// True if the call passes all target-independent checks for tail call; /// optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:77,optimiz,optimization,77,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,1,['optimiz'],['optimization']
Performance,/// True if the global is ever loaded. If the global isn't ever loaded it; /// can be deleted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h:31,load,loaded,31,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h,2,['load'],['loaded']
Performance,/// True if the macro directive was loaded from a PCH file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MacroInfo.h:36,load,loaded,36,interpreter/llvm-project/clang/include/clang/Lex/MacroInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MacroInfo.h,1,['load'],['loaded']
Performance,/// True if the processing cache is valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:27,cache,cache,27,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['cache'],['cache']
Performance,"/// True if the subobject was named in a manner not supported by C++11. Such; /// lvalues can still be folded, but they are not core constant expressions; /// and we cannot perform lvalue-to-rvalue conversions on them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:173,perform,perform,173,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['perform'],['perform']
Performance,"/// True if the subtarget should run the local reassignment; /// heuristic of the register allocator.; /// This heuristic may be compile time intensive, \p OptLevel provides; /// a finer grain to tune the register allocator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:196,tune,tune,196,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['tune'],['tune']
Performance,"/// True if the value passed to this parameter must undergo; /// K&R-style default argument promotion:; ///; /// C99 6.5.2.2.; /// If the expression that denotes the called function has a type; /// that does not include a prototype, the integer promotions are; /// performed on each argument, and arguments that have type float; /// are promoted to double.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:265,perform,performed,265,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['perform'],['performed']
Performance,/// True if this content cache was initially created for a source file; /// considered to be volatile (likely to change between stat and open).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:25,cache,cache,25,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['cache'],['cache']
Performance,/// True if we are optimizing for size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:19,optimiz,optimizing,19,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimizing']
Performance,"/// True when a select result is replaced by one of its operands; /// in select-icmp sequence. This will eventually result in the elimination; /// of the select.; ///; /// \param SI Select instruction; /// \param Icmp Compare instruction; /// \param SIOpd Operand that replaces the select; ///; /// Notes:; /// - The replacement is global and requires dominator information; /// - The caller is responsible for the actual replacement; ///; /// Example:; ///; /// entry:; /// %4 = select i1 %3, %C* %0, %C* null; /// %5 = icmp eq %C* %4, null; /// br i1 %5, label %9, label %7; /// ...; /// ; <label>:7 ; preds = %entry; /// %8 = getelementptr inbounds %C* %4, i64 0, i32 0; /// ...; ///; /// can be transformed to; ///; /// %5 = icmp eq %C* %0, null; /// %6 = select i1 %3, i1 %5, i1 true; /// br i1 %6, label %9, label %7; /// ...; /// ; <label>:7 ; preds = %entry; /// %8 = getelementptr inbounds %C* %0, i64 0, i32 0 // replace by %0!; ///; /// Similar when the first operand of the select is a constant or/and; /// the compare is for not equal rather than equal.; ///; /// NOTE: The function is only called when the select and compare constants; /// are equal, the optimization can work only for EQ predicates. This is not a; /// major restriction since a NE compare should be 'normalized' to an equal; /// compare, which usually happens in the combiner and test case; /// select-cmp-br.ll checks for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:1169,optimiz,optimization,1169,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['optimiz'],['optimization']
Performance,"/// Try and optimize BUILD_VECTORs with ""dominant values"" - these are values; /// which constitute a large proportion of the elements. In such cases we can; /// splat a vector with the dominant element and make up the shortfall with; /// INSERT_VECTOR_ELTs. Returns SDValue if not profitable.; /// Note that this includes vectors of 2 elements by association. The; /// upper-most element is the ""dominant"" one, allowing us to use a splat to; /// ""insert"" the upper element, and an insert of the lower element at position; /// 0, which improves codegen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:12,optimiz,optimize,12,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['optimiz'],['optimize']
Performance,"/// Try folding register operands that are defined by move immediate; /// instructions, i.e. a trivial constant folding optimization, if; /// and only if the def and use are in the same BB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:120,optimiz,optimization,120,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['optimiz'],['optimization']
Performance,"/// Try to ""correct"" a typo in the source code by finding; /// visible declarations whose names are similar to the name that was; /// present in the source code.; ///; /// \param TypoName the \c DeclarationNameInfo structure that contains; /// the name that was present in the source code along with its location.; ///; /// \param LookupKind the name-lookup criteria used to search for the name.; ///; /// \param S the scope in which name lookup occurs.; ///; /// \param SS the nested-name-specifier that precedes the name we're; /// looking for, if present.; ///; /// \param CCC A CorrectionCandidateCallback object that provides further; /// validation of typo correction candidates. It also provides flags for; /// determining the set of keywords permitted.; ///; /// \param TDG A TypoDiagnosticGenerator functor that will be used to print; /// diagnostics when the actual typo correction is attempted.; ///; /// \param TRC A TypoRecoveryCallback functor that will be used to build an; /// Expr from a typo correction candidate.; ///; /// \param MemberContext if non-NULL, the context in which to look for; /// a member access expression.; ///; /// \param EnteringContext whether we're entering the context described by; /// the nested-name-specifier SS.; ///; /// \param OPT when non-NULL, the search for visible declarations will; /// also walk the protocols in the qualified interfaces of \p OPT.; ///; /// \returns a new \c TypoExpr that will later be replaced in the AST with an; /// Expr representing the result of performing typo correction, or nullptr if; /// typo correction is not possible. If nullptr is returned, no diagnostics will; /// be emitted and it is the responsibility of the caller to emit any that are; /// needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:1524,perform,performing,1524,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['perform'],['performing']
Performance,"/// Try to add a comment on the PC-relative load.; /// For instance, in Mach-O, this is used to add annotations to instructions; /// that use C string literals, as found in __cstring.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCSymbolizer.h:44,load,load,44,interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCSymbolizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCSymbolizer.h,1,['load'],['load']
Performance,"/// Try to add a symbolic operand instead of \p Value to the MCInst.; ///; /// Instead of having a difficult to read immediate, a symbolic operand would; /// represent this immediate in a more understandable way, for instance as a; /// symbol or an offset from a symbol. Relocations can also be used to enrich; /// the symbolic expression.; /// \param Inst - The MCInst where to insert the symbolic operand.; /// \param cStream - Stream to print comments and annotations on.; /// \param Value - Operand value, pc-adjusted by the caller if necessary.; /// \param Address - Load address of the instruction.; /// \param IsBranch - Is the instruction a branch?; /// \param Offset - Byte offset of the operand inside the inst.; /// \param OpSize - Size of the operand in bytes.; /// \param InstSize - Size of the instruction in bytes.; /// \return Whether a symbolic operand was added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCSymbolizer.h:572,Load,Load,572,interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCSymbolizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCSymbolizer.h,1,['Load'],['Load']
Performance,"/// Try to calculate arithmetic and shuffle op costs for reduction intrinsics.; /// We're assuming that reduction operation are performing the following way:; ///; /// %val1 = shufflevector<n x t> %val, <n x t> %undef,; /// <n x i32> <i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef>; /// \----------------v-------------/ \----------v------------/; /// n/2 elements n/2 elements; /// %red1 = op <n x t> %val, <n x t> val1; /// After this operation we have a vector %red1 where only the first n/2; /// elements are meaningful, the second n/2 elements are undefined and can be; /// dropped. All other operations are actually working with the vector of; /// length n/2, not n, though the real vector length is still n.; /// %val2 = shufflevector<n x t> %red1, <n x t> %undef,; /// <n x i32> <i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef>; /// \----------------v-------------/ \----------v------------/; /// n/4 elements 3*n/4 elements; /// %red2 = op <n x t> %red1, <n x t> val2 - working with the vector of; /// length n/2, the resulting vector has length n/4 etc.; ///; /// The cost model should take into account that the actual length of the; /// vector is reduced on each iteration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:128,perform,performing,128,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['perform'],['performing']
Performance,"/// Try to calculate the cost of performing strict (in-order) reductions,; /// which involves doing a sequence of floating point additions in lane; /// order, starting with an initial value. For example, consider a scalar; /// initial value 'InitVal' of type float and a vector of type <4 x float>:; ///; /// Vector = <float %v0, float %v1, float %v2, float %v3>; ///; /// %add1 = %InitVal + %v0; /// %add2 = %add1 + %v1; /// %add3 = %add2 + %v2; /// %add4 = %add3 + %v3; ///; /// As a simple estimate we can say the cost of such a reduction is 4 times; /// the cost of a scalar FP addition. We can only estimate the costs for; /// fixed-width vectors here because for scalable vectors we do not know the; /// runtime number of operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:33,perform,performing,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,2,"['perform', 'scalab']","['performing', 'scalable']"
Performance,"/// Try to capture the given variable.; ///; /// \param Var The variable to capture.; ///; /// \param Loc The location at which the capture occurs.; ///; /// \param Kind The kind of capture, which may be implicit (for either a; /// block or a lambda), or explicit by-value or by-reference (for a lambda).; ///; /// \param EllipsisLoc The location of the ellipsis, if one is provided in; /// an explicit lambda capture.; ///; /// \param BuildAndDiagnose Whether we are actually supposed to add the; /// captures or diagnose errors. If false, this routine merely check whether; /// the capture can occur without performing the capture itself or complaining; /// if the variable cannot be captured.; ///; /// \param CaptureType Will be set to the type of the field used to capture; /// this variable in the innermost block or lambda. Only valid when the; /// variable can be captured.; ///; /// \param DeclRefType Will be set to the type of a reference to the capture; /// from within the current scope. Only valid when the variable can be; /// captured.; ///; /// \param FunctionScopeIndexToStopAt If non-null, it points to the index; /// of the FunctionScopeInfo stack beyond which we do not attempt to capture.; /// This is useful when enclosing lambdas must speculatively capture; /// variables that may or may not be used in certain specializations of; /// a nested generic lambda.; ///; /// \returns true if an error occurred (i.e., the variable cannot be; /// captured) and false if the capture succeeded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:610,perform,performing,610,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,/// Try to combine a load/store with a add/sub of the base pointer node into a; /// post-indexed load/store. The transformation folded the add/subtract into the; /// new indexed load/store effectively and all of its uses are redirected to the; /// new load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,load,load,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,['load'],['load']
Performance,"/// Try to convert a value of non-vector type to a vector type by converting; /// the type to the element type of the vector and then performing a splat.; /// If the language is OpenCL, we only use conversions that promote scalar; /// rank; for C, Obj-C, and C++ we allow any real scalar conversion except; /// for float->int.; ///; /// OpenCL V2.0 6.2.6.p2:; /// An error shall occur if any scalar operand type has greater rank; /// than the type of the vector element.; ///; /// \param scalar - if non-null, actually perform the conversions; /// \return true if the operation fails (but without diagnosing the failure)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:134,perform,performing,134,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['perform'],"['perform', 'performing']"
Performance,"/// Try to convert a wide shuffle of concatenated vectors into 2 narrow shuffles; /// followed by concatenation. Narrow vector ops may have better performance; /// than wide ops, and this can unlock further narrowing of other vector ops.; /// Targets can invert this transform later if it is not profitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:147,perform,performance,147,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['perform'],['performance']
Performance,"/// Try to create a COFFVCRuntimeBootstrapper instance. An optional; /// RuntimePath can be given to specify the location of directory that; /// contains all vc runtime library files such as ucrt.lib and msvcrt.lib. If; /// no path was given, it will try to search the MSVC toolchain and Windows; /// SDK installation and use the found library files automatically.; ///; /// Note that depending on the build setting, a different library; /// file must be used. In general, if vc runtime was statically linked to the; /// object file that is to be jit-linked, LoadStaticVCRuntime and; /// InitializeStaticVCRuntime must be used with libcmt.lib, libucrt.lib,; /// libvcruntimelib. If vc runtime was dynamically linked LoadDynamicVCRuntime; /// must be used along with msvcrt.lib, ucrt.lib, vcruntime.lib.; ///; /// More information is on:; /// https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/COFFVCRuntimeSupport.h:559,Load,LoadStaticVCRuntime,559,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/COFFVCRuntimeSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/COFFVCRuntimeSupport.h,2,['Load'],"['LoadDynamicVCRuntime', 'LoadStaticVCRuntime']"
Performance,/// Try to elide argument copies from memory into a local alloca. Succeeds if; /// ArgVal is a load from a suitable fixed stack object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:95,load,load,95,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['load'],['load']
Performance,"/// Try to emit a reference to the given value without producing it as; /// an l-value. This is just an optimization, but it avoids us needing; /// to emit global copies of variables if they're named without triggering; /// a formal use in a context where we can't emit a direct reference to them,; /// for instance if a block or lambda or a member of a local class uses a; /// const int variable or constexpr variable from an enclosing function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:104,optimiz,optimization,104,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['optimiz'],['optimization']
Performance,"/// Try to find existing copies of the incoming values in stack slots used for; /// statepoint spilling. If we can find a spill slot for the incoming value,; /// mark that slot as allocated, and reuse the same slot for this safepoint.; /// This helps to avoid series of loads and stores that only serve to reshuffle; /// values on the stack between calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:270,load,loads,270,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['load'],['loads']
Performance,"/// Try to fold ((icmp X u< P) & (icmp(X & M) != M)) or ((icmp X s> -1) &; /// (icmp(X & M) != M)) into (icmp X u< M). Where P is a power of 2, M < P, and; /// M is a contiguous shifted mask starting at the right most significant zero; /// bit in P. SGT is supported as when P is the largest representable power of; /// 2, an earlier optimization converts the expression into (icmp X s> -1).; /// Parameter P supports masking using undef/poison in either scalar or vector; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:334,optimiz,optimization,334,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['optimiz'],['optimization']
Performance,/// Try to fold a build_vector that performs an 'addsub' or 'fmaddsub' or; /// 'fsubadd' operation accordingly to X86ISD::ADDSUB or X86ISD::FMADDSUB or; /// X86ISD::FMSUBADD node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,perform,performs,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['performs']
Performance,/// Try to fold load I.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,1,['load'],['load']
Performance,/// Try to fold the select into one of the operands to allow further; /// optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:74,optimiz,optimization,74,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['optimiz'],['optimization']
Performance,/// Try to interpret values loaded into registers that forward parameters; /// for \p CallMI. Store parameters with interpreted value into \p Params.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:28,load,loaded,28,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['load'],['loaded']
Performance,/// Try to load the module map file in the given directory.; ///; /// \param Dir The directory where we will look for a module map file.; /// \param IsSystem Whether this is a system header directory.; /// \param IsFramework Whether this is a framework directory.; ///; /// \returns The result of attempting to load the module map file from the; /// named directory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:11,load,load,11,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,2,['load'],['load']
Performance,/// Try to load the module map file in the given directory.; ///; /// \param DirName The name of the directory where we will look for a module; /// map file.; /// \param IsSystem Whether this is a system header directory.; /// \param IsFramework Whether this is a framework directory.; ///; /// \returns The result of attempting to load the module map file from the; /// named directory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:11,load,load,11,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,2,['load'],['load']
Performance,/// Try to locate the three instruction involved in a missed; /// load-elimination case that is due to an intervening store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:66,load,load-elimination,66,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['load'],['load-elimination']
Performance,"/// Try to lower a vector shuffle as a zero extension on any microarch.; ///; /// This routine will try to do everything in its power to cleverly lower; /// a shuffle which happens to match the pattern of a zero extend. It doesn't; /// check for the profitability of this lowering, it tries to aggressively; /// match this pattern. It will use all of the micro-architectural details it; /// can to emit an efficient lowering. It handles both blends with all-zero; /// inputs to explicitly zero-extend and undef-lanes (sometimes undef due to; /// masking out later).; ///; /// The reason we have dedicated lowering for zext-style shuffles is that they; /// are both incredibly common and often quite performance sensitive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:699,perform,performance,699,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['performance']
Performance,"/// Try to match and generate: SMLAD, SMLADX - Signed Multiply Accumulate; /// Dual performs two signed 16x16-bit multiplications. It adds the; /// products to a 32-bit accumulate operand. Optionally, the instruction can; /// exchange the halfwords of the second operand before performing the; /// arithmetic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:84,perform,performs,84,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,2,['perform'],"['performing', 'performs']"
Performance,/// Try to optimize a compare instruction. A compare instruction is an; /// instruction which produces AArch64::NZCV. It can be truly compare; /// instruction; /// when there are no uses of its destination register.; ///; /// The following steps are tried in order:; /// 1. Convert CmpInstr into an unconditional version.; /// 2. Remove CmpInstr if above there is an instruction producing a needed; /// condition code or an instruction which can be converted into such an; /// instruction.; /// Only comparison with zero is supported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:11,optimiz,optimize,11,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['optimiz'],['optimize']
Performance,"/// Try to optimize a phi as best as we can. Returns a SmallVector of Paths; /// that act as legal clobbers. Note that this won't return *all* clobbers.; ///; /// Phi optimization algorithm tl;dr:; /// - Find the earliest def/phi, A, we can optimize to; /// - Find if all paths from the starting memory access ultimately reach A; /// - If not, optimization isn't possible.; /// - Otherwise, walk from A to another clobber or phi, A'.; /// - If A' is a def, we're done.; /// - If A' is a phi, try to optimize it.; ///; /// A path is a series of {MemoryAccess, MemoryLocation} pairs. A path; /// terminates when a MemoryAccess that clobbers said MemoryLocation is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:11,optimiz,optimize,11,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,5,['optimiz'],"['optimization', 'optimize']"
Performance,"/// Try to optimize a sequence of instructions checking if an operation; /// on LHS and RHS overflows.; ///; /// If this overflow check is done via one of the overflow check intrinsics,; /// then CtxI has to be the call instruction calling that intrinsic. If this; /// overflow check is done by arithmetic followed by a compare, then CtxI has; /// to be the arithmetic instruction.; ///; /// If a simplification is possible, stores the simplified result of the; /// operation in OperationResult and result of the overflow check in; /// OverflowResult, and return true. If no simplification is possible,; /// returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:11,optimiz,optimize,11,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,1,['optimiz'],['optimize']
Performance,"/// Try to optimize an AutoreleaseRV with a RetainRV or UnsafeClaimRV. If the; /// optimization occurs, returns true to indicate that the caller should; /// assume the instructions are dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:11,optimiz,optimize,11,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,2,['optimiz'],"['optimization', 'optimize']"
Performance,"/// Try to optimize extending or truncating conversion instructions (like; /// zext, trunc, fptoui, uitofp) for the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:11,optimiz,optimize,11,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['optimiz'],['optimize']
Performance,/// Try to perform FMA combining on a given FADD node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,perform,perform,11,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['perform'],['perform']
Performance,"/// Try to perform FMA combining on a given FMUL node based on the distributive; /// law x * (y + 1) = x * y + x and variants thereof (commuted versions,; /// subtraction instead of addition).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,perform,perform,11,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['perform'],['perform']
Performance,/// Try to perform FMA combining on a given FSUB node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,perform,perform,11,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['perform'],['perform']
Performance,"/// Try to perform initialization of the given entity, creating a; /// record of the steps required to perform the initialization.; ///; /// The generated initialization sequence will either contain enough; /// information to diagnose; ///; /// \param S the semantic analysis object.; ///; /// \param Entity the entity being initialized.; ///; /// \param Kind the kind of initialization being performed.; ///; /// \param Args the argument(s) provided for initialization.; ///; /// \param TopLevelOfInitList true if we are initializing from an expression; /// at the top level inside an initializer list. This disallows; /// narrowing conversions in C++11 onwards.; /// \param TreatUnavailableAsInvalid true if we want to treat unavailable; /// as invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:11,perform,perform,11,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,3,['perform'],"['perform', 'performed']"
Performance,"/// Try to promote (devirtualize) a virtual call on an Alloca. Return true on; /// success.; ///; /// Look for a pattern like:; ///; /// %o = alloca %class.Impl; /// %1 = getelementptr %class.Impl, %class.Impl* %o, i64 0, i32 0, i32 0; /// store i32 (...)** bitcast (i8** getelementptr inbounds; /// ({ [3 x i8*] }, { [3 x i8*] }* @_ZTV4Impl, i64 0, inrange i32 0, i64 2); /// to i32 (...)**), i32 (...)*** %1; /// %2 = getelementptr inbounds %class.Impl, %class.Impl* %o, i64 0, i32 0; /// %3 = bitcast %class.Interface* %2 to void (%class.Interface*)***; /// %vtable.i = load void (%class.Interface*)**, void (%class.Interface*)*** %3; /// %4 = load void (%class.Interface*)*, void (%class.Interface*)** %vtable.i; /// call void %4(%class.Interface* nonnull %2); ///; /// @_ZTV4Impl = linkonce_odr dso_local unnamed_addr constant { [3 x i8*] }; /// { [3 x i8*]; /// [i8* null, i8* bitcast ({ i8*, i8*, i8* }* @_ZTI4Impl to i8*),; /// i8* bitcast (void (%class.Impl*)* @_ZN4Impl3RunEv to i8*)] }; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h:573,load,load,573,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CallPromotionUtils.h,2,['load'],['load']
Performance,"/// Try to promote memory values to scalars by sinking stores out of; /// the loop and moving loads to before the loop. We do this by looping over; /// the stores in the loop, looking for stores to Must pointers which are; /// loop invariant. It takes a set of must-alias values, Loop exit blocks; /// vector, loop exit blocks insertion point vector, PredIteratorCache,; /// LoopInfo, DominatorTree, Loop, AliasSet information for all instructions; /// of the loop and loop safety information as arguments.; /// Diagnostics is emitted via \p ORE. It returns changed status.; /// \p AllowSpeculation is whether values should be hoisted even if they are not; /// guaranteed to execute in the loop, but are safe to speculatively execute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:94,load,loads,94,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,1,['load'],['loads']
Performance,"/// Try to remove a buffer from the cache. No effect if state is Final.; ///; /// \pre state is Tentative/Final.; /// \post Tentative => ToBuild or Final => Final.; /// \return false on success, i.e. if Tentative => ToBuild.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h:36,cache,cache,36,interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h,1,['cache'],['cache']
Performance,"/// Try to remove the load by folding it to a register operand at the use.; /// We fold the load instructions if and only if the; /// def and use are in the same BB. We only look at one load and see; /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register; /// defined by the load we are trying to fold. DefMI returns the machine; /// instruction that defines FoldAsLoadDefReg, and the function returns; /// the machine instruction generated due to folding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:22,load,load,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,4,['load'],['load']
Performance,"/// Try to remove the load by folding it to a register; /// operand at the use. We fold the load instructions if load defines a virtual; /// register, the virtual register is used once in the same BB, and the; /// instructions in-between do not load or store, and have no side effects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:22,load,load,22,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,4,['load'],['load']
Performance,/// Try to replace a load which executes on each loop iteraiton with Phi; /// translation of load in preheader and load(s) in conditionally executed; /// paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:21,load,load,21,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,3,['load'],['load']
Performance,/// Try to return an estimate cost factor that can be used as a multiplier; /// when scalarizing an operation for a vector with ElementCount \p VF.; /// For scalable vectors this currently takes the most pessimistic view based; /// upon the maximum possible value for vscale.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h:157,scalab,scalable,157,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h,1,['scalab'],['scalable']
Performance,/// Try to reuse the switch table index compare. Following pattern:; /// \code; /// if (idx < tablesize); /// r = table[idx]; // table does not contain default_value; /// else; /// r = default_value;; /// if (r != default_value); /// ...; /// \endcode; /// Is optimized to:; /// \code; /// cond = idx < tablesize;; /// if (cond); /// r = table[idx];; /// else; /// r = default_value;; /// if (cond); /// ...; /// \endcode; /// Jump threading will then eliminate the second if(cond).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:260,optimiz,optimized,260,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['optimiz'],['optimized']
Performance,/// Try to scalarize vector loads feeding extractelement instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:28,load,loads,28,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['load'],['loads']
Performance,"/// Try turning a load/store into a pre-indexed load/store when the base; /// pointer is an add or subtract and it has other uses besides the load/store.; /// After the transformation, the new indexed load/store has effectively folded; /// the add/subtract in and all of its other uses are redirected to the; /// new load/store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:18,load,load,18,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,5,['load'],['load']
Performance,"/// TryConstCast - See if a const_cast from source to destination is allowed,; /// and perform it if it is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:87,perform,perform,87,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['perform'],['perform']
Performance,"/// TryImplicitConversion - Attempt to perform an implicit conversion; /// from the given expression (Expr) to the given type (ToType). This; /// function returns an implicit conversion sequence that can be used; /// to perform the initialization. Given; ///; /// void f(float f);; /// void g(int i) { f(i); }; ///; /// this routine would produce an implicit conversion sequence to; /// describe the initialization of f from i, which will be a standard; /// conversion sequence containing an lvalue-to-rvalue conversion (C++; /// 4.1) followed by a floating-integral conversion (C++ 4.9).; //; /// Note that this routine only determines how the conversion can be; /// performed; it does not actually perform the conversion. As such,; /// it will not produce any diagnostics if no conversion is available,; /// but will instead return an implicit conversion sequence of kind; /// ""BadConversion"".; ///; /// If @p SuppressUserConversions, then user-defined conversions are; /// not permitted.; /// If @p AllowExplicit, then explicit user-defined conversions are; /// permitted.; ///; /// \param AllowObjCWritebackConversion Whether we allow the Objective-C; /// writeback conversion, which allows __autoreleasing id* parameters to; /// be initialized with __strong id* or __weak id* arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:39,perform,perform,39,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,4,['perform'],"['perform', 'performed']"
Performance,"/// TryStaticCast - Check if a static cast can be performed, and do so if; /// possible. If @p CStyle, ignore access restrictions on hierarchy casting; /// and casting away constness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp:50,perform,performed,50,interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCast.cpp,1,['perform'],['performed']
Performance,"/// Turn ""(a cond b) ? 1.0f : 2.0f"" into ""load (tmp + ((a cond b) ? 0 : 4)""; /// where ""tmp"" is a constant pool entry containing an array with 1.0 and 2.0; /// in it. This may be a win when the constant is not otherwise available; /// because it replaces two constant pool loads with one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:42,load,load,42,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],"['load', 'loads']"
Performance,/// Turn load of vector type into a load of the individual elements.; /// \param LD load to expand; /// \returns BUILD_VECTOR and TokenFactor nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:9,load,load,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,3,['load'],['load']
Performance,/// TypeForDecl - This indicates the Type object that represents this; /// TypeDecl. It is a cache maintained by ASTContext::getObjCInterfaceType,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:93,cache,cache,93,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['cache'],['cache']
Performance,"/// TypeStringCache caches the meta encodings of Types.; ///; /// The reason for caching TypeStrings is two fold:; /// 1. To cache a type's encoding for later uses;; /// 2. As a means to break recursive member type inclusion.; ///; /// A cache Entry can have a Status of:; /// NonRecursive: The type encoding is not recursive;; /// Recursive: The type encoding is recursive;; /// Incomplete: An incomplete TypeString;; /// IncompleteUsed: An incomplete TypeString that has been used in a; /// Recursive type encoding.; ///; /// A NonRecursive entry will have all of its sub-members expanded as fully; /// as possible. Whilst it may contain types which are recursive, the type; /// itself is not recursive and thus its encoding may be safely used whenever; /// the type is encountered.; ///; /// A Recursive entry will have all of its sub-members expanded as fully as; /// possible. The type itself is recursive and it may contain other types which; /// are recursive. The Recursive encoding must not be used during the expansion; /// of a recursive type's recursive branch. For simplicity the code uses; /// IncompleteCount to reject all usage of Recursive encodings for member types.; ///; /// An Incomplete entry is always a RecordType and only encodes its; /// identifier e.g. ""s(S){}"". Incomplete 'StubEnc' entries are ephemeral and; /// are placed into the cache during type expansion as a means to identify and; /// handle recursive inclusion of types as sub-members. If there is recursion; /// the entry becomes IncompleteUsed.; ///; /// During the expansion of a RecordType's members:; ///; /// If the cache contains a NonRecursive encoding for the member type, the; /// cached encoding is used;; ///; /// If the cache contains a Recursive encoding for the member type, the; /// cached encoding is 'Swapped' out, as it may be incorrect, and...; ///; /// If the member is a RecordType, an Incomplete encoding is placed into the; /// cache to break potential recursive inclusion of itself as a s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:20,cache,caches,20,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,3,['cache'],"['cache', 'caches']"
Performance,"/// Types that have already been loaded from the chain.; ///; /// When the pointer at index I is non-NULL, the type with; /// ID = (I + 1) << FastQual::Width has already been loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:33,load,loaded,33,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,2,['load'],['loaded']
Performance,/// TypoExpr - Internal placeholder for expressions where typo correction; /// still needs to be performed and/or an error diagnostic emitted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:97,perform,performed,97,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['perform'],['performed']
Performance,"/// UTF-8 is the LLVM native encoding, being the same as ""do not perform; /// encoding conversion"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:65,perform,perform,65,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['perform'],['perform']
Performance,"/// Undoes the transformation performed by QuantizeReals() (assuming the same `count`, `min`, `max` and `nQuantBits`).; /// \return The number of unpacked values that were found to be out of range (0 means all values were in range).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:30,perform,performed,30,tree/ntuple/v7/src/RColumnElement.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx,1,['perform'],['performed']
Performance,"/// Unfold a load from the given machineinstr if the load itself could be; /// hoisted. Return the unfolded and hoistable load, or null if the load; /// couldn't be unfolded or if it wouldn't be hoistable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:13,load,load,13,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,4,['load'],['load']
Performance,/// Unfold the select instruction held in \p SIToUnfold by replacing it with; /// control flow.; ///; /// Put newly discovered select instructions into \p NewSIsToUnfold. Put newly; /// created basic blocks into \p NewBBs.; ///; /// TODO: merge it with CodeGenPrepare::optimizeSelectInst() if possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:269,optimiz,optimizeSelectInst,269,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,1,['optimiz'],['optimizeSelectInst']
Performance,/// Union predicates don't get cached so create a dummy set ID for it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:31,cache,cached,31,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['cache'],['cached']
Performance,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:224,optimiz,optimization,224,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,1,['optimiz'],['optimization']
Performance,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:186,Optimiz,Optimize,186,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['Optimiz'],['Optimize']
Performance,"/// Unsigned division operation.; ///; /// Perform an unsigned divide operation on this APInt by RHS. Both this and; /// RHS are treated as unsigned quantities for purposes of this division.; ///; /// \returns a new APInt value containing the division result, rounded towards; /// zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:43,Perform,Perform,43,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['Perform'],['Perform']
Performance,/// Unsigned remainder operation.; ///; /// Perform an unsigned remainder operation on this APInt with RHS being the; /// divisor. Both this and RHS are treated as unsigned quantities for purposes; /// of this operation.; ///; /// \returns a new APInt value containing the remainder result,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:44,Perform,Perform,44,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['Perform'],['Perform']
Performance,/// Update \p MI memory load instruction to bypass any caches up to; /// the \p Scope memory scope for address spaces \p; /// AddrSpace. Return true iff the instruction was modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,2,"['cache', 'load']","['caches', 'load']"
Performance,/// Update \p MI memory read-modify-write instruction to bypass any caches up; /// to the \p Scope memory scope for address spaces \p AddrSpace. Return true; /// iff the instruction was modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:68,cache,caches,68,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['cache'],['caches']
Performance,/// Update \p MI memory store instruction to bypass any caches up to; /// the \p Scope memory scope for address spaces \p; /// AddrSpace. Return true iff the instruction was modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:56,cache,caches,56,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['cache'],['caches']
Performance,"/// Update internal caches that depend on the function name (such as the; /// intrinsic ID and libcall cache).; /// Note, this method does not need to be called directly, as it is called; /// from Value::setName() whenever the name of this function changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:20,cache,caches,20,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,2,['cache'],"['cache', 'caches']"
Performance,/// Update no-wrap flags of an AddRec. This may drop the cached info about; /// this AddRec (such as range info) in case if new flags may potentially; /// sharpen it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:57,cache,cached,57,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['cache'],['cached']
Performance,"/// Update profile for callee as well as cloned version. We need to do this; /// for regular inlining, but not for inlining from sample profile loader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:144,load,loader,144,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,1,['load'],['loader']
Performance,/// Update scheduler DAG and queues after scheduling an instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:29,queue,queues,29,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['queue'],['queues']
Performance,/// Update scheduler queues after scheduling an instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:21,queue,queues,21,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['queue'],['queues']
Performance,"/// Update section-specific memory permissions and other attributes.; ///; /// This method is called when object loading is complete and section page; /// permissions can be applied. It is up to the memory manager implementation; /// to decide whether or not to act on this method. The memory manager will; /// typically allocate all sections as read-write and then apply specific; /// permissions when this method is called. Code sections cannot be executed; /// until this function has been called. In addition, any cache coherency; /// operations needed to reliably use the memory are also performed.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h:113,load,loading,113,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,3,"['cache', 'load', 'perform']","['cache', 'loading', 'performed']"
Performance,/// Update the LRU cache order when a binary is accessed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h:19,cache,cache,19,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,1,['cache'],['cache']
Performance,/// Update the cache of values being affected by this assumption (i.e.; /// the values about which this assumption provides information).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:15,cache,cache,15,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['cache'],['cache']
Performance,"/// Update the current token to represent the provided; /// identifier, in order to cache an action performed by typo correction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:84,cache,cache,84,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,2,"['cache', 'perform']","['cache', 'performed']"
Performance,"/// Update the last branch of a particular cloned path to point to the correct; /// case successor.; ///; /// Note that this is an optional step and would have been done in later; /// optimizations, but it makes the CFG significantly easier to work with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp:184,optimiz,optimizations,184,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DFAJumpThreading.cpp,1,['optimiz'],['optimizations']
Performance,"/// Update the output mapping based on the load instruction, and the outputs; /// of the extracted function.; ///; /// \param Region - The region extracted; /// \param Outputs - The outputs from the extracted function.; /// \param LI - The load instruction used to update the mapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h:43,load,load,43,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h,2,['load'],['load']
Performance,"/// Update the program state with all the path-sensitive information; /// that's necessary to perform construction of an object with a given; /// syntactic construction context. V and CallOpts have to be obtained from; /// computeObjectUnderConstruction() invoked with the same set of; /// the remaining arguments (E, State, LCtx, CC).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h:94,perform,perform,94,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExprEngine.h,1,['perform'],['perform']
Performance,/// Update the state of Sema after loading some additional modules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:35,load,loading,35,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loading']
Performance,/// Updates the cache to remove any influence an overdefined value in; /// OldSucc might have (unless also overdefined in NewSucc). This just; /// flushes elements from the cache and does not add any.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:16,cache,cache,16,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,2,['cache'],['cache']
Performance,/// Updates to the visible declarations of declaration contexts that; /// haven't been loaded yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:87,load,loaded,87,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,/// Use a Map to store the Function stack for each thread whilst building the; /// graph.; ///; /// FIXME: Perhaps we can Build this into LatencyAccountant? or vise versa?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h:138,Latency,LatencyAccountant,138,interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h,1,['Latency'],['LatencyAccountant']
Performance,"/// Use a function which takes in a MachineIRBuilder to perform a combine.; /// By default, it erases the instruction \p MI from the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:56,perform,perform,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['perform'],['perform']
Performance,/// Use a function which takes in a MachineIRBuilder to perform a combine.; /// This variant does not erase \p MI after calling the build function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:56,perform,perform,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['perform'],['perform']
Performance,/// Use the standard optimization pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:21,optimiz,optimization,21,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['optimiz'],['optimization']
Performance,/// Used by BackwardsPropagateMask to find suitable loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:52,load,loads,52,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loads']
Performance,/// Used by the High-Performance Erlang Compiler (HiPE).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h:21,Perform,Performance,21,interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,1,['Perform'],['Performance']
Performance,"/// Used by the unit tests to drain the queue of clusters to be preloaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:40,queue,queue,40,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,1,['queue'],['queue']
Performance,/// Used during condbr translation to find trees of conditions that can be; /// optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h:80,optimiz,optimized,80,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,1,['optimiz'],['optimized']
Performance,"/// Used e.g. to probe for system headers locations.; /// If not provided, the real filesystem is used.; /// FIXME: the driver does perform some non-virtualized IO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h:132,perform,perform,132,interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,1,['perform'],['perform']
Performance,"/// Used for dynamically loading instances of InlineOrder as plugins; ///; /// Plugins must implement an InlineOrderFactory, for an example refer to:; /// llvm/unittests/Analysis/InlineOrderPlugin/InlineOrderPlugin.cpp; ///; /// If a PluginInlineOrderAnalysis has been registered with the; /// current ModuleAnalysisManager, llvm::getInlineOrder returns an; /// InlineOrder created by the PluginInlineOrderAnalysis' Factory.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h:25,load,loading,25,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineOrder.h,1,['load'],['loading']
Performance,"/// Used for dynamically registering InlineAdvisors as plugins; ///; /// An advisor plugin adds a new advisor at runtime by registering an instance; /// of PluginInlineAdvisorAnalysis in the current ModuleAnalysisManager.; /// For example, the following code dynamically registers a; /// DefaultInlineAdvisor:; ///; /// namespace {; ///; /// InlineAdvisor *defaultAdvisorFactory(Module &M, FunctionAnalysisManager; /// &FAM,; /// InlineParams Params, InlineContext IC); /// {; /// return new DefaultInlineAdvisor(M, FAM, Params, IC);; /// }; ///; /// struct DefaultDynamicAdvisor : PassInfoMixin<DefaultDynamicAdvisor> {; /// PreservedAnalyses run(Module &, ModuleAnalysisManager &MAM) {; /// PluginInlineAdvisorAnalysis PA(defaultAdvisorFactory);; /// MAM.registerPass([&] { return PA; });; /// return PreservedAnalyses::all();; /// }; /// };; ///; /// } // namespace; ///; /// extern ""C"" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo; /// llvmGetPassPluginInfo() {; /// return {LLVM_PLUGIN_API_VERSION, ""DynamicDefaultAdvisor"",; /// LLVM_VERSION_STRING,; /// [](PassBuilder &PB) {; /// PB.registerPipelineStartEPCallback(; /// [](ModulePassManager &MPM, OptimizationLevel Level) {; /// MPM.addPass(DefaultDynamicAdvisor());; /// });; /// }};; /// }; ///; /// A plugin must implement an AdvisorFactory and register it with a; /// PluginInlineAdvisorAnlysis to the provided ModuleanAlysisManager.; ///; /// If such a plugin has been registered; /// InlineAdvisorAnalysis::Result::tryCreate will return the dynamically loaded; /// advisor.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h:1160,Optimiz,OptimizationLevel,1160,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineAdvisor.h,2,"['Optimiz', 'load']","['OptimizationLevel', 'loaded']"
Performance,"/// Used for special AVR rtlib functions which have an ""optimized""; /// convention to preserve registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h:56,optimiz,optimized,56,interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,1,['optimiz'],['optimized']
Performance,"/// Used for special MSP430 rtlib functions which have an ""optimized""; /// convention using additional registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h:59,optimiz,optimized,59,interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,1,['optimiz'],['optimized']
Performance,/// Used on microMIPS Load/Store unaligned instructions (12-bit offset),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp:22,Load,Load,22,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelDAGToDAG.cpp,1,['Load'],['Load']
Performance,/// Used to communicate Linker Optimization Hint information between; /// the Streamer and the .o writer,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h:31,Optimiz,Optimization,31,interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,1,['Optimiz'],['Optimization']
Performance,/// Used to determine if the Constant needs the queue pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp:48,queue,queue,48,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,1,['queue'],['queue']
Performance,"/// Used to implement to perform semantic checking on; /// attribute((section(""foo""))) specifiers.; ///; /// In this case, ""foo"" is passed in to be checked. If the section; /// specifier is invalid, return an Error that indicates the problem.; ///; /// This is a simple quality of implementation feature to catch errors; /// and give good diagnostics in cases when the assembler or code generator; /// would otherwise reject the section specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:25,perform,perform,25,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['perform'],['perform']
Performance,"/// Used to perform separate target specific disassembly for a particular; /// symbol. May parse any prelude that precedes instructions after the; /// start of a symbol, or the entire symbol.; /// This is used for example by WebAssembly to decode preludes.; ///; /// Base implementation returns std::nullopt. So all targets by default ignore; /// to treat symbols separately.; ///; /// \param Symbol - The symbol.; /// \param Size - The number of bytes consumed.; /// \param Address - The address, in the memory space of region, of the first; /// byte of the symbol.; /// \param Bytes - A reference to the actual bytes at the symbol location.; /// \param CStream - The stream to print comments and annotations on.; /// \return - MCDisassembler::Success if bytes are decoded; /// successfully. Size must hold the number of bytes that; /// were decoded.; /// - MCDisassembler::Fail if the bytes are invalid. Size; /// must hold the number of bytes that were decoded before; /// failing. The target must print nothing. This can be; /// done by buffering the output if needed.; /// - std::nullopt if the target doesn't want to handle the; /// symbol separately. Value of Size is ignored in this; /// case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h:12,perform,perform,12,interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCDisassembler/MCDisassembler.h,1,['perform'],['perform']
Performance,/// Used to perform some checks on the legality of vector operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,perform,perform,12,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['perform'],['perform']
Performance,"/// Used when computing address flags for selecting loads and stores.; /// If we have an OR, check if the LHS and RHS are provably disjoint.; /// An OR of two provably disjoint values is equivalent to an ADD.; /// Most PPC load/store instructions compute the effective address as a sum,; /// so doing this conversion is useful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:52,load,loads,52,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['load'],"['load', 'loads']"
Performance,/// Useful if a Match Table Record gets optimized out,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:40,optimiz,optimized,40,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,1,['optimiz'],['optimized']
Performance,/// Uses the CodeGenModule mangled name cache and avoids recomputing.; ///\returns the mangled name of a \c GD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:40,cache,cache,40,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,1,['cache'],['cache']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is zero and the length of the; /// string in \a B is the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestra(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],['perform']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrs(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement in the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],['perform']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrz(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI </c> instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],['perform']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the resulting mask is non-zero, otherwise,; /// returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestrc(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],['perform']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns a 128-bit integer vector representing the result; /// mask of the comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// __m128i _mm_cmpestrm(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRM / PCMPESTRM </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for b",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],['perform']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns an integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestri(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index le",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],['perform']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with explicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpestro(__m128i A, int LA, __m128i B, int LB, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPESTRI / PCMPESTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LA; /// An integer that specifies the length of the string in \a A.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param LB; /// An integer that specifies the length of the string in \a B.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Re",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],['perform']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the bit mask is non-zero, otherwise, returns; /// 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrc(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the bit mask is non-zero, otherwise, returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,3,['perform'],['perform']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a A is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrs(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns 1 if the length of the string in \a A is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,3,['perform'],['perform']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns 1 if the length of the string in \a B is less than; /// the maximum, otherwise, returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistrz(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search \a B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B.; /// \returns Returns 1 if the length of the string in \a B is less than the; /// maximum, otherwise, returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,3,['perform'],['perform']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns an integer representing the result index of the; /// comparison.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistri(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words, the type of comparison to perform, and the format of the return; /// value. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// Bit [6]: Determines whether the index of the lowest set bit or the; /// highest set bit is returned. \n; /// 0: The i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,2,['perform'],['perform']
Performance,"/// Uses the immediate operand \a M to perform a comparison of string; /// data with implicitly defined lengths that is contained in source operands; /// \a A and \a B. Returns bit 0 of the resulting bit mask.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// int _mm_cmpistro(__m128i A, __m128i B, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the <c> VPCMPISTRI / PCMPISTRI </c>; /// instruction.; ///; /// \param A; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param B; /// A 128-bit integer vector containing one of the source operands to be; /// compared.; /// \param M; /// An 8-bit immediate operand specifying whether the characters are bytes or; /// words and the type of comparison to perform. \n; /// Bits [1:0]: Determine source data format. \n; /// 00: 16 unsigned bytes \n; /// 01: 8 unsigned words \n; /// 10: 16 signed bytes \n; /// 11: 8 signed words \n; /// Bits [3:2]: Determine comparison type and aggregation method. \n; /// 00: Subset: Each character in \a B is compared for equality with all; /// the characters in \a A. \n; /// 01: Ranges: Each character in \a B is compared to \a A. The comparison; /// basis is greater than or equal for even-indexed elements in \a A,; /// and less than or equal for odd-indexed elements in \a A. \n; /// 10: Match: Compare each pair of corresponding characters in \a A and; /// \a B for equality. \n; /// 11: Substring: Search B for substring matches of \a A. \n; /// Bits [5:4]: Determine whether to perform a one's complement on the bit; /// mask of the comparison results. \n; /// 00: No effect. \n; /// 01: Negate the bit mask. \n; /// 10: No effect. \n; /// 11: Negate the bit mask only for bits with an index less than or equal; /// to the size of \a A or \a B. \n; /// \returns Returns bit 0 of the resulting bit mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/smmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/smmintrin.h,3,['perform'],['perform']
Performance,/// Using a SmallString<0> because loadClangModule() is recursive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:35,load,loadClangModule,35,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,2,['load'],['loadClangModule']
Performance,"/// UsualArithmeticConversions - Performs various conversions that are common to; /// binary operators (C99 6.3.1.8). If both operands aren't arithmetic, this; /// routine returns the first non-arithmetic type found. The client is; /// responsible for emitting appropriate error diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:33,Perform,Performs,33,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Perform'],['Performs']
Performance,"/// UsualUnaryConversions - Performs various conversions that are common to most; /// operators (C99 6.3). The conversions of array and function types are; /// sometimes suppressed. For example, the array->pointer conversion doesn't; /// apply if the array is an argument to the sizeof or address (&) operators.; /// In these instances, this routine should *not* be called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:28,Perform,Performs,28,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Perform'],['Performs']
Performance,/// Utilities for targets to add passes to the pass manager.; ///; /// createTargetRegisterAllocator - Create the register allocator pass for; /// this target at the current optimization level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:174,optimiz,optimization,174,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,1,['optimiz'],['optimization']
Performance,/// Utility class for loading a ASTContext from an AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:22,load,loading,22,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['load'],['loading']
Performance,/// Utility class to perform tail duplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h:21,perform,perform,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TailDuplicator.h,1,['perform'],['perform']
Performance,"/// Utility function for performing a given action on each lane of a vector; /// with \p EC elements. To simplify porting legacy code, this defaults to; /// unrolling the implied loop for non-scalable element counts, but this is; /// not considered to be part of the contract of this routine, and is; /// expected to change in the future. The callback takes as arguments an; /// IRBuilder whose insert point is correctly set for instantiating the; /// given index, and a value which is (at runtime) the index to access.; /// This index *may* be a constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:25,perform,performing,25,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,2,"['perform', 'scalab']","['performing', 'scalable']"
Performance,"/// Utility function for performing a given action on each lane of a vector; /// with \p EVL effective length. EVL is assumed > 0. To simplify porting legacy; /// code, this defaults to unrolling the implied loop for non-scalable element; /// counts, but this is not considered to be part of the contract of this; /// routine, and is expected to change in the future. The callback takes as; /// arguments an IRBuilder whose insert point is correctly set for instantiating; /// the given index, and a value which is (at runtime) the index to access. This; /// index *may* be a constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:25,perform,performing,25,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,2,"['perform', 'scalab']","['performing', 'scalable']"
Performance,"/// V is a value which is inserted into a vector of VecEltTy.; /// Look through the value to see if we can decompose it into; /// insertions into the vector. See the example in the comment for; /// OptimizeIntegerToVectorInsertions for the pattern this handles.; /// The type of V is always a non-zero multiple of VecEltTy's size.; /// Shift is the number of bits between the lsb of V and the lsb of; /// the vector.; ///; /// This returns false if the pattern can't be matched or true if it can,; /// filling in Elements with the elements found here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:198,Optimiz,OptimizeIntegerToVectorInsertions,198,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['Optimiz'],['OptimizeIntegerToVectorInsertions']
Performance,"/// VPInterleaveRecipe is a recipe for transforming an interleave group of load; /// or stores into one wide load/store and shuffles. The first operand of a; /// VPInterleave recipe is the address, followed by the stored values, followed; /// by an optional mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:75,load,load,75,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,2,['load'],['load']
Performance,"/// VRRC = VADD_SPLAT Elt, EltSize - Temporary node to be expanded; /// during instruction selection to optimize a BUILD_VECTOR into; /// operations on splats. This is necessary to avoid losing these; /// optimizations due to constant folding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:104,optimiz,optimize,104,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,2,['optimiz'],"['optimizations', 'optimize']"
Performance,/// VSCALE(IMM) - Returns the runtime scaling factor used to calculate the; /// number of elements within a scalable vector. IMM is a constant integer; /// multiplier that is applied to the runtime value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:108,scalab,scalable,108,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['scalab'],['scalable']
Performance,"/// VSRC, CHAIN = LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// instructions such as LXVDSX, LXVWSX.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:53,load,load,53,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['load'],['load']
Performance,"/// VSRC, CHAIN = LD_VSX_LH CHAIN, Ptr - This is a floating-point load of a; /// v2f32 value into the lower half of a VSR register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:66,load,load,66,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['load'],['load']
Performance,"/// VSRC, CHAIN = LOAD_VEC_BE CHAIN, Ptr - Occurs only for little endian.; /// Maps directly to one of lxvd2x/lxvw4x/lxvh8x/lxvb16x depending on; /// the vector type to load vector in big-endian element order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:169,load,load,169,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['load'],['load']
Performance,"/// VSRC, CHAIN = SEXT_LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// that sign-extends.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,load,load,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['load'],['load']
Performance,"/// VSRC, CHAIN = XXSWAPD CHAIN, VSRC - Occurs only for little; /// endian. Maps to an xxswapd instruction that corrects an lxvd2x; /// or stxvd2x instruction. The chain is necessary because the; /// sequence replaces a load and needs to provide the same number; /// of outputs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:220,load,load,220,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['load'],['load']
Performance,"/// VSRC, CHAIN = ZEXT_LD_SPLAT, CHAIN, Ptr - a splatting load memory; /// that zero-extends.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:58,load,load,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['load'],['load']
Performance,"/// Val, OUTCHAIN = ATOMIC_LOAD(INCHAIN, ptr); /// This corresponds to ""load atomic"" instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:72,load,load,72,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['load'],['load']
Performance,"/// Value representing pointer-to-member.; ///; /// This value is qualified as NonLoc because neither loading nor storing; /// operations are applied to it. Instead, the analyzer uses the L-value coming; /// from pointer-to-member applied to an object.; /// This SVal is represented by a NamedDecl which can be a member function; /// pointer or a member data pointer and an optional list of CXXBaseSpecifiers.; /// This list is required to accumulate the pointer-to-member cast history to; /// figure out the correct subobject field. In particular, implicit casts grow; /// this list and explicit casts like static_cast shrink this list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h:102,load,loading,102,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h,1,['load'],['loading']
Performance,"/// Value's destructor should be virtual by design, but that would require; /// that Value and all of its subclasses have a vtable that effectively; /// duplicates the information in the value ID. As a size optimization, the; /// destructor has been protected, and the caller should manually call; /// deleteValue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h:207,optimiz,optimization,207,interpreter/llvm-project/llvm/include/llvm/IR/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h,1,['optimiz'],['optimization']
Performance,"/// Variants of check performed on an authenticated pointer.; ///; /// In cases such as authenticating the LR value when performing a tail call; /// or when re-signing a signed pointer with a different signing schema,; /// a failed authentication may not generate an exception on its own and may; /// create an authentication or signing oracle if not checked explicitly.; ///; /// A number of check methods modify control flow in a similar way by; /// rewriting the code; ///; /// ```; /// <authenticate LR>; /// <more instructions>; /// ```; ///; /// as follows:; ///; /// ```; /// <authenticate LR>; /// <method-specific checker>; /// ret_block:; /// <more instructions>; /// ...; ///; /// break_block:; /// brk <code>; /// ```",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h:22,perform,performed,22,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h,2,['perform'],"['performed', 'performing']"
Performance,"/// Various thresholds and options controlling the behavior of the profile; /// inference algorithm. Default values are tuned for several large-scale; /// applications, and can be modified via corresponding command-line flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:120,tune,tuned,120,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,1,['tune'],['tuned']
Performance,"/// Vector commit of preprocessed pages. The `ranges` array specifies a range of sealed pages to be; /// committed for each column. The returned vector contains, in order, the RNTupleLocator for each; /// page on each range in `ranges`, i.e. the first N entries refer to the N pages in `ranges[0]`,; /// followed by M entries that refer to the M pages in `ranges[1]`, etc.; /// The mask allows to skip writing out certain pages. The vector has the size of all the pages.; /// For every `false` value in the mask, the corresponding locator is skipped (missing) in the output vector.; /// The default is to call `CommitSealedPageImpl` for each page; derived classes may provide an; /// optimized implementation though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:684,optimiz,optimized,684,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['optimiz'],['optimized']
Performance,"/// VectorInfo stores abstract the following information for each vector; /// element:; ///; /// 1) The memory address loaded into the element as Polynomial; /// 2) a set of load instruction necessary to construct the vector,; /// 3) a set of all other instructions that are necessary to create the vector and; /// 4) a pointer value that can be used as relative base for all elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:119,load,loaded,119,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,2,['load'],"['load', 'loaded']"
Performance,"/// Vectorize at all optimization levels greater than 1 except for -Oz.; /// For -Oz the loop vectorizer is disabled, while the slp vectorizer is; /// enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:21,optimiz,optimization,21,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['optimiz'],['optimization']
Performance,"/// Vectorize loops using scalable vectors or fixed-width vectors, but favor; /// scalable vectors when the cost-model is inconclusive. This is the; /// default when the scalable.enable hint is enabled through a pragma.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:26,scalab,scalable,26,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,3,['scalab'],['scalable']
Performance,"/// Verifies that `Start` is clobbered by `ClobberAt`, and that nothing; /// inbetween `Start` and `ClobberAt` can clobbers `Start`.; ///; /// This is meant to be as simple and self-contained as possible. Because it; /// uses no cache, etc., it can be relatively expensive.; ///; /// \param Start The MemoryAccess that we want to walk from.; /// \param ClobberAt A clobber for Start.; /// \param StartLoc The MemoryLocation for Start.; /// \param MSSA The MemorySSA instance that Start and ClobberAt belong to.; /// \param Query The UpwardsMemoryQuery we used for our search.; /// \param AA The AliasAnalysis we used for our search.; /// \param AllowImpreciseClobber Always false, unless we do relaxed verify.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:229,cache,cache,229,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['cache'],['cache']
Performance,/// Verify that assumption cache isn't stale after a region is extracted.; /// Returns true when verifier finds errors. AssumptionCache is passed as; /// parameter to make this function stateless.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:27,cache,cache,27,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,1,['cache'],['cache']
Performance,"/// Verify that if we change the normalization set of a server to a RooAddPdf,; /// the projection caches in the RooAddPdf are cleared correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAddPdf.cxx:99,cache,caches,99,roofit/roofitcore/test/testRooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooAddPdf.cxx,1,['cache'],['caches']
Performance,/// VerifyTree - Walk the btree performing assertions on various properties to; /// verify consistency. This is useful for debugging new changes to the tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:32,perform,performing,32,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,1,['perform'],['performing']
Performance,/// Virt2PhysMap - This is a virtual to physical register; /// mapping. Each virtual register is required to have an entry in; /// it; even spilled virtual registers (the register mapped to a; /// spilled register is the temporary used to load it from the; /// stack).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h:239,load,load,239,interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VirtRegMap.h,1,['load'],['load']
Performance,/// VirtualFileSystem to load profile files from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:25,load,load,25,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,1,['load'],['load']
Performance,/// Visit all the top-level module maps loaded when building the given module; /// file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:40,load,loaded,40,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// Visit each of the modules.; ///; /// This routine visits each of the modules, starting with the; /// ""root"" modules that no other loaded modules depend on, and; /// proceeding to the leaf modules, visiting each module only once; /// during the traversal.; ///; /// This traversal is intended to support various ""lookup""; /// operations that can find data in any of the loaded modules.; ///; /// \param Visitor A visitor function that will be invoked with each; /// module. The return value must be convertible to bool; when false, the; /// visitation continues to modules that the current module depends on. When; /// true, the visitation skips any modules that the current module depends on.; ///; /// \param ModuleFilesHit If non-NULL, contains the set of module files; /// that we know we need to visit because the global module index told us to.; /// Any module that is known to both the global module index and the module; /// manager that is *not* in this set can be skipped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:134,load,loaded,134,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,2,['load'],['loaded']
Performance,/// Visitor to rewrite aggregate loads and stores as scalar.; ///; /// This pass aggressively rewrites all aggregate loads and stores on; /// a particular pointer (or any pointer derived from it which we can identify); /// with scalar loads and stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:33,load,loads,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,3,['load'],['loads']
Performance,/// Visitor used to perform a simple type transformation that does not change; /// the semantics of the type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:20,perform,perform,20,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['perform'],['perform']
Performance,/// WList - A set of queued nodes that need to be processed by the; /// worklist algorithm. It is up to the implementation of WList to decide; /// the order that nodes are processed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h:21,queue,queued,21,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h,1,['queue'],['queued']
Performance,/// Walk up the CFG from StartPos (which is in StartBB) and find local and; /// non-local dependencies on Arg.; ///; /// TODO: Cache results?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:127,Cache,Cache,127,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,1,['Cache'],['Cache']
Performance,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:582,optimiz,optimized,582,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,2,['optimiz'],['optimized']
Performance,/// Warnings (and follow-on notes) that were suppressed due to; /// SFINAE while performing template argument deduction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h:81,perform,performing,81,interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/TemplateDeduction.h,1,['perform'],['performing']
Performance,"/// We do not provide the '/' operator here because division for polynomial; /// types does not work in the same way as for normal integer types. We can; /// only divide the minimum value (or coefficient) by RHS, which is not the; /// same as; /// (Min * Vscale) / RHS; /// The caller is recommended to use this function in combination with; /// isKnownMultipleOf(RHS), which lets the caller know if it's possible to; /// perform a lossless divide by RHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h:422,perform,perform,422,interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,1,['perform'],['perform']
Performance,"/// We have mapping between value A and other value B where B was a field in; /// addressing mode represented by A. Also we have an original value C; /// representing an address we start with. Traversing from C through phi and; /// selects we ended up with A's in a map. This utility function tries to find; /// a value V which is a field in addressing mode C and traversing through phi; /// nodes and selects we will end up in corresponded values B in a map.; /// The utility will create a new Phi/Selects if needed.; // The simple example looks as follows:; // BB1:; // p1 = b1 + 40; // br cond BB2, BB3; // BB2:; // p2 = b2 + 40; // br BB3; // BB3:; // p = phi [p1, BB1], [p2, BB2]; // v = load p; // Map is; // p1 -> b1; // p2 -> b2; // Request is; // p -> ?; // The function tries to find or build phi [b1, BB1], [b2, BB2] in BB3.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:693,load,load,693,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['load'],['load']
Performance,/// We keep track attributes for each live-in virtual registers; /// to use SExt/ZExt flags in later optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:101,optimiz,optimization,101,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,1,['optimiz'],['optimization']
Performance,"/// We need to perform a generic polymorphic operation (like a typeid; /// or a cast), which requires an object with a vfptr. Adjust the; /// address to point to an object with a vfptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:15,perform,perform,15,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['perform'],['perform']
Performance,"/// We notify the Preprocessor that if it is caching tokens (because; /// backtrack is enabled) it should replace the most recent cached tokens; /// with the given annotation token. This function has no effect if; /// backtracking is not enabled.; ///; /// Note that the use of this function is just for optimization, so that the; /// cached tokens doesn't get re-parsed and re-resolved after a backtrack is; /// invoked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:130,cache,cached,130,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,3,"['cache', 'optimiz']","['cached', 'optimization']"
Performance,"/// We use a simple cost model for edit actions, which seems good enough.; /// Simple cost model for edit actions. This seems to make the matching; /// algorithm perform reasonably well.; /// The values range between 0 and 1, or infinity if this edit action should; /// always be avoided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:162,perform,perform,162,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,1,['perform'],['perform']
Performance,"/// We want to produce a diagnostic at location IncLoc concerning an; /// unreachable effect at location MLoc (eg, where a desired entity was; /// declared or defined). Determine whether the right way to make MLoc; /// reachable is by #include, and if so, what header should be included.; ///; /// This is not necessarily fast, and might load unexpected module maps, so; /// should only be called by code that intends to produce an error.; ///; /// \param IncLoc The location at which the missing effect was detected.; /// \param MLoc A location within an unimported module at which the desired; /// effect occurred.; /// \return A file that can be #included to provide the desired effect. Null; /// if no such file could be determined or if a #include is not; /// appropriate (eg, if a module should be imported instead).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:338,load,load,338,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['load'],['load']
Performance,"/// We will prefer importing the prevailing candidate, if not, we'll; /// still pick the first available candidate. The reason we want to make; /// sure we do import the prevailing candidate is because the goal of; /// workload-awareness is to enable optimizations specializing the call; /// graph of that workload. Suppose a function is already defined in the; /// module, but it's not the prevailing variant. Suppose also we do not; /// inline it (in fact, if it were interposable, we can't inline it),; /// but we could specialize it to the workload in other ways. However,; /// the linker would drop it in the favor of the prevailing copy.; /// Instead, by importing the prevailing variant (assuming also the use; /// of `-avail-extern-to-local`), we keep the specialization. We could; /// alteranatively make the non-prevailing variant local, but the; /// prevailing one is also the one for which we would have previously; /// collected profiles, making it preferrable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:251,optimiz,optimizations,251,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['optimiz'],['optimizations']
Performance,"/// We're checking to see if we can fold \p LI into \p FoldInst. Note; /// that we could have a sequence where multiple LLVM IR instructions are; /// folded into the same machineinstr. For example we could have:; ///; /// A: x = load i32 *P; /// B: y = icmp A, 42; /// C: br y, ...; ///; /// In this scenario, \p LI is ""A"", and \p FoldInst is ""C"". We know about ""B""; /// (and any other folded instructions) because it is between A and C.; ///; /// If we succeed folding, return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:229,load,load,229,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,1,['load'],['load']
Performance,/// Weak pointer optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,optimiz,optimizations,17,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['optimiz'],['optimizations']
Performance,"/// What kind of timing do load multiple/store multiple have (double issue,; /// single issue etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:27,load,load,27,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,1,['load'],['load']
Performance,/// What kind of timing do load multiple/store multiple instructions have.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:27,load,load,27,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,1,['load'],['load']
Performance,/// When CodeGen is created the first llvm::Module gets cached in many places; /// and we must keep it alive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:56,cache,cached,56,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,1,['cache'],['cached']
Performance,"/// When Kind == EK_Member, whether this is an implicit member; /// initialization in a copy or move constructor. These can perform array; /// copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:124,perform,perform,124,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['perform'],['perform']
Performance,"/// When MachO binaries include a LC_CODE_SIGNATURE load command,; /// the __LINKEDIT data segment will include a section corresponding; /// to the LC_CODE_SIGNATURE load command. This section serves as a signature; /// for the binary. Included in the CodeSignature section is a header followed; /// by a hash of the binary. If present, the CodeSignature section is the; /// last component of the binary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h:52,load,load,52,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOLayoutBuilder.h,2,['load'],['load']
Performance,"/// When \p PredVT is a scalable vector predicate in the form; /// MVT::nx<M>xi1, it builds the correspondent scalable vector of; /// integers MVT::nx<M>xi<bits> s.t. M x bits = 128. When targeting; /// structured vectors (NumVec >1), the output data type is; /// MVT::nx<M*NumVec>xi<bits> s.t. M x bits = 128. If the input; /// PredVT is not in the form MVT::nx<M>xi1, it returns an invalid; /// EVT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:24,scalab,scalable,24,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,2,['scalab'],['scalable']
Performance,"/// When a C++ decl with an initializer is deferred, null is; /// appended to CXXGlobalInits, and the index of that null is placed; /// here so that the initializer will be performed in the correct; /// order. Once the decl is emitted, the index is replaced with ~0U to ensure; /// that we don't re-emit the initializer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:173,perform,performed,173,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['perform'],['performed']
Performance,"/// When accessing thread-local variables under either the general-dynamic or; /// local-dynamic system, we make a ""TLS-descriptor"" call. The variable will; /// have a descriptor, accessible via a PC-relative ADRP, and whose first entry; /// is a function pointer to carry out the resolution.; ///; /// The sequence is:; /// adrp x0, :tlsdesc:var; /// ldr x1, [x0, #:tlsdesc_lo12:var]; /// add x0, x0, #:tlsdesc_lo12:var; /// .tlsdesccall var; /// blr x1; /// (TPIDR_EL0 offset now in x0); ///; /// The above sequence must be produced unscheduled, to enable the linker to; /// optimize/relax this sequence.; /// Therefore, a pseudo-instruction (TLSDESC_CALLSEQ) is used to represent the; /// above sequence, and expanded really late in the compilation flow, to ensure; /// the sequence is produced as per above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:577,optimiz,optimize,577,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['optimiz'],['optimize']
Performance,"/// When an instance of this is inserted into the stream, the arguments; /// following will not appear in the remark printed in the compiler output; /// (-Rpass) but only in the optimization record file; /// (-fsave-optimization-record).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:178,optimiz,optimization,178,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,2,['optimiz'],"['optimization', 'optimization-record']"
Performance,"/// When backtracking is enabled and tokens are cached,; /// this allows to revert a specific number of tokens.; ///; /// Note that the number of tokens being reverted should be up to the last; /// backtrack position, not more.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:48,cache,cached,48,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['cache'],['cached']
Performance,"/// When calculate the latency of the root instruction, accumulate the; /// latency of the sequence to the root latency.; /// \param Root - Instruction that could be combined with one of its operands",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:23,latency,latency,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,3,['latency'],['latency']
Performance,"/// When calculate the latency of the root instruction, accumulate the; /// latency of the sequence to the root latency.; /// \param Root - Instruction that could be combined with one of its operands; /// For X86 instruction (vpmaddwd + vpmaddwd) -> vpdpwssd, the vpmaddwd; /// is not in the critical path, so the root latency only include vpmaddwd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:23,latency,latency,23,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,4,['latency'],['latency']
Performance,"/// When dsymutil generates the companion file, it strips all unnecessary; /// sections (e.g. everything in the _TEXT segment) by omitting their body; /// and setting the offset in their corresponding load command to zero.; ///; /// While the load command itself is valid, reading the section corresponds; /// to reading the number of bytes specified in the load command, starting; /// from offset 0 (i.e. the Mach-O header at the beginning of the file).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h:201,load,load,201,interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/MachO.h,3,['load'],['load']
Performance,"/// When performing a comparison against a constant, it is possible that not all; /// the bits in the LHS are demanded. This helper method computes the mask that; /// IS demanded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:9,perform,performing,9,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['perform'],['performing']
Performance,"/// When performing dependency directives scan, this is the caching (and; /// dependency-directives-extracting) filesystem overlaid on top of \c FS; /// (passed in the constructor).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h:9,perform,performing,9,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningWorker.h,1,['perform'],['performing']
Performance,"/// When performing template argument deduction for a function; /// template, there were too few call arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:9,perform,performing,9,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,"/// When performing template argument deduction for a function; /// template, there were too many call arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:9,perform,performing,9,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,"/// When the input category changes states, the cached state mappings are invalidated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMappedCategory.h:48,cache,cached,48,roofit/roofitcore/inc/RooMappedCategory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMappedCategory.h,2,['cache'],['cached']
Performance,"/// When true, a PCH with modules cache path different to the current; /// compilation will not be rejected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:34,cache,cache,34,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,1,['cache'],['cache']
Performance,"/// When we if-convert we need to create edge masks. We have to cache values; /// so that we don't end up with exponential recursion/IR. Note that; /// if-conversion currently takes place during VPlan-construction, so these; /// caches are only used at that stage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:64,cache,cache,64,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,2,['cache'],"['cache', 'caches']"
Performance,"/// Where to cache the file. If empty, defaults to RFilePtr::GetCacheDir().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:13,cache,cache,13,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['cache'],['cache']
Performance,/// Whether \p CachedGainLR and \p CachedGainRL are valid,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h:15,Cache,CachedGainLR,15,interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,2,['Cache'],"['CachedGainLR', 'CachedGainRL']"
Performance,/// Whether \p Tok is the most recent token (`CachedLexPos - 1`) in; /// CachedTokens.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:46,Cache,CachedLexPos,46,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,2,['Cache'],"['CachedLexPos', 'CachedTokens']"
Performance,/// Whether a selector is out of date. We mark a selector as out of date; /// if we load another module after the method pool entry was pulled in.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:84,load,load,84,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['load']
Performance,"/// Whether alias analysis is allowed to use the dominator tree, for use by; /// passes that lazily update the DT while performing AA queries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:120,perform,performing,120,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['perform'],['performing']
Performance,/// Whether it resembles a flexible array member. This is a static member; /// because we want to be able to call it with a nullptr. That allows us to; /// perform non-Decl specific checks based on the object's type and strict; /// flex array level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:156,perform,perform,156,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['perform'],['perform']
Performance,/// Whether optimizations should be enabled. This is to distinguish between; /// uses of the combiner unconditionally and only when optimizations are; /// specifically enabled/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h:12,optimiz,optimizations,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h,2,['optimiz'],['optimizations']
Performance,/// Whether or not we should populate a PassInstrumentationCallbacks's class to; /// pass name map.; ///; /// This is for optimization purposes so we don't populate it if we never use; /// it. This should be updated if new pass instrumentation wants to use the map.; /// We currently only use this for --print-before/after.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:122,optimiz,optimization,122,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,1,['optimiz'],['optimization']
Performance,"/// Whether the JIT should perform lookups of external symbols (e.g.,; /// using dlsym).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:27,perform,perform,27,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['perform'],['perform']
Performance,"/// Whether the MemoryUse is optimized. If ensureOptimizedUses() was called,; /// uses will usually be optimized, but this is not guaranteed (e.g. due to; /// invalidation and optimization limits.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:29,optimiz,optimized,29,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,3,['optimiz'],"['optimization', 'optimized']"
Performance,/// Whether the entity being initialized may end up using the; /// named return value optimization (NRVO).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:86,optimiz,optimization,86,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['optimiz'],['optimization']
Performance,/// Whether the field declarations of this record have been loaded; /// from external storage. To avoid unnecessary deserialization of; /// methods/nested types we allow deserialization of just the fields; /// when needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:60,load,loaded,60,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['load'],['loaded']
Performance,"/// Whether the file should be cached before reading. Only available for; /// ""remote"" file protocols. If the download fails, the file will be opened; /// remotely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:31,cache,cached,31,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['cache'],['cached']
Performance,"/// Whether the importer will perform a minimal import, creating; /// to-be-completed forward declarations when possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:30,perform,perform,30,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['perform'],['perform']
Performance,"/// Whether the transformation should always rebuild AST nodes, even; /// if none of the children have changed.; ///; /// Subclasses may override this function to specify when the transformation; /// should rebuild all AST nodes.; ///; /// We must always rebuild all AST nodes when performing variadic template; /// pack expansion, in order to avoid violating the AST invariant that each; /// statement node appears at most once in its containing declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:282,perform,performing,282,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performing']
Performance,"/// Whether this declaration context has had externally visible; /// storage added since the last lookup. In this case, \c LookupPtr's; /// invariant may not hold and needs to be fixed before we perform; /// another lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:195,perform,perform,195,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,2,['perform'],['perform']
Performance,/// Whether this declaration was loaded from an AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:33,load,loaded,33,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['load'],['loaded']
Performance,"/// Whether this function has Return Value Optimization, i.e.; /// the return value is constructed in the caller's stack frame.; /// This is done for functions that return non-primive values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h:43,Optimiz,Optimization,43,interpreter/llvm-project/clang/lib/AST/Interp/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h,1,['Optimiz'],['Optimization']
Performance,"/// Whether this local variable could be allocated in the return; /// slot of its function, enabling the named return value optimization; /// (NRVO).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:124,optimiz,optimization,124,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['optimiz'],['optimization']
Performance,/// Whether this module was loaded from a module file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h:28,load,loaded,28,interpreter/llvm-project/clang/include/clang/Basic/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h,1,['load'],['loaded']
Performance,"/// Whether this structure is considered to already have been; /// ""resolved"", meaning that it was loaded from the external source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:99,load,loaded,99,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['load'],['loaded']
Performance,/// Whether to disable most of the normal validation performed on; /// precompiled headers and module files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:53,perform,performed,53,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,1,['perform'],['performed']
Performance,/// Whether to disable the normal validation performed on precompiled; /// headers and module files when they are loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:45,perform,performed,45,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,4,"['load', 'perform']","['loaded', 'performed']"
Performance,/// Whether to emit optimization remarks with hotness informations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:20,optimiz,optimization,20,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['optimiz'],['optimization']
Performance,/// Whether to include brief documentation within the set of code; /// completions cached.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:83,cache,cached,83,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['cache'],['cached']
Performance,/// Whether to insert cache invalidating instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:22,cache,cache,22,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['cache'],['cache']
Performance,/// Whether to optimize the modules' command-line arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:15,optimiz,optimize,15,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,3,['optimiz'],['optimize']
Performance,/// Whether to perform a minimal import.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h:15,perform,perform,15,interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTImporter.h,1,['perform'],['perform']
Performance,/// Whether to set up command-lines to load PCM files eagerly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h:39,load,load,39,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningService.h,3,['load'],['load']
Performance,"/// Whether to use implicit multi-threading to compress pages. Only has an effect if buffered writing is turned on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:28,multi-thread,multi-threading,28,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,1,['multi-thread'],['multi-threading']
Performance,/// Whether to validate system input files when a module is loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h:60,load,loaded,60,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,1,['load'],['loaded']
Performance,/// Whether to write comment locations into the PCH when building it.; /// Reading the comments from the PCH can be a performance hit even if the; /// clients don't use them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:118,perform,performance,118,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,1,['perform'],['performance']
Performance,"/// Whether we allow for extra compile-time budget to perform more; /// analysis to be more informative.; ///; /// This is useful to enable additional missed optimizations to be reported; /// that are normally too noisy. In this mode, we can use the extra analysis; /// (1) to filter trivial false positives or (2) to provide more context so; /// that non-trivial false positives can be quickly detected by the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:54,perform,perform,54,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,2,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,/// Whether we allow for extra compile-time budget to perform more; /// analysis to produce fewer false positives.; ///; /// This is useful when reporting missed optimizations. In this case we can; /// use the extra analysis (1) to filter trivial false positives or (2) to; /// provide more context so that non-trivial false positives can be quickly; /// detected by the user.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:54,perform,perform,54,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,2,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"/// Whether we already printed a warning about performing a copy of the TTreeReaderArray contents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:47,perform,performing,47,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,1,['perform'],['performing']
Performance,/// Whether we are performing an implicit module build.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h:19,perform,performing,19,interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,1,['perform'],['performing']
Performance,/// Whether we are performing template argument deduction for; /// parameters and arguments in a top-level template argument,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:19,perform,performing,19,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['perform'],['performing']
Performance,/// Whether we have already loaded known namespaces from an extenal; /// source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:28,load,loaded,28,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['load'],['loaded']
Performance,/// Whether we have already loaded macros from the external source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:28,load,loaded,28,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['load'],['loaded']
Performance,/// Whether we have tried loading the global module index yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:26,load,loading,26,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loading']
Performance,/// Whether we should disable the use of the hash string within the; /// module cache.; ///; /// Note: Only used for testing!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h:80,cache,cache,80,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,1,['cache'],['cache']
Performance,"/// Whether we should try to optimize for size only.; /// Currently, this applies a dead simple heuristic: only consider globals; /// used in minsize functions for merging.; /// FIXME: This could learn about optsize, and be used in the cost model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h:29,optimiz,optimize,29,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,1,['optimiz'],['optimize']
Performance,/// Whether we tried and failed to load a module file for this module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h:35,load,load,35,interpreter/llvm-project/clang/include/clang/Basic/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h,1,['load'],['load']
Performance,/// Whether we're optimizing for minsize (-Oz).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h:18,optimiz,optimizing,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h,1,['optimiz'],['optimizing']
Performance,/// Whether we're optimizing for size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h:18,optimiz,optimizing,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerInfo.h,1,['optimiz'],['optimizing']
Performance,/// Whether we've performed an exhaustive search for module maps; /// within the subdirectories of this directory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/DirectoryLookup.h:18,perform,performed,18,interpreter/llvm-project/clang/include/clang/Lex/DirectoryLookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/DirectoryLookup.h,1,['perform'],['performed']
Performance,/// Which debugger to tune for.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:22,tune,tune,22,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['tune'],['tune']
Performance,"/// While we walk the loop instructions, we build up and maintain a mapping; /// of simplified values specific to this iteration. The idea is to propagate; /// any special information we have about loads that can be replaced with; /// constants after complete unrolling, and account for likely simplifications; /// post-unrolling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:198,load,loads,198,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,1,['load'],['loads']
Performance,"/// Widen a scalar load.; ///; /// \details \p Widen scalar load for uniform, small type loads from constant; // memory / to a full 32-bits and then truncate the input to allow a scalar; // load instead of a vector load.; //; /// \returns True.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:19,load,load,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,5,['load'],"['load', 'loads']"
Performance,"/// Widen a suitably aligned v3 load. For all other cases, split the input; /// vector load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h:32,load,load,32,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.h,2,['load'],['load']
Performance,"/// Widening is performance neutral as far as the cycles spent in check; /// conditions goes (but can still help, e.g., code layout, having less; /// deopt state).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:16,perform,performance,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,1,['perform'],['performance']
Performance,"/// Within template argument deduction from a function call,; /// we are matching in a case where we can perform template argument; /// deduction from a template-id of a derived class of the argument type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:105,perform,perform,105,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['perform'],['perform']
Performance,/// Worker object for performing CFG-based warnings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:22,perform,performing,22,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,"/// Worklist of the RefSCCs queued for processing.; ///; /// When a pass refines the graph and creates new RefSCCs or causes them to; /// have a different shape or set of component SCCs it should add the RefSCCs; /// to this worklist so that we visit them in the refined form.; ///; /// This worklist is in reverse post-order, as we pop off the back in order; /// to observe RefSCCs in post-order. When adding RefSCCs, clients should add; /// them in reverse post-order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:28,queue,queued,28,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['queue'],['queued']
Performance,"/// Worklist of the SCCs queued for processing.; ///; /// When a pass refines the graph and creates new SCCs or causes them to have; /// a different shape or set of component functions it should add the SCCs to; /// this worklist so that we visit them in the refined form.; ///; /// Note that if the SCCs are part of a RefSCC that is added to the \c; /// RCWorklist, they don't need to be added here as visiting the RefSCC will; /// be sufficient to re-visit the SCCs within it.; ///; /// This worklist is in reverse post-order, as we pop off the back in order; /// to observe SCCs in post-order. When adding SCCs, clients should add them; /// in reverse post-order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:25,queue,queued,25,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['queue'],['queued']
Performance,"/// Wrap a machine instruction, MI, into a FAULTING machine instruction.; /// The FAULTING instruction does the same load/store as MI; /// (defining the same register), and branches to HandlerMBB if the mem access; /// faults. The FAULTING instruction is inserted at the end of MBB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:117,load,load,117,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['load'],['load']
Performance,"/// Wrap predicated VPReplicateRecipes with a mask operand in an if-then; /// region block and remove the mask operand. Optimize the created regions by; /// iteratively sinking scalar operands into the region, followed by merging; /// regions until no improvements are remaining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:120,Optimiz,Optimize,120,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,1,['Optimiz'],['Optimize']
Performance,/// Wrapper Method to do all the necessary work when an Instruction is; /// deleted.; /// Optimizations should use this to make sure that deleted instructions; /// are always accounted for.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:90,Optimiz,Optimizations,90,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['Optimiz'],['Optimizations']
Performance,"/// Wrapper class to handle memory instructions, including loads,; /// stores and intrinsic loads and stores defined by the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:59,load,loads,59,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,2,['load'],['loads']
Performance,"/// Write a global index into the given; ///; /// \param FileMgr The file manager to use to load module files.; /// \param PCHContainerRdr - The PCHContainerOperations to use for loading and; /// creating modules.; /// \param Path The path to the directory containing module files, into; /// which the global index will be written.; /// \param Optionally pass already precomputed interesting identifiers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h:92,load,load,92,interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,2,['load'],"['load', 'loading']"
Performance,/// Write a segment load command.; ///; /// \param NumSections The number of sections in this segment.; /// \param SectionDataSize The total size of the sections.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h:20,load,load,20,interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCMachObjectWriter.h,1,['load'],['load']
Performance,"/// Write out the generated object file, either from CacheEntryPath or from; /// OutputBuffer, preferring hard-link when possible.; /// Returns the path to the generated file in SavedObjectsDirectoryPath.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:53,Cache,CacheEntryPath,53,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['Cache'],['CacheEntryPath']
Performance,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:360,optimiz,optimization,360,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,1,['optimiz'],['optimization']
Performance,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:440,optimiz,optimization,440,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,1,['optimiz'],['optimization']
Performance,/// Write the state of 'pragma clang optimize' at the end of the module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:37,optimiz,optimize,37,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['optimiz'],['optimize']
Performance,/// Writes back to memory the cache line (if modified) that contains the; /// linear address specified in \a __p from any level of the cache hierarchy in; /// the cache coherence domain; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> CLWB </c> instruction.; ///; /// \param __p; /// A pointer to the memory location used to identify the cache line to be; /// written back.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h:30,cache,cache,30,interpreter/llvm-project/clang/lib/Headers/clwbintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clwbintrin.h,4,['cache'],['cache']
Performance,/// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP; /// type.; /// It is used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:108,optimiz,optimizations,108,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,['optimiz'],"['optimizations', 'optimized']"
Performance,"/// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating; /// point type down to the precision of the destination VT. TRUNC is a; /// flag, which is always an integer that is zero or one. If TRUNC is 0,; /// this is a normal rounding, if it is 1, this FP_ROUND is known to not; /// change the value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't; /// removed.; /// It is used to limit optimizations while the DAG is being optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:731,optimiz,optimizations,731,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,['optimiz'],"['optimizations', 'optimized']"
Performance,"/// X86FastEmitLoad - Emit a machine instruction to load a value of type VT.; /// The address is either pre-computed, i.e. Ptr, or a GlobalAddress, i.e. GV.; /// Return true and the result register by reference if it is possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:52,load,load,52,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['load'],['load']
Performance,/// X86SelectLoad - Select and emit code to implement load instructions.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:54,load,load,54,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['load'],['load']
Performance,"/// XS, XD - These prefix codes are for single and double precision scalar; /// floating point operations performed in the SSE registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:106,perform,performed,106,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,1,['perform'],['performed']
Performance,/// Zero constant to queue,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:21,queue,queue,21,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['queue'],['queue']
Performance,/// Zeroes out the cache line for the address \a __line. This uses a; /// non-temporal store. Calling \c _mm_sfence() afterward might be needed; /// to enforce ordering.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c CLZERO instruction.; ///; /// \param __line; /// An address within the cache line to zero out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clzerointrin.h:19,cache,cache,19,interpreter/llvm-project/clang/lib/Headers/clzerointrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clzerointrin.h,2,['cache'],['cache']
Performance,"/// [class.dtor]p4:; /// At the end of the definition of a class, overload resolution is; /// performed among the prospective destructors declared in that class with; /// an empty argument list to select the destructor for the class, also; /// known as the selected destructor.; ///; /// We do the overload resolution here, then mark the selected constructor in the AST.; /// Later CXXRecordDecl::getDestructor() will return the selected constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:94,perform,performed,94,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['perform'],['performed']
Performance,/// \Returns true if the target supports broadcasting a load to a vector of; /// type <NumElements x ElementTy>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:56,load,load,56,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,/// \Token literal data loaded and owned by us.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:24,load,loaded,24,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,/// \When performing memory disambiguation checks at runtime do not; /// make more than this number of comparisons.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:10,perform,performing,10,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['perform'],['performing']
Performance,"/// \brief Activate the loading process by starting the batchloader, and; /// spawning the loading thread.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx:24,load,loading,24,tmva/tmva/inc/TMVA/RBatchGenerator.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx,2,['load'],['loading']
Performance,"/// \brief Add filters to the RDataFrame and load a chunk of data; /// \param x_rdf; /// \param func; /// \return A pair of size_t defining the number of events processed and how many passed all filters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx:45,load,load,45,tmva/tmva/inc/TMVA/RChunkLoader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx,1,['load'],['load']
Performance,"/// \brief Build a new Objective-C boxed expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:75,perform,performs,75,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// \brief Build a new requires expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,perform,performs,66,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// \brief Create training batches from the given chunk of data based on the given event indices; /// Batches are added to the training queue of batches; /// The eventIndices can be shuffled to ensure random order for each epoch; /// \param chunkTensor; /// \param eventIndices; /// \param shuffle",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchLoader.hxx:136,queue,queue,136,tmva/tmva/inc/TMVA/RBatchLoader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchLoader.hxx,1,['queue'],['queue']
Performance,"/// \brief De-activate the loading process by deactivating the batchgenerator; /// and joining the loading thread",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx:27,load,loading,27,tmva/tmva/inc/TMVA/RBatchGenerator.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchGenerator.hxx,2,['load'],['loading']
Performance,"/// \brief DeActivate the batchloader. This means that no more batches are created.; /// Batches can still be returned if they are already loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchLoader.hxx:139,load,loaded,139,tmva/tmva/inc/TMVA/RBatchLoader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBatchLoader.hxx,1,['load'],['loaded']
Performance,"/// \brief Declares a llvm.vp.* intrinsic in \p M that matches the parameters; /// \p Params. Additionally, the load and gather intrinsics require; /// \p ReturnType to be specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h:112,load,load,112,interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,1,['load'],['load']
Performance,"/// \brief Enable ROOT's implicit multi-threading for all objects and methods that provide an internal; /// parallelisation mechanism.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TROOT.h:34,multi-thread,multi-threading,34,core/base/inc/TROOT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TROOT.h,1,['multi-thread'],['multi-threading']
Performance,"/// \brief Enable support for multi-threading within the ROOT code; /// in particular, enables the global mutex to make ROOT thread safe/aware.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TROOT.h:30,multi-thread,multi-threading,30,core/base/inc/TROOT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TROOT.h,1,['multi-thread'],['multi-threading']
Performance,/// \brief Get maximum # of store operations to be glued together; ///; /// This function returns the maximum number of store operations permitted; /// to glue together during lowering of llvm.memcpy. The value is set by; // the target at the performance threshold for such a replacement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:243,perform,performance,243,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['performance']
Performance,"/// \brief In order to implement the runtime type binding and expression; /// evaluation we need to be able to compile code which contains unknown; /// symbols (undefined variables, types, functions, etc.). This cannot be done; /// by a compiler like clang, because it is not valid C++ code.; ///; /// DynamicExprTransformer transforms these unknown symbols into valid C++; /// code at AST (abstract syntax tree) level. Thus it provides an opportunity; /// their evaluation to happen at runtime. Several steps are performed:; ///; /// 1. Skip compiler's error diagnostics - if a compiler encounters unknown; /// symbol, by definition, it must output an error and it mustn't produce; /// machine code. Cling implements an extension to Clang semantic analyzer; /// that allows the compiler to recover even an unknown symbol is encountered.; /// For instance if the compiler sees a symbol it looks for its definition in; /// a internal structure (symbol table) and it is not found it asks whether; /// somebody else could provide the missing symbol. That is the place where; /// the DynamicIDHandler, which is controlled by DynamicExprTransformer comes; /// into play. It marks all unknown symbols as dependent as if they are; /// templates and are going to be resolved at first instantiation, with the; /// only difference that an instantiation never happens. The advantage is that; /// the unknown symbols are not diagnosed but the disadvantage is that; /// somebody needs to transform them into valid expressions with valid types.; ///; /// 2. Replace all dependent symbols - all artificially dependent symbols need; /// to be replaced with appropriate valid symbols in order the compiler to; /// produce executable machine code. The DynamicExprTransformer walks up all; /// statements and declarations that might be possibly marked earlier as; /// dependent and replaces them with valid expression, which preserves the; /// meant behavior. Main implementation goal is to replace the as little; /// as",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.h:514,perform,performed,514,interpreter/cling/lib/Interpreter/DynamicLookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.h,1,['perform'],['performed']
Performance,"/// \brief Interface function signaling a request to perform constant term optimization.; ///; /// The default implementation takes no action other than to forward the calls to all servers. May be overridden in; /// likelihood classes without a cached dataset, like RooSubsidiaryL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/TestStatistics/RooAbsL.h:53,perform,perform,53,roofit/roofitcore/inc/RooFit/TestStatistics/RooAbsL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/TestStatistics/RooAbsL.h,3,"['cache', 'optimiz', 'perform']","['cached', 'optimization', 'perform']"
Performance,"/// \brief Load a chunk of data using the RChunkLoaderFunctor; /// \param chunkTensor; /// \param currentRow; /// \return A pair of size_t defining the number of events processed and how many passed all filters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx:11,Load,Load,11,tmva/tmva/inc/TMVA/RChunkLoader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx,1,['Load'],['Load']
Performance,"/// \brief Load the final given value into fChunkTensor; /// \tparam First_T; /// \param first",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx:11,Load,Load,11,tmva/tmva/inc/TMVA/RChunkLoader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx,1,['Load'],['Load']
Performance,"/// \brief Load the final given value into fChunkTensor; /// \tparam VecType; /// \param first",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx:11,Load,Load,11,tmva/tmva/inc/TMVA/RChunkLoader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx,1,['Load'],['Load']
Performance,"/// \brief Loop over the events in the dataframe untill either the end of the dataframe; /// is reached, or a full chunk is loaded; /// \param x_rdf; /// \param func; /// \return A pair of size_t defining the number of events processed and how many passed all filters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx:124,load,loaded,124,tmva/tmva/inc/TMVA/RChunkLoader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx,1,['load'],['loaded']
Performance,"/// \brief Loop through the values of a given vector and load them into the RTensor; /// Note: the given vec_size does not have to be the same size as the given vector; /// If the size is bigger than the given vector, zeros are used as padding.; /// If the size is smaller, the remaining values are ignored.; /// \tparam VecType; /// \param vec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx:57,load,load,57,tmva/tmva/inc/TMVA/RChunkLoader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx,1,['load'],['load']
Performance,"/// \brief Recursively loop through the given values, and load them onto the fChunkTensor; /// \tparam First_T; /// \tparam ...Rest_T; /// \param first; /// \param ...rest",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx:58,load,load,58,tmva/tmva/inc/TMVA/RChunkLoader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx,1,['load'],['load']
Performance,"/// \brief Recursively loop through the given values, and load them onto the fChunkTensor; /// \tparam VecType; /// \tparam ...Rest_T; /// \param first; /// \param ...rest",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx:58,load,load,58,tmva/tmva/inc/TMVA/RChunkLoader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RChunkLoader.hxx,1,['load'],['load']
Performance,"/// \brief Release event data from queue.; /// \return 0 on success; a DAOS error code otherwise (< 0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:35,queue,queue,35,tree/ntuple/v7/inc/ROOT/RDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx,1,['queue'],['queue']
Performance,"/// \brief Reserve event in queue, optionally tied to a parent event.; /// \return 0 on success; a DAOS error code otherwise (< 0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx:28,queue,queue,28,tree/ntuple/v7/inc/ROOT/RDaos.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RDaos.hxx,1,['queue'],['queue']
Performance,"/// \brief Specify maximum number of load instructions per memcmp call.; ///; /// When lowering \@llvm.memcmp this field specifies the maximum number of; /// pairs of load operations that may be substituted for a call to memcmp.; /// Targets must set this value based on the cost threshold for that target.; /// Targets should assume that the memcmp will be done using as many of the; /// largest load operations first, followed by smaller ones, if necessary, per; /// alignment restrictions. For example, loading 7 bytes on a 32-bit machine; /// with 32-bit alignment would result in one 4-byte load, a one 2-byte load; /// and one 1-byte load. This only applies to copying a constant array of; /// constant size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:37,load,load,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,7,['load'],"['load', 'loading']"
Performance,"/// \brief Start queue and worker loops on child processes; ///; /// This function exists purely because activation from the constructor is; /// impossible; the constructor must return a constructed instance, which it; /// can't do if it's stuck in an infinite loop. This means the Job that first; /// creates the JobManager instance must also activate it (or any other user; /// of this class).; /// This should be called soon after creation of instance, because everything; /// between construction and activation gets executed both on the master; /// process and on the slaves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/JobManager.cxx:17,queue,queue,17,roofit/multiprocess/src/JobManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/JobManager.cxx,1,['queue'],['queue']
Performance,"/// \brief The queue process's event loop; ///; /// Polls for incoming messages from other processes and handles them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Queue.cxx:15,queue,queue,15,roofit/multiprocess/src/Queue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Queue.cxx,1,['queue'],['queue']
Performance,"/// \brief The worker processes' event loop; ///; /// Asks the queue process for tasks, polls for incoming messages from other; /// processes and handles them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/worker.cxx:63,queue,queue,63,roofit/multiprocess/src/worker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/worker.cxx,1,['queue'],['queue']
Performance,"/// \brief This callback is invoked whenever the interpreter failed to load a library.; ///; /// \param[in] - Error message and parameters passed to loadLibrary; /// \returns true if the error was handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h:71,load,load,71,interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h,2,['load'],"['load', 'loadLibrary']"
Performance,"/// \brief Whether to perform a normal or minimal equivalence check.; /// In case of `Minimal`, we do not perform a recursive check of decls with; /// external storage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h:22,perform,perform,22,interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,2,['perform'],['perform']
Performance,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:7,Cache,CacheCost,7,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,8,"['Cache', 'cache']","['CacheCost', 'cache']"
Performance,"/// \class ProcessManager; /// \brief Fork processes for queue and workers; ///; /// This class manages three types of processes:; /// 1. master: the initial main process. It defines and enqueues tasks; /// and processes results.; /// 2. workers: a pool of processes that will try to take tasks from the; /// queue. These are forked from master.; /// 3. queue: This process runs the queue_loop and maintains the queue of; /// tasks. It is also forked from master.; ///; /// \param N_workers Number of worker processes to spawn.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/ProcessManager.cxx:57,queue,queue,57,roofit/multiprocess/src/ProcessManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/ProcessManager.cxx,4,['queue'],['queue']
Performance,"/// \cond ROOFIT_INTERNAL; /*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, NIKHEF, verkerke@nikhef.nl *; * *; * Copyright (c) 2000-2011, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooUnitTest.cxx; \class RooUnitTest; \ingroup Roofitcore. RooUnit test is an abstract base class for unit regression tests for; RooFit and RooStats tests performed in stressRooFit and stressRooStats; Implementations of this class must implement abstract method testCode(); which defines the regression test to be performed. Inside testCode(); the regression test can define objects on which the regression is performed.; These are:; Object | function; ----------------|------------; RooPlot | regPlot(); RooFitResult | regResult(); double | regValue(); RooTable | regTable(); TH1/2/3 | regTH(); RooWorkspace | regWS(); **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooUnitTest.cxx:819,perform,performed,819,roofit/roofitcore/src/RooUnitTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooUnitTest.cxx,3,['perform'],['performed']
Performance,"/// \defgroup DebuggerTuning Predicates to tune DWARF for a given debugger.; ///; /// Returns whether we are ""tuning"" for a given debugger.; /// @{",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:43,tune,tune,43,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,1,['tune'],['tune']
Performance,"/// \file EmptyInclude.h; /// \ingroup tutorial_proof; ///; /// Empty file to test TProof::Load in runProof.C and StressProof.cxx in; /// conjunction with ProcFileElements and ProofEventProc .; ///; /// \author Gerardo Ganis (gerardo.ganis@cern.ch)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/EmptyInclude.h:91,Load,Load,91,tutorials/proof/EmptyInclude.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/proof/EmptyInclude.h,1,['Load'],['Load']
Performance,"/// \file; /// - Project : TMVA - a Root-integrated toolkit for multivariate data analysis; /// - Package : TMVA; /// - Exectuable: TMVACrossValidation; ///; ///; /// Performs a verification that the cross evaluation splitting was performed as; /// intended. If the input data has ids (EventNumbers); ///; /// 0,1,2,3,4,5,6,7,8,9,10; ///; /// these will be split into e.g. 3 parts; ///; /// Part 0: 0,3,6,9; /// Part 1: 1,4,7,10; /// Part 2: 2,5,8; ///; /// This file verifies that each fold is calculated so that the test data for; /// each fold is equal to the equivalent part. That is the test set for fold 0; /// is part 0 and the train set is part 1 + part 2.; ///; /// Fold 0:; /// Train: 1,2,4,5,7,8,10,; /// Test : 0,3,6,9; ///; /// Et.c.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationSplitting.cxx:167,Perform,Performs,167,tmva/tmva/test/crossvalidation/TestCrossValidationSplitting.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/crossvalidation/TestCrossValidationSplitting.cxx,2,"['Perform', 'perform']","['Performs', 'performed']"
Performance,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:81,optimiz,optimized,81,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,1,['optimiz'],['optimized']
Performance,"/// \file; /// \ingroup tutorial_rcanvas; ///; /// This macro demonstrate usage of existing ROOT fonts for RText.; /// Also load of custom font is shown; ///; /// \macro_image (rcanvas_js); /// \macro_code; ///; /// \date 2021-07-07; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /// \author Sergey Linev <s.linev@gsi.de>; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/rtext_font.cxx:124,load,load,124,tutorials/rcanvas/rtext_font.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/rtext_font.cxx,1,['load'],['load']
Performance,"/// \file; /// \ingroup tutorial_rcanvas; ///; /// This macro shows how ROOT RCanvas::Update method is working.; /// One can do sync and/or async depending how important is that graphics is updated before next action will be performed; ///; /// \macro_image (rcanvas_js); /// \macro_code; ///; /// \date 2021-07-05; /// \warning This is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback; /// is welcome!; /// \author Sergey Linev <s.linev@gsi.de>; /*************************************************************************; * Copyright (C) 1995-2021, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/rcanvas_update.cxx:225,perform,performed,225,tutorials/rcanvas/rcanvas_update.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/rcanvas_update.cxx,1,['perform'],['performed']
Performance,"/// \file; /// \ingroup tutorial_webcanv; /// User class with custom JavaScript painter in the web canvas.; ///; /// Custom class is just triangle which drawn on the frame with NDC coordinates; /// `triangle.mjs` provides JavaScript code for object painting and interactivity; /// It is also possible to use such ""simple"" class without loading of custom JS code,; /// but then it requires appropriate Paint() method and will miss interactivity in browser; ///; /// This macro must be executed with ACLiC like 'root --web triangle.cxx+'; ///; /// \macro_image (tcanvas_jsp); /// \macro_code; ///; /// \author Sergey Linev",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/triangle.cxx:336,load,loading,336,tutorials/webcanv/triangle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/triangle.cxx,1,['load'],['loading']
Performance,"/// \file; /// \ingroup tutorial_webcanv; /// \notebook -js; /// Usage of TTF fonts in web canvas.; ///; /// One can load TTF font file and specify it for usage in the web canvas; /// Produced drawing also can be saved in PDF files.; ///; /// Functionality available only in web-based graphics; ///; /// \macro_image (tcanvas_js); /// \macro_code; ///; /// \author Sergey Linev",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/fonts_ttf.cxx:117,load,load,117,tutorials/webcanv/fonts_ttf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webcanv/fonts_ttf.cxx,1,['load'],['load']
Performance,"/// \file; /// \ingroup tutorial_webgui; /// \ingroup webwidgets; /// Test suite for RWebWindow communication performance; ///; /// On the first place latency of round-trip (ping-pong) packet is measured; /// File ping.cxx implements server-side code of RWebWindow; /// In ping.html client code plus visualization is provided.; ///; /// \macro_code; ///; /// \author Sergey Linev",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx:110,perform,performance,110,tutorials/webgui/ping/ping.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx,2,"['latency', 'perform']","['latency', 'performance']"
Performance,"/// \macro LLVM_PLUGIN_API_VERSION; /// Identifies the API version understood by this plugin.; ///; /// When a plugin is loaded, the driver will check it's supported plugin version; /// against that of the plugin. A mismatch is an error. The supported version; /// will be incremented for ABI-breaking changes to the \c PassPluginLibraryInfo; /// struct, i.e. when callbacks are added, removed, or reordered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h:121,load,loaded,121,interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,1,['load'],['loaded']
Performance,"/// \name CodeGen-relevant special data; /// Fields containing data that is relevant to CodeGen.; //@{; /// The IDs of all declarations that fulfill the criteria of; /// ""interesting"" decls.; ///; /// This contains the data loaded from all EAGERLY_DESERIALIZED_DECLS blocks; /// in the chain. The referenced declarations are deserialized and passed to; /// the consumer eagerly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:224,load,loaded,224,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// \name High-Level API; /// @{; /// Perform any late binding of symbols (for example, to assign symbol; /// indices for use when generating relocations).; ///; /// This routine is called by the assembler after layout and relaxation is; /// complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCObjectWriter.h:38,Perform,Perform,38,interpreter/llvm-project/llvm/include/llvm/MC/MCObjectWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCObjectWriter.h,1,['Perform'],['Perform']
Performance,"/// \name Name lookup; ///; /// These routines provide name lookup that is used during semantic; /// analysis to resolve the various kinds of names (identifiers,; /// overloaded operator names, constructor names, etc.) into zero or; /// more declarations within a particular scope. The major entry; /// points are LookupName, which performs unqualified name lookup,; /// and LookupQualifiedName, which performs qualified name lookup.; ///; /// All name lookup is performed based on some specific criteria,; /// which specify what names will be visible to name lookup and how; /// far name lookup should work. These criteria are important both; /// for capturing language semantics (certain lookups will ignore; /// certain names, for example) and for performance, since name; /// lookup is often a bottleneck in the compilation of C++. Name; /// lookup criteria is specified via the LookupCriteria enumeration.; ///; /// The results of name lookup can vary based on the kind of name; /// lookup performed, the current language, and the translation; /// unit. In C, for example, name lookup will either return nothing; /// (no entity found) or a single declaration. In C++, name lookup; /// can additionally refer to a set of overloaded functions or; /// result in an ambiguity. All of the possible results of name; /// lookup are captured by the LookupResult class, which provides; /// the ability to distinguish among them.; //@{; /// Describes the kind of name lookup to perform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:332,perform,performs,332,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,7,"['bottleneck', 'perform']","['bottleneck', 'perform', 'performance', 'performed', 'performs']"
Performance,"/// \p PassName is the name of the pass emitting this diagnostic. If this name; /// matches the regular expression given in -Rpass-analysis=, then the; /// diagnostic will be emitted. \p RemarkName is a textual identifier for the; /// remark (single-word, camel-case). \p Loc is the debug location and \p; /// CodeRegion is the region that the optimization operates on (currently only; /// block is supported).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:344,optimiz,optimization,344,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,"/// \p PassName is the name of the pass emitting this diagnostic. If this name; /// matches the regular expression given in -Rpass-analysis=, then the; /// diagnostic will be emitted. \p RemarkName is a textual identifier for the; /// remark (single-word, camel-case). \p Loc is the debug location and \p; /// CodeRegion is the region that the optimization operates on (currently only; /// block is supported). The front-end will append its own message related to; /// options that address floating-point non-commutativity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:344,optimiz,optimization,344,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,"/// \p PassName is the name of the pass emitting this diagnostic. If this name; /// matches the regular expression given in -Rpass-analysis=, then the; /// diagnostic will be emitted. \p RemarkName is a textual identifier for the; /// remark (single-word, camel-case). \p Loc is the debug location and \p; /// CodeRegion is the region that the optimization operates on (currently only; /// block is supported). The front-end will append its own message related to; /// options that address pointer aliasing legality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:344,optimiz,optimization,344,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,"/// \p PassName is the name of the pass emitting this diagnostic. If this name; /// matches the regular expression given in -Rpass-analysis=, then the; /// diagnostic will be emitted. \p RemarkName is a textual identifier for the; /// remark. \p Loc is the debug location and \p MBB is the block that the; /// optimization operates in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:310,optimiz,optimization,310,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,1,['optimiz'],['optimization']
Performance,"/// \p PassName is the name of the pass emitting this diagnostic. If this name; /// matches the regular expression given in -Rpass-missed=, then the; /// diagnostic will be emitted. \p RemarkName is a textual identifier for the; /// remark (single-word, camel-case). \p Loc is the debug location and \p; /// CodeRegion is the region that the optimization operates on (currently only; /// block is supported).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:342,optimiz,optimization,342,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,"/// \p PassName is the name of the pass emitting this diagnostic. If this name; /// matches the regular expression given in -Rpass-missed=, then the; /// diagnostic will be emitted. \p RemarkName is a textual identifier for the; /// remark. \p Loc is the debug location and \p MBB is the block that the; /// optimization operates in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:308,optimiz,optimization,308,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,1,['optimiz'],['optimization']
Performance,"/// \p PassName is the name of the pass emitting this diagnostic. If this name; /// matches the regular expression given in -Rpass=, then the diagnostic will; /// be emitted. \p RemarkName is a textual identifier for the remark (single-; /// word, camel-case). \p Loc is the debug location and \p CodeRegion is the; /// region that the optimization operates on (currently only block is; /// supported).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:336,optimiz,optimization,336,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,"/// \p PassName is the name of the pass emitting this diagnostic. If this name; /// matches the regular expression given in -Rpass=, then the diagnostic will; /// be emitted. \p RemarkName is a textual identifier for the remark. \p; /// Loc is the debug location and \p MBB is the block that the optimization; /// operates in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:296,optimiz,optimization,296,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,1,['optimiz'],['optimization']
Performance,"/// \p PassName is the name of the pass emitting this diagnostic. \p; /// RemarkName is a textual identifier for the remark (single-word,; /// camel-case). \p Fn is the function where the diagnostic is being emitted.; /// \p Loc is the location information to use in the diagnostic. If line table; /// information is available, the diagnostic will include the source code; /// location. \p CodeRegion is IR value (currently basic block) that the; /// optimization operates on. This is currently used to provide run-time; /// hotness information with PGO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:451,optimiz,optimization,451,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,"/// \p PassName is the name of the pass emitting this diagnostic. \p; /// RemarkName is a textual identifier for the remark (single-word,; /// camel-case). \p Loc is the debug location and \p CodeRegion is the; /// region that the optimization operates on (currently basic block is; /// supported).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:231,optimiz,optimization,231,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,/// \param Updates An ordered sequence of updates to perform. The current CFG; /// and the reverse of these updates provides the pre-view of the CFG.; /// \param PostViewUpdates An ordered sequence of update to perform in order; /// to obtain a post-view of the CFG. The DT will be updated assuming the; /// obtained PostViewCFG is the desired end state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTree.h:53,perform,perform,53,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTree.h,2,['perform'],['perform']
Performance,/// \param V loaded lvalue.; /// \return whether @c val is a string-like const global.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp:13,load,loaded,13,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NonnullGlobalConstantsChecker.cpp,1,['load'],['loaded']
Performance,"/// \return An upper bound for the vectorization factors (both fixed and; /// scalable). If the factors are 0, vectorization and interleaving should be; /// avoided up front.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:78,scalab,scalable,78,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['scalab'],['scalable']
Performance,"/// \return An upper bound for the vectorization factors for both; /// fixed and scalable vectorization, where the minimum-known number of; /// elements is a power-of-2 larger than zero. If scalable vectorization is; /// disabled or unsupported, then the scalable part will be equal to; /// ElementCount::getScalable(0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:81,scalab,scalable,81,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,3,['scalab'],['scalable']
Performance,/// \return How much before a load we should place the prefetch; /// instruction. This is currently measured in number of; /// instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:30,load,load,30,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,2,['load'],['load']
Performance,/// \return The alignment of the pointer used by this load/store/gather or; /// scatter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h:54,load,load,54,interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,1,['load'],['load']
Performance,"/// \return The associativity of the cache level, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:37,cache,cache,37,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['cache'],['cache']
Performance,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:96,Load,Load,96,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,3,"['Load', 'load']","['Load', 'load', 'loaded']"
Performance,/// \return The cost of Load and Store instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:24,Load,Load,24,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['Load'],['Load']
Performance,/// \return The cost of VP Load and Store instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:27,Load,Load,27,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['Load'],['Load']
Performance,"/// \return The cost of a shuffle instruction of kind Kind and of type Tp.; /// The exact mask may be passed as Mask, or else the array will be empty.; /// The index and subtype parameters are used by the subvector insertion and; /// extraction shuffle kinds to show the insert/extract point and the type of; /// the subvector being inserted/extracted. The operands of the shuffle can be; /// passed through \p Args, which helps improve the cost estimation in some; /// cases, like in broadcast loads.; /// NOTE: For subvector extractions Tp represents the source type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:495,load,loads,495,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['loads']
Performance,/// \return The cost of masked Load and Store instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:31,Load,Load,31,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['Load'],['Load']
Performance,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:249,load,load,249,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,2,['load'],['load']
Performance,/// \return The maximum interleave factor that any transform should try to; /// perform for this target. This number depends on the level of parallelism; /// and the number of execution units in the CPU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:80,perform,perform,80,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['perform'],['perform']
Performance,"/// \return The maximum number of iterations to prefetch ahead. If; /// the required number of iterations is more than this number, no; /// prefetching is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:155,perform,performed,155,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,2,['perform'],['performed']
Performance,"/// \return The minimum vectorization factor for types of given element; /// bit width, or 0 if there is no minimum VF. The returned value only; /// applies when shouldMaximizeVectorBandwidth returns true.; /// If IsScalable is true, the returned ElementCount must be a scalable VF.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:270,scalab,scalable,270,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['scalab'],['scalable']
Performance,"/// \return The pointer operand of this load,store, gather or scatter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,1,['load'],['load']
Performance,/// \return The size of a cache line in bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:26,cache,cache,26,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['cache'],['cache']
Performance,"/// \return The size of the cache level in bytes, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:28,cache,cache,28,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['cache'],['cache']
Performance,"/// \return The vector element size in bits to use when vectorizing the; /// expression tree ending at \p V. If V is a store, the size is the width of; /// the stored value. Otherwise, the size is the width of the largest loaded; /// value reaching V. This method is used by the vectorizer to calculate; /// vectorization factors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:222,load,loaded,222,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['loaded']
Performance,/// \return True if the last defined optimization level is -Ofast.; /// And False otherwise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:37,optimiz,optimization,37,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['optimiz'],['optimization']
Performance,/// \return True if the return type described by \p Outs can be returned; /// without performing sret demotion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:86,perform,performing,86,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,1,['perform'],['performing']
Performance,/// \return the alignment of the pointer used by this load/store/gather or; /// scatter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp:54,load,load,54,interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,1,['load'],['load']
Performance,"/// \return the maximum legal scalable VF, based on the safe max number; /// of elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:30,scalab,scalable,30,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['scalab'],['scalable']
Performance,/// \return the modified name for function \c F suitable to be; /// used as the key for IRPGO profile lookup. \c InLTO indicates if this is; /// called from LTO optimization passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:161,optimiz,optimization,161,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,1,['optimiz'],['optimization']
Performance,"/// \return the target-provided register class ID for the provided type,; /// accounting for type promotion and other type-legalization techniques that; /// the target might apply. However, it specifically does not account for the; /// scalarization or splitting of vector types. Should a vector type require; /// scalarization or splitting into multiple underlying vector registers, that; /// type should be mapped to a register class containing no registers.; /// Specifically, this is designed to provide a simple, high-level view of the; /// register allocation later performed by the backend. These register classes; /// don't necessarily map onto the register classes used by the backend.; /// FIXME: It's not currently possible to determine how many registers; /// are used by the provided type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:572,perform,performed,572,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['perform'],['performed']
Performance,/// \return the value of vscale to tune the cost model for.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:35,tune,tune,35,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['tune'],['tune']
Performance,/// \return true if either fixed- or scalable VF is a valid vector VF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:37,scalab,scalable,37,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,1,['scalab'],['scalable']
Performance,/// \return true if either fixed- or scalable VF is non-zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:37,scalab,scalable,37,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,1,['scalab'],['scalable']
Performance,/// \return true if scalable vectorization has been explicitly disabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:20,scalab,scalable,20,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['scalab'],['scalable']
Performance,/// \return true when scalable vectorization is preferred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,scalab,scalable,22,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['scalab'],['scalable']
Performance,/// \returns A bitmask that is true where the lane position is less-than \p; /// EVLParam; ///; /// \p Builder; /// Used for instruction creation.; /// \p VLParam; /// The explicit vector length parameter to test against the lane; /// positions.; /// \p ElemCount; /// Static (potentially scalable) number of vector elements.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp:289,scalab,scalable,289,interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandVectorPredication.cpp,1,['scalab'],['scalable']
Performance,"/// \returns If MUBUF instructions always perform range checking, even for; /// buffer resources used for private memory access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:42,perform,perform,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['perform'],['perform']
Performance,"/// \returns Load info if \p MI is a load operation, ""std::nullopt"" otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:13,Load,Load,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,2,"['Load', 'load']","['Load', 'load']"
Performance,/// \returns Loadcnt bit width,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp:13,Load,Loadcnt,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,1,['Load'],['Loadcnt']
Performance,/// \returns The bitwidth of the largest vector type that should be used to; /// load/store in the given address space.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:81,load,load,81,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,/// \returns The new vector factor value if the target doesn't support \p; /// SizeInBytes loads or has a better vector factor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:91,load,loads,91,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['loads']
Performance,"/// \returns The register class to be used for loading and storing values; /// from an ""Indirect Address"" .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h:47,load,loading,47,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,1,['load'],['loading']
Performance,/// \returns True if it is legal to vectorize the given load chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:56,load,load,56,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,/// \returns True if the given type is supported for scalable vectors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,scalab,scalable,53,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['scalab'],['scalable']
Performance,/// \returns True if the instruction is not a volatile or atomic load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:65,load,load,65,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['load']
Performance,/// \returns True if the load instruction is legal to vectorize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:25,load,load,25,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,/// \returns True if the specified indexed load for the given type is legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:43,load,load,43,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,/// \returns True if the target supports scalable vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:41,scalab,scalable,41,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['scalab'],['scalable']
Performance,/// \returns \p Loadcnt and \p Dscnt components of \p Decoded encoded as an; /// immediate that can be used with S_WAIT_LOADCNT_DSCNT for given isa; /// \p Version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h:16,Load,Loadcnt,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.h,1,['Load'],['Loadcnt']
Performance,"/// \returns a list of candidate directories for ROCm installation, which is; /// cached and populated only once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp:82,cache,cached,82,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,1,['cache'],['cached']
Performance,/// \returns shift for Loadcnt/Storecnt in combined S_WAIT instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp:23,Load,Loadcnt,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUBaseInfo.cpp,1,['Load'],['Loadcnt']
Performance,/// \returns the \c ExecutorAddr of a \c GlobalDecl. This interface uses; /// the CodeGenModule's internal mangling cache to avoid recomputing the; /// mangled name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h:116,cache,cache,116,interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h,1,['cache'],['cache']
Performance,"/// \returns the compare predicate type if the test performed by; /// llvm.is.fpclass(x, \p Mask) is equivalent to fcmp o__ x, 0.0 with the; /// floating-point environment assumed for \p F for type \p Ty",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:52,perform,performed,52,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['perform'],['performed']
Performance,/// \returns the index where the substitution is to be performed in RegExStr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:55,perform,performed,55,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['perform'],['performed']
Performance,/// \returns true if LSR should not optimize a chain that includes \p I.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,optimiz,optimize,36,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['optimiz'],['optimize']
Performance,"/// \returns true if \p Def is a no-op store, either because it; /// directly stores back a loaded value or stores zero to a calloced object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:92,load,loaded,92,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['load'],['loaded']
Performance,/// \returns true if \p Opcode is an optimization hint opcode which is not; /// supposed to appear after ISel.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetOpcodes.h:37,optimiz,optimization,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetOpcodes.h,1,['optimiz'],['optimization']
Performance,/// \returns true if the load \p MI is likely loading from a floating-point; /// type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.h:25,load,load,25,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64RegisterBankInfo.h,2,['load'],"['load', 'loading']"
Performance,"/// \returns true if the target uses LOADcnt/SAMPLEcnt/BVHcnt, DScnt/KMcnt; /// and STOREcnt rather than VMcnt, LGKMcnt and VScnt respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:37,LOAD,LOADcnt,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['LOAD'],['LOADcnt']
Performance,/// \{; /// Cache of macro expanders to reduce malloc traffic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:12,Cache,Cache,12,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['Cache'],['Cache']
Performance,"/// \}; /// Collect debug info quality metrics for an entire DIContext.; ///; /// Do the impossible and reduce the quality of the debug info down to a few; /// numbers. The idea is to condense the data into numbers that can be tracked; /// over time to identify trends in newer compiler versions and gauge the effect; /// of particular optimizations. The raw numbers themselves are not particularly; /// useful, only the delta between compiling the same program with different; /// compilers is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:336,optimiz,optimizations,336,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,1,['optimiz'],['optimizations']
Performance,/// \}; /// Keeps macro expanded tokens for TokenLexers.; //; /// Works like a stack; a TokenLexer adds the macro expanded tokens that is; /// going to lex in the cache and when it finishes the tokens are removed; /// from the end of the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:163,cache,cache,163,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,2,['cache'],['cache']
Performance,"/// `LoadStructureImpl()` has been called before `AttachImpl()` is called",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:5,Load,LoadStructureImpl,5,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['Load'],['LoadStructureImpl']
Performance,/// addArchive - Add an Archive to the execution engine.; ///; /// This method is only supported by MCJIT. MCJIT will use the archive to; /// resolve external symbols in objects it is loading. If a symbol is found; /// in the Archive the contained object file will be extracted (in memory); /// and loaded for possible execution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:184,load,loading,184,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,2,['load'],"['loaded', 'loading']"
Performance,/// addMachineSSAOptimization - Add standard passes that optimize machine; /// instructions in SSA form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:57,optimiz,optimize,57,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['optimiz'],['optimize']
Performance,/// addObjectFile - Add an ObjectFile to the execution engine.; ///; /// This method is only supported by MCJIT. MCJIT will immediately load the; /// object into memory and adds its symbols to the list used to resolve; /// external symbols while preparing other objects for execution.; ///; /// Objects added using this function will not be made executable until; /// needed by another object.; ///; /// MCJIT will take ownership of the ObjectFile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:136,load,load,136,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['load'],['load']
Performance,/// addPostFastRegAllocRewrite - Add passes to the optimized register; /// allocation pipeline after fast register allocation is complete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:51,optimiz,optimized,51,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['optimiz'],['optimized']
Performance,"/// addPreRewrite - Add passes to the optimized register allocation pipeline; /// after register allocation is complete, but before virtual registers are; /// rewritten to physical registers.; ///; /// These passes must preserve VirtRegMap and LiveIntervals, and when running; /// after RABasic or RAGreedy, they should take advantage of LiveRegMatrix.; /// When these passes run, VirtRegMap contains legal physreg assignments for; /// all virtual registers.; ///; /// Note if the target overloads addRegAssignAndRewriteOptimized, this may not; /// be honored. This is also not generally used for the fast variant,; /// where the allocation and rewriting are done in one pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:38,optimiz,optimized,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['optimiz'],['optimized']
Performance,/// areLoadsFromSameBasePtr - This is used by the pre-regalloc scheduler to; /// determine if two loads are loading from the same base address. It should; /// only return true if the base pointers are the same and the only differences; /// between the two addresses is the offset. It also returns the offsets by; /// reference.; ///; /// FIXME: remove this in favor of the MachineInstr interface once pre-RA-sched; /// is permanently disabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:98,load,loads,98,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,2,['load'],"['loading', 'loads']"
Performance,/// areLoadsFromSameBasePtr - This is used by the pre-regalloc scheduler to; /// determine if two loads are loading from the same base address. It should; /// only return true if the base pointers are the same and the only; /// differences between the two addresses is the offset. It also returns the; /// offsets by reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:98,load,loads,98,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,2,['load'],"['loading', 'loads']"
Performance,/// areLoadsFromSameBasePtr - This is used by the pre-regalloc scheduler; /// to determine if two loads are loading from the same base address. It; /// should only return true if the base pointers are the same and the; /// only differences between the two addresses are the offset. It also returns; /// the offsets by reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:98,load,loads,98,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,2,['load'],"['loading', 'loads']"
Performance,"/// array_pod_sort - This sorts an array with the specified start and end; /// extent. This is just like std::sort, except that it calls qsort instead of; /// using an inlined template. qsort is slightly slower than std::sort, but; /// most sorts are not performance critical in LLVM and std::sort has to be; /// template instantiated for each type, leading to significant measured code; /// bloat. This function should generally be used instead of std::sort where; /// possible.; ///; /// This function assumes that you have simple POD-like types that can be; /// compared with std::less and can be moved with memcpy. If this isn't true,; /// you should use std::sort.; ///; /// NOTE: If qsort_r were portable, we could allow a custom comparator and; /// default to std::less.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:255,perform,performance,255,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['perform'],['performance']
Performance,/// brief A function argument from which we performed template argument; // deduction for a call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:44,perform,performed,44,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performed']
Performance,"/// build_pair (load, load) -> load; /// if load locations are consecutive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,['load'],['load']
Performance,/// capacity - Returns the number of nodes permitted in the folding set; /// before a rebucket operation is performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:108,perform,performed,108,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['perform'],['performed']
Performance,"/// checkBuiltinArgument - Given a call to a builtin function, perform; /// normal type-checking on the given argument, updating the call in; /// place. This is useful when a builtin function requires custom; /// type-checking for some of its arguments but not necessarily all of; /// them.; ///; /// Returns true on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:63,perform,perform,63,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['perform'],['perform']
Performance,"/// cleanup - After running all passes, clean up pass manager cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:62,cache,cache,62,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,1,['cache'],['cache']
Performance,/// clear - Empty the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,cache,cache,22,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['cache'],['cache']
Performance,/// clear - Erase all elements from the queue.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:40,queue,queue,40,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,1,['queue'],['queue']
Performance,/// clearKillFlags - Iterate over all the uses of the given register and; /// clear the kill flag from the MachineOperand. This function is used by; /// optimization passes which extend register lifetimes and need only; /// preserve conservative kill flag information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:153,optimiz,optimization,153,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,2,['optimiz'],['optimization']
Performance,/// computeLatency - Compute node latency.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h:34,latency,latency,34,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,1,['latency'],['latency']
Performance,"/// computeMOFlags - Given a node N and it's Parent (a MemSDNode), compute; /// the address flags of the load/store instruction that is to be matched.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:105,load,load,105,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['load']
Performance,"/// computeMOFlags - Given a node N and it's Parent (a MemSDNode), compute; /// the address flags of the load/store instruction that is to be matched.; /// The address flags are stored in a map, which is then searched; /// through to determine the optimal load/store instruction format.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:105,load,load,105,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,2,['load'],['load']
Performance,"/// convertToThreeAddress - This method must be implemented by targets that; /// set the M_CONVERTIBLE_TO_3_ADDR flag. When this flag is set, the target; /// may be able to convert a two-address instruction into a true; /// three-address instruction on demand. This allows the X86 target (for; /// example) to convert ADD and SHL instructions into LEA instructions if they; /// would require register copies due to two-addressness.; ///; /// This method returns a null pointer if the transformation cannot be; /// performed, otherwise it returns the new instruction.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:514,perform,performed,514,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,1,['perform'],['performed']
Performance,"/// createGCEmptyBasicblocksPass - Empty basic blocks (basic blocks without; /// real code) appear as the result of optimization passes removing; /// instructions. These blocks confuscate profile analysis (e.g., basic block; /// sections) since they will share the address of their fallthrough blocks.; /// This pass garbage-collects such basic blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:116,optimiz,optimization,116,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['optimiz'],['optimization']
Performance,/// createHybridListDAGScheduler - This creates a bottom up register pressure; /// aware list scheduler that make use of latency information to avoid stalls; /// for long latency instructions in low register pressure mode. In high; /// register pressure mode it schedules to reduce register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:121,latency,latency,121,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,2,['latency'],['latency']
Performance,/// createRISCVPushPopOptimizationPass - returns an instance of the; /// Push/Pop optimization pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:82,optimiz,optimization,82,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,1,['optimiz'],['optimization']
Performance,/// createTargetRegisterAllocator - Create the register allocator pass for; /// this target at the current optimization level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:107,optimiz,optimization,107,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['optimiz'],['optimization']
Performance,"/// debugOptimizerCrash - This method is called when some optimizer pass; /// crashes on input. It attempts to prune down the testcase to something; /// reasonable, and figure out exactly which pass is crashing.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:58,optimiz,optimizer,58,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['optimiz'],['optimizer']
Performance,"/// doInitialPlacement - Perform the initial placement of the constant pool; /// entries. To start with, we put them all at the end of the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:25,Perform,Perform,25,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,2,['Perform'],['Perform']
Performance,"/// emitDestroy - Immediately perform the destruction of the given; /// object.; ///; /// \param addr - the address of the object; a type*; /// \param type - the type of the object; if an array type, all; /// objects are destroyed in reverse order; /// \param destroyer - the function to call to destroy individual; /// elements; /// \param useEHCleanupForArray - whether an EH cleanup should be; /// used when destroying array elements, in case one of the; /// destructions throws an exception",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:30,perform,perform,30,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['perform'],['perform']
Performance,/// emitInstructionSpecifier - Loads the instruction specifier for the current; /// instruction into a DisassemblerTables.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.h:31,Load,Loads,31,interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.h,1,['Load'],['Loads']
Performance,/// emitLoadConstPool - Emits a load from constpool to materialize the; /// specified immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp:32,load,load,32,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseRegisterInfo.cpp,4,['load'],['load']
Performance,/// emitStructGetterCall - Call the runtime function to load a property; /// into the return value slot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:56,load,load,56,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['load'],['load']
Performance,"/// emitThumbRegPlusImmInReg - Emits a series of instructions to materialize a; /// destreg = basereg + immediate in Thumb code. Materialize the immediate in a; /// register using mov / mvn (armv6-M >) sequences, movs / lsls / adds / lsls /; /// adds / lsls / adds sequences (armv6-M) or load the immediate from a; /// constpool entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp:288,load,load,288,interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ThumbRegisterInfo.cpp,1,['load'],['load']
Performance,/// enqueue - Add VirtReg to the priority queue of unassigned registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:42,queue,queue,42,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,2,['queue'],['queue']
Performance,"/// equivalentAddressValues - Test if A and B will obviously have the same; /// value. This includes recognizing that %t0 and %t1 will have the same; /// value in code like this:; /// %t0 = getelementptr \@a, 0, 3; /// store i32 0, i32* %t0; /// %t1 = getelementptr \@a, 0, 3; /// %t2 = load i32* %t1; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:287,load,load,287,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['load'],['load']
Performance,"/// erase_one - Erase one element from the queue, regardless of its; /// position. This operation performs a linear search to find an element; /// equal to t, but then uses all logarithmic-time algorithms to do; /// the erase operation.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:43,queue,queue,43,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,2,"['perform', 'queue']","['performs', 'queue']"
Performance,"/// establishNestingLevels - Examines the loop nesting of the Src and Dst; /// instructions and establishes their shared loops. Sets the variables; /// CommonLevels, SrcLevels, and MaxLevels.; /// The source and destination instructions needn't be contained in the same; /// loop. The routine establishNestingLevels finds the level of most deeply; /// nested loop that contains them both, CommonLevels. An instruction that's; /// not contained in a loop is at level = 0. MaxLevels is equal to the level; /// of the source plus the level of the destination, minus CommonLevels.; /// This lets us allocate vectors MaxLevels in length, with room for every; /// distinct loop referenced in both the source and destination subscripts.; /// The variable SrcLevels is the nesting depth of the source instruction.; /// It's used to help calculate distinct loops referenced by the destination.; /// Here's the map from loops to levels:; /// 0 - unused; /// 1 - outermost common loop; /// ... - other common loops; /// CommonLevels - innermost common loop; /// ... - loops containing Src but not Dst; /// SrcLevels - innermost loop containing Src but not Dst; /// ... - loops containing Dst but not Src; /// MaxLevels - innermost loop containing Dst but not Src; /// Consider the follow code fragment:; /// for (a = ...) {; /// for (b = ...) {; /// for (c = ...) {; /// for (d = ...) {; /// A[] = ...;; /// }; /// }; /// for (e = ...) {; /// for (f = ...) {; /// for (g = ...) {; /// ... = A[];; /// }; /// }; /// }; /// }; /// }; /// If we're looking at the possibility of a dependence between the store; /// to A (the Src) and the load from A (the Dst), we'll note that they; /// have 2 loops in common, so CommonLevels will equal 2 and the direction; /// vector for Result will have 2 entries. SrcLevels = 4 and MaxLevels = 7.; /// A map from loop names to level indices would look like; /// a - 1; /// b - 2 = CommonLevels; /// c - 3; /// d - 4 = SrcLevels; /// e - 5; /// f - 6; /// g - 7 = MaxLevels",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1623,load,load,1623,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['load'],['load']
Performance,"/// evaluate function using the cached parameter values (of TF1); /// re-implement for better efficiency",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedMultiTF1.h:32,cache,cached,32,hist/hist/inc/Math/WrappedMultiTF1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedMultiTF1.h,3,['cache'],['cached']
Performance,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:987,optimiz,optimization,987,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,2,['optimiz'],['optimization']
Performance,"/// finalizeObject - ensure the module is fully processed and is usable.; ///; /// It is the user-level function for completing the process of making the; /// object usable for execution. It should be called after sections within an; /// object have been relocated using mapSectionAddress. When this method is; /// called the MCJIT execution engine will reapply relocations for a loaded; /// object. This method has no effect for the interpreter.; ///; /// Returns true on success, false on failure. Error messages can be retrieved; /// by calling getError();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:380,load,loaded,380,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['load'],['loaded']
Performance,"/// finalizeObject - ensure the module is fully processed and is usable.; ///; /// It is the user-level function for completing the process of making the; /// object usable for execution. It should be called after sections within an; /// object have been relocated using mapSectionAddress. When this method is; /// called the MCJIT execution engine will reapply relocations for a loaded; /// object.; /// Is it OK to finalize a set of modules, add modules and finalize again.; // FIXME: Do we really need both of these?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:380,load,loaded,380,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,1,['load'],['loaded']
Performance,"/// findResourceDir finds the resource directory relative to the clang; /// compiler being used in Args, by running it with ""-print-resource-dir""; /// option and cache the results for reuse. \returns resource directory path; /// associated with the given invocation command or empty string if the; /// compiler path is NOT an absolute path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:162,cache,cache,162,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,1,['cache'],['cache']
Performance,"/// findValue - Look through bitcasts and simple memory reference patterns; /// to identify an equivalent, but more informative, value. If OffsetOk; /// is true, look through getelementptrs with non-zero offsets too.; ///; /// Most analysis passes don't require this logic, because instcombine; /// will simplify most of these kinds of things away. But it's a goal of; /// this Lint pass to be useful even on non-optimized IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:413,optimiz,optimized,413,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,1,['optimiz'],['optimized']
Performance,"/// flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h:40,perform,perform,40,math/mathcore/inc/Math/Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h,1,['perform'],['perform']
Performance,"/// foldAsLoad - If LI has a single use and a single def that can be folded as; /// a load, eliminate the register by folding the def into the use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:86,load,load,86,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,1,['load'],['load']
Performance,"/// foldMemoryOperand - If this target supports it, fold a load or store of; /// the specified stack slot into the specified machine instruction for the; /// specified operand(s). If this is possible, the target should perform the; /// folding and return true, otherwise it should return false. If it folds; /// the instruction, it is likely that the MachineInstruction the iterator; /// references has been changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:59,load,load,59,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,2,"['load', 'perform']","['load', 'perform']"
Performance,"/// foldMemoryOperand - Same as the previous version except it allows folding; /// of any load and store from / to any address, not just from a specific; /// stack slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:90,load,load,90,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,1,['load'],['load']
Performance,/// foldMemoryOperand - Try folding stack slot references in Ops into their; /// instructions.; ///; /// @param Ops Operand indices from AnalyzeVirtRegInBundle().; /// @param LoadMI Load instruction to use instead of stack slot when non-null.; /// @return True on success.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:175,Load,LoadMI,175,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,2,['Load'],"['Load', 'LoadMI']"
Performance,/// forceUnitLatencies - Register-pressure-reducing scheduling doesn't; /// need actual latency information but the hybrid scheduler does.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:88,latency,latency,88,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['latency'],['latency']
Performance,"/// function signature for waiting call-backs; /// Such callback used when calling thread need to waits for some special data,; /// but wants to run application event loop; /// As argument, spent time in second will be provided; /// Waiting will be performed until function returns non-zero value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindow.hxx:249,perform,performed,249,gui/webdisplay/inc/ROOT/RWebWindow.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindow.hxx,1,['perform'],['performed']
Performance,"/// function to set a global flag in RooStats to use NLL offset when performing nll computations; /// Note that not all ROoStats tools implement this capabilities",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/RooStatsUtils.h:69,perform,performing,69,roofit/roostats/inc/RooStats/RooStatsUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/RooStatsUtils.h,1,['perform'],['performing']
Performance,"/// generateCodeForModule - Run code generation for the specified module and; /// load it into memory.; ///; /// When this function has completed, all code and data for the specified; /// module, and any module on which this module depends, will be generated; /// and loaded into memory, but relocations will not yet have been applied; /// and all memory will be readable and writable but not executable.; ///; /// This function is primarily useful when generating code for an external; /// target, allowing the client an opportunity to remap section addresses; /// before relocations are applied. Clients that intend to execute code; /// locally can use the getFunctionAddress call, which will generate code; /// and apply final preparations all in one step.; ///; /// This method has no effect for the interpreter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:82,load,load,82,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,2,['load'],"['load', 'loaded']"
Performance,"/// getAnalysisIfAvailable<AnalysisType>() - Subclasses use this function to; /// get analysis information that might be around, for example to update it.; /// This is different than getAnalysis in that it can fail (if the analysis; /// results haven't been computed), so should only be used if you can handle; /// the case when the analysis is not available. This method is often used by; /// transformation APIs to update analysis results for a pass automatically as; /// the transform is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:491,perform,performed,491,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,2,['perform'],['performed']
Performance,"/// getArgsForToolChain - Return the derived argument list for the; /// tool chain \p TC (or the default tool chain, if TC is not specified).; /// If a device offloading kind is specified, a translation specific for that; /// kind is performed, if any.; ///; /// \param BoundArch - The bound architecture name, or 0.; /// \param DeviceOffloadKind - The offload device kind that should be used in; /// the translation, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h:234,perform,performed,234,interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,1,['perform'],['performed']
Performance,/// getConstantArrayInfoInChars - Performing the computation in CharUnits; /// instead of in bits prevents overflowing the uint64_t for some large arrays.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:34,Perform,Performing,34,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['Perform'],['Performing']
Performance,/// getExtendImm - Encode the extend type and amount for a load/store inst:; /// doshift: should the offset be scaled by the access size; /// shifter: 000 ==> uxtb; /// 001 ==> uxth; /// 010 ==> uxtw; /// 011 ==> uxtx; /// 100 ==> sxtb; /// 101 ==> sxth; /// 110 ==> sxtw; /// 111 ==> sxtx; /// {3-1} = shifter; /// {0} = doshift,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AddressingModes.h:59,load,load,59,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AddressingModes.h,1,['load'],['load']
Performance,/// getExtendType - Extract the extend type for the offset operand of; /// loads/stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AddressingModes.h:75,load,loads,75,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AddressingModes.h,1,['load'],['loads']
Performance,"/// getFunctionParamOptimizedAlign - since function arguments are passed via; /// .param space, we may want to increase their alignment in a way that; /// ensures that we can effectively vectorize their loads & stores. We can; /// increase alignment only if the function has internal or has private; /// linkage as for other linkage types callers may already rely on default; /// alignment. To allow using 128-bit vectorized loads/stores, this function; /// ensures that alignment is 16 or greater.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:203,load,loads,203,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,4,['load'],['loads']
Performance,/// getInstNamespace - Find and return the target machine's instruction; /// namespace. The namespace is cached because it is requested multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenTarget.cpp:105,cache,cached,105,interpreter/llvm-project/llvm/utils/TableGen/CodeGenTarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenTarget.cpp,1,['cache'],['cached']
Performance,"/// getInstrTimingClassLatency - Compute the instruction latency of a given; /// instruction using Timing Class information, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:57,latency,latency,57,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,1,['latency'],['latency']
Performance,/// getLdStSORegOpValue - Return encoding info for 'reg +/- reg shop imm'; /// operand as needed by load/store instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:100,load,load,100,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,1,['load'],['load']
Performance,"/// getLdStUImm12OpValue - Return encoding info for 12-bit unsigned immediate; /// attached to a load, store or prfm instruction. If operand requires a; /// relocation, record it and return zero in that part of the encoding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCCodeEmitter.cpp:97,load,load,97,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCCodeEmitter.cpp,1,['load'],['load']
Performance,/// getLdStmModeOpValue - Return encoding for load/store multiple mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:46,load,load,46,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,1,['load'],['load']
Performance,/// getLoadLiteralOpValue - Return the encoded value for a load-literal; /// pc-relative address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCCodeEmitter.cpp:59,load,load-literal,59,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCCodeEmitter.cpp,2,['load'],['load-literal']
Performance,/// getMappedIdxOpcForImmOpc - Return the mapped index form load/store opcode; /// for a given imm form load/store opcode \p ImmFormOpcode.; /// FIXME: move this to PPCInstrInfo class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h:60,load,load,60,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.h,2,['load'],['load']
Performance,/// getMaxCursors - Return the maximum number of concurrent cursors that can; /// be supported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:49,concurren,concurrent,49,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,1,['concurren'],['concurrent']
Performance,"/// getMemDoShift - Extract the ""do shift"" flag value for load/store; /// instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AddressingModes.h:58,load,load,58,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64AddressingModes.h,1,['load'],['load']
Performance,"/// getMemExtendOpValue - Return the encoded value for a reg-extend load/store; /// instruction: bit 0 is whether a shift is present, bit 1 is whether the; /// operation is a sign extend (as opposed to a zero extend).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCCodeEmitter.cpp:68,load,load,68,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64MCCodeEmitter.cpp,1,['load'],['load']
Performance,/// getNeonEltType - Return the QualType corresponding to the elements of; /// the vector type specified by the NeonTypeFlags. This is used to check; /// the pointer arguments for Neon load/store intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:185,load,load,185,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['load'],['load']
Performance,"/// getOpcodeAfterMemoryUnfold - Returns the opcode of the would be new; /// instruction after load / store are unfolded from an instruction of the; /// specified opcode. It returns zero if the specified unfolding is not; /// possible. If LoadRegIndex is non-null, it is filled in with the operand; /// index of the operand which will hold the register holding the loaded; /// value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:95,load,load,95,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,3,"['Load', 'load']","['LoadRegIndex', 'load', 'loaded']"
Performance,"/// getOperandLatency - Compute and return the use operand latency of a given; /// pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overriden by; /// a target. Use computeOperandLatency to get the best estimate of latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:59,latency,latency,59,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,6,['latency'],['latency']
Performance,"/// getPostIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:167,load,load,167,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,6,['load'],['load']
Performance,"/// getPreIndexedAddressParts - returns true by value, base pointer and; /// offset pointer and addressing mode by reference if the node's address; /// can be legally represented as pre-indexed load / store address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:194,load,load,194,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,4,['load'],['load']
Performance,"/// getPreferredTypeAlign - Return the ""preferred"" alignment of the specified; /// type for the current target in bits. This can be different than the ABI; /// alignment in cases where it is beneficial for performance or backwards; /// compatibility preserving to overalign a data type. (Note: despite the name,; /// the preferred alignment is ABI-impacting, and not an optimization.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:206,perform,performance,206,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"/// getPreferredVectorAction - The code we generate when vector types are; /// legalized by promoting the integer element type is often much worse; /// than code we generate if we widen the type for applicable vector types.; /// The issue with promoting is that the vector is scalaraized, individual; /// elements promoted and then the vector is rebuilt. So say we load a pair; /// of v4i8's and shuffle them. This will turn into a mess of 8 extending; /// loads, moves back into VSR's (or memory ops if we don't have moves) and; /// then the VPERM for the shuffle. All in all a very slow sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:365,load,load,365,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,2,['load'],"['load', 'loads']"
Performance,"/// getPrimaryContext - There may be many different; /// declarations of the same entity (including forward declarations; /// of classes, multiple definitions of namespaces, etc.), each with; /// a different set of declarations. This routine returns the; /// ""primary"" DeclContext structure, which will contain the; /// information needed to perform name lookup into this context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:342,perform,perform,342,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['perform'],['perform']
Performance,"/// getProcessTriple() - Return an appropriate target triple for generating; /// code to be loaded into the current process, e.g. when using the JIT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Host.h:92,load,loaded,92,interpreter/llvm-project/llvm/include/llvm/TargetParser/Host.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Host.h,1,['load'],['loaded']
Performance,/// getScalableVectorType - Return the unique reference to a scalable vector; /// type of the specified element type and size. VectorType must be a built-in; /// type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:61,scalab,scalable,61,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['scalab'],['scalable']
Performance,"/// getSplitIteration - Give a dependence that's splittable at some; /// particular level, return the iteration that should be used to split; /// the loop.; ///; /// Generally, the dependence analyzer will be used to build; /// a dependence graph for a function (basically a map from instructions; /// to dependences). Looking for cycles in the graph shows us loops; /// that cannot be trivially vectorized/parallelized.; ///; /// We can try to improve the situation by examining all the dependences; /// that make up the cycle, looking for ones we can break.; /// Sometimes, peeling the first or last iteration of a loop will break; /// dependences, and there are flags for those possibilities.; /// Sometimes, splitting a loop at some other iteration will do the trick,; /// and we've got a flag for that case. Rather than waste the space to; /// record the exact iteration (since we rarely know), we provide; /// a method that calculates the iteration. It's a drag that it must work; /// from scratch, but wonderful in that it's possible.; ///; /// Here's an example:; ///; /// for (i = 0; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// There's a loop-carried flow dependence from the store to the load,; /// found by the weak-crossing SIV test. The dependence will have a flag,; /// indicating that the dependence can be broken by splitting the loop.; /// Calling getSplitIteration will return 5.; /// Splitting the loop breaks the dependence, like so:; ///; /// for (i = 0; i <= 5; i++); /// A[i] = ...; /// ... = A[11 - i]; /// for (i = 6; i < 10; i++); /// A[i] = ...; /// ... = A[11 - i]; ///; /// breaks the dependence and allows us to vectorize/parallelize; /// both loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:1214,load,load,1214,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['load'],['load']
Performance,/// getStackArgumentTokenFactor - Compute a TokenFactor to force all; /// the incoming stack arguments to be loaded from the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:109,load,loaded,109,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['load'],['loaded']
Performance,"/// getStatValue - Get the 'stat' information for the specified path,; /// using the cache to accelerate it if possible. This returns true; /// if the path points to a virtual file or does not exist, or returns; /// false if it's an existent real file. If FileDescriptor is NULL,; /// do directory look-up instead of file look-up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:85,cache,cache,85,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['cache'],['cache']
Performance,/// getTgtMemIntrinsic - Represent NEON load and store intrinsics as; /// MemIntrinsicNodes. The associated MachineMemOperands record the alignment; /// specified in the intrinsic calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['load'],['load']
Performance,"/// gold informs us that all symbols have been read. At this point, we use; /// get_symbols to see if any of our definitions have been overridden by a; /// native object file. Then, perform optimization and codegen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:182,perform,perform,182,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,/// handleTargetFeatures - Perform initialization based on the user; /// configured set of features.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp:27,Perform,Perform,27,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.cpp,2,['Perform'],['Perform']
Performance,/// hasCachedDigest - Returns true if the digest for this tree is cached.; /// This can only be true if the tree is immutable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:66,cache,cached,66,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,1,['cache'],['cached']
Performance,"/// hasNormalLoadOperand - Check if any of the operands of a BUILD_VECTOR node; /// are normal, non-volatile loads. If so, it is profitable to bitcast an; /// i64 vector to have f64 elements, since the value can then be loaded; /// directly into a VFP register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:109,load,loads,109,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['load'],"['loaded', 'loads']"
Performance,"/// helper method for clearing the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ToyMCImportanceSampler.h:35,cache,cache,35,roofit/roostats/inc/RooStats/ToyMCImportanceSampler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ToyMCImportanceSampler.h,2,['cache'],['cache']
Performance,/// init - Prepare cache for a new function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:19,cache,cache,19,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,1,['cache'],['cache']
Performance,"/// initialize the calculator by performing a global fit and make the Asimov data set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/AsymptoticCalculator.h:33,perform,performing,33,roofit/roostats/inc/RooStats/AsymptoticCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/AsymptoticCalculator.h,1,['perform'],['performing']
Performance,"/// initializePass - This method may be overriden by immutable passes to allow; /// them to perform various initialization actions they require. This is; /// primarily because an ImmutablePass can ""require"" another ImmutablePass,; /// and if it does, the overloaded version of initializePass may get access to; /// these passes with getAnalysis<>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:92,perform,perform,92,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,1,['perform'],['perform']
Performance,"/// initializeSubtargetDependencies - Initializes using a CPU, a TuneCPU, and; /// feature string so that we can use initializer lists for subtarget; /// initialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h:65,Tune,TuneCPU,65,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCSubtarget.h,1,['Tune'],['TuneCPU']
Performance,/// isCXX11ConstantExpr - Return true if this expression is a constant; /// expression in C++11. Can only be used in C++.; ///; /// Note: This does not perform the implicit conversions required by C++11; /// [expr.const]p5.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:152,perform,perform,152,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['perform'],['perform']
Performance,/// isDereferenceableInvariantLoad - Return true if this instruction will never; /// trap and is loading from a location whose value is invariant across a run of; /// this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:97,load,loading,97,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['load'],['loading']
Performance,/// isEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h:94,optimiz,optimization,94,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.h,1,['optimiz'],['optimization']
Performance,/// isEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization.; /// Note: This is modelled after ARM's IsEligibleForTailCallOptimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:94,optimiz,optimization,94,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['optimiz'],['optimization']
Performance,/// isEqual - Compares two trees for structural equality and returns true; /// if they are equal. This worst case performance of this operation is; // linear in the sizes of the trees.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:114,perform,performance,114,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,1,['perform'],['performance']
Performance,"/// isFPImmLegal - Returns true if the target can instruction select the; /// specified FP immediate natively. If false, the legalizer will; /// materialize the FP immediate as a load from a constant pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:179,load,load,179,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,5,['load'],['load']
Performance,"/// isIntegerConstantExpr - Return the value if this expression is a valid; /// integer constant expression. If not a valid i-c-e, return std::nullopt; /// and fill in Loc (if specified) with the location of the invalid; /// expression.; ///; /// Note: This does not perform the implicit conversions required by C++11; /// [expr.const]p5.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:267,perform,perform,267,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['perform'],['perform']
Performance,/// isLegalAddressImmediate - Return true if the integer value can be used; /// as the offset of the target addressing mode for load / store of the; /// given type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:128,load,load,128,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['load']
Performance,"/// isLegalAddressingMode - Return true if the addressing mode represented by; /// AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:118,load,load,118,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['load'],['load']
Performance,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:118,load,load,118,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,5,['load'],['load']
Performance,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h:118,load,load,118,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.h,2,['load'],['load']
Performance,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.; /// Used to guide target specific optimizations, like loop strength reduction; /// (LoopStrengthReduce.cpp) and memory optimization for address mode; /// (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:118,load,load,118,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,3,"['load', 'optimiz']","['load', 'optimization', 'optimizations']"
Performance,"/// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type; /// Used to guide target specific optimizations, like loop strength; /// reduction (LoopStrengthReduce.cpp) and memory optimization for; /// address mode (CodeGenPrepare.cpp)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:118,load,load,118,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,3,"['load', 'optimiz']","['load', 'optimization', 'optimizations']"
Performance,"/// isLoadFromStackSlot - If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:80,load,load,80,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,30,['load'],"['load', 'loaded', 'loading']"
Performance,"/// isLoadOfStoredAddress - If we have a load from the previously stored pointer; /// as indicated by StorePtr1/StorePtr2/StoreSize, return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:41,load,load,41,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,1,['load'],['load']
Performance,/// isNotEqual - Compares two trees for structural inequality. Performance; /// is the same is isEqual.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:63,Perform,Performance,63,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,1,['Perform'],['Performance']
Performance,"/// isOnlyCopiedFromConstantMemory - Recursively walk the uses of a (derived); /// pointer to an alloca. Ignore any reads of the pointer, return false if we; /// see any stores or other unknown uses. If we see pointer arithmetic, keep; /// track of whether it moves the pointer (with IsOffset) but otherwise traverse; /// the uses. If we see a memcpy/memmove that targets an unoffseted pointer to; /// the alloca, and if the source pointer is a pointer to a constant memory; /// location, we can optimize this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:496,optimiz,optimize,496,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['optimiz'],['optimize']
Performance,"/// isSOImmTwoPartValNeg - Return true if the specified value can be obtained; /// by two SOImmVal, that -V = First + Second.; /// ""R+V"" can be optimized to (sub (sub R, First), Second).; /// ""R=V"" can be optimized to (sub (mvn R, ~(-First)), Second).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h:144,optimiz,optimized,144,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMAddressingModes.h,2,['optimiz'],['optimized']
Performance,"/// isSplatValue - Return true if the vector V has the same value; /// across all DemandedElts. For scalable vectors, we don't know the; /// number of lanes at compile time. Instead, we use a 1 bit APInt; /// to represent a conservative value for all lanes; that is, that; /// one bit value is implicitly splatted across all lanes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:100,scalab,scalable,100,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['scalab'],['scalable']
Performance,"/// isStoreToStackSlot - If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:205,load,loaded,205,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,10,['load'],['loaded']
Performance,/// iterator range for the given range of loaded; /// preprocessed entities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:42,load,loaded,42,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['load'],['loaded']
Performance,"/// method to perform the minimization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/inc/TFumiliMinimizer.h:14,perform,perform,14,math/fumili/inc/TFumiliMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/inc/TFumiliMinimizer.h,8,['perform'],['perform']
Performance,/// noload_decls_begin/end - Iterate over the declarations stored in this; /// context that are currently loaded; don't attempt to retrieve anything; /// from an external source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:106,load,loaded,106,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['load'],['loaded']
Performance,/// notifyObjectLoaded - Called after an object has had its sections allocated; /// and addresses assigned to all symbols. Note: Section memory will not have; /// been relocated yet. notifyFunctionLoaded will not be called for; /// individual functions in the object.; ///; /// ELF-specific information; /// The ObjectImage contains the generated object image; /// with section headers updated to reflect the address at which sections; /// were loaded and with relocations performed in-place on debug sections.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITEventListener.h:445,load,loaded,445,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITEventListener.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITEventListener.h,2,"['load', 'perform']","['loaded', 'performed']"
Performance,/// optimizeCall - Take the given call instruction and return a more; /// optimal value to replace the instruction with or 0 if a more; /// optimal form can't be found. Note that the returned value may; /// be equal to the instruction being optimized. In this case all; /// other instructions that use the given instruction were modified; /// and the given instruction is dead.; /// The call must not be an indirect call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:4,optimiz,optimizeCall,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,2,['optimiz'],"['optimizeCall', 'optimized']"
Performance,/// optimizeCompareInstr - Check if there exists an earlier instruction that; /// operates on the same source operands and sets flags in the same way as; /// Compare; remove Compare if possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:4,optimiz,optimizeCompareInstr,4,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,1,['optimiz'],['optimizeCompareInstr']
Performance,"/// optimizeCompareInstr - Convert the instruction supplying the argument to the; /// comparison into one that sets the zero bit in the flags register;; /// Remove a redundant Compare instruction if an earlier instruction can set the; /// flags in the same way as Compare.; /// E.g. SUBrr(r1,r2) and CMPrr(r1,r2). We also handle the case where two; /// operands are swapped: SUBrr(r1,r2) and CMPrr(r2,r1), by updating the; /// condition code of instructions which use the flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:4,optimiz,optimizeCompareInstr,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['optimiz'],['optimizeCompareInstr']
Performance,/// optimizeCompareInstr - Convert the instruction supplying the argument to; /// the comparison into one that sets the zero bit in the flags register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:4,optimiz,optimizeCompareInstr,4,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['optimiz'],['optimizeCompareInstr']
Performance,"/// optimizeCompareInstr - Convert the instruction to set the zero flag so; /// that we can remove a ""comparison with zero""; Remove a redundant CMP; /// instruction if the flags can be updated in the same way by an earlier; /// instruction such as SUB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:4,optimiz,optimizeCompareInstr,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,1,['optimiz'],['optimizeCompareInstr']
Performance,"/// optimizeLoadInstr - Try to remove the load by folding it to a register; /// operand at the use. We fold the load instructions if and only if the; /// def and use are in the same BB. We only look at one load and see; /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register; /// defined by the load we are trying to fold. DefMI returns the machine; /// instruction that defines FoldAsLoadDefReg, and the function returns; /// the machine instruction generated due to folding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:4,optimiz,optimizeLoadInstr,4,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,5,"['load', 'optimiz']","['load', 'optimizeLoadInstr']"
Performance,/// optimizePTestInstr - Attempt to remove a ptest of a predicate-generating; /// operation which could set the flags in an identical manner,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:4,optimiz,optimizePTestInstr,4,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['optimiz'],['optimizePTestInstr']
Performance,"/// our position in the cached proposal data set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/PdfProposal.h:24,cache,cached,24,roofit/roostats/inc/RooStats/PdfProposal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/PdfProposal.h,1,['cache'],['cached']
Performance,"/// outranks - Indicates whether, if an instruction has two different applicable; /// classes, which class should be preferred when performing decode. This; /// imposes a total ordering (ties are resolved toward ""lower""); ///; /// @param upper - The class that may be preferable; /// @param lower - The class that may be less preferable; /// @return - True if upper is to be preferred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.cpp:132,perform,performing,132,interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.cpp,1,['perform'],['performing']
Performance,/// p2align immediate for load and store address alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h:26,load,load,26,interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h,1,['load'],['load']
Performance,"/// parseDirectiveDumpOrLoad; /// ::= ( .dump | .load ) ""filename""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp:49,load,load,49,interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/DarwinAsmParser.cpp,1,['load'],['load']
Performance,"/// parseLoad; /// ::= 'load' 'volatile'? TypeAndValue (',' 'align' i32)?; /// ::= 'load' 'atomic' 'volatile'? TypeAndValue; /// 'singlethread'? AtomicOrdering (',' 'align' i32)?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,2,['load'],['load']
Performance,"/// perform a Cholesky decomposition; /** perform a Cholesky decomposition of a symmetric positive; * definite matrix m; *; * this is the constructor to use in special applications where; * plain arrays are used; *; * NOTE: the matrix is given in packed representation, matrix; * element m(i,j) (j <= i) is supposed to be in array element; * (i * (i + 1)) / 2 + j; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/CholeskyDecomp.h:4,perform,perform,4,math/smatrix/inc/Math/CholeskyDecomp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/CholeskyDecomp.h,4,['perform'],['perform']
Performance,"/// perform a Cholesky decomposition; /** perform a Cholesky decomposition of a symmetric positive; * definite matrix m; *; * this is the constructor to uses with an SMatrix (and objects; * that behave like an SMatrix in terms of using; * operator()(int i, int j) for access to elements); */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/CholeskyDecomp.h:4,perform,perform,4,math/smatrix/inc/Math/CholeskyDecomp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/CholeskyDecomp.h,4,['perform'],['perform']
Performance,"/// perform a global fit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProfileLikelihoodCalculator.h:4,perform,perform,4,roofit/roostats/inc/RooStats/ProfileLikelihoodCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProfileLikelihoodCalculator.h,1,['perform'],['perform']
Performance,"/// perform an iteration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootSolver.h:4,perform,perform,4,math/mathmore/src/GSLMultiRootSolver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiRootSolver.h,1,['perform'],['perform']
Performance,"/// perform page to page number mapping",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:4,perform,perform,4,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,2,['perform'],['perform']
Performance,"/// perform prediction of the deep neural network; /// using batches (called by GetMvaValues)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodDL.h:4,perform,perform,4,tmva/tmva/inc/TMVA/MethodDL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodDL.h,1,['perform'],['perform']
Performance,"/// perform special action when drawing is ready",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RVirtualCanvasPainter.hxx:4,perform,perform,4,graf2d/gpadv7/inc/ROOT/RVirtualCanvasPainter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RVirtualCanvasPainter.hxx,2,['perform'],['perform']
Performance,"/// perform the flush",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h:4,perform,perform,4,roofit/roofitcore/src/BidirMMapPipe.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.h,1,['perform'],['perform']
Performance,/// processInstr - Accepts a CodeGenInstruction and loads decode information; /// for it into a DisassemblerTables if appropriate.; ///; /// \param tables The DiassemblerTables to be populated with decode; /// information.; /// \param insn The CodeGenInstruction to be used as a source for this; /// information.; /// \param uid The unique ID of the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.h:52,load,loads,52,interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86RecognizableInstr.h,1,['load'],['loads']
Performance,"/// protectFromPeepholes - Protect a value that we're intending to; /// store to the side, but which will probably be used later, from; /// aggressive peepholing optimizations that might delete it.; ///; /// Pass the result to unprotectFromPeepholes to declare that; /// protection is no longer required.; ///; /// There's no particular reason why this shouldn't apply to; /// l-values, it's just that no existing peepholes work on pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:162,optimiz,optimizations,162,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['optimiz'],['optimizations']
Performance,"/// reachesChainWithoutSideEffects - Return true if this operand (which must; /// be a chain) reaches the specified operand without crossing any; /// side-effecting instructions on any chain path. In practice, this looks; /// through token factors and non-volatile loads. In order to remain efficient,; /// this only looks a couple of nodes in, it does not do an exhaustive search.; ///; /// Note that we only need to examine chains when we're searching for; /// side-effects; SelectionDAG requires that all side-effects are represented; /// by chains, even if another operand would force a specific ordering. This; /// constraint is necessary to allow transformations like splitting loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:265,load,loads,265,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,['load'],['loads']
Performance,"/// reheapify - If an element in the queue has changed in a way that; /// affects its standing in the comparison function, the queue's; /// internal state becomes invalid. Calling reheapify() resets the; /// queue's state, making it valid again. This operation has time; /// complexity proportional to the number of elements in the queue,; /// so don't plan to use it a lot.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:37,queue,queue,37,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,4,['queue'],['queue']
Performance,/// reset - Reset cached information about node(Level) from subtree(Level -1).; /// @param Level 1..height. The node to update after parent node changed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:18,cache,cached,18,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['cache'],['cached']
Performance,"/// reset the cached limit values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/LikelihoodInterval.h:14,cache,cached,14,roofit/roostats/inc/RooStats/LikelihoodInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/LikelihoodInterval.h,1,['cache'],['cached']
Performance,"/// restoreCalleeSavedRegisters - Issues instruction(s) to restore all callee; /// saved registers and returns true if it isn't possible / profitable to do; /// so by issuing a series of load instructions via loadRegToStackSlot().; /// If it returns true, and any of the registers in CSI is not restored,; /// it sets the corresponding Restored flag in CSI to false.; /// Returns false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:187,load,load,187,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,2,['load'],"['load', 'loadRegToStackSlot']"
Performance,/// runOnFunction - Replace gcread/gcwrite intrinsics with loads and stores.; /// Leave gcroot intrinsics; the code generator needs to see those.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:59,load,loads,59,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,1,['load'],['loads']
Performance,/// runOnMachineFunction - This method must be overloaded to perform the; /// desired machine code transformation or analysis.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:61,perform,perform,61,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,1,['perform'],['perform']
Performance,"/// runOnSCC - This method should be implemented by the subclass to perform; /// whatever action is necessary for the specified SCC. Note that; /// non-recursive (or only self-recursive) functions will have an SCC size of; /// 1, where recursive portions of the call graph will have SCC size > 1.; ///; /// SCC passes that add or delete functions to the SCC are required to update; /// the SCC list, otherwise stale pointers may be dereferenced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h:68,perform,perform,68,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraphSCCPass.h,1,['perform'],['perform']
Performance,"/// runPasses - Just like the method above, but this just returns true or; /// false indicating whether or not the optimizer crashed on the specified; /// input (true = crashed). Does not produce any output.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:115,optimiz,optimizer,115,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['optimiz'],['optimizer']
Performance,"/// runPasses - Run the specified passes on Program, outputting a bitcode file; /// and writing the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:152,optimiz,optimizations,152,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,2,['optimiz'],"['optimizations', 'optimizer']"
Performance,"/// runPasses - Run the specified passes on Program, outputting a bitcode; /// file and writting the filename into OutputFile if successful. If the; /// optimizations fail for some reason (optimizer crashes), return true,; /// otherwise return false. If DeleteOutput is set to true, the bitcode is; /// deleted on success, and the filename string is undefined. This prints to; /// outs() a single line message indicating whether compilation was successful; /// or failed, unless Quiet is set. ExtraArgs specifies additional arguments; /// to pass to the child bugpoint instance.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:153,optimiz,optimizations,153,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,2,['optimiz'],"['optimizations', 'optimizer']"
Performance,"/// scanActiveBundles - Perform an initial scan of all bundles activated by; /// addConstraints and addLinks, updating their state. Add all the bundles; /// that now prefer a register to RecentPositive.; /// Prepare internal data structures for iterate.; /// Return true is there are any positive nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h:24,Perform,Perform,24,interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SpillPlacement.h,1,['Perform'],['Perform']
Performance,"/// scheduleNodeTopDown - Add the node to the schedule. Decrement the pending; /// count of its successors. If a successor pending count is zero, add it to; /// the Available queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:175,queue,queue,175,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,1,['queue'],['queue']
Performance,"/// set parameter values (only the cached one in this class,leave unchanges those of TF1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedMultiTF1.h:35,cache,cached,35,hist/hist/inc/Math/WrappedMultiTF1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedMultiTF1.h,1,['cache'],['cached']
Performance,/// setOptLevel - Set the optimization level for the JIT. This option; /// defaults to CodeGenOptLevel::Default.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:26,optimiz,optimization,26,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['optimiz'],['optimization']
Performance,"/// setProcessAllSections (MCJIT Only): By default, only sections that are; /// ""required for execution"" are passed to the RTDyldMemoryManager, and other; /// sections are discarded. Passing 'true' to this method will cause; /// RuntimeDyld to pass all sections to its RTDyldMemoryManager regardless; /// of whether they are ""required to execute"" in the usual sense.; ///; /// Rationale: Some MCJIT clients want to be able to inspect metadata; /// sections (e.g. Dwarf, Stack-maps) to enable functionality or analyze; /// performance. Passing these sections to the memory manager allows the; /// client to make policy about the relevant sections, rather than having; /// MCJIT do it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:522,perform,performance,522,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['perform'],['performance']
Performance,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads should; /// be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.; ///; /// FIXME: remove this in favor of the MachineInstr interface once pre-RA-sched; /// is permanently disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:146,load,loads,146,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,7,"['cache', 'load']","['cache', 'load', 'loading', 'loads']"
Performance,"/// shouldScheduleLoadsNear - This is a used by the pre-regalloc scheduler to; /// determine (in conjunction with areLoadsFromSameBasePtr) if two loads; /// should be scheduled togther. On some targets if two loads are loading from; /// addresses in the same cache line, it's better if they are scheduled; /// together. This function takes two integers that represent the load offsets; /// from the common base address. It returns true if it decides it's desirable; /// to schedule the two loads together. ""NumLoads"" is the number of loads that; /// have already been scheduled after Load1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:146,load,loads,146,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,14,"['cache', 'load']","['cache', 'load', 'loading', 'loads']"
Performance,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:40,Load,LoadI,40,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,3,"['Load', 'load', 'optimiz']","['LoadI', 'load', 'optimization']"
Performance,"/// since getSymbol is a relatively heavy-weight operation, the symbol; /// is only computed once and is cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:105,cache,cached,105,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['cache'],['cached']
Performance,"/// specialization that queues first parts of multipart messages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger.h:24,queue,queues,24,roofit/multiprocess/res/RooFit/MultiProcess/Messenger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Messenger.h,2,['queue'],['queues']
Performance,"/// sub - Return the result of replacing the first match of the regex in; /// \p String with the \p Repl string. Backreferences like ""\0"" and ""\g<1>""; /// in the replacement string are replaced with the appropriate match; /// substring.; ///; /// Note that the replacement string has backslash escaping performed on; /// it. Invalid backreferences are ignored (replaced by empty strings).; ///; /// \param Error If non-null, any errors in the substitution (invalid; /// backreferences, trailing backslashes) will be recorded as a non-empty; /// string. If there is no error, it will be an empty string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Regex.h:303,perform,performed,303,interpreter/llvm-project/llvm/include/llvm/Support/Regex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Regex.h,1,['perform'],['performed']
Performance,"/// the cached proposal data set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/PdfProposal.h:8,cache,cached,8,roofit/roostats/inc/RooStats/PdfProposal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/PdfProposal.h,1,['cache'],['cached']
Performance,/// trackValueOfGlobalVariable - Clients can use this method to; /// inform the SCCPSolver that it should track loads and stores to the; /// specified global variable if it can. This is only legal to call if; /// performing Interprocedural SCCP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h:112,load,loads,112,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h,2,"['load', 'perform']","['loads', 'performing']"
Performance,"/// transform from internal to external; /// result is cached also inside the class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimTransformFunction.h:55,cache,cached,55,math/mathcore/inc/Math/MinimTransformFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimTransformFunction.h,1,['cache'],['cached']
Performance,/// tryAddingPcLoadReferenceComment - trys to add a comment as to what is being; /// referenced by a load instruction with the base register that is the Pc.; /// These can often be values in a literal pool near the Address of the; /// instruction. The Address of the instruction and its immediate Value are; /// used as a possible literal pool entry. The SymbolLookUp call back will; /// return the name of a symbol referenced by the literal pool's entry if; /// the referenced address is that of a symbol. Or it will return a pointer to; /// a literal 'C' string if the referenced address of the literal pool's entry; /// is an address into a section with 'C' string literals.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp:101,load,load,101,interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Disassembler/ARMDisassembler.cpp,1,['load'],['load']
Performance,"/// tryAddingSymbolicOperand - tryAddingSymbolicOperand trys to add a symbolic; /// operand in place of the immediate Value in the MCInst. The immediate; /// Value has not had any PC adjustment made by the caller. If the instruction; /// is a branch that adds the PC to the immediate Value then isBranch is; /// Success, else Fail. If GetOpInfo is non-null, then it is called to get any; /// symbolic information at the Address for this instrution. If that returns; /// non-zero then the symbolic information it returns is used to create an; /// MCExpr and that is added as an operand to the MCInst. If GetOpInfo(); /// returns zero and isBranch is Success then a symbol look up for; /// Address + Value is done and if a symbol is found an MCExpr is created with; /// that, else an MCExpr with Address + Value is created. If GetOpInfo(); /// returns zero and isBranch is Fail then the Opcode of the MCInst is; /// tested and for ADRP an other instructions that help to load of pointers; /// a symbol look up is done to see it is returns a specific reference type; /// to add to the comment stream. This function returns Success if it adds; /// an operand to the MCInst and Fail otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Disassembler/AArch64ExternalSymbolizer.cpp:969,load,load,969,interpreter/llvm-project/llvm/lib/Target/AArch64/Disassembler/AArch64ExternalSymbolizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Disassembler/AArch64ExternalSymbolizer.cpp,1,['load'],['load']
Performance,"/// tryToUnfoldSelectInCurrBB - Look for PHI/Select or PHI/CMP/Select in the; /// same BB in the form; /// bb:; /// %p = phi [false, %bb1], [true, %bb2], [false, %bb3], [true, %bb4], ...; /// %s = select %p, trueval, falseval; ///; /// or; ///; /// bb:; /// %p = phi [0, %bb1], [1, %bb2], [0, %bb3], [1, %bb4], ...; /// %c = cmp %p, 0; /// %s = select %c, trueval, falseval; ///; /// And expand the select into a branch structure. This later enables; /// jump-threading over bb in this pass.; ///; /// Using the similar approach of SimplifyCFG::FoldCondBranchOnPHI(), unfold; /// select if the associated PHI has at least one constant. If the unfolded; /// select is not jump-threaded, it will be folded again in the later; /// optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:728,optimiz,optimizations,728,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['optimiz'],['optimizations']
Performance,"/// unfoldMemoryOperand - Separate a single instruction which folded a load or; /// a store or a load and a store into two or more instruction. If this is; /// possible, returns true as well as the new instructions by reference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:71,load,load,71,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,4,['load'],['load']
Performance,/// validate - Return true if this matchable is a valid thing to match against; /// and perform a bunch of validity checking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:88,perform,perform,88,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['perform'],['perform']
Performance,/// verifyInstruction - Perform target specific instruction verification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:24,Perform,Perform,24,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,1,['Perform'],['Perform']
Performance,/// writeSegmentLoadCommand - Write a segment load command.; ///; /// \param NumSections The number of sections in this segment.; /// \param SectionDataSize The total size of the sections.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp:46,load,load,46,interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MachObjectWriter.cpp,1,['load'],['load']
Performance,/// } Inline Assembly; /// Target Optimization {; // Return lower limit for number of blocks in a jump table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:34,Optimiz,Optimization,34,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,1,['Optimiz'],['Optimization']
Performance,/// } Load & Store; // Custom legalize address nodes into LO/HI parts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:6,Load,Load,6,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['Load'],['Load']
Performance,/// } Optimization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h:6,Optimiz,Optimization,6,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h,1,['Optimiz'],['Optimization']
Performance,/// } Stack Spill & Reload; /// Optimization {,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h:32,Optimiz,Optimization,32,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.h,1,['Optimiz'],['Optimization']
Performance,/// } Target Optimization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h:13,Optimiz,Optimization,13,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.h,1,['Optimiz'],['Optimization']
Performance,"/////////////// cache and change file's icon ///////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowserLite.cxx:16,cache,cache,16,gui/gui/src/TRootBrowserLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowserLite.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////////////////////////////////////; /// A RAII that performs RooFit's static initialisation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/Initialisation.cxx:130,perform,performs,130,roofit/roofitcore/src/Initialisation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/Initialisation.cxx,1,['perform'],['performs']
Performance,"//////////////////////////////////////////////////////////////////////////////////////////////////; /// Add message to send queue for specified connection; /// If connid == 0, message will be add to all connections",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:124,queue,queue,124,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['queue'],['queue']
Performance,"//////////////////////////////////////////////////////////////////////////////////////////////////; /// Configure batch image mode for web graphics.; /// Allows to process many images with single headless browser invocation and increase performance of image production.; /// When many canvases are stored as image in difference places, they first collected in batch and then processed when at least `n`; /// images are prepared. Only then headless browser invoked and create all these images at once.; /// This allows to significantly increase performance of image production in web mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:237,perform,performance,237,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,2,['perform'],['performance']
Performance,"//////////////////////////////////////////////////////////////////////////////////////////////////; /// Configures custom script for canvas.; /// If started with ""modules:"" prefix, module(s) will be imported with `loadModules` function of JSROOT.; /// If custom path was configured in RWebWindowsManager::AddServerLocation, it can be used in module paths.; /// If started with ""load:"" prefix, code will be loaded with `loadScript` function of JSROOT (old, deprecated way); /// Script also can be a plain JavaScript code which imports JSROOT and provides draw function for custom classes; /// See tutorials/webgui/custom/custom.mjs demonstrating such example",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:214,load,loadModules,214,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,4,['load'],"['load', 'loadModules', 'loadScript', 'loaded']"
Performance,"//////////////////////////////////////////////////////////////////////////////////////////////////; /// For batch mode special handling of scripts are required; /// Headless browser not able to load modules from the file system; /// Therefore custom web-canvas modules and scripts has to be loaded in advance and processed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:194,load,load,194,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,2,['load'],"['load', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////////////////////; /// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:152,perform,performance,152,tree/dataframe/src/RSqliteDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx,1,['perform'],['performance']
Performance,"//////////////////////////////////////////////////////////////////////////////////////////////; /// Process disconnect event; /// Clear cache data and dependent connections",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomViewer.cxx:136,cache,cache,136,geom/webviewer/src/RGeomViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomViewer.cxx,1,['cache'],['cache']
Performance,"//////////////////////////////////////////////////////////////////////////////////////////; /// Checks if new data can be send (internal use only); /// If necessary, provide credits to the client; /// \param only_once if true, data sending performed once or until there is no data to send",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:240,perform,performed,240,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['perform'],['performed']
Performance,"//////////////////////////////////////////////////////////////////////////////////////////; /// Checks if one should send data for specified connection; /// Returns true when send operation was performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:194,perform,performed,194,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['perform'],['performed']
Performance,"//////////////////////////////////////////////////////////////////////////////////////////; /// Configure server location which can be used for loading of custom scripts or files; /// When THttpServer instance of RWebWindowsManager will be created,; /// THttpServer::AddLocation() method with correspondent arguments will be invoked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx:144,load,loading,144,gui/webdisplay/src/RWebWindowsManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx,1,['load'],['loading']
Performance,"//////////////////////////////////////////////////////////////////////////////////////////; /// Re-assigns main thread id; /// Normally main thread id recognized at the moment when library is loaded; /// It supposed to be a thread where gApplication->Run() will be called; /// If application runs in separate thread, one have to call this method; /// to let RWebWindowsManager correctly recognize such situation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx:192,load,loaded,192,gui/webdisplay/src/RWebWindowsManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx,1,['load'],['loaded']
Performance,"//////////////////////////////////////////////////////////////////////////////////////////; /// Returns true when called from main process; /// Main process recognized at the moment when library is loaded; /// It supposed to be a thread where gApplication->Run() will be called; /// If application runs in separate thread, one have to use AssignMainThrd() method; /// to let RWebWindowsManager correctly recognize such situation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx:198,load,loaded,198,gui/webdisplay/src/RWebWindowsManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx,1,['load'],['loaded']
Performance,"/////////////////////////////////////////////////////////////////////////////////////; /// Create dialog instance to use as embedded dialog inside provided widget; /// Loads libROOTBrowserv7 and tries to call RFileDialog::Embedded() method; /// Embedded dialog started on the client side where FileDialogController.SaveAs() method called; /// Such method immediately send message with ""FILEDIALOG:"" prefix; /// On the server side widget should detect such message and call RFileDialog::Embedded(); /// providing received string as second argument.; /// Returned instance of shared_ptr<RFileDialog> may be used to assign callback when file is selected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:168,Load,Loads,168,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['Load'],['Loads']
Performance,"///////////////////////////////////////////////////////////////////////////////////; /// Returns send queue length for specified connection; /// \param connid connection id, 0 - maximal value for all connections is returned; /// If wrong connection id specified, -1 is return",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:102,queue,queue,102,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['queue'],['queue']
Performance,"///////////////////////////////////////////////////////////////////////////////////; /// Returns true if sending via specified connection can be performed; /// \param connid connection id, when 0 - all existing connections are checked; /// \param direct when true, checks if direct sending (without queuing) is possible",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:145,perform,performed,145,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['perform'],['performed']
Performance,"//////////////////////////////////////////////////////////////////////////////////; /// Evaluate object. Returns either cached value or triggers a recalculation.; /// The recalculation happens by calling getValV(), which in the end calls the; /// virtual evaluate() functions of the respective PDFs.; /// \param[in] normalisationSet getValV() reacts differently depending on the value of the normalisation set.; /// If the set is `nullptr`, an unnormalised value is returned.; /// \note The normalisation is arbitrary, because it is up to the implementation; /// of the PDF to e.g. leave out normalisation constants for speed reasons. The range; /// of the variables is also ignored.; ///; /// To normalise the result properly, a RooArgSet has to be passed, which contains; /// the variables to normalise over.; /// These are integrated over their current ranges to compute the normalisation constant,; /// and the unnormalised result is divided by this value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:120,cache,cached,120,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['cache'],['cached']
Performance,"/////////////////////////////////////////////////////////////////////////////////; /// Change visibility for specified element; /// Returns true if changes was performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx:160,perform,performed,160,geom/webviewer/src/RGeomData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx,2,['perform'],['performed']
Performance,"/////////////////////////////////////////////////////////////////////////////////; /// Let use THttpServer threads to process requests; /// WARNING!!! only for expert use; /// Should be only used when application provides proper locking and; /// does not block. Such mode provides minimal possible latency; /// Must be called before callbacks are assigned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:298,latency,latency,298,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['latency'],['latency']
Performance,"/////////////////////////////////////////////////////////////////////////////////; /// Run window functionality for specified time; /// If no action can be performed - just sleep specified time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:156,perform,performed,156,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['perform'],['performed']
Performance,"/////////////////////////////////////////////////////////////////////////////////; /// The function generates and executes a command that loads the Doxygen URL in; /// a browser. It works for Mac, Windows and Linux. In the case of Linux, the; /// function also checks if the DISPLAY is set. If it isn't, a warning message; /// and the URL will be displayed on the terminal.; ///; /// \param[in] url web page to be displayed in a browser",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:138,load,loads,138,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['load'],['loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraph; \ingroup Graphs; A TGraph is an object made of two arrays X and Y with npoints each.; The TGraph painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. #### Notes. - Unlike histogram or tree (or even TGraph2D), TGraph objects; are not automatically attached to the current TFile, in order to keep the; management and size of the TGraph as small as possible.; - The TGraph constructors do not have the TGraph title and name as parameters.; A TGraph has the default title and name ""Graph"". To change the default title; and name `SetTitle` and `SetName` should be called on the TGraph after its creation.; TGraph was a light weight object to start with, like TPolyline or TPolyMarker.; That’s why it did not have any title and name parameters in the constructors. #### Example. The picture below gives an example:. Begin_Macro(source); {; double x[100], y[100];; int n = 20;; for (int i=0;i<n;i++) {; x[i] = i*0.1;; y[i] = 10*sin(x[i]+0.2);; }; auto g = new TGraph(n,x,y);; g->SetTitle(""Graph title;X title;Y title"");; g->Draw(""AC*"");; }; End_Macro. #### Default X-Points. If one doesn't specify the points in the x-axis, they will get the default values 0, 1, 2, 3, (etc. depending; on the length of the y-points):. Begin_Macro(source); {; double y[6] = {3, 8, 1, 10, 5, 7};; auto g = new TGraph(6,y);; g->SetTitle(""A Graph with default X points"");; g->Draw();; }; End_Macro. */; ////////////////////////////////////////////////////////////////////////////////; /// Graph default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:210,perform,performed,210,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphBentErrors; \ingroup Graphs; A TGraphBentErrors is a TGraph with bent, asymmetric error bars. The TGraphBentErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:; Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with bent error bars"",200,10,700,500);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""TGraphBentErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphBentErrors default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx:226,perform,performed,226,hist/hist/src/TGraphBentErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphBentErrors.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /** \class TGraphErrors; \ingroup Graphs; A TGraphErrors is a TGraph with error bars. The TGraphErrors painting is performed thanks to the TGraphPainter; class. All details about the various painting options are given in this class. The picture below gives an example:. Begin_Macro(source); {; auto c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetFillColor(42);; c1->SetGrid();; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(12);; const Int_t n = 10;; Double_t x[n] = {-0.22, 0.05, 0.25, 0.35, 0.5, 0.61,0.7,0.85,0.89,0.95};; Double_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; Double_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Double_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; auto gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; End_Macro; */; ////////////////////////////////////////////////////////////////////////////////; /// TGraphErrors default constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:197,perform,performed,197,hist/hist/src/TGraphErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /*** Create a data loader; \param[in] thedlName name of DataLoader object. This name will be used as the; top directory name where the training results; (weights, i.e .XML and .C files) will be stored.; The results will be stored by default in the `theDlName/weights`; directory and relative to the current directory. If the directory is not existing,; a new one will be created automatically.; For using a different location (i.e. a different path to the current directory) one; can set an absolute path location in `TMVA::gConfig()::GetIONames().fWeightFileDirPrefix`; For example, by setting; ~~~~~~~~~~~~~~~{.cpp}; TMVA::gConfig()::GetIONames().fWeightFileDirPrefix = ""/tmp"";; TMVA::gConfig()::GetIONames().fWeightFileDir = ""myTrainingResults"";; ~~~~~~~~~~~~~~~; The training results will be stored in the `/tmp/thedlName/myTrainingResults`; directory.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataLoader.cxx:101,load,loader,101,tmva/tmva/src/DataLoader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataLoader.cxx,1,['load'],['loader']
Performance,"////////////////////////////////////////////////////////////////////////////////; /**; * Second pass through the AST. Two operations are performed:; * 1. Selection rules for classes to be autoselected are created. The; * algorithm works as follows: the members of the classes matching the name of; * the classes which contained autoselected members in the selection namespace; * are inspected. If a field with the same name of the one which was; * autoselected a selection rule based on its typename is built.; * 2. If a class is found which is a @c TemplateSpecialisationDecl its; * name is checked to match one of the patterns identified during the first; * pass. If a match is found, a property is added to the selection rule with; * the number of template arguments to keep in order to percolate this; * information down to the @c AnnotatedRecordDecl creation which happens in the; * @c RScanner .; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/DictSelectionReader.cxx:137,perform,performed,137,core/dictgen/src/DictSelectionReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/DictSelectionReader.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; // //; // From now on we have the methods concerning the threading part of the cache //; // //; ////////////////////////////////////////////////////////////////////////////////; ////////////////////////////////////////////////////////////////////////////////; /// Static function that returns the parallel option; /// (to indicate an additional thread)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:161,cache,cache,161,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; // //; // From now on we have the methods concerning the unzipping part of the cache //; // //; ////////////////////////////////////////////////////////////////////////////////; ////////////////////////////////////////////////////////////////////////////////; /// Read the logical record header from the buffer buf.; /// That must be the pointer tho the header part not the object by itself and; /// must contain data of at least maxbytes; /// Returns nread;; ///; /// In output arguments:; ///; /// - nbytes : number of bytes in record; /// if negative, this is a deleted record; /// if 0, cannot read record, wrong value of argument first; /// - objlen : uncompressed object size; /// - keylen : length of logical record header; ///; /// Note that the arguments objlen and keylen are returned only; /// if maxbytes >=16; /// Note: This was adapted from TFile... so some things dont apply",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:161,cache,cache,161,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; // Get the list of 'published'/'known' library for the class and load them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:147,load,load,147,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; // Iterate through the data member of the class (either through the TProtoClass; // or through Cling) and trigger, recursively, the loading the necessary libraries.; // \note `cls` is expected to be already normalized!; // \returns 1 on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:214,load,loading,214,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; // Load GL shape settings from ROOT's TEnv into static data members.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:85,Load,Load,85,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; // Make sure the application environment exists and the GUI libs are loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/src/TBrowser.cxx:151,load,loaded,151,core/gui/src/TBrowser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/src/TBrowser.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// @param[in] numthreads Number of threads to use. If not specified or; /// set to zero, the number of threads is automatically; /// decided by the implementation. Any other value is; /// used as a hint.; ///; /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; /// The following objects and methods automatically take advantage of; /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; ///; /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; /// - TTree::GetEntry reads multiple branches in parallel; /// - TTree::FlushBaskets writes multiple baskets to disk in parallel; /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; /// - THx::Fit performs in parallel the evaluation of the objective function over the data; /// - TMVA::DNN trains the deep neural networks in parallel; /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; ///; /// EnableImplicitMT calls in turn EnableThreadSafety.; /// The 'numthreads' parameter allows to control the number of threads to; /// be used by the implicit multi-threading. However, this parameter is just; /// a hint for ROOT: it will try to satisfy the request if the execution; /// scenario allows it. For example, if ROOT is configured to use an external; /// scheduler, setting a value for 'numthreads' might not have any effect.; /// The maximum number of threads can be influenced by the environment; /// variable `ROOT_MAX_THREADS`: `export ROOT_MAX_THREADS=2` will try to set; /// the maximum number of active threads to 2, if the scheduling library; /// (such as tbb) ""permits"".; ///; /// \note Use `DisableImplicitMT()` to disable multi-threading (some locks will remain in place as; /// described in EnableThreadSafety()). `EnableImplicitMT(1)` creates a thread-pool of size 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:461,multi-thread,multi-threading,461,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,4,"['multi-thread', 'perform']","['multi-threading', 'performs']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Accept a connection on a parallel server socket. Returns a full-duplex; /// parallel communication TPSocket object. If no pending connections are; /// present on the queue and nonblocking mode has not been enabled; /// with SetOption(kNoBlock,1) the call blocks until a connection is; /// present. The returned socket must be deleted by the user. The socket; /// is also added to the TROOT sockets list which will make sure that; /// any open sockets are properly closed on program termination.; /// In case of error 0 is returned and in case non-blocking I/O is; /// enabled and no connections are available -1 is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx:252,queue,queue,252,net/net/src/TPServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Accept a connection on a server socket. Returns a full-duplex; /// communication TSocket object. If no pending connections are; /// present on the queue and nonblocking mode has not been enabled; /// with SetOption(kNoBlock,1) the call blocks until a connection is; /// present. The returned socket must be deleted by the user. The socket; /// is also added to the TROOT sockets list which will make sure that; /// any open sockets are properly closed on program termination.; /// In case of error 0 is returned and in case non-blocking I/O is; /// enabled and no connections are available -1 is returned.; ///; /// The opt can be used to require client authentication; valid options are; ///; /// kSrvAuth = require client authentication; /// kSrvNoAuth = force no client authentication; ///; /// Example: use Opt = kSrvAuth to require client authentication.; ///; /// Default options are taken from fgAcceptOpt and are initially; /// equivalent to kSrvNoAuth; they can be changed with the static; /// method TServerSocket::SetAcceptOptions(Opt).; /// The active defaults can be visualized using the static method; /// TServerSocket::ShowAcceptOptions().; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx:233,queue,queue,233,net/net/src/TServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// AclicMode indicates whether the library should be built in; /// debug mode or optimized. The values are:; /// - TSystem::kDefault : compile the same as the current ROOT; /// - TSystem::kDebug : compiled in debug mode; /// - TSystem::kOpt : optimized the library",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:164,optimiz,optimized,164,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,4,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Action to be performed when this menu item is selected.; /// If the selected method requires arguments we popup an; /// automatically generated dialog, otherwise the method is; /// directly executed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/src/TContextMenu.cxx:99,perform,performed,99,core/gui/src/TContextMenu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/src/TContextMenu.cxx,2,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Action to be performed when this toggle menu item is selected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/gui/src/TContextMenu.cxx:99,perform,performed,99,core/gui/src/TContextMenu.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/gui/src/TContextMenu.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Activate cache mode optimization with given definition of observables.; /// The cache operation mode of all objects in the expression tree will; /// modified such that all nodes that depend directly or indirectly on; /// any of the listed observables will be set to ADirty, as they are; /// expected to change every time. This save change tracking overhead for; /// nodes that are a priori known to change every time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:95,cache,cache,95,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,6,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Activate call profile if flag is set to true. A 2-D histogram is kept that stores the required number; /// of function calls versus the value of x, the convolution variable; ///; /// All clones of RooNumConvolution objects will keep logging to the histogram of the original class; /// so that performance of temporary object clones, such as used in e.g. fitting, plotting and generating; /// are all logged in a single place.; ///; /// Function caller should take ownership of profiling histogram as it is not deleted at the RooNumConvolution dtor; ///; /// Calling this function with flag set to false will deactivate call profiling and delete the profiling histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx:379,perform,performance,379,roofit/roofitcore/src/RooNumConvolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add a branch discovered by actual usage to the list of branches to be stored; /// in the cache this function is called by TBranch::GetBasket; /// If we are not longer in the training phase this is an error.; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:175,cache,cache,175,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add a branch to the list of branches to be stored in the cache; /// this function is called by TBranch::GetBasket; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:143,cache,cache,143,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add a branch to the list of branches to be stored in the cache; /// this function is called by the user via TTree::AddBranchToCache.; /// The branch is added even if we are outside of the training phase.; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:143,cache,cache,143,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add a branch to the list of branches to be stored in the cache; /// this is to be used by user (thats why we pass the name of the branch).; /// It works in exactly the same way as TTree::SetBranchStatus so you; /// probably want to look over there for details about the use of bname; /// with regular expressions.; /// The branches are taken with respect to the Owner of this TTreeCache; /// (i.e. the original Tree); /// NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:143,cache,cache,143,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add a class generator. This generator will be called by TClass::GetClass; /// in case its does not find a loaded rootcint dictionary to request the; /// creation of a TClass object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:192,load,loaded,192,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add a new column to the data set which holds the pre-calculated values; /// of 'newVar'. This operation is only meaningful if 'newVar' is a derived; /// value.; ///; /// The return value points to the added element holding 'newVar's value; /// in the data collection. The element is always the corresponding fundamental; /// type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooFormulaVar); ///; /// Note: This function is explicitly NOT intended as a speed optimization; /// opportunity for the user. Components of complex PDFs that can be; /// precalculated with the dataset are automatically identified as such; /// and will be precalculated when fitting to a dataset; ///; /// By forcibly precalculating functions with non-trivial Jacobians,; /// or functions of multiple variables occurring in the data set,; /// using addColumn(), you may alter the outcome of the fit.; ///; /// Only in cases where such a modification of fit behaviour is intentional,; /// this function should be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:547,optimiz,optimization,547,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,2,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add a new file to this chain.; ///; /// Filename formats are similar to TChain::Add. Wildcards are not; /// applied. urls may also contain query and fragment identifiers; /// where the tree name can be specified in the url fragment.; ///; /// eg.; /// ~~~ {.cpp}; /// root://machine/path/file_name[?query[#tree_name]]; /// root://machine/path/file_name.root[.oext]/tree_name[?query]; /// ~~~; /// If tree_name is given as a part of the file name it is used to; /// as the name of the tree to load from the file. Otherwise if tname; /// argument is specified the chain will load the tree named tname from; /// the file, otherwise the original treename specified in the TChain; /// constructor will be used.; /// Tagging the tree_name with a slash [/tree_name] is only supported for; /// backward compatibility; it requires the file name ot contain the string; /// '.root' and its use is deprecated.; ///; /// A. If nentries <= 0, the file is opened and the tree header read; /// into memory to get the number of entries.; ///; /// B. If nentries > 0, the file is not opened, and nentries is assumed; /// to be the number of entries in the file. In this case, no check; /// is made that the file exists nor that the tree exists in the file,; /// nor that the real TTree entries match with the input argument.; /// This second mode is interesting in case the number of entries in; /// the file is already stored in a run database for example.; /// \warning If you pass `nentries` > `tree_entries`, this may lead to silent; /// data corruption in your analysis or undefined behavior in your program.; /// Use the other options if unsure.; ///; /// C. If nentries == TTree::kMaxEntries (default), the file is not opened.; /// The number of entries in each file will be read only when the file; /// is opened to read an entry. This option is the default and very; /// efficient if one processes the chain sequentially. No",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:578,load,load,578,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,2,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add a trial event to our cache and update our estimates; /// of the function maximum value and integral.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAcceptReject.cxx:111,cache,cache,111,roofit/roofitcore/src/RooAcceptReject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAcceptReject.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add all histograms in the collection to this histogram.; /// This function computes the min/max for the x axis,; /// compute a new number of bins, if necessary,; /// add bin contents, errors and statistics.; /// If all histograms have bin labels, bins with identical labels; /// will be merged, no matter what their order is.; /// If overflows are present and limits are different the function will fail.; /// The function returns the total number of entries in the result histogram; /// if the merge is successful, -1 otherwise.; ///; /// Possible option:; /// -NOL : the merger will ignore the labels and merge the histograms bin by bin using bin center values to match bins; /// -NOCHECK: the histogram will not perform a check for duplicate labels in case of axes with labels. The check; /// (enabled by default) slows down the merging; ///; /// IMPORTANT remark. The axis x may have different number; /// of bins and different limits, BUT the largest bin width must be; /// a multiple of the smallest bin width and the upper limit must also; /// be a multiple of the bin width.; /// Example:; ///; /// ~~~ {.cpp}; /// void atest() {; /// TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; /// TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; /// TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; /// TRandom r;; /// for (Int_t i=0;i<10000;i++) {; /// h1->Fill(r.Gaus(-55,10));; /// h2->Fill(r.Gaus(55,10));; /// h3->Fill(r.Gaus(0,10));; /// }; ///; /// TList *list = new TList;; /// list->Add(h1);; /// list->Add(h2);; /// list->Add(h3);; /// TH1F *h = (TH1F*)h1->Clone(""h"");; /// h->Reset();; /// h->Merge(list);; /// h->Draw();; /// }; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:801,perform,perform,801,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add and extra daughter to the current path array. No validity check performed !",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBranchArray.cxx:154,perform,performed,154,geom/geom/src/TGeoBranchArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBranchArray.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add branch b to the Tree cache.; /// if subbranches is true all the branches of the subbranches are; /// also put to the cache.; ///; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:111,cache,cache,111,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add branch with name bname to the Tree cache.; /// If bname=""*"" all branches are added to the cache.; /// if subbranches is true all the branches of the subbranches are; /// also put to the cache.; ///; /// Returns:; /// - 0 branch added or already included; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:125,cache,cache,125,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add data objects that might be needed during the processing of; /// the selector (see Process()). This object can be very large, so they; /// are distributed in an optimized way using a dedicated file.; /// If push is TRUE the input data are sent over even if no apparent change; /// occured to the list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:250,optimiz,optimized,250,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add details on cache contents when printing in tree mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx:101,cache,cache,101,roofit/roofitcore/src/RooObjCacheManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Add new slice to calo tower. Updates cached variables fMaxValE; /// and fMaxValEt; /// Return last index in the vector of slice infos.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloData.cxx:123,cache,cached,123,graf3d/eve/src/TEveCaloData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloData.cxx,2,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Adds a text item to the end of the cache, removing as many items; /// from the front as required to keep cache size below limit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:121,cache,cache,121,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Adds an already constructed method to be managed by this factory.; ///; /// \note Private.; /// \note Know what you are doing when using this method. The method that you; /// are loading could be trained already.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx:265,load,loading,265,tmva/tmva/src/Factory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx,1,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Advertise capability to perform (analytical) integrals; /// internally. For a given integration request over allVars while; /// normalized over normSet2 and in range 'rangeName', returns; /// largest subset that can be performed internally in analVars; /// Return code is unique integer code identifying integration scenario; /// to be passed to analyticalIntegralWN() to calculate requeste integral; ///; /// Class RooAbsAnaConv defers analytical integration request to; /// resolution model and/or coefficient implementations and; /// aggregates results into composite configuration with a unique; /// code assigned by RooAICRegistry",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx:110,perform,perform,110,roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,2,['perform'],"['perform', 'performed']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Advertises internal (analytical) integration capabilities. Call; /// is forwarded to RooHistPdf cache p.d.f of cache that is used for; /// given choice of observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:182,cache,cache,182,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Align a physical node with a new relative matrix/shape.; /// Example: /TOP_1/A_1/B_1/C_1; /// node->Align(transl_1, box) will perform:; /// - change RELATIVE translation of C_1 node (with respect to its; /// container volume B) to transl_1; /// - change the shape of the C volume; /// *NOTE* The operations will affect ONLY the LAST node in the branch. All; /// volumes/nodes in the branch represented by this physical node are; /// CLONED so the operation does not affect other possible replicas.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPhysicalNode.cxx:212,perform,perform,212,geom/geom/src/TGeoPhysicalNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPhysicalNode.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Analyze and print reports for performed tests",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressGraphics.cxx:116,perform,performed,116,test/stressGraphics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressGraphics.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Apply a 2D viewport delta (shift) to the projection of worldRef onto viewport,; /// returning the resultant world vector which equates to it. Useful for making; /// 3D world objects track mouse moves.; ///; /// Camera must have valid frustum cache - call Apply()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:328,cache,cache,328,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Apply the camera to the current GL context, setting the viewport, projection; /// and modelview matrices. After this vertices etc can be directly entered; /// in the world frame. This also updates the cached frustum values, enabling; /// all the projection, overlap tests etc defined in TGLCamera to be used.; ///; /// Arguments are:; /// - 'box' - view volume box - ignored for ortho camera. Assumed to be same; /// as one passed to Setup().; /// - 'pickRect' - optional picking rect. If non-null, restrict drawing to this; /// viewport rect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLOrthoCamera.cxx:287,cache,cached,287,graf3d/gl/src/TGLOrthoCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLOrthoCamera.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Apply the camera to the current GL context, setting the viewport, projection; /// and modelview matrices. After this vertices etc can be directly entered; /// in the world frame. This also updates the cached frustum values, enabling; /// all the projection, overlap tests etc defined in TGLCamera to be used.; ///; /// Arguments are:; /// - 'box' - view volume box - used to adjust near/far clipping; /// - 'pickRect' - optional picking rect. If non-null, restrict drawing to this; /// viewport rect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPerspectiveCamera.cxx:287,cache,cached,287,graf3d/gl/src/TGLPerspectiveCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPerspectiveCamera.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Assert cell id cache is ok.; /// Returns true if the cache has been updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo.cxx:101,cache,cache,101,graf3d/eve/src/TEveCalo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo.cxx,4,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Asynchronous pad update.; /// In case of web-based canvas triggers update of the canvas on the client side,; /// but does not wait that real update is completed. Avoids blocking of caller thread.; /// Have to be used if called from other web-based widget to avoid logical dead-locks.; /// In case of normal canvas just canvas->Update() is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx:425,perform,performed,425,graf2d/gpad/src/TCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx,2,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Attach object to a branch of given TTree. By default it will; /// register the internal value cache RooAbsReal::_value as branch; /// buffer for a double tree branch with the same name as this; /// object. If no double branch is found with the name of this; /// object, this method looks for a Float_t Int_t, UChar_t and UInt_t, etc; /// branch. If any of these are found, a TreeReadBuffer; /// that branch is created, and saved in _treeReadBuffer.; /// TreeReadBuffer::operator double() can be used to convert the values.; /// This is used by copyCache().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:180,cache,cache,180,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Automatic pad generation by division.; ///; /// - The current canvas is divided in nx by ny equal divisions (pads).; /// - xmargin is the space along x between pads in percent of canvas.; /// - ymargin is the space along y between pads in percent of canvas.; /// - color is the color of the new pads. If 0, color is the canvas color.; ///; /// Pads are automatically named `canvasname_n` where `n` is the division number; /// starting from top left pad.; ///; /// Example if canvasname=c1 , nx=2, ny=3:; ///; /// \image html gpad_pad3.png; ///; /// Once a pad is divided into sub-pads, one can set the current pad; /// to a subpad with a given division number as illustrated above; /// with TPad::cd(subpad_number).; ///; /// For example, to set the current pad to c1_4, one can do:; /// ~~~ {.cpp}; /// c1->cd(4); /// ~~~; /// __Note1:__ c1.cd() is equivalent to c1.cd(0) and sets the current pad; /// to c1 itself.; ///; /// __Note2:__ after a statement like c1.cd(6), the global variable gPad; /// points to the current pad. One can use gPad to set attributes; /// of the current pad.; ///; /// __Note3:__ in case xmargin <=0 and ymargin <= 0, there is no space; /// between pads. The current pad margins are recomputed to; /// optimize the layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:1317,optimiz,optimize,1317,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['optimiz'],['optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Backup the current state without affecting the cache stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:133,cache,cache,133,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Baskets associated to this branch are forced to be in memory.; /// You can call TTree::SetMaxVirtualSize(maxmemory) to instruct; /// the system that the total size of the imported baskets does not; /// exceed maxmemory bytes.; ///; /// The function returns the number of baskets that have been put in memory.; /// This method may be called to force all baskets of one or more branches; /// in memory when random access to entries in this branch is required.; /// See also TTree::LoadBaskets to load all baskets of all branches in memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:565,Load,LoadBaskets,565,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,2,"['Load', 'load']","['LoadBaskets', 'load']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Books MVA method. The option configuration string is custom for each MVA; /// the TString field ""theNameAppendix"" serves to define (and distinguish); /// several instances of a given MVA, eg, when one wants to compare the; /// performance of various configurations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx:313,perform,performance,313,tmva/tmva/src/Factory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Build and return the posterior function (not normalized) as a RooAbsReal; /// the posterior is obtained from the product of the likelihood function and the; /// prior pdf which is then integrated in the nuisance parameters (if existing).; /// A prior function for the nuisance can be specified either in the prior pdf object; /// or in the model itself. If no prior nuisance is specified, but prior parameters are then; /// the integration is performed assuming a flat prior for the nuisance parameters.; ///; /// NOTE: the return object is managed by the BayesianCalculator class, users do not need to delete it,; /// but the object will be deleted when the BayesiabCalculator object is deleted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:529,perform,performed,529,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Builds the cache for physical nodes and global matrices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:97,cache,cache,97,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// By default the interpretation of the fraction coefficients is; /// performed in the contextual choice of observables. This makes the; /// shape of the p.d.f explicitly dependent on the choice of; /// observables. This method instructs RooAddModel to freeze the; /// interpretation of the coefficients to be done in the given set of; /// observables. If frozen, fractions are automatically transformed; /// from the reference normalization set to the contextual normalization; /// set by ratios of integrals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:153,perform,performed,153,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// By default the interpretation of the fraction coefficients is; /// performed in the contextual choice of observables. This makes the; /// shape of the p.d.f explicitly dependent on the choice of; /// observables. This method instructs RooAddPdf to freeze the; /// interpretation of the coefficients to be done in the given set of; /// observables. If frozen, fractions are automatically transformed; /// from the reference normalization set to the contextual normalization; /// set by ratios of integrals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:153,perform,performed,153,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// By default the interpretation of the fraction coefficients is; /// performed in the default range. This make the shape of a RooAddModel; /// explicitly dependent on the range of the observables. To allow; /// a range independent definition of the fraction this function; /// instructs RooAddModel to freeze its interpretation in the given; /// named range. If the current normalization range is different; /// from the reference range, the appropriate fraction coefficients; /// are automatically calculated from the reference fractions using; /// ratios of integrals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:153,perform,performed,153,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Cache given RooAbsArgs with this tree: The tree is; /// given direct write access of the args internal cache; /// the args values is pre-calculated for all data points; /// in this data collection. Upon a get() call, the; /// internal cache of 'newVar' will be loaded with the; /// precalculated value and it's dirty flag will be cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:86,Cache,Cache,86,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,4,"['Cache', 'cache', 'load']","['Cache', 'cache', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Cache given RooAbsArgs: The tree is; /// given direct write access of the args internal cache; /// the args values is pre-calculated for all data points; /// in this data collection. Upon a get() call, the; /// internal cache of 'newVar' will be loaded with the; /// precalculated value and it's dirty flag will be cleared.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx:86,Cache,Cache,86,roofit/roofitcore/src/RooVectorDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx,4,"['Cache', 'cache', 'load']","['Cache', 'cache', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Caches calculated summary statistics of transformed variables.; ///; /// \param[in] k index of class; /// \param[in] ivar index of variable; /// \param[in] mean the mean value of the variable; /// \param[in] rms the root-mean-square value of the variable; /// \param[in] min the minimum value of the variable; /// \param[in] max the maximum value of the variable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/TransformationHandler.cxx:86,Cache,Caches,86,tmva/tmva/src/TransformationHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/TransformationHandler.cxx,1,['Cache'],['Caches']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Calculate and return value of test statistic. If the test statistic; /// is calculated from a RooSimultaneous, the test statistic calculation; /// is performed separately on each simultaneous p.d.f component and associated; /// data, and then combined. If the test statistic calculation is parallelized,; /// partitions are calculated in nCPU processes and combined a posteriori.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsTestStatistic.cxx:236,perform,performed,236,roofit/roofitcore/src/RooAbsTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsTestStatistic.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Calculate integral internally from appropriate integral cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddition.cxx:142,cache,cache,142,roofit/roofitcore/src/RooAddition.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddition.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Calculate integral internally from appropriate partial integral cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:150,cache,cache,150,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; /// (as rect) against the viewport rect.; /// Camera must have valid frustum cache - call Apply() after last modification, before using.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:244,cache,cache,244,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Calculate overlap (kInside, kOutside, kPartial) of box with camera; /// frustum; /// Camera must have valid frustum cache - call Apply() after last modification, before using",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:202,cache,cache,202,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Calculate shape of p.d.f for x,alpha values; /// defined by dIter iterator over cache histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:166,cache,cache,166,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Calculate the numeric running integral and store; /// the result in the cache histogram provided; /// by RooAbsCachedPdf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:158,cache,cache,158,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Calculate viewport rectangle which just contains projection of; /// world frame bounding box 'box' onto the viewport. If face is; /// null the rect contains the whole bounding box (8 vertices/6; /// faces). If face is non-null it indicates a box face, and the; /// rect contains the single face (4 vertices). Note use other; /// version of ViewportRect() if you wish to just pass a static; /// EFace enum member (e.g. kFaceLowX); ///; /// Note:; /// 1. Rectangle is NOT clipped by viewport limits - so can result; /// in rect with corners outside viewport - negative etc; /// 2. TGLRect provides int (pixel based) values - not subpixel accurate; /// 3. Camera must have valid frustum cache - call Apply() after last; /// modification, before calling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:770,cache,cache,770,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Calculates the ROC integral (AUC); ///; /// @param num_points Granularity of the resulting curve used for integration.; /// The curve will be subdivided into num_points - 1 regions; /// where the performance of the classifier is sampled.; /// Larger number means more accurate, but more costly,; /// evaluation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ROCCurve.cxx:282,perform,performance,282,tmva/tmva/src/ROCCurve.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ROCCurve.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Calculates the difference between the union and intersection of; /// two regions.; ///; /// \param [in] rega, regb specify the two regions with which you want to perform; /// the computation; /// \param [in] result returns the result of the computation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx:248,perform,perform,248,core/base/src/TVirtualX.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Calculates the entry offset array, if possible.; ///; /// Result is cached, meaning that this should only be invoked once per basket.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:154,cache,cached,154,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Call the Optimizer with the set of parameters and ranges that; /// are meant to be tuned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:95,Optimiz,Optimizer,95,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,2,"['Optimiz', 'tune']","['Optimizer', 'tuned']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Call the Optimizer with the set of parameters and ranges that; /// are meant to be tuned.; // std::map<TString,Double_t> TMVA::MethodCrossValidation::OptimizeTuningParameters(TString fomType, TString fitType); // {; // }; ////////////////////////////////////////////////////////////////////////////////; /// Set the tuning parameters according to the argument.; // void TMVA::MethodCrossValidation::SetTuneParameters(std::map<TString,Double_t> tuneParameters); // {; // }; ////////////////////////////////////////////////////////////////////////////////; /// training.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCrossValidation.cxx:95,Optimiz,Optimizer,95,tmva/tmva/src/MethodCrossValidation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCrossValidation.cxx,4,"['Optimiz', 'tune']","['OptimizeTuningParameters', 'Optimizer', 'tuneParameters', 'tuned']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Callback that actually performs the projection.; /// Called when projection parameters have been updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveStraightLineSet.cxx:109,perform,performs,109,graf3d/eve/src/TEveStraightLineSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveStraightLineSet.cxx,3,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Called by TChain::LoadTree when the parent chain changes it's tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx:104,Load,LoadTree,104,tree/treeplayer/src/TTreeIndex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx,1,['Load'],['LoadTree']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Called by the read cache to check if the requested data is not; /// in the write cache buffer.; /// Returns -1 if data not in write cache,; /// 0 otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx:105,cache,cache,105,io/io/src/TFileCacheWrite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Called when a new tree is loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx:112,load,loaded,112,proof/proofplayer/src/TProofDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Change cache operation mode to given mode. If recurseAdirty; /// is true, then a mode change to AlwaysDirty will automatically; /// be propagated recursively to all client nodes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:93,cache,cache,93,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Change current path to point to the node having this id.; /// Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCache.cxx:206,perform,performance,206,geom/geom/src/TGeoCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCache.cxx,3,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Change the file that is being cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:116,cache,cached,116,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Change the interpolation order that is used in RooHistPdf cache; /// representation smoothing the RooDataHist shapes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:144,cache,cache,144,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Change the underlying buffer size of the cache.; /// If the change of size means some cache content is lost, or if the buffer; /// is now larger, setup for a cache refill the next time there is a read; /// Buffersize might be clamped, see TFileCacheRead::SetBufferSize; /// Returns:; /// - 0 if the buffer content is still available; /// - 1 if some or all of the buffer content has been made unavailable; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:127,cache,cache,127,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Change the underlying buffer size of the cache.; /// The buffersize might be clamped, see TFileCacheRead::SetBufferSize; /// Returns:; /// - 0 if the buffer content is still available; /// - 1 if some or all of the buffer content has been made unavailable; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:127,cache,cache,127,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Check if Ged library is loaded and load geometry editor classe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoPainter.cxx:110,load,loaded,110,geom/geompainter/src/TGeoPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoPainter.cxx,2,['load'],"['load', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Check if a file needs to be send to the slave. Use the following; /// algorithm:; /// - check if file appears in file map; /// - if yes, get file's modtime and check against time in map,; /// if modtime not same get md5 and compare against md5 in map,; /// if not same return kTRUE.; /// - if no, get file's md5 and modtime and store in file map, ask; /// slave if file exists with specific md5, if yes return kFALSE,; /// if no return kTRUE.; /// The options 'cpopt' define if to copy things from cache to sandbox and what.; /// To retrieve from the cache the binaries associated with the file TProof::kCpBin; /// must be set in cpopt; the default is copy everything.; /// Returns kTRUE in case file needs to be send, returns kFALSE in case; /// file is already on remote node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:584,cache,cache,584,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Check if cache entry was previously created",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:95,cache,cache,95,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Check if class ""classname"" is known to the interpreter (in fact,; /// this check is not needed anymore, so classname is ignored). If; /// not it will load library ""libname"". If the library couldn't be found with original; /// libname and if the name was not prefixed with lib, try to prefix with ""lib"" and search again.; /// If DynamicPathName still couldn't find the library, return -1.; /// If check is true it will only check if libname exists and is; /// readable.; /// Returns 0 on successful loading, -1 in case libname does not; /// exist or in case of error and -2 in case of version mismatch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:236,load,load,236,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,2,['load'],"['load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Check if lib is in the dynamic linker cache, returns true if it is, and if so,; /// modifies the library file name parameter `lib` from `/usr/lib/libFOO.dylib`; /// to `-lFOO` such that it can be passed to the linker.; /// This is a unique feature of macOS 11.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:124,cache,cache,124,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Check if the argument is a sane cling argument. Performing the following checks:; /// 1) It does not start with ""--"" and is not the --param option.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:134,Perform,Performing,134,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['Perform'],['Performing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Check if the local cache information for group, user, dsName is up-to-date; /// If not, make the relevant updates; /// Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx:105,cache,cache,105,proof/proof/src/TDataSetManagerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Check the memory cache associated with file 'fn'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHandleDataSet.cxx:103,cache,cache,103,proof/proofbench/src/TSelHandleDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHandleDataSet.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Check whether a class has a dictionary or ROOT can load one.; /// This is equivalent to ask HasDictionary() or whether a library is known; /// where it can be loaded from, or whether a Dictionary function is; /// available because the class's dictionary library was already loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:137,load,load,137,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,3,['load'],"['load', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Check whether a class has a dictionary or not.; /// This is equivalent to ask if a class is coming from a bootstrapping; /// procedure initiated during the loading of a library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:242,load,loading,242,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// CheckFile() returns kTRUE on success and kFALSE on failure. In; /// case the file exists but is not cached, CheckFile() returns; /// kFALSE and errno is set to EAGAIN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/dcache/src/TDCacheFile.cxx:186,cache,cached,186,io/dcache/src/TDCacheFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/dcache/src/TDCacheFile.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Checks if an entity with the specified name is defined in Cling.; /// Returns kUnknown if the entity is not defined.; /// Returns kWithClassDefInline if the entity exists and has a ClassDefInline; /// Returns kKnown if the entity is defined.; ///; /// By default, structs, namespaces, classes, enums and unions are looked for.; /// If the flag isClassOrNamespaceOnly is true, classes, structs and; /// namespaces only are considered. I.e. if the name is an enum or a union,; /// the returned value is false.; ///; /// In the case where the class is not loaded and belongs to a namespace; /// or is nested, looking for the full class name is outputting a lots of; /// (expected) error messages. Currently the only way to avoid this is to; /// specifically check that each level of nesting is already loaded.; /// In case of templates the idea is that everything between the outer; /// '<' and '>' has to be skipped, e.g.: `aap<pippo<noot>::klaas>::a_class`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:639,load,loaded,639,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Checks if macro 'mac' is loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx:111,load,loaded,111,graf3d/eve/src/TEveUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx,2,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Claim n virtual machines; /// This function figures out the image and performance index before returning; /// the list of condor slaves",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TCondor.cxx:156,perform,performance,156,proof/proof/src/TCondor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TCondor.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Claim virtual machine with name vmname; /// This function does not figure out the image and performance index before; /// returning the condor slave",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TCondor.cxx:178,perform,performance,178,proof/proof/src/TCondor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TCondor.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Clear DL cache and reset internal point array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveJetConeGL.cxx:95,cache,cache,95,graf3d/eve/src/TEveJetConeGL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveJetConeGL.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Clear all cache elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx:96,cache,cache,96,roofit/roofitcore/src/RooExpensiveObjectCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Clear all entries for all LODs for this drawable from the; /// display list cache but keeping the reserved ids from GL context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:162,cache,cache,162,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Clear cache element with given unique ID; /// Retrieve payload object of cache element with given unique ID",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx:92,cache,cache,92,roofit/roofitcore/src/RooExpensiveObjectCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Clear cached information matching uri",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx:92,cache,cached,92,proof/proof/src/TDataSetManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx,2,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Clear the GenData cache as its content is not invariant under changes in; /// the mu vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:104,cache,cache,104,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Clear the cache of GCs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:96,cache,cache,96,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Clear the content of the dataset cache, if any (matching 'dataset', if defined).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:119,cache,cache,119,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Clone an object.; /// This function is called when the directory is not a TDirectoryFile.; /// This version has to load the I/O package, hence via Cling.; ///; /// If autoadd is true and if the object class has a; /// DirectoryAutoAdd function, it will be called at the end of the; /// function with the parameter gDirector. This usually means that; /// the object will be appended to the current ROOT directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx:201,load,load,201,core/base/src/TDirectory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Close a Web file. Close the socket connection and delete the cache; /// See also the TFile::Close() function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:147,cache,cache,147,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Closing geometry implies checking the geometry validity, fixing shapes; /// with negative parameters (run-time shapes)building the cache manager,; /// voxelizing all volumes, counting the total number of physical nodes and; /// registering the manager class to the browser.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:217,cache,cache,217,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Collect class signal lists from class cls and all its; /// base-classes.; ///; /// The recursive traversal is not performed for classes not; /// deriving from TQClass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQObject.cxx:200,perform,performed,200,core/base/src/TQObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQObject.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Compute the X and Y values corresponding to the minimum value of the function; ///; /// Return the minimum value of the function; /// To find the minimum on a range, first set this range via the SetRange function; ///; /// Method:; /// First, a grid search is performed to find the initial estimate of the; /// minimum location. The range of the function is divided into fNpx and fNpy; /// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; /// by SetNpx and SetNpy functions; /// Then, a minimization is used with starting values found by the grid search; /// The minimizer algorithm used (by default Minuit) can be changed by callinga; /// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); /// Other option for the minimizer can be set using the static method of the MinimizerOptions class; ///; /// Note that this method will always do first a grid search in contrast to GetMinimum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:346,perform,performed,346,hist/hist/src/TF2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Compute the X, Y and Z values corresponding to the minimum value of the function; /// on its range.; ///; /// Returns the function value at the minimum.; /// To find the minimum on a subrange, use the SetRange() function first.; ///; /// Method:; /// First, a grid search is performed to find the initial estimate of the; /// minimum location. The range of the function is divided; /// into fNpx,fNpy and fNpz sub-ranges. If the function is ""good"" (or ""bad""),; /// these values can be changed by SetNpx(), SetNpy() and SetNpz() functions.; /// Then, Minuit minimization is used with starting values found by the grid search; ///; /// Note that this method will always do first a grid search in contrast to GetMinimum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx:361,perform,performed,361,hist/hist/src/TF3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Compute the best axis limits for the X and Y axis.; ///; /// If the bit kIsInteger is set, the number of channels is also recomputed.; /// The axis parameters are replaced by the optimized parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:265,optimiz,optimized,265,hist/hist/src/THLimitsFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Compute the best axis limits for the X axis.; ///; /// If the bit kIsInteger is set, the number of channels is also recomputed.; /// The axis parameters are replaced by the optimized parameters.; ///; /// Example:; /// With the input parameters xmin=-1.467 and xmax=2.344, the function; /// will compute better limits -1.8 and 2.7 and store them in the axis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:259,optimiz,optimized,259,hist/hist/src/THLimitsFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Compute the best axis limits for the X, Y and Z axis.; ///; /// If the bit kIsInteger is set, the number of channels is also recomputed.; /// The axis parameters are replaced by the optimized parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:268,optimiz,optimized,268,hist/hist/src/THLimitsFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Compute the glyphs positions, fgAscent and fgWidth (needed for alignment).; /// Perform the Glyphs transformation.; /// Compute the string control box.; /// If required take the ""kerning"" into account.; /// SetRotation and PrepareString should have been called before.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TTF.cxx:166,Perform,Perform,166,graf2d/graf/src/TTF.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TTF.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Compute ticks positions. Linear and not optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLAxis.cxx:126,optimiz,optimized,126,graf3d/gl/src/TGLAxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLAxis.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Compute ticks positions. Linear and optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLAxis.cxx:122,optimiz,optimized,122,graf3d/gl/src/TGLAxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLAxis.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Computes the intersection of two regions.; ///; /// \param [in] rega, regb specify the two regions with which you want to perform; /// the computation; /// \param [in] result returns the result of the computation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx:208,perform,perform,208,core/base/src/TVirtualX.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Computes the union of two regions.; ///; /// \param [in] rega, regb specify the two regions with which you want to perform; /// the computation; /// \param [in] result returns the result of the computation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx:201,perform,perform,201,core/base/src/TVirtualX.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Connects the TTree to Neurons in input and output; /// layers. The formulas associated to each neuron are created; /// and reported to the network formula manager.; /// By default, the branch is not normalised since this would degrade; /// performance for classification jobs.; /// Normalisation can be requested by putting '@' in front of the formula.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx:326,perform,performance,326,math/mlp/src/TMultiLayerPerceptron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Construct RunningIntegral CacheElement",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:112,Cache,CacheElement,112,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,1,['Cache'],['CacheElement']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Construct integral of 'function' over observables in 'depList'; /// in range 'rangeName' with normalization observables 'funcNormSet'; /// (for p.d.f.s). In the integral is performed to the maximum extent; /// possible the internal (analytical) integrals advertised by function.; /// The other integrations are performed numerically. The optional; /// config object prescribes how these numeric integrations are configured.; ///; /// \Note If pdf component selection was globally overridden to always include; /// all components (either with RooAbsReal::globalSelectComp(bool) or a; /// RooAbsReal::GlobalSelectComponentRAII), then any created integral will; /// ignore component selections during its lifetime. This is especially useful; /// when creating normalization or projection integrals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:259,perform,performed,259,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,2,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Construct of cache element, copy relevant input from RooIntegralMorph,; /// create the cdfs from the input p.d.fs and instantiate the root finders; /// on the cdfs to perform the inversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:99,cache,cache,99,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,2,"['cache', 'perform']","['cache', 'perform']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Construct string with unique suffix for cache objects based on; /// observable names that define cache configuration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:126,cache,cache,126,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Construct unique suffix name for cache p.d.f object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx:119,cache,cache,119,roofit/roofitcore/src/RooAbsCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for numerical (FFT) convolution of PDFs.; /// \param[in] name Name of this PDF; /// \param[in] title Title for plotting this PDF; /// \param[in] convVar Observable to convolve the PDFs in \attention Use a high number of bins (>= 1000) for good accuracy.; /// \param[in] pdf1 First PDF to be convolved; /// \param[in] pdf2 Second PDF to be convolved; /// \param[in] ipOrder Order for interpolation between bins (since FFT is discrete); /// The binning used for the FFT sampling is controlled by the binning named ""cache"" in the convolution observable `convVar`.; /// If such a binning is not set, the same number of bins as for `convVar` will be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:611,cache,cache,611,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor from a list of PDFs.; ///; /// The optional cutOff parameter can be used as a speed optimization if; /// one or more of the PDF have sizable regions with very small values,; /// which would pull the entire product of PDFs to zero in those regions.; ///; /// After each PDF multiplication, the running product is compared with; /// the cutOff parameter. If the running product is smaller than the; /// cutOff value, the product series is terminated and remaining PDFs; /// are not evaluated.; ///; /// There is no magic value of the cutOff, the user should experiment; /// to find the appropriate balance between speed and precision.; /// If a cutoff is specified, the PDFs most likely to be small should; /// be put first in the product. The default cutOff value is zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:182,optimiz,optimization,182,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor of cache object which owns RooDataHist cache histogram,; /// RooHistPdf pdf that represents is shape and RooChangeTracker meta; /// object that tracks changes in listed dependent parameter of cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:101,cache,cache,101,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor of cache storage unit class; ///; /// Create RooDataHist that will cache function values and create; /// RooHistFunc that represent s RooDataHist shape as function, create; /// meta object that tracks changes in declared parameters of p.d.f; /// through actualParameters()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx:101,cache,cache,101,roofit/roofitcore/src/RooAbsCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; /// all cache elements will be cleared when a server redirect is intercepted by the cache manager.; /// This is the default strategy and should only be overridden when you really understand; /// what you're doing as properly implementing server redirect in cache elements can get very; /// complicated, especially if there are (cyclical) reference back to the owning object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx:108,cache,cache,108,roofit/roofitcore/src/RooObjCacheManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx,4,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor taking name, title and function to be cached and; /// fixed choice of variable to cache. To control granularity of the; /// binning of the cache histogram set the desired properties in the; /// binning named ""cache"" in the observables of the function.; /// If the fixed set of cache observables does not match the observables; /// defined in the use context of the p.d.f the cache is still filled; /// completely. Ee.g. when it is specified to cache x and p and only x; /// is a observable in the given use context the cache histogram will; /// store sampled values for all values of observable x and parameter p.; /// In such a mode of operation the cache will also not be recalculated; /// if the observable p changes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx:136,cache,cached,136,roofit/roofitcore/src/RooCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx,18,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor taking name, title and function to be cached. To control; /// granularity of the binning of the cache histogram set the desired properties; /// in the binning named ""cache"" in the observables of the function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedReal.cxx:136,cache,cached,136,roofit/roofitcore/src/RooCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedReal.cxx,3,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor taking name, title and function to be cached. To control; /// granularity of the binning of the cache histogram set the desired properties; /// in the binning named ""cache"" in the observables of the function. The dimensions; /// of the cache are automatically matched to the number of observables used; /// in each use context. Multiple cache in different observable may exists; /// simultaneously if the cached p.d.f is used with multiple observable; /// configurations simultaneously",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx:136,cache,cached,136,roofit/roofitcore/src/RooCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx,6,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with 2 PDFs (most frequent use case).; ///; /// The optional cutOff parameter can be used as a speed optimization if; /// one or more of the PDF have sizable regions with very small values,; /// which would pull the entire product of PDFs to zero in those regions.; ///; /// After each PDF multiplication, the running product is compared with; /// the cutOff parameter. If the running product is smaller than the; /// cutOff value, the product series is terminated and remaining PDFs; /// are not evaluated.; ///; /// There is no magic value of the cutOff, the user should experiment; /// to find the appropriate balance between speed and precision.; /// If a cutoff is specified, the PDFs most likely to be small should; /// be put first in the product. The default cutOff value is zero.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:199,optimiz,optimization,199,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor with observables x, pdf shapes pdf1 and pdf2 which represent; /// the shapes at the end points of the interpolation parameter alpha; /// If doCacheAlpha is true, a two-dimensional cache is constructed in; /// both alpha and x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:278,cache,cache,278,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor. Takes owner as argument and register cache with owner.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCache.cxx:136,cache,cache,136,roofit/roofitcore/src/RooAbsCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor. This object would transfer the data from; /// 'from' to 'to' using the method indicated in method.; ///; /// The value of the parameter 'method' determines in which; /// order the branches' baskets are written to the output file.; ///; /// When a TTree is filled the data is stored in the individual; /// branches' basket. Each basket is written individually to; /// the disk as soon as it is full. In consequence the baskets; /// of branches that contain 'large' data chunk are written to; /// the disk more often.; ///; /// There is currently 3 supported sorting order:; ///; /// SortBasketsByOffset (the default); /// SortBasketsByBranch; /// SortBasketsByEntry; ///; /// When using SortBasketsByOffset the baskets are written in; /// the output file in the same order as in the original file; /// (i.e. the basket are sorted on their offset in the original; /// file; Usually this also means that the baskets are sorted; /// on the index/number of the _last_ entry they contain); ///; /// When using SortBasketsByBranch all the baskets of each; /// individual branches are stored contiguously. This tends to; /// optimize reading speed when reading a small number (1->5) of; /// branches, since all their baskets will be clustered together; /// instead of being spread across the file. However it might; /// decrease the performance when reading more branches (or the full; /// entry).; ///; /// When using SortBasketsByEntry the baskets with the lowest; /// starting entry are written first. (i.e. the baskets are; /// sorted on the index/number of the first entry they contain).; /// This means that on the file the baskets will be in the order; /// in which they will be needed when reading the whole tree; /// sequentially.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx:1216,optimiz,optimize,1216,tree/tree/src/TTreeCloner.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Constructor: check PROOF and load selectors PAR",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx:115,load,load,115,proof/proofbench/src/TProofBench.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx,2,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Control global dirty inhibit mode. When set to true no value or shape dirty; /// flags are propagated and cache is always considered to be dirty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:192,cache,cache,192,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Convert a 2D viewport position to 3D world line - the projection of the; /// viewport point into 3D space. Line runs from near to far camera clip planes; /// (the minimum and maximum visible depth). See also; /// TGLVertex3 TGLCamera::ViewportToWorld(const TGLVertex3 & viewportVertex) const; /// for 3D viewport -> 3D world vertex conversions.; /// See also OpenGL gluUnProject & glDepth documentation; ///; /// Camera must have valid frustum cache - call Apply() after last modification, before using",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:530,cache,cache,530,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Convert a 3D vector worldDelta (shift) about vertex worldRef to a viewport; /// (screen) '3D' vector. The X()/Y() components of the vector are the horizontal /; /// vertical pixel deltas. The Z() component is the viewport depth delta - for a; /// default depth range between 0.0 (at near clip plane) to 1.0 (at far clip plane); /// See OpenGL gluProject & glDepth documentation; ///; /// Camera must have valid frustum cache - call Apply()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:505,cache,cache,505,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Convert a 3D world vertex to '3D' viewport (screen) one. The X()/Y(); /// components of the viewport vertex are the horizontal/vertical pixel; /// positions. The Z() component is the viewport depth value - for a; /// default depth range this is 0.0 (at near clip plane) to 1.0 (at far; /// clip plane). See OpenGL gluProject & glDepth documentation; ///; /// Camera must have valid frustum cache - call Apply() after last modification, before using",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:476,cache,cache,476,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Convert the distance along unit vector DIR to local frame. If DIR; /// is not specified perform a conversion such as the returned distance is the; /// the minimum for all possible directions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx:174,perform,perform,174,geom/geom/src/TGeoMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Convert the local distance along unit vector DIR to master frame. If DIR; /// is not specified perform a conversion such as the returned distance is the; /// the minimum for all possible directions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx:181,perform,perform,181,geom/geom/src/TGeoMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copies first pending event from event queue to Event_t structure; /// and removes event from queue. Not all of the event fields are valid; /// for each event type, except fType and fWindow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:124,queue,queue,124,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,4,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy a Tree with selection, make a clone of this Tree header, then copy the; /// selected entries.; ///; /// - selection is a standard selection expression (see TTreePlayer::Draw); /// - option is reserved for possible future use; /// - nentries is the number of entries to process (default is all); /// - first is the first entry to process (default is 0); ///; /// IMPORTANT: The copied tree stays connected with this tree until this tree; /// is deleted. In particular, any changes in branch addresses; /// in this tree are forwarded to the clone trees. Any changes; /// made to the branch addresses of the copied trees are over-ridden; /// anytime this tree changes its branch addresses.; /// Once this tree is deleted, all the addresses of the copied tree; /// are reset to their default values.; ///; /// The following example illustrates how to copy some events from the Tree; /// generated in $ROOTSYS/test/Event; /// ~~~{.cpp}; /// gSystem->Load(""libEvent"");; /// TFile f(""Event.root"");; /// TTree *T = (TTree*)f.Get(""T"");; /// Event *event = new Event();; /// T->SetBranchAddress(""event"",&event);; /// TFile f2(""Event2.root"",""recreate"");; /// TTree *T2 = T->CopyTree(""fNtrack<595"");; /// T2->Write();; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:1036,Load,Load,1036,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy a macro, and its possible associated .h[h] file,; /// to the cache directory, from where the workers can get the file.; /// If headerRequired is 1, return -1 in case the header is not found.; /// If headerRequired is 0, try to copy header too.; /// If headerRequired is -1, don't look for header, only copy macro.; /// If the selector pionter is not 0, consider the macro to be a selector; /// and try to load the selector and set it to the pointer.; /// The mask 'opt' is an or of ESendFileOpt:; /// kCpBin (0x8) Retrieve from the cache the binaries associated; /// with the file; /// kCp (0x10) Retrieve the files from the cache; /// Return -1 in case of error, 0 otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:152,cache,cache,152,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,4,"['cache', 'load']","['cache', 'load']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy cache of another RooAbsArg to our cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsRealLValue.cxx:91,cache,cache,91,roofit/roofitcore/src/RooAbsRealLValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsRealLValue.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy cache of another RooAbsArg to our cache; ///; /// Warning: This function copies the cached values of source,; /// it is the callers responsibility to make sure the cache is clean",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooStringVar.cxx:91,cache,cache,91,roofit/roofitcore/src/RooStringVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooStringVar.cxx,4,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy constructor. Takes owner as argument and registers cache with owne.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCache.cxx:142,cache,cache,142,roofit/roofitcore/src/RooAbsCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy constructor. Track parameters are copied but the; /// extrapolation is not performed so you should still call; /// MakeTrack() to do that.; /// If points of 't' are locked, they are cloned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrack.cxx:166,perform,performed,166,graf3d/eve/src/TEveTrack.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrack.cxx,2,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy out relevant parts of buffer - we create and delete mesh; /// parts on demand in DirectDraw() and they are DL cached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCylinder.cxx:201,cache,cached,201,graf3d/gl/src/TGLCylinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCylinder.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy the cached value from given source and raise dirty flag.; /// It is the callers responsibility to ensure that the sources; /// cache is clean(valid) before this function is called, e.g. by; /// calling syncCache() on the source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCategory.cxx:95,cache,cached,95,roofit/roofitcore/src/RooAbsCategory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCategory.cxx,4,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy the cached value of another RooAbsArg to our cache.; /// Warning: This function just copies the cached values of source,; /// it is the callers responsibility to make sure the cache is clean.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:95,cache,cached,95,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,4,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy the cached value of another RooAbsArg to our cache; /// Warning: This function copies the cached values of source,; /// it is the callers responsibility to make sure the cache is clean",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx:95,cache,cached,95,roofit/roofitcore/src/RooRealVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx,4,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy the specified macro in the cache directory. The macro file is; /// uploaded if new or updated. If existing, the corresponding header; /// basename(macro).h or .hh, is also uploaded. For the other arguments; /// see TProof::Load().; /// Returns 0 in case of success and -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:118,cache,cache,118,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,2,"['Load', 'cache']","['Load', 'cache']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Copy this F1 to a new F1.; /// Note that the cached integral with its related arrays are not copied; /// (they are also set as transient data members)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:131,cache,cached,131,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create JSON representation of data, which should be send to the clients; /// Here server-side painting is performed - each drawable adds own elements in; /// so-called display list, which transferred to the clients",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/canvaspainter/src/RCanvasPainter.cxx:192,perform,performed,192,gui/canvaspainter/src/RCanvasPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/canvaspainter/src/RCanvasPainter.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create a NetFile object. A net file is the same as a TFile; /// except that it is being accessed via a rootd server. The url; /// argument must be of the form: root[k]://host.dom.ain/file.root.; /// When protocol is ""rootk"" try using kerberos5 authentication.; /// If the file specified in the URL does not exist, is not accessable; /// or can not be created the kZombie bit will be set in the TNetFile; /// object. Use IsZombie() to see if the file is accessable.; /// If the remote daemon thinks the file is still connected, while you are; /// sure this is not the case you can force open the file by preceding the; /// option argument with an ""-"", e.g.: ""-recreate"". Do this only; /// in cases when you are very sure nobody else is using the file.; /// To bypass the writelock on a file, to allow the reading of a file; /// that is being written by another process, explicitly specify the; /// ""+read"" option (""read"" being the default option).; /// The netopt argument can be used to specify the size of the tcp window in; /// bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; /// The default and minimum tcp window size is 65535 bytes.; /// If netopt < -1 then |netopt| is the number of parallel sockets that will; /// be used to connect to rootd. This option should be used on fat pipes; /// (i.e. high bandwidth, high latency links). The ideal number of parallel; /// sockets depends on the bandwidth*delay product. Generally 5-7 is a good; /// number.; /// For a description of the option and other arguments see the TFile ctor.; /// The preferred interface to this constructor is via TFile::Open().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx:1434,latency,latency,1434,net/net/src/TNetFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx,1,['latency'],['latency']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create a RooAddPdf cache element for a given normalization set and; /// projection configuration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx:105,cache,cache,105,roofit/roofitcore/src/RooAddHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create a RooPlot of the pull distribution for the given; /// parameter. The range lo-hi is plotted in nbins. If fitGauss is; /// set, an unbinned ML fit of the distribution to a Gaussian p.d.f; /// is performed. The fit result is overlaid on the returned RooPlot; /// and a box with the fitted mean and sigma is added.; ///; /// If the parameters of the models for generation and fit differ, simple heuristics are used to find the; /// corresponding parameters:; /// - Parameters have the same name: They will be used to compute pulls.; /// - Parameters have different names: The position of the fit parameter in the set of fit parameters will be; /// computed. The parameter at the same position in the set of generator parameters will be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx:287,perform,performed,287,roofit/roofitcore/src/RooMCStudy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create a mime type cache. Read the mime types file ""filename"" and; /// built a list of mime types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGMimeTypes.cxx:105,cache,cache,105,gui/gui/src/TGMimeTypes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGMimeTypes.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create a parallel server socket object for a named service. Set reuse; /// to true to force reuse of the server socket (i.e. do not wait for the; /// time out to pass). Using backlog one can set the desirable queue length; /// for pending connections.; /// Use tcpwindowsize to specify the size of the receive buffer, it has; /// to be specified here to make sure the window scale option is set (for; /// tcpwindowsize > 65KB and for platforms supporting window scaling).; /// Use IsValid() to check the validity of the; /// server socket. In case server socket is not valid use GetErrorCode(); /// to obtain the specific error value. These values are:; /// 0 = no error (socket is valid); /// -1 = low level socket() call failed; /// -2 = low level bind() call failed; /// -3 = low level listen() call failed; /// Every valid server socket is added to the TROOT sockets list which; /// will make sure that any open sockets are properly closed on; /// program termination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx:295,queue,queue,295,net/net/src/TPServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create a parallel server socket object on a specified port. Set reuse; /// to true to force reuse of the server socket (i.e. do not wait for the; /// time out to pass). Using backlog one can set the desirable queue length; /// for pending connections.; /// Use tcpwindowsize to specify the size of the receive buffer, it has; /// to be specified here to make sure the window scale option is set (for; /// tcpwindowsize > 65KB and for platforms supporting window scaling).; /// Use IsValid() to check the validity of the; /// server socket. In case server socket is not valid use GetErrorCode(); /// to obtain the specific error value. These values are:; /// 0 = no error (socket is valid); /// -1 = low level socket() call failed; /// -2 = low level bind() call failed; /// -3 = low level listen() call failed; /// Every valid server socket is added to the TROOT sockets list which; /// will make sure that any open sockets are properly closed on; /// program termination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx:295,queue,queue,295,net/net/src/TPServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPServerSocket.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create a parallel socket on a connection already opened via; /// TSocket sock.; /// This constructor is provided to optimize TNetFile opening when; /// instatiated via a call to TNetXNGFile.; /// Returns when connection has been accepted by remote side. Use IsValid(); /// to check the validity of the socket. Every socket is added to the TROOT; /// sockets list which will make sure that any open sockets are properly; /// closed on program termination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx:202,optimiz,optimize,202,net/net/src/TPSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx,1,['optimiz'],['optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create a server socket object for a named service. Set reuse to true; /// to force reuse of the server socket (i.e. do not wait for the time; /// out to pass). Using backlog one can set the desirable queue length; /// for pending connections.; /// Use tcpwindowsize to specify the size of the receive buffer, it has; /// to be specified here to make sure the window scale option is set (for; /// tcpwindowsize > 65KB and for platforms supporting window scaling).; /// Use IsValid() to check the validity of the; /// server socket. In case server socket is not valid use GetErrorCode(); /// to obtain the specific error value. These values are:; /// 0 = no error (socket is valid); /// -1 = low level socket() call failed; /// -2 = low level bind() call failed; /// -3 = low level listen() call failed; /// Every valid server socket is added to the TROOT sockets list which; /// will make sure that any open sockets are properly closed on; /// program termination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx:286,queue,queue,286,net/net/src/TServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create a server socket object on a specified port. Set reuse to true; /// to force reuse of the server socket (i.e. do not wait for the time; /// out to pass). Using backlog one can set the desirable queue length; /// for pending connections. If port is 0 a port scan will be done to; /// find a free port. This option is mutual exlusive with the reuse option.; /// Use tcpwindowsize to specify the size of the receive buffer, it has; /// to be specified here to make sure the window scale option is set (for; /// tcpwindowsize > 65KB and for platforms supporting window scaling).; /// Use IsValid() to check the validity of the; /// server socket. In case server socket is not valid use GetErrorCode(); /// to obtain the specific error value. These values are:; /// 0 = no error (socket is valid); /// -1 = low level socket() call failed; /// -2 = low level bind() call failed; /// -3 = low level listen() call failed; /// Every valid server socket is added to the TROOT sockets list which; /// will make sure that any open sockets are properly closed on; /// program termination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx:286,queue,queue,286,net/net/src/TServerSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TServerSocket.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create an object that represents the integral of the function over one or more observables listed in `iset`.; /// The actual integration calculation is only performed when the return object is evaluated. The name; /// of the integral object is automatically constructed from the name of the input function, the variables; /// it integrates and the range integrates over; ///; /// The following named arguments are accepted; /// | Type of CmdArg | Effect on CDF; /// | ---------------------|-------------------; /// | SupNormSet(const RooArgSet&) | Observables over which should be normalized _in addition_ to the integration observables; /// | ScanNumCdf() | Apply scanning technique if cdf integral involves numeric integration [ default ]; /// | ScanAllCdf() | Always apply scanning technique; /// | ScanNoCdf() | Never apply scanning technique; /// | ScanParameters(Int_t nbins, Int_t intOrder) | Parameters for scanning technique of making CDF: number of sampled bins and order of interpolation applied on numeric cdf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:243,perform,performed,243,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create an object that represents the integral of the function over one or more observables listed in `iset`.; /// The actual integration calculation is only performed when the returned object is evaluated. The name; /// of the integral object is automatically constructed from the name of the input function, the variables; /// it integrates and the range integrates over.; ///; /// \note The integral over a PDF is usually not normalised (*i.e.*, it is usually not; /// 1 when integrating the PDF over the full range). In fact, this integral is used *to compute*; /// the normalisation of each PDF. See the [rf110 tutorial](group__tutorial__roofit.html); /// for details on PDF normalisation.; ///; /// The following named arguments are accepted; /// | | Effect on integral creation; /// |--|-------------------------------; /// | `NormSet(const RooArgSet&)` | Specify normalization set, mostly useful when working with PDFs; /// | `NumIntConfig(const RooNumIntConfig&)` | Use given configuration for any numeric integration, if necessary; /// | `Range(const char* name)` | Integrate only over given range. Multiple ranges may be specified by passing multiple Range() arguments",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:243,perform,performed,243,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create an object that represents the integral of the function over one or more observables listed in iset.; /// The actual integration calculation is only performed when the return object is evaluated. The name; /// of the integral object is automatically constructed from the name of the input function, the variables; /// it integrates and the range integrates over. If nset is specified the integrand is request; /// to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified; /// the integral is performed over the named range, otherwise it is performed over the domain of each; /// integrated observable. If cfg is specified it will be used to configure any numeric integration; /// aspect of the integral. It will not force the integral to be performed numerically, which is; /// decided automatically by RooRealIntegral.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:241,perform,performed,241,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,4,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create an object that represents the running integral of the function over one or more observables listed in iset, i.e.; /// \f[; /// \int_{x_\mathrm{lo}}^x f(x') \, \mathrm{d}x'; /// \f]; ///; /// The actual integration calculation is only performed when the return object is evaluated. The name; /// of the integral object is automatically constructed from the name of the input function, the variables; /// it integrates and the range integrates over. The default strategy to calculate the running integrals is; ///; /// - If the integrand (this object) supports analytical integration, construct an integral object; /// that calculate the running integrals value by calculating the analytical integral each; /// time the running integral object is evaluated; ///; /// - If the integrand (this object) requires numeric integration to construct the running integral; /// create an object of class RooNumRunningInt which first samples the entire function and integrates; /// the sampled function numerically. This method has superior performance as there is no need to; /// perform a full (numeric) integration for each evaluation of the running integral object, but; /// only when one of its parameters has changed.; ///; /// The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; /// scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); /// argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; /// granularity for the scanning technique can be controlled with the ScanParameters technique; /// which allows to specify the number of samples to be taken, and to which order the resulting; /// running integral should be interpolated. The default values are 1000 samples and 2nd order; /// interpolation.; ///; /// The following named arguments are accepted; /// | | Effect on integral cr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:327,perform,performed,327,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create confidence levels drawing; /// tab. Then it call Virtual Fitter to perform it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx:160,perform,perform,160,gui/fitpanelv7/src/RFitPanel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create custom cache element for running integral calculations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:100,cache,cache,100,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create or recreate the dataset lists for 'uri'.; /// The list are saved in text form in 'uri'/ls.txt for fast browsing and in; /// 'uri'/ls.root in form of TMacro for optimized and portable transfer.; /// Return 0 on success, 1 if the file was empty, -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx:253,optimiz,optimized,253,proof/proof/src/TDataSetManagerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create performance graphs for this classifier a multiclass setting.; /// Requires that the method has already been evaluated (that a resultset; /// already exists.); ///; /// Currently uses the new way of calculating ROC Curves. If anything looks; /// fishy, please contact the ROOT TMVA team.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ResultsMulticlass.cxx:93,perform,performance,93,tmva/tmva/src/ResultsMulticlass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ResultsMulticlass.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create the selector object and save the relevant files and binary information; /// in the cache so that the worker can pick it up.; /// Returns 0 and fill fSelector in case of success. Returns -1 and sets; /// fSelector to 0 in case of failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayerLite.cxx:176,cache,cache,176,proof/proofplayer/src/TProofPlayerLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayerLite.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create timer which will invoke ProcessRequests() function periodically; ///; /// Timer is required to perform all actions in main ROOT thread; /// Method arguments are the same as for TTimer constructor; /// By default, sync timer with 100 ms period is created; ///; /// It is recommended to always use sync timer mode and only change period to; /// adjust server reaction time. Use of async timer requires, that application regularly; /// calls gSystem->ProcessEvents(). It happens automatically in ROOT interactive shell.; /// If milliSec == 0, no timer will be created.; /// In this case application should regularly call ProcessRequests() method.; ///; /// Async timer allows to use THttpServer in applications, which does not have explicit; /// gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call; /// (like malloc) and can lead to dead locks, especially in multi-threaded applications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx:188,perform,perform,188,net/http/src/THttpServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx,2,"['multi-thread', 'perform']","['multi-threaded', 'perform']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Create tracking medium; ///; /// - numed tracking medium number assigned; /// - name tracking medium name; /// - nmat material number; /// - isvol sensitive volume flag; /// - ifield magnetic field; /// - fieldm max. field value (kilogauss); /// - tmaxfd max. angle due to field (deg/step); /// - stemax max. step allowed; /// - deemax max. fraction of energy lost in a step; /// - epsil tracking precision (cm); /// - stmin min. step due to continuous processes (cm); ///; /// - ifield = 0 if no magnetic field; ifield = -1 if user decision in guswim;; /// - ifield = 1 if tracking performed with g3rkuta; ifield = 2 if tracking; /// performed with g3helix; ifield = 3 if tracking performed with g3helx3.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBuilder.cxx:669,perform,performed,669,geom/geom/src/TGeoBuilder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBuilder.cxx,6,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Creates a TFileCacheWrite data structure.; /// The write cache will be connected to file.; /// The size of the cache will be buffersize,; /// if buffersize < 10000 a default size of 512 Kbytes is used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx:143,cache,cache,143,io/io/src/TFileCacheWrite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Creates embedded civetweb server; ///; /// @param args string with civetweb server configuration; ///; /// As main argument, http port should be specified like ""8090"".; /// Or one can provide combination of ipaddress and portnumber like ""127.0.0.1:8090""; /// Or one can specify unix socket name like ""x/tmp/root.socket""; /// Extra parameters like in URL string could be specified after '?' mark:; ///; /// thrds=N - there N is number of threads used by the civetweb (default is 10); /// top=name - configure top name, visible in the web browser; /// ssl_certificate=filename - SSL certificate, see docs/OpenSSL.md from civetweb; /// auth_file=filename - authentication file name, created with htdigets utility; /// auth_domain=domain - authentication domain; /// websocket_timeout=tm - set web sockets timeout in seconds (default 300); /// websocket_disable - disable web sockets handling (default enabled); /// bind - ip address to bind server socket; /// loopback - bind specified port to loopback 127.0.0.1 address; /// debug - enable debug mode, server always returns html page with request info; /// log=filename - configure civetweb log file; /// max_age=value - configures ""Cache-Control: max_age=value"" http header for all file-related requests, default 3600; /// socket_mode=value - configures unix socket mode, default is 0700; /// nocache - try to fully disable cache control for file requests; /// winsymlinks=no - do not resolve symbolic links on file system (Windows only), default true; /// dirlisting=no - enable/disable directory listing for browsing filesystem (default no); ///; /// Examples of valid args values:; ///; /// serv->CreateEngine(""http:8080?websocket_disable"");; /// serv->CreateEngine(""http:7546?thrds=30&websocket_timeout=20"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TCivetweb.cxx:1267,Cache,Cache-Control,1267,net/http/src/TCivetweb.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TCivetweb.cxx,2,"['Cache', 'cache']","['Cache-Control', 'cache']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Creates special thread to process all requests, directed to http server; ///; /// Should be used with care - only dedicated instance of TRootSniffer is allowed; /// By default THttpServer allows to access global lists pointers gROOT or gFile.; /// To be on the safe side, all kind of such access performed from the main thread.; /// Therefore usage of specialized thread means that no any global pointers will; /// be accessible by THttpServer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx:382,perform,performed,382,net/http/src/THttpServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Debugging tool which plots the cells of a 2-dimensional PDEFoam; /// as rectangles in C++ format readable for ROOT.; ///; /// Parameters:; /// - filename - filename of output root macro; ///; /// - opt - cell_value, rms, rms_ov_mean; /// If cell_value is set, the following values will be filled into; /// the result histogram:; /// - number of events - in case of classification with 2 separate; /// foams or multi-target regression; /// - discriminator - in case of classification with one; /// unified foam; /// - target - in case of mono-target regression; /// If none of {cell_value, rms, rms_ov_mean} is given, the cells; /// will not be filled.; /// If 'opt' contains the string 'cellnumber', the index of; /// each cell is draw in addition.; ///; /// - createCanvas - whether to create a new canvas or not; ///; /// - colors - whether to fill cells with colors or shades of grey; ///; /// Example:; ///; /// The following commands load a mono-target regression foam from; /// file 'foam.root' and create a ROOT macro 'output.C', which; /// draws all PDEFoam cells with little boxes. The latter are; /// filled with colors according to the target value stored in the; /// cell. Also the cell number is drawn.; ///; /// TFile file(""foam.root"");; /// TMVA::PDEFoam *foam = (TMVA::PDEFoam*) gDirectory->Get(""MonoTargetRegressionFoam"");; /// foam->RootPlot2dim(""output.C"",""cell_value,cellnumber"");; /// gROOT->Macro(""output.C"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx:1025,load,load,1025,tmva/tmva/src/PDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Defer preferred scan order to cached pdf preference",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx:116,cache,cached,116,roofit/roofitcore/src/RooCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Defines observables to be cached, given a set of user defined observables; /// Returns the subset of nset that are observables this p.d.f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsSelfCachedReal.h:112,cache,cached,112,roofit/roofitcore/inc/RooAbsSelfCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsSelfCachedReal.h,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Defines parameters on which cache contents depends. Returns; /// subset of variables of self that is not contained in the; /// supplied nset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsSelfCachedReal.h:114,cache,cache,114,roofit/roofitcore/inc/RooAbsSelfCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsSelfCachedReal.h,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Delete all global interpreter objects created since the last call to Reset; ///; /// If option=""a"" is set reset to startup context (i.e. unload also; /// all loaded files, classes, structs, typedefs, etc.).; ///; /// This function is typically used at the beginning (or end) of an unnamed macro; /// to clean the environment.; ///; /// IMPORTANT WARNING:; /// Do not use this call from within any function (neither compiled nor; /// interpreted. This should only be used from a unnamed macro; /// (which starts with a { (curly braces) ). For example, using TROOT::Reset; /// from within an interpreted function will lead to the unloading of the; /// dictionary and source file, including the one defining the function being; /// executed.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:244,load,loaded,244,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Delete picture cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGPicture.cxx:101,cache,cache,101,gui/gui/src/TGPicture.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGPicture.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Deserialize input by performing byteswap as needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafG.cxx:107,perform,performing,107,tree/tree/src/TLeafG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeafG.cxx,4,['perform'],['performing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Destructor of normalization cache element. If this element; /// provides the 'current' normalization stored in RooAbsPdf::_norm; /// zero _norm pointer here before object pointed to is deleted here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:114,cache,cache,114,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Destructor. Unregisters cache with owner.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCache.cxx:110,cache,cache,110,roofit/roofitcore/src/RooAbsCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Determine integration scenario. If no interpolation is used,; /// RooHistFunc can perform all integrals over its dependents; /// analytically via partial or complete summation of the input; /// histogram. If interpolation is used, only the integral; /// over all RooHistPdf observables is implemented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistFunc.cxx:168,perform,perform,168,roofit/roofitcore/src/RooHistFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistFunc.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Determine integration scenario. If no interpolation is used,; /// RooHistPdf can perform all integrals over its dependents; /// analytically via partial or complete summation of the input; /// histogram. If interpolation is used on the integral over; /// all histogram observables is supported",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx:167,perform,perform,167,roofit/roofitcore/src/RooHistPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHistPdf.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Determine which part (if any) of given integral can be performed analytically.; /// If any analytical integration is possible, return integration scenario code.; ///; /// RooProdPdf implements two strategies in implementing analytical integrals; ///; /// First, PDF components whose entire set of dependents are requested to be integrated; /// can be dropped from the product, as they will integrate out to 1 by construction; ///; /// Second, RooProdPdf queries each remaining component PDF for its analytical integration; /// capability of the requested set ('allVars'). It finds the largest common set of variables; /// that can be integrated by all remaining components. If such a set exists, it reconfirms that; /// each component is capable of analytically integrating the common set, and combines the components; /// individual integration codes into a single integration code valid for RooProdPdf.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:141,perform,performed,141,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Determine which part (if any) of given integral can be performed analytically.; /// If any analytical integration is possible, return integration scenario code; ///; /// RooAddPdf queries each component PDF for its analytical integration capability of the requested; /// set ('allVars'). It finds the largest common set of variables that can be integrated; /// by all components. If such a set exists, it reconfirms that each component is capable of; /// analytically integrating the common set, and combines the components individual integration; /// codes into a single integration code valid for RooAddPdf.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:141,perform,performed,141,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Direct access to the unique_ptr holding the integrator that's used to sample the bins.; /// This can be used to change options such as sampling accuracy or to entirely exchange the integrator.; ///; /// #### Example: Use the 61-point Gauss-Kronrod integration rule; /// ```{.cpp}; /// ROOT::Math::IntegratorOneDimOptions intOptions = pdf.integrator()->Options();; /// intOptions.SetNPoints(6); // 61-point integration rule; /// intOptions.SetRelTolerance(1.E-9); // Smaller tolerance -> more subdivisions; /// pdf.integrator()->SetOptions(intOptions);; /// ```; /// \see ROOT::Math::IntegratorOneDim::SetOptions for more details on integration options.; /// \note When RooBinSamplingPdf is loaded from files, integrator options will fall back to the default values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx:776,load,loaded,776,roofit/roofitcore/src/RooBinSamplingPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBinSamplingPdf.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Directives has the same syntax as the argument of SetMakeSharedLib but is; /// used to create an executable. This creation is used as a means to output; /// a list of unresolved symbols, when loading a shared library has failed.; /// The required variable is $ExeName rather than $SharedLib, e.g.:; /// ~~~ {.cpp}; /// gSystem->SetMakeExe(; /// ""g++ -Wall -fPIC $IncludePath $SourceFiles; /// -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:278,load,loading,278,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Disables the implicit multi-threading in ROOT (see EnableImplicitMT).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:108,multi-thread,multi-threading,108,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['multi-thread'],['multi-threading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Display the content of the dataset cache, if any (matching 'dataset', if defined).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:121,cache,cache,121,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Divide this polycone shape belonging to volume ""voldiv"" into ndiv volumes; /// called divname, from start position with the given step. Returns pointer; /// to created division cell volume in case of Z divisions. Z divisions can be; /// performed if the divided range is in between two consecutive Z planes.; /// In case a wrong division axis is supplied, returns pointer to; /// volume that was divided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPcon.cxx:323,perform,performed,323,geom/geom/src/TGeoPcon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPcon.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Divide this polygone shape belonging to volume ""voldiv"" into ndiv volumes; /// called divname, from start position with the given step. Returns pointer; /// to created division cell volume in case of Z divisions. Phi divisions are; /// allowed only if nedges%ndiv=0 and create polygone ""segments"" with nedges/ndiv edges.; /// Z divisions can be performed if the divided range is in between two consecutive Z planes.; /// In case a wrong division axis is supplied, returns pointer to volume that was divided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPgon.cxx:431,perform,performed,431,geom/geom/src/TGeoPgon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPgon.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Do the root finding using the Brent-Decker method. Returns a boolean status and; /// loads 'result' with our best guess at the root if true.; /// Prints a warning if the initial interval does not bracket a single; /// root or if the root is not found after a fixed number of iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBrentRootFinder.cxx:171,load,loads,171,roofit/roofitcore/src/RooBrentRootFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooBrentRootFinder.cxx,1,['load'],['loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Does training, test set evaluation and performance evaluation of using; /// cross-evalution.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CrossValidation.cxx:125,perform,performance,125,tmva/tmva/src/CrossValidation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/CrossValidation.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Draw Performance plots",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBenchRunCPU.cxx:91,Perform,Performance,91,proof/proofbench/src/TProofBenchRunCPU.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBenchRunCPU.cxx,1,['Perform'],['Performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Draw physical shape, using LOD flags, potential from display list cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPhysicalShape.cxx:152,cache,cache,152,graf3d/gl/src/TGLPhysicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPhysicalShape.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Draw the GL drawable, using draw flags. If DL caching is enabled; /// (see SetDLCache) then attempt to draw from the cache, if not found; /// attempt to capture the draw - done by DirectDraw() - into a new cache entry.; /// If not cached just call DirectDraw() for normal non DL cached drawing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:203,cache,cache,203,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,4,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Draw this volume with current settings and perform raytracing in the pad.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx:129,perform,perform,129,geom/geom/src/TGeoVolume.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Draws the distribution (on the test sample) of the; /// impact on the network output of a small variation of; /// each input.; /// DrawDInputs() draws something that approximates the distribution of the; /// derivative of the NN w.r.t. each input. That quantity is recognized as; /// one of the measures to determine key quantities in the network.; ///; /// What is done is to vary one input around its nominal value and to see; /// how the NN changes. This is done for each entry in the sample and produces; /// a distribution.; ///; /// What you can learn from that is:; /// - is variable a really useful, or is my network insensitive to it ?; /// - is there any risk of big systematic ? Is the network extremely sensitive; /// to small variations of any of my inputs ?; ///; /// As you might understand, this is to be considered with care and can serve; /// as input for an ""educated guess"" when optimizing the network.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMLPAnalyzer.cxx:985,optimiz,optimizing,985,math/mlp/src/TMLPAnalyzer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMLPAnalyzer.cxx,1,['optimiz'],['optimizing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Driver function to activate global constant term optimization.; /// If activated, constant terms are found and cached with the dataset.; /// The operation mode of cached nodes is set to AClean meaning that; /// their getVal() call will never result in an evaluate call.; /// Finally the branches in the dataset that correspond to observables; /// that are exclusively used in constant terms are disabled as; /// they serve no more purpose",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:135,optimiz,optimization,135,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,3,"['cache', 'optimiz']","['cached', 'optimization']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Driver function to propagate constant term optimizations in test statistic.; /// If code Activate is sent, constant term optimization will be executed.; /// If code Deactivate is sent, any existing constant term optimizations will; /// be abandoned. If codes ConfigChange or ValueChange are sent, any existing; /// constant term optimizations will be redone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx:129,optimiz,optimizations,129,roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.cxx,4,['optimiz'],"['optimization', 'optimizations']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Drop all entries for all LODs for this drawable from the display; /// list cache, WITHOUT returning the reserved ids to GL context.; ///; /// This is called by scene if it realized that the GL context was; /// destroyed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:161,cache,cache,161,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Dummy function kept for back compatibility.; /// The cache is now activated automatically when processing TTrees/TChain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:139,cache,cache,139,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Dummy function.; /// It could be implemented and load all baskets of all trees in the chain.; /// For the time being use TChain::Merge and TTree::LoadBasket; /// on the resulting tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:135,load,load,135,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,2,"['Load', 'load']","['LoadBasket', 'load']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Dummy static function, used to load plugin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/src/TGeoManagerEditor.cxx:117,load,load,117,geom/geombuilder/src/TGeoManagerEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/src/TGeoManagerEditor.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Element was changed, perform framework side action.; /// Called from TEveElement::ElementChanged().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx:107,perform,perform,107,graf3d/eve/src/TEveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Enable specified package. Executes the PROOF-INF/BUILD.sh; /// script if it exists followed by the PROOF-INF/SETUP.C script.; /// In case notOnClient = true, don't enable the package on the client.; /// The default is to enable packages also on the client.; /// It is is possible to specify a list of objects to be passed to the SETUP; /// functions via 'loadopts'; the objects must be streamable.; /// Returns 0 in case of success and -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:441,load,loadopts,441,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['load'],['loadopts']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Enable specified package. Executes the PROOF-INF/BUILD.sh; /// script if it exists followed by the PROOF-INF/SETUP.C script.; /// In case notOnClient = true, don't enable the package on the client.; /// The default is to enable packages also on the client.; /// It is is possible to specify options for the loading step via 'loadopts';; /// the string will be passed passed as argument to SETUP.; /// Special option 'chkv=`<o>`' (or 'checkversion=`<o>`') can be used to control; /// plugin version checking during building: possible choices are:; /// off no check; failure may occur at loading; /// on check ROOT version [default]; /// svn check ROOT version and Git commit SHA1.; /// (Use ';', ' ' or '|' to separate 'chkv=`<o>`' from the rest.); /// If specified, enables packages only on the specified workers.; /// Returns 0 in case of success and -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:393,load,loading,393,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,3,['load'],"['loading', 'loadopts']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Enable the TTreeCache unless explicitly disabled for this TTree by; /// a prior call to `SetCacheSize(0)`.; /// If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config; /// `TTreeCache.Size` has been set to zero, this call will over-ride them with; /// a value of 1.0 (i.e. use a cache size to hold 1 cluster); ///; /// Return true if there is a cache attached to the `TTree` (either pre-exisiting; /// or created as part of this call)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:382,cache,cache,382,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Enable/Disable saving of the performance tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:115,perform,performance,115,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// End of methods for miss cache.; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:110,cache,cache,110,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Entry point of worker threads for multi-threaded MakeAll().; /// info points to an (internal) THtmlThreadInfo object containing the current; /// THtml object, and whether ""force"" was passed to MakeAll().; /// The thread will poll GetNextClass() until no further class is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:120,multi-thread,multi-threaded,120,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['multi-thread'],['multi-threaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Erase all HTML from this widget and clear the screen. This is; /// typically done before loading a new document.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:175,load,loading,175,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,1,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Estimate the cluster size.; ///; /// In almost all cases, this quickly returns the size of the auto-flush; /// in the TTree.; ///; /// However, in the case where the cluster size was not fixed (old files and; /// case where autoflush was explicitly set to zero), we need estimate; /// a cluster size in relation to the size of the cache.; ///; /// After this value is calculated once for the TClusterIterator, it is; /// cached and reused in future calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:417,cache,cache,417,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Evaluate the minimisation function; /// Input parameters:; /// - npar: number of currently variable parameters; /// - par: array of (constant and variable) parameters; /// - flag: Indicates what is to be calculated (see example below); /// - grad: array of gradients; /// Output parameters:; /// - fval: The calculated function value.; /// - grad: The (optional) vector of first derivatives).; ///; /// The meaning of the parameters par is of course defined by the user,; /// who uses the values of those parameters to calculate their function value.; /// The starting values must be specified by the user.; /// Later values are determined by Minuit as it searches for the minimum; /// or performs whatever analysis is requested by the user.; ///; /// Note that this virtual function may be redefined in a class derived from TMinuit.; /// The default function calls the function specified in SetFCN; ///; /// Example of Minimisation function:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:775,perform,performs,775,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Evaluate the minimisation function; ///; /// Input parameters:; /// - npar: number of currently variable parameters; /// - par: array of (constant and variable) parameters; /// - flag: Indicates what is to be calculated; /// - grad: array of gradients; ///; /// Output parameters:; /// - fval: The calculated function value.; /// - grad: The vector of first derivatives.; ///; /// The meaning of the parameters par is of course defined by the user,; /// who uses the values of those parameters to calculate their function value.; /// The starting values must be specified by the user.; ///; /// Inside FCN user has to define Z-matrix by means TFumili::GetZ; /// and TFumili::Derivatives,; /// set theoretical function by means of TFumili::SetUserFunc,; /// but first - pass number of parameters by TFumili::SetParNumber; ///; /// Later values are determined by Fumili as it searches for the minimum; /// or performs whatever analysis is requested by the user.; ///; /// The default function calls the function specified in SetFCN",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:993,perform,performs,993,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Explicitely delete font structure obtained with LoadQueryFont().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:134,Load,LoadQueryFont,134,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,1,['Load'],['LoadQueryFont']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Explicitly delete font structure obtained with LoadQueryFont().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/GX11Gui.cxx:133,Load,LoadQueryFont,133,graf2d/x11/src/GX11Gui.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/GX11Gui.cxx,2,['Load'],['LoadQueryFont']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Explicitly deletes the font structure ""fs"" obtained via LoadQueryFont().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx:142,Load,LoadQueryFont,142,core/base/src/TVirtualX.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx,1,['Load'],['LoadQueryFont']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Explicitly synchronize RooAbsCategory internal cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCategory.cxx:133,cache,cache,133,roofit/roofitcore/src/RooAbsCategory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCategory.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Extract requested segments from the cached content.; /// Such cache can be produced when server suddenly returns full data instead of segments; /// Returns -1 in case of error, 0 in case of success",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:122,cache,cached,122,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,2,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Extract the camera eye direction (vector), running from EyePoint(); /// Camera must have valid frustum cache - call Apply() after last modification, before using",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:189,cache,cache,189,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fill a RooDataHist with values sampled from this function at the; /// bin centers. If extendedMode is true, the p.d.f. values is multiplied; /// by the number of expected events in each bin; ///; /// An optional scaling by a given scaleFactor can be performed.; /// Returns a pointer to the input RooDataHist, or zero; /// in case of an error.; ///; /// If correctForBinSize is true the RooDataHist; /// is filled with the functions density (function value times the; /// bin volume) rather than function value.; ///; /// If showProgress is true; /// a process indicator is printed on stdout in steps of one percent,; /// which is mostly useful for the sampling of expensive functions; /// such as likelihoods",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:336,perform,performed,336,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fill a slice of cachePdf with the output of the FFT convolution calculation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:102,cache,cachePdf,102,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['cache'],['cachePdf']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fill cache using running integral cache elements calculate(); /// method with specification of cdf-specific boundary conditions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumCdf.cxx:91,cache,cache,91,roofit/roofitcore/src/RooNumCdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumCdf.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fill cache with sampling of function as defined by the evaluate() implementation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsSelfCachedReal.h:91,cache,cache,91,roofit/roofitcore/inc/RooAbsSelfCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsSelfCachedReal.h,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fill the cache object by calling its calculate() method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:95,cache,cache,95,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fill the cache with the interpolated shape.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:95,cache,cache,95,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fill the contents of the cache the FFT convolution output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:111,cache,cache,111,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fill the file cache with the next set of basket.; ///; /// \param from index of the first lement of fFromBranches to start caching; /// \return The index of first element of fFromBranches that is not in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx:100,cache,cache,100,tree/tree/src/TTreeCloner.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fill the map of libraries to be loaded in presence of a class; /// Transparently support the old and new rootmap file format",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:118,load,loaded,118,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fill the transient cache with partial bin volumes with up-to-date; /// values for the partial volume specified by observables 'dimSet'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:105,cache,cache,105,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fill type with the string representation of sequence; /// information including 'cached','repeat','write' or; /// 'nodelete'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx:167,cache,cached,167,core/meta/src/TStreamerElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Find and return logical shape identified by unique 'ID' in refresh-cache.; /// Returns 0 if not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx:153,cache,cache,153,graf3d/gl/src/TGLScene.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Find and return the TTreeCache registered with the file and which may; /// contain branches for us. If create is true and there is no cache; /// a new cache is created with default size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:220,cache,cache,220,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Find branch nodes with all-constant parameters, and add them to the list of; /// nodes that can be cached with a dataset in a test statistic calculation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:185,cache,cached,185,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,2,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Find existing isotope by name. Not optimized for a big number of isotopes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoElement.cxx:121,optimiz,optimized,121,geom/geom/src/TGeoElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoElement.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Find the center of the camera frustum from intersection of planes; /// This method will work even with parallel left/right & top/bottom and; /// infinite eye point of ortho cameras; /// Camera must have valid frustum cache - call Apply() after last modification, before using",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:303,cache,cache,303,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Find the intersection of projection of supplied viewport TPoint (a 3D world; /// line - see ViewportToWorld) with supplied world plane. Returns std::pair; /// of bool and vertex. If line intersects; ///; /// Camera must have valid frustum cache - call Apply() after last modification, before using",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:325,cache,cache,325,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Find the intersection of projection of supplied viewport point (a 3D world; /// line - see ViewportToWorld) with supplied world plane. Returns std::pair; /// of Bool_t and TGLVertex3. If line intersects std::pair.first (Bool_t) is; /// kTRUE, and std::pair.second (TGLVertex) contains the intersection vertex.; /// If line does not intersect (line and plane parallel) std::pair.first; /// (Bool_t) if kFALSE, and std::pair.second (TGLVertex) is invalid.; ///; /// NOTE: The projection lines is extended for the plane intersection test; /// hence the intersection vertex can lie outside the near/far clip regions; /// (not visible); ///; /// Camera must have valid frustum cache - call Apply() after last modification, before using",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:758,cache,cache,758,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Find the tree which contains entry, and set it as the current tree.; ///; /// Returns the entry number in that tree.; ///; /// The input argument entry is the entry serial number in the whole chain.; ///; /// In case of error, LoadTree returns a negative number:; /// * -1: The chain is empty.; /// * -2: The requested entry number is less than zero or too large for the chain.; /// * -3: The file corresponding to the entry could not be correctly open; /// * -4: The TChainElement corresponding to the entry is missing or; /// the TTree is missing from the file.; /// * -5: Internal error, please report the circumstance when this happen; /// as a ROOT issue.; /// * -6: An error occurred within the notify callback.; ///; /// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new sub-tree.; /// See TNotifyLink for more information on the notification mechanism.; ///; /// \note This is the only routine which sets the value of fTree to a non-zero pointer.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:313,Load,LoadTree,313,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['Load'],['LoadTree']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Fit a THnSparse with function f; ///; /// since the data is sparse by default a likelihood fit is performed; /// merging all the regions with empty bins for better performance efficiency; ///; /// Since the THnSparse is not drawn no graphics options are passed; /// Here is the list of possible options; ///; /// = ""I"" Use integral of function in bin instead of value at bin center; /// = ""X"" Use chi2 method (default is log-likelihood method); /// = ""U"" Use a User specified fitting algorithm (via SetFCN); /// = ""Q"" Quiet mode (minimum printing); /// = ""V"" Verbose mode (default is between Q and V); /// = ""E"" Perform better Errors estimation using Minos technique; /// = ""B"" Use this option when you want to fix one or more parameters; /// and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; /// = ""M"" More. Improve fit results; /// = ""R"" Use the Range specified in the function range",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:184,perform,performed,184,hist/hist/src/THnBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx,3,"['Perform', 'perform']","['Perform', 'performance', 'performed']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// FlagsOpt should contain the options to pass to the C++ compiler; /// in order to compile the library in optimized mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:190,optimiz,optimized,190,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Flush the write cache if active.; ///; /// Return kTRUE in case of error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:102,cache,cache,102,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// For given collection entry return the string that is used to; /// identify the object and, potentially, perform wildcard/regexp; /// filtering on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TCollection.cxx:190,perform,perform,190,core/cont/src/TCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TCollection.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// For the case where the requestor class is emulated and this class is abstract,; /// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; /// representation whether or not the class is loaded.; ///; /// If the object does not exist, it is created; ///; /// Note: There are two special version numbers:; ///; /// - 0: Use the class version from the currently loaded class library.; /// - -1: Assume no class library loaded (emulated class).; ///; /// Warning: If we create a new streamer info, whether or not the build; /// optimizes is controlled externally to us by a global variable!; /// Don't call us unless you have set that variable properly; /// with TStreamer::Optimize()!; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:300,load,loaded,300,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,5,"['Optimiz', 'load', 'optimiz']","['Optimize', 'loaded', 'optimizes']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// For the case where the requestor class is emulated and this class is abstract,; /// returns a pointer to the TVirtualStreamerInfo object for version with an emulated; /// representation whether or not the class is loaded.; ///; /// If the object does not exist, it is created; ///; /// Warning: If we create a new streamer info, whether or not the build; /// optimizes is controlled externally to us by a global variable!; /// Don't call us unless you have set that variable properly; /// with TStreamer::Optimize()!; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:300,load,loaded,300,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,3,"['Optimiz', 'load', 'optimiz']","['Optimize', 'loaded', 'optimizes']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// For the event currently being fetched into the miss cache, find the IO; /// (offset / length tuple) to pull in the current basket for a given branch.; ///; /// Returns:; /// - IOPos describing the IO operation necessary for the basket on this branch; /// - On failure, IOPos.length will be set to 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:138,cache,cache,138,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Force the internal value cache to be up to date",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooErrorVar.cxx:111,cache,cache,111,roofit/roofitcore/src/RooErrorVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooErrorVar.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Forward a change in the cached normalization argset; /// to all the registered proxies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:110,cache,cached,110,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Forward constant term optimization management calls to component; /// test statistics",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsTestStatistic.cxx:108,optimiz,optimization,108,roofit/roofitcore/src/RooAbsTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsTestStatistic.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Function called when loading a new class library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:107,load,loading,107,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Function that is called at the end of redirectServers(). Can be overloaded; /// to inject some class-dependent behavior after server redirection, e.g.; /// resetting of caches. The return value is meant to be an error flag, so in; /// case something goes wrong the function should return `true`. If you; /// overload this function, don't forget to also call the function of the; /// base class.; ///; /// \see redirectServers() For a detailed explanation of the function parameters.; ///; // \param[in] newServerList One of the original parameters passed to redirectServers().; // \param[in] mustReplaceAll One of the original parameters passed to redirectServers().; // \param[in] nameChange One of the original parameters passed to redirectServers().; // \param[in] isRecursiveStep One of the original parameters passed to redirectServers().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:255,cache,caches,255,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['cache'],['caches']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Function used internally to check the consistency between the; /// various histograms. Checks are performed on nonexistent or empty; /// histograms, the precise histogram class, and the number of bins.; /// In addition, integrals over the ""allowed"" bin ranges are computed.; /// Any inconsistency results in a error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:184,perform,performed,184,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Generate a collection of graphs, for all methods for a given class. Suitable; /// for comparing method performance.; ///; /// Argument iClass specifies the class to generate the ROC curve in a; /// multiclass setting. It is ignored for binary classification.; ///; /// NOTE: The ROC curve is 1 vs. all where the given class is considered signal; /// and the others considered background. This is ok in binary classification; /// but in in multi class classification, the ROC surface is an N dimensional; /// shape, where N is number of classes - 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx:189,perform,performance,189,tmva/tmva/src/Factory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx,2,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Generate one event. Generate an event from the p.d.f and; /// then perform an accept/reject sampling based on the efficiency; /// function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooEffGenContext.cxx:153,perform,perform,153,roofit/roofitcore/src/RooEffGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooEffGenContext.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Generates all necessary data for the Contour method from its; /// tab. Then it call Virtual Fitter to perform it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TAdvancedGraphicsDialog.cxx:188,perform,perform,188,gui/fitpanel/src/TAdvancedGraphicsDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TAdvancedGraphicsDialog.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Generates all necessary data for the Scan method from its; /// tab. Then it call Virtual Fitter to perform it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TAdvancedGraphicsDialog.cxx:185,perform,perform,185,gui/fitpanel/src/TAdvancedGraphicsDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TAdvancedGraphicsDialog.cxx,2,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Get CPU load on Linux.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:94,load,load,94,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Get CPU load on Mac OS X.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:94,load,load,94,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Get CPU stat for Linux. Use sampleTime to set the interval over which; /// the CPU load will be measured, in ms (default 1000).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:169,load,load,169,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Get CPU stat for Mac OS X. Use sampleTime to set the interval over which; /// the CPU load will be measured, in ms (default 1000).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:172,load,load,172,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Get a font by name. If font is not found, fixed font is returned,; /// if fixed font also does not exist return 0 and print error.; /// The loaded font needs to be freed using TVirtualX::DeleteFont().; /// If fixedDefault is false the ""fixed"" font will not be substituted; /// as fallback when the asked for font does not exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGClient.cxx:226,load,loaded,226,gui/gui/src/TGClient.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGClient.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Get closest point from given vertex v to line segment defined with s and r.; /// Argument rMagInv is cached. rMagInv= 1./rMag()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrackPropagator.cxx:187,cache,cached,187,graf3d/eve/src/TEveTrackPropagator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrackPropagator.cxx,2,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Get geometry with given filename.; /// This is cached internally so the second time this function is; /// called with the same argument the same geo-manager is returned.; /// gGeoManager is set to the return value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx:133,cache,cached,133,graf3d/eve/src/TEveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx,2,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Get list of shared libraries loaded at the start of the executable.; /// Returns 0 in case list cannot be obtained or in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:115,load,loaded,115,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Get performance specs. Check file 'path', or files in directory 'path'; /// (default current directory).; /// The degree of the polynomial used for the fit is 'degfit' (default 1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx:90,perform,performance,90,proof/proofbench/src/TProofBench.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Get the directory where to locally stage/cache remote files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:127,cache,cache,127,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// GetTuningOptions; /// Function to allow for ranges and number of steps (for scan) when optimising kernel; /// function parameters. Specified when booking the method after the parameter to be; /// optimised between square brackets with each value separated by ;, the first value; /// is the lower limit, the second the upper limit and the third is the number of steps.; /// Example: ""Tune=Gamma[0.01;1.0;100]"" would only tune the RBF Gamma between 0.01 and; /// 100 steps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodSVM.cxx:469,Tune,Tune,469,tmva/tmva/src/MethodSVM.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodSVM.cxx,2,"['Tune', 'tune']","['Tune', 'tune']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Getter for optimization structure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx:97,optimiz,optimization,97,geom/geom/src/TGeoVolume.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Give the total efficiency of the primary cache... defined as the ratio; /// of blocks found in the cache vs. the number of blocks prefetched; /// ( it could be more than 1 if we read the same block from the cache more; /// than once ); ///; /// Note: This should eb used at the end of the processing or we will; /// get incomplete stats",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:127,cache,cache,127,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Given a particular IO description (offset / length) representing a 'miss' of; /// the TTreeCache's primary cache, calculate all the corresponding IO that; /// should be performed.; ///; /// `all` indicates that this function should search the set of _all_ branches; /// in this TTree. When set to false, we only search through branches that; /// have previously incurred a miss.; ///; /// Returns:; /// - TBranch pointer corresponding to the basket that will be retrieved by; /// this IO operation.; /// - If no corresponding branch could be found (or an error occurs), this; /// returns nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:193,cache,cache,193,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,"['cache', 'perform']","['cache', 'performed']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Given an IO operation (pos, len) that was a cache miss in the primary TTC,; /// try the operation again with the miss cache.; ///; /// Returns true if the IO operation was successful and the contents of buf; /// were populated with the requested data.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:130,cache,cache,130,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Global switch to cache all integral values that integrate at least ndim dimensions numerically",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:103,cache,cache,103,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Go in parallel mode with at most ""nodes"" slaves. Since the fSlaves; /// list is sorted by slave performace the active list will contain first; /// the most performant nodes. Returns the number of active slaves.; /// If random is TRUE, and nodes is less than the number of available workers,; /// a random selection is done.; /// Returns -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:182,perform,performace,182,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['perform'],"['performace', 'performant']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Go one level up in geometry. Updates cache accordingly.; /// Determine the overlapping state of current node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:123,cache,cache,123,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Handle ""Stop Loading"" navigation button.; /// Not active for the time being.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootIDE/TGRootIDE.cxx:99,Load,Loading,99,test/RootIDE/TGRootIDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootIDE/TGRootIDE.cxx,1,['Load'],['Loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Handle here all cache and package requests.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:102,cache,cache,102,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Helper for GetNativeFont() and GetFontFromAttributes(). Creates and; /// initializes a new TGFont object.; ///; /// font -- If non-NULL, store the information in this existing TGFont; /// object, rather than creating a new one; the existing; /// contents of the font will be released. If NULL, a new; /// TGFont object is created.; /// fontStruct -- information about font.; /// fontName -- The string passed to TVirtualX::LoadQueryFont() to construct the; /// fontStruct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:509,Load,LoadQueryFont,509,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['Load'],['LoadQueryFont']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Helper function used by TClass::GetClass().; /// This function attempts to load the dictionary for 'classname' from; /// the TClassTable or the autoloader.; /// If silent is 'true', do not warn about missing dictionary for the class.; /// (typically used for class that are used only for transient members); ///; /// The 'requestedname' is expected to be already normalized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:161,load,load,161,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Helper function used by TClass::GetClass().; /// This function attempts to load the dictionary for 'classname'; /// either from the TClassTable or from the list of generator.; /// If silent is 'true', do not warn about missing dictionary for the class.; /// (typically used for class that are used only for transient members); ///; /// The 'requestedname' is expected to be already normalized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:161,load,load,161,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,2,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Helper function used by TClass::GetClass().; /// This function attempts to load the dictionary for 'classname'; /// from the list of generator.; /// If silent is 'true', do not warn about missing dictionary for the class.; /// (typically used for class that are used only for transient members); ///; /// The 'requestedname' is expected to be already normalized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:161,load,load,161,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Hook function to intercept printCompactTree() calls so that it can print out; /// the content of its private cache in the print sequence",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx:195,cache,cache,195,roofit/roofitcore/src/RooNumConvolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Hook function to print cache contents in tree printing of RooProdPdf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:109,cache,cache,109,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Hook function to print cache guts in tree printing mode of RooAbsArgs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCacheElement.cxx:109,cache,cache,109,roofit/roofitcore/src/RooAbsCacheElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCacheElement.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// If RooArgSets set1 and set2 or sets with similar contents have; /// been seen by this cache manager before return `false` If not,; /// return `true`. If sets have not been seen and doRefill is true,; /// update cache reference to current input sets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx:172,cache,cache,172,roofit/roofitcore/src/RooNormSetCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNormSetCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// If clearOnRedirect is false, forward constant term optimization calls to; /// cache elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx:137,optimiz,optimization,137,roofit/roofitcore/src/RooObjCacheManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// If flag is true, perform constant term optimization on; /// function being minimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx:103,perform,perform,103,roofit/roofitcore/src/RooMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// If id is NULL - loads the specified gif file at position [x0,y0] in the; /// current window. Otherwise creates pixmap from gif file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx:102,load,loads,102,core/base/src/TVirtualX.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx,3,['load'],['loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// If it's not contained by 2 namespaces, drop it.; /**; * Check that the recordDecl is enclosed in the ROOT::Meta::Selection namespace,; * excluding the portion dedicated the definition of the syntax, which is part; * of ROOT, not of the user code.; * If performance is needed, an alternative approach to string comparisons; * could be adopted. One could use for example hashes of strings in first; * approximation.; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/DictSelectionReader.cxx:339,perform,performance,339,core/dictgen/src/DictSelectionReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/DictSelectionReader.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// If the block has already been optimized and the entries; /// are stored as a list and not as bits, trying to enter a new entry; /// will make the block switch to bits representation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx:116,optimiz,optimized,116,tree/tree/src/TEntryListBlock.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// If the dictionary is loaded, we can remove the class from the list; /// (otherwise the class might be loaded twice).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:107,load,loaded,107,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// If the interpreter encounters Name, check whether that is an object ROOT; /// could retrieve. To not re-read objects from disk, cache the name/object; /// pair for a given LookupCtx.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:214,cache,cache,214,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// If the specified window is mapped, ReparentWindow automatically; /// performs an UnmapWindow request on it, removes it from its current; /// position in the hierarchy, and inserts it as the child of the specified; /// parent. The window is placed in the stacking order on top with respect; /// to sibling windows.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx:155,perform,performs,155,core/base/src/TVirtualX.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// If this p.d.f is operated with a fixed set of observables, return; /// all variables of the external input p.d.f that are not one of; /// the cache observables. If this p.d.f is operated in automatic mode,; /// return the parameters of the external input p.d.f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx:228,cache,cache,228,roofit/roofitcore/src/RooCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// If this pdf is operated with a fixed set of observables, return; /// the subset of the fixed observables that are actual dependents; /// of the external input p.d.f. If this p.d.f is operated without; /// a fixed set of cache observables, return the actual observables; /// of the external input p.d.f given the choice of observables defined; /// in nset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx:306,cache,cache,306,roofit/roofitcore/src/RooCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Implementation of getVal() overriding default implementation; /// of RooAbsPdf. Return normalized value stored in cache p.d.f; /// rather than return value of evaluate() which is undefined; /// for RooAbsCachedPdf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:200,cache,cache,200,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Implementation of getVal() overriding default implementation; /// of RooAbsReal. Return value stored in cache p.d.f; /// rather than return value of evaluate() which is undefined; /// for RooAbsCachedReal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx:190,cache,cache,190,roofit/roofitcore/src/RooAbsCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Implements internal (analytical) integration capabilities. Call; /// is forwarded to RooHistPdf cache p.d.f of cache that is used for; /// given choice of observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:182,cache,cache,182,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Import the results of the last fit performed by gMinuit, interpreting; /// the fit parameters as the given varList of parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitResult.cxx:121,perform,performed,121,roofit/roofitcore/src/RooFitResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitResult.cxx,2,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Incorporate the received object 'obj' into the output list fOutput.; /// The latter is created if not existing.; /// This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; /// consumption.; /// Returns -1 in case of error, 1 if the object has been merged into another; /// one (so that its ownership has not been taken and can be deleted), and 0; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:254,optimiz,optimizing,254,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['optimiz'],['optimizing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Indicate to the RooAbsCachedPdf base class that for the filling of the; /// cache the traversal of the x should be in the innermost loop, to minimize; /// recalculation of the one-dimensional internal cache for a fixed value of alpha",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:162,cache,cache,162,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Init the local cache if required",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx:101,cache,cache,101,proof/proof/src/TDataSetManagerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Initialize cache of dataset: attach variables of cache ArgSet; /// to the corresponding TTree branches",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCompositeDataStore.cxx:97,cache,cache,97,roofit/roofitcore/src/RooCompositeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCompositeDataStore.cxx,6,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Initialize default plugins. Could be also of the form:; /// StartEmbedding(0);; /// TPluginHandler *ph;; /// ph = gROOT->GetPluginManager()->FindHandler(""TGClassBrowser"");; /// if (ph && ph->LoadPlugin() != -1) {; /// ph->ExecPlugin(3, gClient->GetRoot(), 200, 500);; /// }; /// StopEmbedding();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowser.cxx:277,Load,LoadPlugin,277,gui/gui/src/TRootBrowser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootBrowser.cxx,1,['Load'],['LoadPlugin']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Initialize the ROOT system. The creation of the TROOT object initializes; /// the ROOT system. It must be the first ROOT related action that is; /// performed by a program. The TROOT object must be created on the stack; /// (can not be called via new since ""operator new"" is protected). The; /// TROOT object is either created as a global object (outside the main(); /// program), or it is one of the first objects created in main().; /// Make sure that the TROOT object stays in scope for as long as ROOT; /// related actions are performed. TROOT is a so called singleton so; /// only one instance of it can be created. The single TROOT object can; /// always be accessed via the global pointer gROOT.; /// The name and title arguments can be used to identify the running; /// application. The initfunc argument can contain an array of; /// function pointers (last element must be 0). These functions are; /// executed at the end of the constructor. This way one can easily; /// extend the ROOT system without adding permanent dependencies; /// (e.g. the graphics system is initialized via such a function).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:235,perform,performed,235,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,2,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Initialize the cache array; /// npoints is the number of points to be stored (or already stored) in the cache; /// psize is the number of elements per point; ///; /// if (npoints*psize > fCacheSize) the existing cache is deleted; /// and a new array is created.; /// The function returns a pointer to the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx:101,cache,cache,101,hist/hist/src/TVirtualFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TVirtualFitter.cxx,4,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Initialize the calculator; /// The initialization will perform a global fit of the model to the data; /// and build an Asimov data set.; /// It will then also fit the model to the Asimov data set to find the likelihood value; /// of the Asimov data set; /// nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values; /// By default the nuisance parameters are fitted to the data; /// NOTE: If a fit has been done before, one for speeding up could set all the initial parameters; /// to the fit value and in addition set the null snapshot to the best fit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx:141,perform,perform,141,roofit/roostats/src/AsymptoticCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Initialize the graphics environment.; /// If @param only_web is specified, only web-related part of graphics is loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:198,load,loaded,198,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Initialize/cache the necessary information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxy.cxx:97,cache,cache,97,tree/treeplayer/src/TBranchProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxy.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Inject the module named ""modulename"" into cling; load all headers.; /// headers is a 0-terminated array of header files to `#include` after; /// loading the module. The module is searched for in all $LD_LIBRARY_PATH; /// entries (or %PATH% on Windows).; /// This function gets called by the static initialization of dictionary; /// libraries.; /// The payload code is injected ""as is"" in the interpreter.; /// The value of 'triggerFunc' is used to find the shared library location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:135,load,load,135,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['load'],"['load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Intercept cache mode operation changes and propagate them to the components",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx:96,cache,cache,96,roofit/roofitcore/src/RooGenProdProj.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Intercept call to optimize constant term in test statistics; /// and forward it to object on server side.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:104,optimiz,optimize,104,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,1,['optimiz'],['optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Intercept calls to perform automatic optimization of cache mode operation.; /// Forward calls to existing cache elements and save configuration of; /// cache mode optimization so that it can be applied on new cache elements; /// upon insertion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx:105,perform,perform,105,roofit/roofitcore/src/RooObjCacheManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx,7,"['cache', 'optimiz', 'perform']","['cache', 'optimization', 'perform']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Intercept changes to cache operation mode and forward to cache elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx:107,cache,cache,107,roofit/roofitcore/src/RooObjCacheManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Intercept server redirect calls. If clearOnRedirect was set, sterilize; /// the cache (i.e. keep the structure but delete all contents). If not; /// forward serverRedirect to cache elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx:166,cache,cache,166,roofit/roofitcore/src/RooObjCacheManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Intercept server redirects. Throw away cache, as figuring out redirections on the cache is an unsolvable problem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx:125,cache,cache,125,roofit/roofitcore/src/RooNumConvolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvolution.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Interface for cache optimization calls. The default implementation is to forward all these; /// calls to all contained RooAbsArg objects as publicized through containedArg()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCacheElement.cxx:100,cache,cache,100,roofit/roofitcore/src/RooAbsCacheElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCacheElement.cxx,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Interface for constant term optimization calls. The default implementation is to forward all these; /// calls to all contained RooAbsArg objects as publicized through containedArg()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCacheElement.cxx:114,optimiz,optimization,114,roofit/roofitcore/src/RooAbsCacheElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCacheElement.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Interface function getAnalyticalIntergral advertises the; /// analytical integrals that are supported. 'integSet'; /// is the set of dependents for which integration is requested. The; /// function should copy the subset of dependents it can analytically; /// integrate to anaIntSet and return a unique identification code for; /// this integration configuration. If no integration can be; /// performed, zero should be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:480,perform,performed,480,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Interface function signaling a request to perform constant term; /// optimization. This default implementation takes no action other than to; /// forward the calls to all servers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:128,perform,perform,128,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Interface function to create an internal cache object that represent; /// each cached function configuration. This interface allows to create and; /// return a class derived from RooAbsCachedReal::FuncCacheElem so that; /// a derived class fillCacheObject implementation can utilize extra functionality; /// defined in such a derived cache class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx:127,cache,cache,127,roofit/roofitcore/src/RooAbsCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx,6,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Internal (protected) method for performing projection on the X or Y axis; /// called by ProjectionX or ProjectionY",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:118,perform,performing,118,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['perform'],['performing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Internal function. Performs actual fit according to specifications",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx:105,Perform,Performs,105,roofit/roofitcore/src/RooMCStudy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCStudy.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Internal method -- Attach dataset copied with cache contents to copied instances of functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:132,cache,cache,132,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Internal method -- Cache given set of functions with data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:105,Cache,Cache,105,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['Cache'],['Cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Internal method -- Remove cached function values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:112,cache,cached,112,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Invalidate cell ids cache on back ptr references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloData.cxx:106,cache,cache,106,graf3d/eve/src/TEveCaloData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloData.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// It performs an hypothesis tests using the likelihood function; /// and computes the p values for the null and the alternate using the asymptotic; /// formulae for the profile likelihood ratio.; /// See G. Cowan, K. Cranmer, E. Gross and O. Vitells.; /// Asymptotic formulae for likelihood- based tests of new physics. Eur. Phys. J., C71:1–19, 2011.; /// The formulae are valid only for one POI. If more than one POI exists consider as POI only the; /// first one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx:89,perform,performs,89,roofit/roostats/src/AsymptoticCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Iterates through functors in fFuncs and performs the appropriate action.; /// If functor has 0 arguments (has only name) can be:; /// - variable; /// * will be replaced with x[num], where x is an array containing value of this variable under num.; /// - pre-defined formula; /// * will be replaced with formulas body; /// - constant; /// * will be replaced with constant value; /// - parameter; /// * will be replaced with p[num], where p is an array containing value of this parameter under num.; /// If has arguments it can be :; /// - function shortcut, eg. sin; /// * will be replaced with fullname of function, eg. sin -> TMath::Sin; /// - function from cling environment, eg. TMath::BreitWigner(x,y,z); /// * first check if function exists, and has same number of arguments, then accept it and set as found.; /// If all functors after iteration are matched with corresponding action,; /// it inputs C++ code of formula into cling, and sets flag that formula is ready to evaluate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:126,perform,performs,126,hist/hist/src/TFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Keeps track of the status of ImplicitMT w/o resorting to the load of; /// libImt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:147,load,load,147,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Label OK'ed components of a RooAddPdf with cache-and-track",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:129,cache,cache-and-track,129,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['cache'],['cache-and-track']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Label OK'ed components of a RooProdPdf with cache-and-track, _and_ label all RooProdPdf; /// descendants with extra information about (conditional) normalization, needed to be able; /// to Cache-And-Track them outside the RooProdPdf context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:130,cache,cache-and-track,130,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,2,"['Cache', 'cache']","['Cache-And-Track', 'cache-and-track']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Label OK'ed components of a RooProduct with cache-and-track",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:130,cache,cache-and-track,130,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['cache'],['cache-and-track']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Label OK'ed components of a RooRealSumPdf with cache-and-track",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealSumPdf.cxx:133,cache,cache-and-track,133,roofit/roofitcore/src/RooRealSumPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealSumPdf.cxx,1,['cache'],['cache-and-track']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Layout this edge in the GraphViz space. This is done after gvLayout; /// has been performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gviz/src/TGraphEdge.cxx:168,perform,performed,168,graf2d/gviz/src/TGraphEdge.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gviz/src/TGraphEdge.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Layout this node in the GraphViz space. This is done after gvLayout; /// has been performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gviz/src/TGraphNode.cxx:168,perform,performed,168,graf2d/gviz/src/TGraphNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gviz/src/TGraphNode.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// List all RooAbsArg derived contents in this cache element",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx:130,cache,cache,130,roofit/roofitcore/src/RooAddHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddHelpers.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// List contents of file cache. If all is true show all caches also on; /// slaves. If everything is ok all caches are to be the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:108,cache,cache,108,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,6,['cache'],"['cache', 'caches']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// List the loaded shared libraries.; /// `regexp` is a regular expression allowing to filter the list.; ///; /// Examples:; ///; /// The following line lists all the libraries currently loaded:; /// ~~~ {.cpp}; /// gSystem->ListLibraries(); /// ~~~; ///; /// The following line lists all the libraries currently loaded having ""RIO"" in their names:; /// ~~~ {.cpp}; /// gSystem->ListLibraries("".*RIO.*""); /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:95,load,loaded,95,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,3,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load HDU from fits file satisfying the specified filter.; /// Returns kTRUE if success. Otherwise kFALSE.; /// If filter == """" then the primary array is selected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/fitsio/src/TFITS.cxx:86,Load,Load,86,graf2d/fitsio/src/TFITS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/fitsio/src/TFITS.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a 0 terminated buffer. Lines will be split at '\n'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGText.cxx:86,Load,Load,86,gui/gui/src/TGText.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGText.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a file in the editor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionLogView.cxx:86,Load,Load,86,gui/sessionviewer/src/TSessionLogView.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionLogView.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a file in the text view widget. Return false in case file does not; /// exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextView.cxx:86,Load,Load,86,gui/gui/src/TGTextView.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextView.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a file in the window.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressLog.cxx:86,Load,Load,86,gui/sessionviewer/src/TProofProgressLog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressLog.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a file into the editor. If fname is 0, a TGFileDialog will popup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEditor.cxx:86,Load,Load,86,gui/gui/src/TGTextEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEditor.cxx,2,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a library file in cling's memory.; /// if 'system' is true, the library is never unloaded.; /// Return 0 on success, -1 on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:86,Load,Load,86,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:86,Load,Load,86,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a macro file in cling's memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:86,Load,Load,86,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a macro in the interpreter's memory. Equivalent to the command line; /// command "".L filename"". If the filename has ""+"" or ""++"" appended; /// the macro will be compiled by ACLiC. The filename must have the format:; /// [path/]macro.C[+|++[g|O]].; /// The possible error codes are defined by TInterpreter::EErrorCode.; /// If check is true it will only check if filename exists and is; /// readable.; /// Returns 0 on successful loading and -1 in case filename does not; /// exist or in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:86,Load,Load,86,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,2,"['Load', 'load']","['Load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a shared library. Returns 0 on successful loading, 1 in; /// case lib was already loaded, -1 in case lib does not exist; /// or in case of error and -2 in case of version mismatch.; /// When entry is specified the loaded lib is; /// searched for this entry point (return -1 when entry does not exist,; /// 0 otherwise). When the system flag is kTRUE, the library is considered; /// a permanent system library that should not be unloaded during the; /// course of the session.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:86,Load,Load,86,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,4,"['Load', 'load']","['Load', 'loaded', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a source file or library called path into the interpreter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:86,Load,Load,86,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a text buffer in the editor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionLogView.cxx:86,Load,Load,86,gui/sessionviewer/src/TSessionLogView.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionLogView.cxx,3,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a text buffer in the window.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressLog.cxx:86,Load,Load,86,gui/sessionviewer/src/TProofProgressLog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressLog.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load a tree from s TDSetElement",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:86,Load,Load,86,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load all libraries known to ROOT via the rootmap system.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:86,Load,Load,86,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load all plugin macros from the specified path/base directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx:86,Load,Load,86,core/base/src/TPluginManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load all the DataMembers known to the interpreter for the scope 'fClass'; /// and all its bases classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TViewPubDataMembers.cxx:86,Load,Load,86,core/meta/src/TViewPubDataMembers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TViewPubDataMembers.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load all the DataMembers known to the interpreter for the scope 'fClass'; /// into this collection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfDataMembers.cxx:86,Load,Load,86,core/meta/src/TListOfDataMembers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfDataMembers.cxx,2,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load all the functions known to the interpreter for the scope 'fClass'; /// and all its bases classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TViewPubFunctions.cxx:86,Load,Load,86,core/meta/src/TViewPubFunctions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TViewPubFunctions.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load all the functions known to the interpreter for the scope 'fClass'; /// into this collection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfFunctions.cxx:86,Load,Load,86,core/meta/src/TListOfFunctions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfFunctions.cxx,2,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load an entry into the network",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx:86,Load,Load,86,math/mlp/src/TMultiLayerPerceptron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load an entry into the tree, return the status of the read.; /// For chains, entry is the global (i.e. not tree-local) entry number, unless; /// `local` is `true`, in which case `entry` specifies the entry number within; /// the current tree. This is needed for instance for TSelector::Process().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:86,Load,Load,86,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load and execute macro 'mac' if it has not been loaded yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx:86,Load,Load,86,graf3d/eve/src/TEveUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx,4,"['Load', 'load']","['Load', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load and initialize thread library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:86,Load,Load,86,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load basket buffers in memory without unziping.; /// This function is called by TTreeCloner.; /// The function returns 0 in case of success, 1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:86,Load,Load,86,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load bin `binNumber`, and return an argset with the coordinates of the bin centre.; /// \note The argset is owned by this data hist, and this function has a side effect, because; /// it alters the currently active bin.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:86,Load,Load,86,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load class description from I/O buffer and return class object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:86,Load,Load,86,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load directory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:86,Load,Load,86,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load entry on behalf of our master tree, we may use an index.; ///; /// Called by LoadTree() when the masterTree looks for the entry; /// number in a friend tree (us) corresponding to the passed entry; /// number in the masterTree.; ///; /// If we have no index, our entry number and the masterTree entry; /// number are the same.; ///; /// If we *do* have an index, we must find the (major, minor) value pair; /// in masterTree to locate our corresponding entry.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:86,Load,Load,86,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['Load'],"['Load', 'LoadTree']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load external input values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooConvIntegrandBinding.cxx:86,Load,Load,86,roofit/roofitcore/src/RooConvIntegrandBinding.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooConvIntegrandBinding.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load font and query font. If font is not found 0 is returned,; /// otherwise an opaque pointer to the FontStruct_t.; /// Free the loaded font using DeleteFont().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:86,Load,Load,86,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,4,"['Load', 'load']","['Load', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load generatedVars with the subset of directVars that we can generate events for,; /// and return a code that specifies the generator algorithm we will use. A code of; /// zero indicates that we cannot generate any of the directVars (in this case, nothing; /// should be added to generatedVars). Any non-zero codes will be passed to our generateEvent(); /// implementation, but otherwise its value is arbitrary. The default implementation of; /// this method returns zero. Subclasses will usually implement this method using the; /// matchArgs() methods to advertise the algorithms they provide.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:86,Load,Load,86,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load internal trees from directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveVSD.cxx:86,Load,Load,86,graf3d/eve/src/TEveVSD.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveVSD.cxx,2,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load library containing the specified class. Returns 0 in case of error; /// and 1 in case if success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:86,Load,Load,86,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load map between class and library. If rootmapfile is specified a; /// specific rootmap file can be added (typically used by ACLiC).; /// In case of error -1 is returned, 0 otherwise.; /// The interpreter uses this information to automatically load the shared; /// library for a class (autoload mechanism), see the AutoLoad() methods below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:86,Load,Load,86,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,"['Load', 'load']","['Load', 'load']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load plugin and create drag manager object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TVirtualDragManager.cxx:86,Load,Load,86,gui/gui/src/TVirtualDragManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TVirtualDragManager.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load plugin handlers specified in config file, like:; /// ~~~ {.cpp}; /// Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; /// +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; /// ~~~; /// The + allows the extension of an already defined resource (see TEnv).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx:86,Load,Load,86,core/base/src/TPluginManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load plugin handlers specified via macros in a list of plugin; /// directories. The `$ROOTSYS/etc/plugins` is the default top plugin directory; /// specified in `$ROOTSYS/etc/system.rootrc`. The macros must have names; /// like `<BaseClass>/PX0_<PluginClass>.C`, e.g. //`TSQLServer/P20_TMySQLServer.C`,; /// to allow easy sorting and grouping. If the BaseClass is in a namespace; /// the directory must have the name NameSpace@@BaseClass as : is a reserved; /// pathname character on some operating systems. Macros not beginning with; /// 'P' and ending with "".C"" are ignored. If base is specified only plugin; /// macros for that base class are loaded. The macros typically; /// should look like:; /// ~~~ {.cpp}; /// void P10_TDCacheFile(); /// {; /// gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; /// ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; /// }; /// ~~~; /// In general these macros should not cause side effects, by changing global; /// ROOT state via, e.g. gSystem calls, etc. However, in specific cases; /// this might be useful, e.g. adding a library search path, adding a specific; /// dependency, check on some OS or ROOT capability or downloading; /// of the plugin.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx:86,Load,Load,86,core/base/src/TPluginManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx,2,"['Load', 'load']","['Load', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load shared libs necessary for GUI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGApplication.cxx:86,Load,Load,86,gui/gui/src/TGApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGApplication.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load specified package. Executes the PROOF-INF/SETUP.C script; /// on all active nodes. If notOnClient = true, don't load package; /// on the client. The default is to load the package also on the client.; /// The argument 'loadopts' specify a list of objects to be passed to the SETUP.; /// The objects in the list must be streamable; the SETUP macro will be executed; /// like this: SETUP.C(loadopts).; /// Returns 0 in case of success and -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:86,Load,Load,86,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,5,"['Load', 'load']","['Load', 'load', 'loadopts']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load text from a text buffer. Return false in case of failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextView.cxx:86,Load,Load,86,gui/gui/src/TGTextView.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextView.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load text from file fn. Startpos is the begin from where to; /// load the file and length is the number of characters to read; /// from the file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGText.cxx:86,Load,Load,86,gui/gui/src/TGText.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGText.cxx,2,"['Load', 'load']","['Load', 'load']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the TTreePlayer (if not already done).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:86,Load,Load,86,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the current array sizes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx:86,Load,Load,86,tree/treeplayer/src/TFormLeafInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the current array sizes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx:86,Load,Load,86,tree/treeplayer/src/TFormLeafInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx,2,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the data for the entry from the database.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeSQL.cxx:86,Load,Load,86,tree/tree/src/TTreeSQL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeSQL.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the declarations from text into the interpreter.; /// Note that this cannot be (top level) statements; text must contain; /// top level declarations.; /// Returns true on success, false on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:86,Load,Load,86,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the macro into the interpreter.; /// Return true in case the loading was successful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMacro.cxx:86,Load,Load,86,core/base/src/TMacro.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMacro.cxx,2,"['Load', 'load']","['Load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the n-th data point (n='idx') in memory; /// and return a pointer to the internal RooArgSet; /// holding its coordinates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCompositeDataStore.cxx:86,Load,Load,86,roofit/roofitcore/src/RooCompositeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCompositeDataStore.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the n-th data point (n='index') in memory; /// and return a pointer to the internal RooArgSet; /// holding its coordinates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:86,Load,Load,86,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the n-th data point (n='index') into the variables of this dataset,; /// and return a pointer to the RooArgSet that holds them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx:86,Load,Load,86,roofit/roofitcore/src/RooVectorDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the plugin library for this handler. Returns 0 on successful loading; /// and -1 in case the library does not exist or in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx:86,Load,Load,86,core/base/src/TPluginManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx,2,"['Load', 'load']","['Load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the plugin library for this handler. Sets status to 0 on successful loading; /// and -1 in case the library does not exist or in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx:86,Load,Load,86,core/base/src/TPluginManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx,2,"['Load', 'load']","['Load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the snapshot from ws and return the corresponding set with the snapshot values.; /// User must delete returned RooArgSet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx:86,Load,Load,86,roofit/roofitcore/src/ModelConfig.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the specified macro on master, workers and, if notOnClient is; /// kFALSE, on the client. The macro file is uploaded if new or updated.; /// Additional files to be uploaded (or updated, if needed) can be specified; /// after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"".; /// If existing in the same directory, a header basename(macro).h or .hh, is also; /// uploaded.; /// The default is to load the macro also on the client; notOnClient can be used; /// to avoid loading on the client.; /// On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers; /// only, and collection is not done; if uniqueWorkers is kFALSE, collection; /// from the previous request is done, and broadcasting + collection from the; /// other workers is done.; /// The wrks arg can be used on the master to limit the set of workers.; /// Returns 0 in case of success and -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:86,Load,Load,86,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,4,"['Load', 'load']","['Load', 'load', 'loaded', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the values and attributes of the parameters in the snapshot saved with; /// the given name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:86,Load,Load,86,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load the vector of variable values into the RooRealVars associated; /// as variables with the bound RooAbsReal function.; /// \warning This will load as many values as the dimensionality of the function; /// requires. The size of `xvector` is not checked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealBinding.cxx:86,Load,Load,86,roofit/roofitcore/src/RooRealBinding.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealBinding.cxx,2,"['Load', 'load']","['Load', 'load']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load tree fTreeName from directory 'dir'. If not found, look for the; /// first TTree in the directory (and sub-directories) with the name containing; /// fTreeName.; /// The tree pointer is saved in fTree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofPerfAnalysis.cxx:86,Load,Load,86,proof/proofbench/src/TProofPerfAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofPerfAnalysis.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load values from dataset 't' into this data collection, optionally; /// selecting events using 'select' RooFormulaVar; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:86,Load,Load,86,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load values from tree 't' into this data collection, optionally; /// selecting events using the RooFormulaVar 'select'.; ///; /// The source tree 't' is cloned to not disturb its branch; /// structure when retrieving information from it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:86,Load,Load,86,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load visualization-parameter database from file filename. The; /// replace, update arguments replace the values of fVizDBReplace; /// and fVizDBUpdate members for the duration of the macro; /// execution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx:86,Load,Load,86,graf3d/eve/src/TEveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx,2,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load visualization-parameter database from file filename.; /// State of data-members fVizDBReplace and fVizDBUpdate determine; /// how the registered entries are handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx:86,Load,Load,86,graf3d/eve/src/TEveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx,2,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load/append a log msg in the log frame, if open",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressDialog.cxx:86,Load,Load,86,gui/sessionviewer/src/TProofProgressDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TProofProgressDialog.cxx,2,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Load/append a log msg in the log frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:86,Load,Load,86,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Loading in double prec. number, sometimes can be useful",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoamVect.cxx:86,Load,Loading,86,math/foam/src/TFoamVect.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoamVect.cxx,2,['Load'],['Loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Loading in ordinary double prec. vector, sometimes can be useful",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoamVect.cxx:86,Load,Loading,86,math/foam/src/TFoamVect.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/src/TFoamVect.cxx,2,['Load'],['Loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Loads a PNG image from the specified stream (using Windows Imaging; /// Component).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx:86,Load,Loads,86,core/winnt/src/Win32Splash.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx,1,['Load'],['Loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Loads a new data set into the class instance.; /// Returns 1 in case of error, 0 otherwise.; /// \param[in] data; /// \param[in] options",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/Roo2DKeysPdf.cxx:86,Load,Loads,86,roofit/roofit/src/Roo2DKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/Roo2DKeysPdf.cxx,1,['Load'],['Loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Loads the C++ modules that we require to run any ROOT program. This is just; /// supposed to make a C++ module from a modulemap available to the interpreter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:86,Load,Loads,86,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Load'],['Loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Loads the PNG containing the splash image into a HBITMAP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx:86,Load,Loads,86,core/winnt/src/Win32Splash.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/Win32Splash.cxx,1,['Load'],['Loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Loads the list \#listnumber; /// This is the only function that can modify fCurrent and fFile data members",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:86,Load,Loads,86,tree/tree/src/TEntryListFromFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx,1,['Load'],['Loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Loads the weights from a text file conforming to the format; /// defined by DumpWeights.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx:86,Load,Loads,86,math/mlp/src/TMultiLayerPerceptron.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMultiLayerPerceptron.cxx,1,['Load'],['Loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Logical shapes usually support only discreet LOD values,; /// especially in view of display-list caching.; /// This function should be overriden to perform the desired quantization.; /// See TGLSphere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:234,perform,perform,234,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Look up projection cache and per-PDF norm sets. If a PDF doesn't have a special; /// norm set, use the `defaultNorm`. If `defaultNorm == nullptr`, use the member; /// _normSet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:105,cache,cache,105,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// MI include; ///; /// Optimize formula; /// - Minimize the number of operands; /// 1. several operands are glued together; /// 2. some primitive functions glued together - exemp. (x+y) => PlusXY(x,y); /// 3. maximize number of standard calls minimizing number of jumps in Eval cases; /// 4. variables, parameters and constants are mapped - using fOperOfssets0; /// Eval procedure use direct acces to data (only one corresponding case statement in eval procedure); /// ~~~ {.cpp}; /// pdata[operand={Var,Par,Const}][offset]; /// pdata[fOperOffsets0[i]][fOperOffset1[i+1]]; /// ~~~; /// - The fastest evaluation function is chosen at the end; /// 1. fOptimal := pointer to the fastest function for given evaluation string; /// ~~~ {.cpp}; /// switch(GetActionOptimized(0)){; /// case kData : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive0; break;}; /// case kUnary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive1; break;}; /// case kBinary : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive2; break;}; /// case kThree : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive3; break;}; /// case kFDM : {fOptimal= (TFormulaPrimitive::TFuncG)&TFormula::EvalPrimitive4; break;}; /// }; /// ~~~; /// 2. ex.; /// - fOptimal = TFormula::EvalPrimitive0 - if it return only variable, constant or parameter; /// - = TFormula::EvalPrimitive1 - if only one unary operation; /// - = TFormula::EvalPrimitive2 - if only one binary operation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:107,Optimiz,Optimize,107,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['Optimiz'],['Optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Make a daughter of current node current. Can be called only with a valid; /// daughter index (no check). Updates cache accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:199,cache,cache,199,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Make a daughter of current node current. Can be called only with a valid; /// daughter node (no check). Updates cache accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:198,cache,cache,198,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Make sure TStreamerInfo is not optimized, otherwise it will not be; /// possible to support schema evolution in read mode.; /// In case the StreamerInfo has already been computed and optimized,; /// one must disable the option BypassStreamer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferIO.cxx:117,optimiz,optimized,117,io/io/src/TBufferIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferIO.cxx,2,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Make sure that a call to the Redraw() routine has been queued.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:141,queue,queued,141,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,1,['queue'],['queued']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Make sure that all the branches have been loaded properly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:128,load,loaded,128,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Make sure that the input data objects are available to the workers in a; /// dedicated file in the cache; the objects are taken from the dedicated list; /// and / or the specified file.; /// If the fInputData is empty the specified file is sent over.; /// If there is no specified file, a file named ""inputdata.root"" is created locally; /// with the content of fInputData and sent over to the master.; /// If both fInputData and the specified file are not empty, a copy of the file; /// is made locally and augmented with the content of fInputData.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:185,cache,cache,185,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Make top level node the current node. Updates the cache accordingly.; /// Determine the overlapping state of current node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:136,cache,cache,136,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Makes sure that macro 'mac' is loaded, but do not reload it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx:117,load,loaded,117,graf3d/eve/src/TEveUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveUtil.cxx,2,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Max number of bytes to prefetch.; ///; /// By default this is 75% of the; /// read cache size. But specific TFile implementations may need to change it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:169,cache,cache,169,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Merge all the entries in the chain into a new tree in the current file.; ///; /// Note: The ""file"" parameter is *not* the file where the new; /// tree will be inserted. The new tree is inserted into; /// gDirectory, which is usually the most recently opened; /// file, or the directory most recently cd()'d to.; ///; /// If option = ""C"" is given, the compression level for all branches; /// in the new Tree is set to the file compression level. By default,; /// the compression level of all branches is the original compression; /// level in the old trees.; ///; /// If basketsize > 1000, the basket size for all branches of the; /// new tree will be set to basketsize.; ///; /// Example using the file generated in $ROOTSYS/test/Event; /// merge two copies of Event.root; /// ~~~ {.cpp}; /// gSystem.Load(""libEvent"");; /// TChain ch(""T"");; /// ch.Add(""Event1.root"");; /// ch.Add(""Event2.root"");; /// ch.Merge(""all.root"");; /// ~~~; /// If the chain is expecting the input tree inside a directory,; /// this directory is NOT created by this routine.; ///; /// So if you do:; /// ~~~ {.cpp}; /// TChain ch(""mydir/mytree"");; /// ch.Merge(""newfile.root"");; /// ~~~; /// The resulting file will not have subdirectories. In order to; /// preserve the directory structure do the following instead:; /// ~~~ {.cpp}; /// TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; /// file->mkdir(""mydir"")->cd();; /// ch.Merge(file, 0);; /// ~~~; /// If 'option' contains the word 'fast' the merge will be done without; /// unzipping or unstreaming the baskets (i.e., a direct copy of the raw; /// bytes on disk).; ///; /// When 'fast' is specified, 'option' can also contains a; /// sorting order for the baskets in the output file.; ///; /// There is currently 3 supported sorting order:; /// ~~~ {.cpp}; /// SortBasketsByOffset (the default); /// SortBasketsByBranch; /// SortBasketsByEntry; /// ~~~; /// When using SortBask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:887,Load,Load,887,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['Load'],['Load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Method to load a package taking an option const char *; /// Return -1 on error, 0 otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx:96,load,load,96,proof/proof/src/TPackMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Method to load a package taking an option list; /// Return -1 on error, 0 otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx:96,load,load,96,proof/proof/src/TPackMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Minimization function for H1s using a Chisquare method.; /// Default method (function evaluated at center of bin); /// for each point the cache contains the following info; /// - 1D : bc,e,xc (bin content, error, x of center of bin); /// - 2D : bc,e,xc,yc; /// - 3D : bc,e,xc,yc,zc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:224,cache,cache,224,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Minimization function for H1s using a Chisquare method.; /// The ""I""ntegral method is used; /// for each point the cache contains the following info; /// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); /// - 2D : bc,e,xc,xw,yc,yw; /// - 3D : bc,e,xc,xw,yc,yw,zc,zw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:201,cache,cache,201,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Minimization function for H1s using a Likelihood method.; /// Basically, it forms the likelihood by determining the Poisson; /// probability that given a number of entries in a particular bin,; /// the fit would predict it's value. This is then done for each bin,; /// and the sum of the logs is taken as the likelihood.; ///; /// Default method (function evaluated at center of bin); /// for each point the cache contains the following info; /// - 1D : bc,e,xc (bin content, error, x of center of bin); /// - 2D : bc,e,xc,yc; /// - 3D : bc,e,xc,yc,zc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:494,cache,cache,494,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Minimization function for H1s using a Likelihood method.; /// Basically, it forms the likelihood by determining the Poisson; /// probability that given a number of entries in a particular bin,; /// the fit would predict it's value. This is then done for each bin,; /// and the sum of the logs is taken as the likelihood.; ///; /// The ""I""ntegral method is used; /// for each point the cache contains the following info; /// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); /// - 2D : bc,e,xc,xw,yc,yw; /// - 3D : bc,e,xc,xw,yc,yw,zc,zw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:471,cache,cache,471,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Minimization using the simplex method of Nelder and Mead; ///; /// Performs a minimization using the simplex method of Nelder; /// and Mead (ref. -- Comp. J. 7,308 (1965)).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:153,Perform,Performs,153,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Missing primary vertex class.; ////////////////////////////////////////////////////////////////////////////////; /******************************************************************************/; /******************************************************************************/; // This whole construction is somewhat doubtable. It requires; // shameless copying of experiment data. What is good about this; // scheme:; //; // 1) Filters can be applied at copy time so that only part of the; // data is copied over.; //; // 2) Once the data is extracted it can be used without experiment; // software. Thus, external service can provide this data and local; // client can be really thin.; //; // 3) Some pretty advanced visualization schemes/selections can be; // implemented in a general framework by providing data extractors; // only. This is also good for PR or VIP displays.; //; // 4) These classes can be extended by particular implementations. The; // container classes will use TClonesArray with user-specified element; // class.; // The common behaviour could be implemented entirely without usage of; // a common base classes, by just specifying names of members that; // retrieve specific data. This is fine as long as one only uses tree; // selections but becomes painful for extraction of data into local; // structures (could a) use interpreter but this is an overkill and; // would cause serious trouble for multi-threaded environment; b) use; // member offsets and data-types from the dictionary).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/inc/ROOT/REveVSDStructs.hxx:1508,multi-thread,multi-threaded,1508,graf3d/eve7/inc/ROOT/REveVSDStructs.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/inc/ROOT/REveVSDStructs.hxx,1,['multi-thread'],['multi-threaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Move a cache from a file to the current file in dir.; /// if src is null no operation is done, if dir is null or there is no; /// current file the cache is deleted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:93,cache,cache,93,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Move focus to a different box position and extent in nsteps. Perform; /// rotation with dlat,dlong,dpsi at each step.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TView3D.cxx:147,Perform,Perform,147,graf3d/g3d/src/TView3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TView3D.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Notify director and values of a change in tree. Called from TChain and TTree's LoadTree.; /// TTreeReader registers its fNotify data member with the TChain/TTree which; /// in turn leads to this method being called upon the execution of LoadTree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:165,Load,LoadTree,165,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,2,['Load'],['LoadTree']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Observable to be cached for given choice of normalization.; /// Returns the 'x' observable unless doCacheAlpha is set in which; /// case a set with both x and alpha",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:103,cache,cached,103,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// One-dimensional peak search function; ///; /// This function searches for peaks in source spectrum in hin; /// The number of found peaks and their positions are written into; /// the members fNpeaks and fPositionX.; /// The search is performed in the current histogram range.; ///; /// #### Parameters:; ///; /// - hin: pointer to the histogram of source spectrum; /// - sigma: sigma of searched peaks, for details we refer to manual; /// - threshold: (default=0.05) peaks with amplitude less than; /// threshold*highest_peak are discarded. 0<threshold<1; ///; /// By default, the background is removed before deconvolution.; /// Specify the option ""nobackground"" to not remove the background.; ///; /// By default the ""Markov"" chain algorithm is used.; /// Specify the option ""noMarkov"" to disable this algorithm; /// Note that by default the source spectrum is replaced by a new spectrum; ///; /// By default a polymarker object is created and added to the list of; /// functions of the histogram. The histogram is drawn with the specified; /// option and the polymarker object drawn on top of the histogram.; /// The polymarker coordinates correspond to the npeaks peaks found in; /// the histogram.; ///; /// A pointer to the polymarker object can be retrieved later via:; /// ~~~ {.cpp}; /// TList *functions = hin->GetListOfFunctions();; /// TPolyMarker *pm = (TPolyMarker*)functions->FindObject(""TPolyMarker"");; /// ~~~; /// Specify the option ""goff"" to disable the storage and drawing of the; /// polymarker.; ///; /// To disable the final drawing of the histogram with the search results (in case; /// you want to draw it yourself) specify ""nodraw"" in the options parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx:320,perform,performed,320,hist/spectrum/src/TSpectrum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Open a file for reading through the file cache.; ///; /// The file will be downloaded to the cache and opened from there.; /// If the download fails, it will be opened remotely.; /// The file will be downloaded to the directory specified by SetCacheFileDir().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:127,cache,cache,127,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Open a stager, after having loaded the relevant plug-in.; /// The format of 'stager' depends on the plug-in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFileStager.cxx:114,load,loaded,114,net/net/src/TFileStager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFileStager.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Optimize Tuning Parameters; /// This is used to optimise the kernel function parameters and cost. All kernel parameters; /// are optimised by default with default ranges, however the parameters to be optimised can; /// be set when booking the method with the option Tune.; ///; /// Example:; ///; /// ""Tune=Gamma[0.01;1.0;100]"" would only tune the RBF Gamma between 0.01 and 1.0; /// with 100 steps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodSVM.cxx:86,Optimiz,Optimize,86,tmva/tmva/src/MethodSVM.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodSVM.cxx,4,"['Optimiz', 'Tune', 'tune']","['Optimize', 'Tune', 'tune']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Optimize axis limits.; ///; /// When isInter=kTRUE, the function makes an integer binwidth; /// and recompute the number of bins accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:86,Optimiz,Optimize,86,hist/hist/src/THLimitsFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx,1,['Optimiz'],['Optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Optimize voxelization type for all volumes. Save best choice in a macro.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:86,Optimiz,Optimize,86,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['Optimiz'],['Optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Optimize() balances binary tree for first odepth levels; /// for each depth we split sorted depth % dimension variables; /// into \f$ 2^{odepth} \f$ parts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ModulekNN.cxx:86,Optimiz,Optimize,86,tmva/tmva/src/ModulekNN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ModulekNN.cxx,1,['Optimiz'],['Optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Optimized destroy of projected elements with condition; /// there is only one parent for projected element. Method is; /// called from REveElement::Annihilate().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveProjectionBases.cxx:86,Optimiz,Optimized,86,graf3d/eve7/src/REveProjectionBases.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveProjectionBases.cxx,1,['Optimiz'],['Optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Optimized destroy of projected elements with condition; /// there is only one parent for projected element. Method is; /// called from TEveElement::Annihilate().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveProjectionBases.cxx:86,Optimiz,Optimized,86,graf3d/eve/src/TEveProjectionBases.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveProjectionBases.cxx,1,['Optimiz'],['Optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Optimized destruction without check of reference-count.; /// Parents are not notified about child destruction.; /// The method should only be used when an element does not have; /// more than one parent -- otherwise an exception is thrown.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx:86,Optimiz,Optimized,86,graf3d/eve/src/TEveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx,2,['Optimiz'],['Optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Optimized implementation of createProfile for profile likelihoods.; /// Return profile of original function in terms of stated parameters; /// of interest rather than profiling recursively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProfileLL.cxx:86,Optimiz,Optimized,86,roofit/roofitcore/src/RooProfileLL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProfileLL.cxx,1,['Optimiz'],['Optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Overwrite the value stored in this object's cache.; /// This can be used to fake a computation that resulted in `value`.; /// \param[in] value Value to write. The argument is reinterpreted as a category state.; /// If such a state does not exist, this will create undefined behaviour.; /// \param[in] notifyClients If true, notify users of this object that its value changed.; /// This is the default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCategory.cxx:130,cache,cache,130,roofit/roofitcore/src/RooAbsCategory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCategory.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Overwrite the value stored in this object's cache.; /// This can be used to fake a computation that resulted in `value`.; /// \param[in] value Value to write.; /// \param[in] notifyClients If true, notify users of this object that its value changed.; /// This is the default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:130,cache,cache,130,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Paint GL Axis.; ///; /// - p1, p2 : Axis position in the 3D space.; /// - wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; /// - ndiv : Number of axis divisions. It is an integer in the form; /// ""ttsspp"" where ""tt"" is the number of tertiary divisions,; /// ""ss"" is the number of secondary divisions and ""pp"" the; /// number of primary divisions.; /// - opt : Options.; /// ""N"" - By default the number of divisions is optimized to; /// get a nice labeling. When option ""N"" is given, the; /// number of divisions is not optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLAxis.cxx:525,optimiz,optimized,525,graf3d/gl/src/TGLAxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLAxis.cxx,2,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Parameters of the cache. Returns parameters of both pdf1 and pdf2; /// and parameter cache, in case doCacheAlpha is not set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:104,cache,cache,104,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform 2 times a gaussian fit to fetch the center of the histo.; /// To get the second fit range get an interval that tries to keep into account; /// the skewness of the distribution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HybridPlot.cxx:86,Perform,Perform,86,roofit/roostats/src/HybridPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HybridPlot.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform 3D redraw of all scenes and viewers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx:86,Perform,Perform,86,graf3d/eve/src/TEveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx,2,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform 3D redraw of scenes and viewers whose contents has; /// changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx:86,Perform,Perform,86,graf3d/eve/src/TEveManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveManager.cxx,2,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform FFT convolution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:86,Perform,Perform,86,hist/hist/src/TF1Convolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform GL selection, picking objects overlapping WINDOW; /// area described by 'rect'. Return kTRUE if selection should be; /// changed, kFALSE otherwise.; /// Select lock should already been taken in other thread in; /// TGLViewer::ReqSelect().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:86,Perform,Perform,86,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform GL selection, picking overlay objects only.; /// Return TRUE if the selected overlay-element has changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:86,Perform,Perform,86,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform GL work which must be done after each draw.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:86,Perform,Perform,86,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform GL work which must be done before each draw.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:86,Perform,Perform,86,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform Gaussian blur of the image (useful for drop shadows).; /// - hr - horizontal radius of the blur; /// - vr - vertical radius of the blur",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx:86,Perform,Perform,86,graf2d/asimage/src/TASImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a ""negate"" operation on all data vectors : x = -x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpVar.cxx:86,Perform,Perform,86,math/quadp/src/TQpVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpVar.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a ""saxpy"" operation on all data vectors : x += alpha*y",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpVar.cxx:86,Perform,Perform,86,math/quadp/src/TQpVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpVar.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a 2-D \f$ \chi^2 \f$ fit using a series of x and y values stored in the dataset `xydata`.; /// The y values can either be the event weights, or can be another column designated; /// by the YVar() argument. The y value must have errors defined for the \f$ \chi^2 \f$ to; /// be well defined.; ///; /// <table>; /// <tr><th><th> Options to control construction of the chi-square; /// <tr><td> `YVar(RooRealVar& yvar)` <td> Designate given column in dataset as Y value; /// <tr><td> `Integrate(bool flag)` <td> Integrate function over range specified by X errors; /// rather than take value at bin center.; ///; /// <tr><th><th> Options to control flow of fit procedure; /// <tr><td> `InitialHesse(bool flag)` <td> Flag controls if HESSE before MIGRAD as well, off by default; /// <tr><td> `Hesse(bool flag)` <td> Flag controls if HESSE is run after MIGRAD, on by default; /// <tr><td> `Minos(bool flag)` <td> Flag controls if MINOS is run after HESSE, on by default; /// <tr><td> `Minos(const RooArgSet& set)` <td> Only run MINOS on given subset of arguments; /// <tr><td> `Save(bool flag)` <td> Flag controls if RooFitResult object is produced and returned, off by default; /// <tr><td> `Strategy(Int_t flag)` <td> Set Minuit strategy (0 through 2, default is 1); ///; /// <tr><th><th> Options to control informational output; /// <tr><td> `Verbose(bool flag)` <td> Flag controls if verbose output is printed (NLL, parameter changes during fit; /// <tr><td> `Timer(bool flag)` <td> Time CPU and wall clock consumption of fit steps, off by default; /// <tr><td> `PrintLevel(Int_t level)` <td> Set Minuit print level (-1 through 3, default is 1). At -1 all RooFit informational; /// messages are suppressed as well; /// <tr><td> `Warnings(bool flag)` <td> Enable or disable MINUIT warnings (enabled by default); /// <tr><td> `PrintEvalErrors(Int_t numErr)` <td> Control number of p.d.f evaluation errors printe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; /// commands MIGRAD, HESSE in succession; ///; /// The following named arguments are supported; ///; /// <table>; /// <tr><th> <th> Options to control construction of chi2; /// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; /// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; /// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; /// (in RooFit jargon, ""if the pdf can be extended"").; /// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; /// and the chi2 will fall back to the total data weight to scale the normalized pdf.; /// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; /// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; /// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; /// printed and you'll most likely get garbage results.; /// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; /// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; /// Multiple comma separated range names can be specified.; /// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; /// <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization (on by default); /// <tr><td> `IntegrateBins()`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a fit with current parameters' settings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:86,Perform,Perform,86,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a line search from position START; ///; /// along direction STEP, where the length of vector STEP; /// gives the expected position of minimum.; /// - FSTART is value of function at START; /// - SLOPE (if non-zero) is df/dx along STEP at START; /// - TOLER is initial tolerance of minimum in direction STEP; ///; /// SLAMBG and ALPHA control the maximum individual steps allowed.; /// The first step is always =1. The max length of second step is SLAMBG.; /// The max size of subsequent steps is the maximum previous successful; /// step multiplied by ALPHA + the size of most recent successful step,; /// but cannot be smaller than SLAMBG.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:86,Perform,Perform,86,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a permutation transformation on the diagonal matrix S', so that; /// matrix S'' = U''^T . S' . V'' has diagonal elements ordered such that they; /// do not increase.; ///; /// Output:; /// - v - (n x n) - matrix H . V' . V'' in the (n x n) part of v; /// - u - (m x m) - matrix U''^T . U'^T . Q^T; /// - sDiag - diagonal of the (m x n) S''",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompSVD.cxx:86,Perform,Perform,86,math/matrix/src/TDecompSVD.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TDecompSVD.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a quick sanity check to ensure we won't overflow the X; /// coordinate space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:86,Perform,Perform,86,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a rank 1 operation on matrix A:; /// A += alpha * v * v^T",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixT.cxx:86,Perform,Perform,86,math/matrix/src/TMatrixT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixT.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a rank 1 operation on matrix A:; /// A += alpha * v1 * v2^T",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixT.cxx:86,Perform,Perform,86,math/matrix/src/TMatrixT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixT.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a rank 1 operation on the matrix:; /// A += alpha * v * v^T",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSym.cxx:86,Perform,Perform,86,math/matrix/src/TMatrixTSym.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTSym.cxx,2,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a rotation about Z having the sine/cosine of the rotation angle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx:86,Perform,Perform,86,geom/geom/src/TGeoMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx,2,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a stat on the file; see TFile::SysStat().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx:86,Perform,Perform,86,io/io/src/TMemFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a test using dataset 'dset' scanning over the number of workers; /// per node.; /// Return 0 on success, -1 on error; /// Open the file for the results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx:86,Perform,Perform,86,proof/proofbench/src/TProofBench.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform a test using dataset 'dset'; /// Return 0 on success, -1 on error; /// Open the file for the results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx:86,Perform,Perform,86,proof/proofbench/src/TProofBench.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform actions when selected frame was changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldEditor.cxx:86,Perform,Perform,86,gui/guibuilder/src/TGuiBldEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldEditor.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform additional local removal of all elements.; /// See comment to RemoveElementLocal(REveElement*).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx:86,Perform,Perform,86,graf3d/eve7/src/REveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform additional local removal of all elements.; /// See comment to RemoveElementlocal(TEveElement*).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx:86,Perform,Perform,86,graf3d/eve/src/TEveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform additional local removal of el.; /// Called from RemoveElement() which does whole untangling.; /// Put into special function as framework-related handling of; /// element removal should really be common to all classes and; /// clearing of local structures happens in between removal; /// of list-tree-items and final removal.; /// If you override this, you should also override; /// RemoveElementsLocal().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx:86,Perform,Perform,86,graf3d/eve/src/TEveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx,2,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform an extensive sampling to find which type of voxelization is; /// most efficient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx:86,Perform,Perform,86,geom/geom/src/TGeoVolume.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoVolume.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform an initial prefetch, attempting to read as much of the learning; /// phase baskets for all branches at once",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:86,Perform,Perform,86,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform basic syntax on given factory expression. If function returns; /// true syntax errors are found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooFactoryWSTool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFactoryWSTool.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform cleanup after overlay selection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewerBase.cxx:86,Perform,Perform,86,graf3d/gl/src/TGLViewerBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewerBase.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform common initialization for all constructors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooHist.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform drawing using current model settings; /// Returns true if any action was done",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx:86,Perform,Perform,86,gui/fitpanelv7/src/RFitPanel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform entrance formalities in case of no authentication; /// mode, i.e. get target user and check if authorized; /// Don't return if something goes wrong",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:86,Perform,Perform,86,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform fitting using current model settings; /// Returns true if any action was done",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx:86,Perform,Perform,86,gui/fitpanelv7/src/RFitPanel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform hybrid numerical/analytical integration over all real-valued dependents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform initialization that is common to all constructors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooPlot.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooPlot.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform initialization that is common to all curves",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooCurve.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCurve.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform last checks on the geometry",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:86,Perform,Perform,86,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform minimal initialization for overlay selection.; /// Here we assume that scene has already been drawn and that; /// camera and overall bounding box are ok.; /// Scenes are not locked.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewerBase.cxx:86,Perform,Perform,86,graf3d/gl/src/TGLViewerBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewerBase.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform name change",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/src/TGeoPconEditor.cxx:86,Perform,Perform,86,geom/geombuilder/src/TGeoPconEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/src/TGeoPconEditor.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform name change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/src/TGeoMaterialEditor.cxx:86,Perform,Perform,86,geom/geombuilder/src/TGeoMaterialEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/src/TGeoMaterialEditor.cxx,4,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform numerical convolution.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:86,Perform,Perform,86,hist/hist/src/TF1Convolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform one step of Monte Carlo integration using the specified number of iterations; /// with (approximately) the specified number of integrand evaluation calls per iteration.; /// Use the VEGAS algorithm, starting from the specified stage. Returns the best estimate; /// of the integral. Also sets *absError to the estimated absolute error of the integral; /// estimate if absError is non-zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCIntegrator.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooMCIntegrator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMCIntegrator.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform one-time initialization of generator context",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimGenContext.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooSimGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimGenContext.cxx,2,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform one-time initialization of integrator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooGaussKronrodIntegrator1D.cxx:86,Perform,Perform,86,roofit/roofitmore/src/RooGaussKronrodIntegrator1D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitmore/src/RooGaussKronrodIntegrator1D.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform one-time initialization of our static coefficient array if necessary; /// and initialize our workspace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooQuasiRandomGenerator.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooQuasiRandomGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooQuasiRandomGenerator.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform one-time initialization of the generator context",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform orthogonality test for rotation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx:86,Perform,Perform,86,geom/geom/src/TGeoMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform pattern substitution with optional back-ref replacement; /// - protected method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPRegexp.cxx:86,Perform,Perform,86,core/base/src/TPRegexp.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPRegexp.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform post scene-build setup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:86,Perform,Perform,86,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform post-render clean-up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSceneBase.cxx:86,Perform,Perform,86,graf3d/gl/src/TGLSceneBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSceneBase.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform pre-render initialization - fill rnrCtx with; /// values stored during PreDraw().; ///; /// This is called each time before RenderXyzz().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSceneBase.cxx:86,Perform,Perform,86,graf3d/gl/src/TGLSceneBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSceneBase.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform send operation, stored in buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx:86,Perform,Perform,86,net/http/src/THttpWSHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform special action when drawing is ready",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/canvaspainter/src/RCanvasPainter.cxx:86,Perform,Perform,86,gui/canvaspainter/src/RCanvasPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/canvaspainter/src/RCanvasPainter.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform summation of list of category dependents to be integrated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the CPU run scanning over the number of workers per node; /// Return 0 on success, -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx:86,Perform,Perform,86,proof/proofbench/src/TProofBench.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the CPU run; /// Return 0 on success, -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx:86,Perform,Perform,86,proof/proofbench/src/TProofBench.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the FFT of the two functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:86,Perform,Perform,86,hist/hist/src/TF1Convolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the action needed to commence the new session:; /// - set debug flag; /// - check authentication table; /// - Inquire protocol; /// - authenticate the client; /// - login the client; /// Returns 1 for a PROOF master server, 0 otherwise; /// Returns logged-in user and remote process id in rid; /// Called just after opening the connection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:86,Perform,Perform,86,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the action needed to commence the new session:; /// - set debug flag; /// - check authentication table; /// - Inquire protocol; /// - authenticate the client; /// - login the client; /// Returns 1 for a PROOF master server, 0 otherwise; /// Returns logged-in user, the remote client procotol cproto, the; /// client kind of user anon and, if anonymous user, the client passwd.; /// If TServerSocket (servtype==kSOCKD), the protocol number is returned; /// in anon.; /// Called just after opening the connection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:86,Perform,Perform,86,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the action needed to commence the new session:; /// Version called by TServerSocket.; /// - set debug flag; /// - check authentication table; /// - Inquire protocol; /// - authenticate the client; /// Returns logged-in user, the remote client procotol cproto,; /// the authentication protocol (ROOT internal) number is returned; /// in meth, type indicates the kind of authentication:; /// 0 = new authentication; /// 1 = existing authentication; /// 2 = existing authentication with updated offset; /// and the crypted-token in ctoken (used later for cleaning).; /// Called just after opening the connection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:86,Perform,Perform,86,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the actual matching - protected method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPRegexp.cxx:86,Perform,Perform,86,core/base/src/TPRegexp.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPRegexp.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the actual solve using the factors produced in factor.; /// rhs on input contains the aggregated right-hand side of the augmented system;; /// on output contains the solution in aggregated form .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverDens.cxx:86,Perform,Perform,86,math/quadp/src/TQpLinSolverDens.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverDens.cxx,2,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the automatic addition of the graph to the given directory; ///; /// Note this function is called in place when the semantic requires; /// this object to be added to a directory (I.e. when being read from; /// a TKey or being Cloned)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:86,Perform,Perform,86,hist/hist/src/TGraph2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the automatic addition of the histogram to the given directory; ///; /// Note this function is called in place when the semantic requires; /// this object to be added to a directory (I.e. when being read from; /// a TKey or being Cloned)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Perform,Perform,86,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the back-transformation from the principal components; /// pc, and return x; /// It's the users responsibility to make sure that both x and pc are; /// of the right size (i.e., memory must be allocated for p)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariablePCATransform.cxx:86,Perform,Perform,86,tmva/tmva/src/VariablePCATransform.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariablePCATransform.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the fit and evaluate the parameters; /// Returns 0 if the fit is ok, 1 if there are errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx:86,Perform,Perform,86,math/minuit/src/TLinearFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TLinearFitter.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the fit with the default UP value.; /// The value returned is the minimisation status.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:86,Perform,Perform,86,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the integration and return the result",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:86,Perform,Perform,86,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the principal components analysis.; /// This is done in several stages in the TMatrix::EigenVectors method:; /// - Transform the covariance matrix into a tridiagonal matrix.; /// - Find the eigenvalues and vectors of the tridiagonal matrix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx:86,Perform,Perform,86,hist/hist/src/TPrincipal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TPrincipal.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the projection operation required by Gondzio algorithm: replace each; /// component r3_i of the complementarity component of the residuals by r3p_i-r3_i,; /// where r3p_i is the projection of r3_i onto the box [rmin, rmax]. Then if the; /// resulting value is less than -rmax, replace it by -rmax.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpResidual.cxx:86,Perform,Perform,86,math/quadp/src/TQpResidual.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpResidual.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the string rendering in the pad.; /// LayoutGlyphs should have been called before.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:86,Perform,Perform,86,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,2,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform the unfolding with regularisation parameter kreg",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:86,Perform,Perform,86,hist/hist/src/TSVDUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Perform v1 * M * v2, a scalar result",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TVectorT.cxx:86,Perform,Perform,86,math/matrix/src/TVectorT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TVectorT.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performance is not critical here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:86,Perform,Performance,86,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['Perform'],['Performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs a MINOS error analysis on one parameter; ///; /// The parameter ILAX is varied, and the minimum of the; /// function with respect to the other parameters is followed; /// until it crosses the value FMIN+UP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:86,Perform,Performs,86,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs a MINOS error analysis; ///; /// Performs a MINOS error analysis on those parameters for; /// which it is requested on the MINOS command by calling; /// MNMNOT for each parameter requested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:86,Perform,Performs,86,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,2,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs a local function minimization; ///; /// Performs a local function minimization using basically the; /// method of Davidon-Fletcher-Powell as modified by Fletcher; ///; /// ref. -- Fletcher, Comp.J. 13,317 (1970) ""switching method""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:86,Perform,Performs,86,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,2,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs a rough (but global) minimization by monte carlo search; ///; /// Each time a new minimum is found, the search area is shifted; /// to be centered at the best value. Random points are chosen; /// uniformly over a hypercube determined by current step sizes.; /// The Metropolis algorithm accepts a worse point with probability; /// exp(-d/UP), where d is the degradation. Improved points; /// are of course always accepted. Actual steps are random; /// multiples of the nominal steps (DIRIN).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:86,Perform,Performs,86,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs ray propagation between Z segments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPgon.cxx:86,Perform,Performs,86,geom/geom/src/TGeoPgon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPgon.cxx,2,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs redo action. Move cursor position forward in history stack",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQCommand.cxx:86,Perform,Performs,86,core/base/src/TQCommand.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQCommand.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*f1` .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:86,Perform,Performs,86,hist/hist/src/TProfile2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx,2,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*f1`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// By default, the function is computed at the centre of the bin.; /// if option ""I"" is specified (1-d histogram only), the integral of the; /// function in each bin is used instead of the value of the function at; /// the centre of the bin.; ///; /// Only bins inside the function range are recomputed.; ///; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// The function return kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Perform,Performs,86,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*h1` .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:86,Perform,Performs,86,hist/hist/src/TProfile2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx,2,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this + c1*h1`; /// If errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; /// if not already set.; ///; /// Note also that adding histogram with labels is not supported, histogram will be; /// added merging them by bin number independently of the labels.; /// For adding histogram with labels one should use TH1::Merge; ///; /// SPECIAL CASE (Average/Efficiency histograms); /// For histograms representing averages or efficiencies, one should compute the average; /// of the two histograms and not the sum. One can mark a histogram to be an average; /// histogram by setting its bit kIsAverage with; /// myhist.SetBit(TH1::kIsAverage);; /// Note that the two histograms must have their kIsAverage bit set; ///; /// IMPORTANT NOTE1: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Add; ///; /// IMPORTANT NOTE2: if h1 has a normalisation factor, the normalisation factor; /// is used , ie this = this + c1*factor*h1; /// Use the other TH1::Add function if you do not want this feature; ///; /// IMPORTANT NOTE3: You should be careful about the statistics of the; /// returned histogram, whose statistics may be binned or unbinned,; /// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; /// and whether TH1::ResetStats has been called on either this or h1.; /// See TH1::GetStats.; ///; /// The function return kFALSE if the Add operation failed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Perform,Performs,86,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this*c1*f1` .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:86,Perform,Performs,86,hist/hist/src/TProfile3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this/(c1*f1)` .; /// This function is not implemented",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:86,Perform,Performs,86,hist/hist/src/TProfile2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this/(c1*f1)` .; ///; /// This function is not implemented",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx:86,Perform,Performs,86,hist/hist/src/TProfile3D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile3D.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this/(c1*f1)`.; ///; /// This function is not implemented for the TProfile",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:86,Perform,Performs,86,hist/hist/src/TProfile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `this = this/(c1*f1)`; /// if errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Divide; ///; /// The function return kFALSE if the divide operation failed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Perform,Performs,86,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `y = y + c1*f(x,y)`; /// Errors are not recalculated.; ///; /// \param f may be a 1-D function TF1 or 2-d function TF2; /// \param c1 a scaling factor, 1 by default",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:86,Perform,Performs,86,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: `z = z + c1*f(x,y,z)`; /// Errors are not recalculated.; ///; /// \param f may be a 2-D function TF2 or 3-d function TF3; /// \param c1 a scaling factor, 1 by default",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:86,Perform,Performs,86,hist/hist/src/TGraph2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this + c1*f1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:86,Perform,Performs,86,hist/hist/src/TProfile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this + c1*h1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:86,Perform,Performs,86,hist/hist/src/TProfile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this + c1*h1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:86,Perform,Performs,86,hist/hist/src/TH2Poly.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this*c*f1; /// if errors are defined, errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after; /// calling Multiply()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx:86,Perform,Performs,86,hist/hist/src/THnBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THnBase.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this*c1*f1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx:86,Perform,Performs,86,hist/hist/src/TProfile2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile2D.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation: this = this*c1*f1; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx:86,Perform,Performs,86,hist/hist/src/TProfile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TProfile.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the operation:; ///; /// `this = this*c1*f1`; ///; /// If errors are defined (see TH1::Sumw2), errors are also recalculated.; ///; /// Only bins inside the function range are recomputed.; /// IMPORTANT NOTE: If you intend to use the errors of this histogram later; /// you should call Sumw2 before making this operation.; /// This is particularly important if you fit the histogram after TH1::Multiply; ///; /// The function return kFALSE if the Multiply operation failed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:86,Perform,Performs,86,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs the same function as StepBound, and supplies additional information about; /// which component of the nonnegative variables is responsible for restricting alpha.; /// In terms of the abstract formulation, the components have the following meanings :; ///; /// primalValue : the value of the blocking component of the primal variables (u,t,v,w).; /// primalStep : the corresponding value of the blocking component of the primal step; /// variables (b->u,b->t,b->v,b->w); /// dualValue : the value of the blocking component of the dual variables/; /// (lambda,pi,phi,gamma).; /// dualStep : the corresponding value of the blocking component of the dual step; /// variables (b->lambda,b->pi,b->phi,b->gamma); /// firstOrSecond : 1 if the primal step is blocking,; /// 2 if the dual step is block,; /// 0 if no step is blocking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpVar.cxx:86,Perform,Performs,86,math/quadp/src/TQpVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpVar.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Performs undo action. Move cursor position backward in history stack",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQCommand.cxx:86,Perform,Performs,86,core/base/src/TQCommand.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQCommand.cxx,1,['Perform'],['Performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Place new payload object in cache element with given unique ID. Cache; /// will take ownership of provided object!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx:114,cache,cache,114,roofit/roofitcore/src/RooExpensiveObjectCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Plot (project) PDF on specified frame. If a PDF is plotted in an empty frame, it; /// will show a unit normalized curve in the frame variable, taken at the present value; /// of other observables defined for this PDF.; ///; /// \param[in] frame pointer to RooPlot; /// \param[in] arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10 Ordered arguments; ///; /// If a PDF is plotted in a frame in which a dataset has already been plotted, it will; /// show a projected curve integrated over all variables that were present in the shown; /// dataset except for the one on the x-axis. The normalization of the curve will also; /// be adjusted to the event count of the plotted dataset. An informational message; /// will be printed for each projection step that is performed.; ///; /// This function takes the following named arguments; /// <table>; /// <tr><th><th> Projection control; /// <tr><td> `Slice(const RooArgSet& set)` <td> Override default projection behaviour by omitting observables listed; /// in set from the projection, i.e. by not integrating over these.; /// Slicing is usually only sensible in discrete observables, by e.g. creating a slice; /// of the PDF at the current value of the category observable.; ///; /// <tr><td> `Slice(RooCategory& cat, const char* label)` <td> Override default projection behaviour by omitting the specified category; /// observable from the projection, i.e., by not integrating over all states of this category.; /// The slice is positioned at the given label value. To pass multiple Slice() commands, please use the; /// Slice(std::map<RooCategory*, std::string> const&) argument explained below.; ///; /// <tr><td> `Slice(std::map<RooCategory*, std::string> const&)` <td> Omits multiple categories from the projection, as explianed above.; /// Can be used with initializer lists for convenience, e.g.; /// ```{.cpp}; /// pdf.plotOn(frame, Slice({{&tagCategory, ""2tag""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:845,perform,performed,845,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Plot (project) PDF on specified frame.; /// - If a PDF is plotted in an empty frame, it; /// will show a unit-normalized curve in the frame variable. When projecting a multi-; /// dimensional PDF onto the frame axis, hidden parameters are taken are taken at; /// their current value.; /// - If a PDF is plotted in a frame in which a dataset has already been plotted, it will; /// show a projection integrated over all variables that were present in the shown; /// dataset (except for the one on the x-axis). The normalization of the curve will; /// be adjusted to the event count of the plotted dataset. An informational message; /// will be printed for each projection step that is performed.; /// - If a PDF is plotted in a frame showing a dataset *after* a fit, the above happens,; /// but the PDF will be drawn and normalised only in the fit range. If this is not desired,; /// plotting and normalisation range can be overridden using Range() and NormRange() as; /// documented in the table below.; ///; /// This function takes the following named arguments (for more arguments, see also; /// RooAbsReal::plotOn(RooPlot*,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; /// const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,; /// const RooCmdArg&) const ); ///; ///; /// <table>; /// <tr><th> Type of argument <th> Controlling normalisation; /// <tr><td> `NormRange(const char* name)` <td> Calculate curve normalization w.r.t. specified range[s].; /// See the tutorial rf212_plottingInRanges_blinding.C; /// \note Setting a Range() by default also sets a NormRange() on the same range, meaning that the; /// PDF is plotted and normalised in the same range. Overriding this can be useful if the PDF was fit; /// in limited range[s] such as side bands, `NormRange(""sidebandLeft,sidebandRight"")`, but the PDF; /// should be drawn in the full range, `Range(""""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:769,perform,performed,769,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Plots the PDF as a histogram and saves it to a file, so that it can be loaded in; /// as a Roo2DHist PDF in the future to save on calculation time.; /// \param[in] outputFile Name of the file where to store the PDF; /// \param[in] histName PDF histogram name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/Roo2DKeysPdf.cxx:157,load,loaded,157,roofit/roofit/src/Roo2DKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/Roo2DKeysPdf.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Pop and Return the 'current' data cache area from the list of area to be used for; /// temporarily store 'missing' data members.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx:120,cache,cache,120,core/base/src/TBuffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Prepare dataset for use with cached constant terms listed in; /// 'cacheList' of expression 'arg'. Deactivate tree branches; /// for any dataset observable that is either not used at all,; /// or is used exclusively by cached branch nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:115,cache,cached,115,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,3,['cache'],"['cacheList', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Print cache statistics. Like:; ///; /// ~~~ {.cpp}; /// ******TreeCache statistics for file: cms2.root ******; /// Number of branches in the cache ...: 1093; /// Cache Efficiency ..................: 0.997372; /// Cache Efficiency Rel...............: 1.000000; /// Learn entries......................: 100; /// Reading............................: 72761843 bytes in 7 transactions; /// Readahead..........................: 256000 bytes with overhead = 0 bytes; /// Average transaction................: 10394.549000 Kbytes; /// Number of blocks in current cache..: 210, total size: 6280352; /// ~~~; ///; /// - if option = ""a"" the list of blocks in the cache is printed; /// see also class TTreePerfStats.; /// - if option contains 'cachedbranches', the list of branches being; /// cached is printed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:92,cache,cache,92,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,8,"['Cache', 'cache']","['Cache', 'cache', 'cached', 'cachedbranches']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Print cache statistics.; ///; /// The format is:; /// ******TreeCache statistics for file: cms2.root ******; /// Reading............................: 72761843 bytes in 7 transactions; /// Readahead..........................: 256000 bytes with overhead = 0 bytes; /// Average transaction................: 10394.549000 Kbytes; /// Number of blocks in current cache..: 210, total size: 6280352; ///; /// If option = ""a"" the list of blocks in the cache is printed; /// NB: this function is automatically called by TTreeCache::Print",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:92,cache,cache,92,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Print contents of cache when printing self as part of object tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:104,cache,cache,104,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Print information about the optimization process and monitor the convergence; /// status of thye algorithm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx:114,optimiz,optimization,114,math/quadp/src/TGondzioSolver.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx,2,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Print statistics about the TreeCache for this tree.; /// Like:; /// ~~~ {.cpp}; /// ******TreeCache statistics for file: cms2.root ******; /// Reading 73921562 bytes in 716 transactions; /// Average transaction = 103.242405 Kbytes; /// Number of blocks in current cache: 202, total size : 6001193; /// ~~~; /// if option = ""a"" the list of blocks in the cache is printed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:350,cache,cache,350,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Print the information we have about which basket is currently cached and; /// whether they have been 'used'/'read' from the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:148,cache,cached,148,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,2,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Prints formatted information about the dataset 'uri'.; /// The type and format of output is driven by 'opt':; ///; /// 1. opt = ""server:srv1[,srv2[,srv3[,...]]]""; /// Print info about the subsets of 'uri' on servers srv1, srv2, ...; /// 2. opt = ""servers[:exclude:srv1[,srv2[,srv3[,...]]]]""; /// Print info about the subsets of 'uri' on all servers, except; /// the ones in the exclude list srv1, srv2, ...; /// 3. opt = `<any>`; /// Print info about all datasets matching 'uri'; ///; /// If 'opt' contains 'full:' the list of files in the datasets are also printed.; /// In case 3. this is enabled only if 'uri' matches a single dataset.; ///; /// In case 3, if 'opt' contains; /// 'full:' the list of files in the datasets are also printed.; /// 'forcescan:' the dataset are open to get the information; otherwise the; /// pre-processed information is used.; /// 'noheader:' the labelling header is not printed; usefull when to chain; /// several printouts; /// 'noupdate:' do not update the cache (which may be slow on very remote; /// servers); /// 'refresh:' refresh the information (requires appropriate credentials;; /// typically it can be done only for owned datasets)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx:1080,cache,cache,1080,proof/proof/src/TDataSetManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Probably, TPadPainter must be placed in a separate ROOT module -; /// ""padpainter"" (the same as ""histpainter""). But now, it's directly in a; /// gpad dir, so, in case of default painter, no *.so should be loaded,; /// no need in plugin managers.; /// May change in future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx:291,load,loaded,291,graf2d/gpad/src/TCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Process single http request; ///; /// Depending from requested path and filename different actions will be performed.; /// In most cases information is provided by TRootSniffer class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx:193,perform,performed,193,net/http/src/THttpServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Process this tree executing the TSelector code in the specified filename.; /// The return value is -1 in case of error and TSelector::GetStatus() in; /// in case of success.; ///; /// The code in filename is loaded (interpreted or compiled, see below),; /// filename must contain a valid class implementation derived from TSelector,; /// where TSelector has the following member functions:; ///; /// - Begin(): called every time a loop on the tree starts,; /// a convenient place to create your histograms.; /// - SlaveBegin(): called after Begin(), when on PROOF called only on the; /// slave servers.; /// - Process(): called for each event, in this function you decide what; /// to read and fill your histograms.; /// - SlaveTerminate: called at the end of the loop on the tree, when on PROOF; /// called only on the slave servers.; /// - Terminate(): called at the end of the loop on the tree,; /// a convenient place to draw/fit your histograms.; ///; /// If filename is of the form file.C, the file will be interpreted.; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded.; ///; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// ### NOTE 1; /// It may be more interesting to invoke directly the other Process function; /// accepting a TSelector* as argument.eg; /// ~~~{.cpp}; /// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; /// selector->CallSomeFunction(..);; /// mytree.Process(selector,..);; /// ~~~; /// ### NOTE 2; /// One should not call this function twice with the same selector file; /// in the same script. If this is required, proceed as indicated in NOTE1,; /// by getting a pointer to the corresponding TSelector,eg; ///#### workaround 1; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:294,load,loaded,294,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Process this tree executing the TSelector code in the specified filename.; /// The return value is -1 in case of error and TSelector::GetStatus() in; /// in case of success.; ///; /// The code in filename is loaded (interpreted or compiled, see below),; /// filename must contain a valid class implementation derived from TSelector,; /// where TSelector has the following member functions:; ///; /// - `Begin()`: called every time a loop on the tree starts,; /// a convenient place to create your histograms.; /// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; /// slave servers.; /// - `Process()`: called for each event, in this function you decide what; /// to read and fill your histograms.; /// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; /// called only on the slave servers.; /// - `Terminate()`: called at the end of the loop on the tree,; /// a convenient place to draw/fit your histograms.; ///; /// If filename is of the form file.C, the file will be interpreted.; ///; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded.; ///; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// ## NOTE1; ///; /// It may be more interesting to invoke directly the other Process function; /// accepting a TSelector* as argument.eg; /// ~~~ {.cpp}; /// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; /// selector->CallSomeFunction(..);; /// mytree.Process(selector,..);; /// ~~~; /// ## NOTE2; //; /// One should not call this function twice with the same selector file; /// in the same script. If this is required, proceed as indicated in NOTE1,; /// by getting a pointer to the corresponding TSelector,eg; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:294,load,loaded,294,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Protected function to perform the merge operation of a graph with asymmetric errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:108,perform,perform,108,hist/hist/src/TGraphAsymmErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx,2,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Protected function to perform the merge operation of a graph with errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:108,perform,perform,108,hist/hist/src/TGraphErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Protected function to perform the merge operation of a graph with multiple asymmetric errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx:108,perform,perform,108,hist/hist/src/TGraphMultiErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphMultiErrors.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Provides default action which can be performed with the object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/src/TObjectElement.cxx:123,perform,performed,123,gui/browsable/src/TObjectElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/src/TObjectElement.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Provides the most common way for accessing a font: opens (loads) the; /// specified font and returns a pointer to the appropriate FontStruct_t; /// structure. If the font does not exist, it returns NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx:144,load,loads,144,core/base/src/TVirtualX.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx,1,['load'],['loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Purge all entries for all LODs for this drawable from the; /// display list cache, returning the reserved ids to GL context.; ///; /// If you override this function:; /// 1. call the base-class version from it;; /// 2. call it from the destructor of the derived class!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:162,cache,cache,162,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Push a new data cache area onto the list of area to be used for; /// temporarily store 'missing' data members.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx:102,cache,cache,102,core/base/src/TBuffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Query cache for a match with this font/text/angle/alignment; /// request, otherwise arrange for its creation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx:92,cache,cache,92,graf2d/x11/src/Rotated.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/Rotated.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read a Double32_t from the buffer when the factor and minimun value have; /// been specified; /// see comments about Double32_t encoding at TBufferFile::WriteDouble32().; /// Currently TBufferText does not optimize space in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferText.cxx:292,optimiz,optimize,292,io/io/src/TBufferText.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferText.cxx,2,['optimiz'],['optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read a Double32_t from the buffer when the number of bits is specified; /// (explicitly or not); /// see comments about Double32_t encoding at TBufferFile::WriteDouble32().; /// Currently TBufferText does not optimize space in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferText.cxx:295,optimiz,optimize,295,io/io/src/TBufferText.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferText.cxx,1,['optimiz'],['optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read a Float16_t from the buffer when the number of bits is specified; /// (explicitly or not); /// see comments about Float16_t encoding at TBufferFile::WriteFloat16().; /// Currently TBufferText does not optimize space in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferText.cxx:292,optimiz,optimize,292,io/io/src/TBufferText.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferText.cxx,1,['optimiz'],['optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read a TClonesArray from the TBuffer b and load it into a (stl) collection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TContainerConverters.cxx:129,load,load,129,io/io/src/TContainerConverters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TContainerConverters.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read a buffer from the file at the offset 'pos' in the file.; ///; /// Returns kTRUE in case of failure.; /// Compared to ReadBuffer(char*, Int_t), this routine does _not_; /// change the cursor on the physical file representation (fD); /// if the data is in this TFile's cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:358,cache,cache,358,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read a class.rules file which contains one rule per line with comment; /// starting with a #; /// - Returns the number of rules loaded.; /// - Returns -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:214,load,loaded,214,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read a std::map or std::multimap from the TBuffer b and load it into a (stl) collection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TContainerConverters.cxx:142,load,load,142,io/io/src/TContainerConverters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TContainerConverters.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read all leaves of entry and return total number of bytes read.; ///; /// The input argument ""entry"" is the entry number in the current tree.; /// In case of a TChain, the entry number in the current Tree must be found; /// before calling this function. For example:; ///; ///~~~ {.cpp}; /// TChain* chain = ...;; /// Long64_t localEntry = chain->LoadTree(entry);; /// branch->GetEntry(localEntry);; ///~~~; ///; /// The function returns the number of bytes read from the input buffer.; /// If entry does not exist, the function returns 0.; /// If an I/O error occurs, the function returns -1.; ///; /// See IMPORTANT REMARKS in TTree::GetEntry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:433,Load,LoadTree,433,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['Load'],['LoadTree']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read basket buffers in memory and cleanup.; ///; /// Read a basket buffer. Check if buffers of previous ReadBasket; /// should not be dropped. Remember, we keep buffers in memory up to; /// fMaxVirtualSize.; /// The function returns 0 in case of success, 1 in case of error; /// This function was modified with the addition of the parallel; /// unzipping, it will try to get the unzipped file from the cache; /// receiving only a pointer to that buffer (so we shall not; /// delete that pointer), although we get a new buffer in case; /// it's not found in the cache.; /// There is a lot of code duplication but it was necessary to assure; /// the expected behavior when there is no cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:488,cache,cache,488,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read buffer at position pos if the request is in the list of; /// prefetched blocks read from fBuffer.; /// Otherwise try to fill the cache from the list of selected branches,; /// and recheck if pos is now in the list.; /// Returns:; /// - -1 in case of read failure,; /// - 0 in case not in cache,; /// - 1 in case read from cache.; /// This function overloads TFileCacheRead::ReadBuffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:220,cache,cache,220,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read buffer at position pos.; ///; /// If pos is in the list of prefetched blocks read from fBuffer,; /// otherwise need to make a normal read from file. Returns -1 in case of; /// read error, 0 in case not in cache, 1 in case read from cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:296,cache,cache,296,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read buffer via cache.; ///; /// Returns 0 if the requested block is not in the cache, 1 in case read via; /// cache was successful, 2 in case read via cache failed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:102,cache,cache,102,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,4,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read in memory all baskets from all branches up to the limit of maxmemory bytes.; ///; /// If maxmemory is non null and positive SetMaxVirtualSize is called; /// with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; /// The function returns the total number of baskets read into memory; /// if negative an error occurred while loading the branches.; /// This method may be called to force branch baskets in memory; /// when random access to branch entries is required.; /// If random access to only a few branches is required, you should; /// call directly TBranch::LoadBaskets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:428,load,loading,428,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,"['Load', 'load']","['LoadBaskets', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Read specified image file.; /// The file type is determined by the file extension (the type argument is; /// ignored). It will attempt to append .gz and then .Z to the filename and; /// find such a file. If the filename ends with extension consisting of digits; /// only, it will attempt to find the file with this extension stripped; /// off. On success this extension will be used to load subimage from; /// the file with that number. Subimage is supported for GIF files; /// (ICO, BMP, CUR, TIFF, XCF to be supported in future).; /// For example,; /// ~~~ {.cpp}; /// i1 = TImage::Open(""anim.gif.0""); // read the first subimage; /// i4 = TImage::Open(""anim.gif.3""); // read the forth subimage; /// ~~~; /// It is also possible to put XPM raw string (see also SetImageBuffer) as; /// the first input parameter (""filename""), such string is returned by; /// GetImageBuffer method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx:472,load,load,472,graf2d/asimage/src/TASImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Reads a foam with name 'foamname' from file, and returns a clone; /// of the foam. The given ROOT file must be open. (The ROOT file; /// will not be closed in this function.); ///; /// Parameters:; ///; /// - file - an open ROOT file; ///; /// - foamname - name of foam to load from the file; ///; /// Returns:; ///; /// If a foam with name 'foamname' exists in the file, then it is; /// read from the file, cloned and returned. If a foam with name; /// 'foamname' does not exist in the file or the clone operation; /// does not succeed, then NULL is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx:359,load,load,359,tmva/tmva/src/MethodPDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Recursively import children elements of el and apply projection; /// to the newly imported objects.; ///; /// The proj_parent argument should be a projected replica of; /// element 'el'. This allows to insert projected children of; /// a given element when they are added after the projection has; /// been already performed on the parent.; /// This is called from REveElement::ProjectChild().; ///; /// Returns the projected replica of el. Can be 0, if el and none of; /// its children are projectable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveProjectionManager.cxx:401,perform,performed,401,graf3d/eve7/src/REveProjectionManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveProjectionManager.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Recursively import children elements of el and apply projection; /// to the newly imported objects.; ///; /// The proj_parent argument should be a projected replica of; /// element 'el'. This allows to insert projected children of; /// a given element when they are added after the projection has; /// been already performed on the parent.; /// This is called from TEveElement::ProjectChild().; ///; /// Returns the projected replica of el. Can be 0, if el and none of; /// its children are projectable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveProjectionManager.cxx:401,perform,performed,401,graf3d/eve/src/TEveProjectionManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveProjectionManager.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Recursively import elements and apply projection to the newly; /// imported objects.; ///; /// If ext_list is not 0 the new element is also added to the list.; /// This simplifies construction of complex views where projected; /// elements are distributed into several scenes for optimization of; /// updates and rendering.; ///; /// Returns the projected replica of el. Can be 0, if el and none of; /// its children are projectable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveProjectionManager.cxx:366,optimiz,optimization,366,graf3d/eve/src/TEveProjectionManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveProjectionManager.cxx,2,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Recursively import elements and apply projection to the newly; /// imported objects.; ///; /// The proj_parent argument should be a projected replica of parent; /// of element 'el'. This allows to insert projected children of; /// a given element when they are added after the projection has; /// been already performed on the parent.; /// This is called from REveElement::ProjectChild().; ///; /// Returns the projected replica of el. Can be 0, if el and none of; /// its children are projectable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveProjectionManager.cxx:396,perform,performed,396,graf3d/eve7/src/REveProjectionManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveProjectionManager.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Recursively import elements and apply projection to the newly; /// imported objects.; ///; /// The proj_parent argument should be a projected replica of parent; /// of element 'el'. This allows to insert projected children of; /// a given element when they are added after the projection has; /// been already performed on the parent.; /// This is called from TEveElement::ProjectChild().; ///; /// Returns the projected replica of el. Can be 0, if el and none of; /// its children are projectable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveProjectionManager.cxx:396,perform,performed,396,graf3d/eve/src/TEveProjectionManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveProjectionManager.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Redraw all windows that need redrawing. Returns kFALSE if no redraw; /// was needed, kTRUE otherwise.; /// Only redraw the application's windows when the event queue; /// does not contain expose event anymore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGClient.cxx:246,queue,queue,246,gui/gui/src/TGClient.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGClient.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Register Rdict data for future loading by LoadPCM;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:117,load,loading,117,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,"['Load', 'load']","['LoadPCM', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Register RooAbsCache with this object. This function is called; /// by RooAbsCache constructors for objects that are a datamember; /// of this RooAbsArg. By registering itself the RooAbsArg is aware; /// of all its cache data members and will forward server change; /// and cache mode change calls to the cache objects, which in turn; /// can forward them their contents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:301,cache,cache,301,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Register WS handler to the THttpServer; ///; /// Only such handler can be used in multi-threaded processing of websockets",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx:168,multi-thread,multi-threaded,168,net/http/src/THttpServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx,1,['multi-thread'],['multi-threaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Register an RooArgProxy in the proxy list. This function is called by owned; /// proxies upon creation. After registration, this arg will forward pointer; /// changes from serverRedirects and updates in cached normalization sets; /// to the proxies immediately after they occur. The proxied argument is; /// also added as value and/or shape server",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:289,cache,cached,289,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Register an RooListProxy in the proxy list. This function is called by owned; /// proxies upon creation. After registration, this arg will forward pointer; /// changes from serverRedirects and updates in cached normalization sets; /// to the proxies immediately after they occur.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:290,cache,cached,290,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Register an RooSetProxy in the proxy list. This function is called by owned; /// proxies upon creation. After registration, this arg will forward pointer; /// changes from serverRedirects and updates in cached normalization sets; /// to the proxies immediately after they occur.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:289,cache,cached,289,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Register classes that already existed prior to their dictionary loading; /// and that already had a ClassInfo (and thus would not be refresh via; /// UpdateClassInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:150,load,loading,150,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Register object associated with given name and given associated parameters with given values in cache.; /// The cache will take _ownership_of_object_ and is indexed under the given name (which does not; /// need to be the name of cacheObject and with given set of dependent parameters with validity for the; /// current values of those parameters. It can be retrieved later by callin retrieveObject()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx:182,cache,cache,182,roofit/roofitcore/src/RooExpensiveObjectCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx,3,['cache'],"['cache', 'cacheObject']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Register query log using the information in the list which is in the form; /// TParameter(<par>,<value>) or TNamed(<name>,<string>). For bulk sending,; /// the first entry in the list is an TObjString defining the variable names; /// in the format; /// VARname1,VARname2,...; /// while the other entries are TObjStrings with the multiplets to be sent; /// VARvalue1,VARvalue2,...; ///; /// The string 'opt' allows the following additional control:; /// table=`[<db>.]<table>` allows to insert to a different table from the; /// one defined at construction (change is not; /// persistent); if `<db>` is not specified, the same; /// db defined at cinstruction is used.; /// bulk Do a bulk insert; /// More options can be given concurrently, comma-separated .; /// The specified table must already have been created in the DB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSQLMonitoring.cxx:811,concurren,concurrently,811,net/net/src/TSQLMonitoring.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSQLMonitoring.cxx,1,['concurren'],['concurrently']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Rehash the hashlist. If the collision rate becomes too high (i.e.; /// the average size of the linked lists become too long) then lookup; /// efficiency decreases since relatively long lists have to be searched; /// every time. To improve performance rehash the hashtable. This resizes; /// the table to newCapacity slots and refills the table. Use; /// AverageCollisions() to check if you need to rehash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx:325,perform,performance,325,core/cont/src/THashList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Rehash the hashtable. If the collision rate becomes too high (i.e.; /// the average size of the linked lists become too long) then lookup; /// efficiency decreases since relatively long lists have to be searched; /// every time. To improve performance rehash the hashtable. This resizes; /// the table to newCapacity slots and refills the table. Use; /// AverageCollisions() to check if you need to rehash. Set checkObjValidity; /// to kFALSE if you know that all objects in the table are still valid; /// (i.e. have not been deleted from the system in the meanwhile).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashTable.cxx:326,perform,performance,326,core/cont/src/THashTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashTable.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Relative efficiency of the 'miss cache' - ratio of the reads found in cache; /// to the number of reads so far.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:119,cache,cache,119,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Release memory cache associated with the H1 files at 'h1src', if it; /// makes any sense, i.e. are local ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:101,cache,cache,101,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Release memory cache associated with the event files at 'eventsrc', if it; /// makes any sense, i.e. are local ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:101,cache,cache,101,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Release memory cache for dataset 'dset'; /// Return 0 on success, -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx:101,cache,cache,101,proof/proofbench/src/TProofBench.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Release the memory cache associated with file 'fn'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHandleDataSet.cxx:105,cache,cache,105,proof/proofbench/src/TSelHandleDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHandleDataSet.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Reload the library map entries coming from all the loaded shared libraries,; /// after first unloading the current ones.; /// In case of error -1 is returned, 0 otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:137,load,loaded,137,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove a branch to the list of branches to be stored in the cache; /// this function is called by TBranch::GetBasket.; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:146,cache,cache,146,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove a branch to the list of branches to be stored in the cache; /// this is to be used by user (thats why we pass the name of the branch).; /// It works in exactly the same way as TTree::SetBranchStatus so you; /// probably want to look over there for details about the use of bname; /// with regular expressions.; /// The branches are taken with respect to the Owner of this TTreeCache; /// (i.e. the original Tree); /// NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:146,cache,cache,146,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove all elements. This assumes removing of all elements can; /// be done more efficiently then looping over them and removing one; /// by one. This protected function performs the removal on the; /// level of REveElement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx:256,perform,performs,256,graf3d/eve7/src/REveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove all elements. This assumes removing of all elements can; /// be done more efficiently then looping over them and removing one; /// by one. This protected function performs the removal on the; /// level of TEveElement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx:256,perform,performs,256,graf3d/eve/src/TEveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove an object from the object table. If op is 0 or not in the table; /// don't complain. Currently only used by the TClonesArray dtor. Should not; /// be used anywhere else, except in places where ""special"" allocation and; /// de-allocation tricks are performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjectTable.cxx:341,perform,performed,341,core/cont/src/TObjectTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjectTable.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove entry \#entry; /// If the block has already been optimized and the entries; /// are stored as a list and not as bits, trying to remove a new entry; /// will make the block switch to bits representation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx:142,optimiz,optimized,142,tree/tree/src/TEntryListBlock.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListBlock.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove file from all file caches. If file is 0 or """" or ""*"", remove all; /// the files",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:112,cache,caches,112,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['cache'],['caches']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove files from all file caches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:113,cache,caches,113,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['cache'],['caches']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove picture from cache if nobody is using it anymore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGPicture.cxx:106,cache,cache,106,gui/gui/src/TGPicture.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGPicture.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove the branch b from the Tree cache.; /// if subbranches is true all the branches of the subbranches are; /// also removed from the cache.; ///; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:120,cache,cache,120,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove the branch with name 'bname' from the Tree cache.; /// If bname=""*"" all branches are removed from the cache.; /// if subbranches is true all the branches of the subbranches are; /// also removed from the cache.; ///; /// Returns:; /// - 0 branch dropped or not in cache; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:136,cache,cache,136,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,4,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Remove tree with values of cached observables; /// and clear list of cached observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:113,cache,cached,113,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,2,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Reset all the miss cache training.; ///; /// The contents of the miss cache will be emptied as well as the list of; /// branches used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:105,cache,cache,105,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Reset cache holding particle trajectory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrackPropagator.cxx:92,cache,cache,92,graf3d/eve/src/TEveTrackPropagator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrackPropagator.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Reset ps and populate it with points in propagation cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrackPropagator.cxx:138,cache,cache,138,graf3d/eve/src/TEveTrackPropagator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrackPropagator.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Reset the owner, triggering the owner to register this cache in its list of caches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCache.cxx:141,cache,cache,141,roofit/roofitcore/src/RooAbsCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCache.cxx,2,['cache'],"['cache', 'caches']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Restore a backed-up state without affecting the cache stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:134,cache,cache,134,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Retrieve cache corresponding to observables in nset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx:95,cache,cache,95,roofit/roofitcore/src/RooAbsCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Retrieve cache element for the computation of the PDF normalisation.; /// \param[in] nset Current normalisation set (integration over these variables yields 1).; /// \param[in] iset Integration set. Variables to be integrated over (if integrations are performed).; ///; /// If a cache element does not exist, create and fill it on the fly. The cache also contains; /// - Supplemental normalization terms (in case not all added p.d.f.s have the same observables); /// - Projection integrals to calculate transformed fraction coefficients when a frozen reference frame is provided; /// - Projection integrals for similar transformations when a frozen reference range is provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:95,cache,cache,95,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,4,"['cache', 'perform']","['cache', 'performed']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Retrieve cache element with for calculation of p.d.f value with normalization set nset and integrated over iset; /// in range 'rangeName'. If cache element does not exist, create and fill it on the fly. The cache contains; /// suplemental normalization terms (in case not all added p.d.f.s have the same observables), projection; /// integrals to calculated transformed fraction coefficients when a frozen reference frame is provided; /// and projection integrals for similar transformations when a frozen reference range is provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:95,cache,cache,95,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Retrieve cache object associated with given choice of observables. If cache object; /// does not exist, create and fill and register it on the fly. If recalculate=false; /// recalculation of cache contents of existing caches that are marked dirty due to; /// dependent parameter changes is suppressed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:95,cache,cache,95,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,4,['cache'],"['cache', 'caches']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Retrieve generator config from cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx:117,cache,cache,117,roofit/roofitcore/src/RooMultiVarGaussian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMultiVarGaussian.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Retrieve object from cache that was registered under given name with given parameters, _if_; /// current parameter values match those that were stored in the registry for this object.; /// The return object is owned by the cache instance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx:107,cache,cache,107,roofit/roofitcore/src/RooExpensiveObjectCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Retrieve payload object of cache element with given unique ID",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx:113,cache,cache,113,roofit/roofitcore/src/RooExpensiveObjectCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooExpensiveObjectCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return (after creating it if necessary) the TDataMember; /// describing the data member corresponding to the Decl 'id'.; /// The skipChecks flag controls the consistency checks performed inspecting; /// the AST. In some cases, we explicitly alter the datamembers in the; /// typesystem with respect to the AST and therefore we must not enforce; /// consistency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfDataMembers.cxx:263,perform,performed,263,core/meta/src/TListOfDataMembers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfDataMembers.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return (create an empty one if needed) the list of functions.; /// The major difference with GetListOfMethod is that this returns; /// the internal type of fMethod and thus can not be made public.; /// It also never 'loads' the content of the list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:303,load,loads,303,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['load'],['loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return Error on Integral of a parametric function between a and b; /// due to the parameter uncertainties and their covariance matrix from the fit.; /// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo->Fit(func, ""S"");; /// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect result is returned.; ///; /// IMPORTANT NOTE3:; ///; /// The user must pass a pointer to the elements of the full covariance matrix; /// dim",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:458,perform,performed,458,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return Error on Integral of a parametric function with dimension larger than one; /// between a[] and b[] due to the parameters uncertainties.; /// For a TF1 with dimension larger than 1 (for example a TF2 or TF3); /// TF1::IntegralMultiple is used for the integral calculation; ///; /// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; /// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; /// previously performed fit using the TFitResult class.; /// Note that to get the TFitResult, te fit should be done using the fit option `S`.; /// Example:; /// ~~~~{.cpp}; /// TFitResultPtr r = histo2d->Fit(func2, ""S"");; /// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; /// ~~~~; ///; /// IMPORTANT NOTE1:; ///; /// A null pointer to the parameter values vector and to the covariance matrix can be passed.; /// In this case, when the parameter values pointer is null, the parameter values stored in this; /// TF1 function object are used in the integral error computation.; /// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; /// from a global fitter instance when it exists. Note that the global fitter instance; /// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; /// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; /// returned.; ///; ///; /// IMPORTANT NOTE2:; ///; /// When no covariance matrix is passed and in the meantime a fit is done; /// using another function, the routine will signal an error and it will return zero only; /// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; /// In the case that npar is the same, an incorrect res",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:593,perform,performed,593,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return RooAbsArg components contained in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:131,cache,cache,131,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return RooAbsArg elements contained in projection cache element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx:136,cache,cache,136,roofit/roofitcore/src/RooProjectedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return a GC from the cache. As many as N_CACHE_GCs are kept valid; /// at any one time. They are replaced using an LRU algorithm.; ///; /// A value of FONT_Any (-1) for the font means ""don't care"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:107,cache,cache,107,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return a buffer from cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx:107,cache,cache,107,io/io/src/TFilePrefetch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return a fresh basket by either reusing an existing basket that needs; /// to be drop (according to TTree::MemoryFull) or create a new one.; ///; /// If the user_buffer argument is non-null, then the memory in the; /// user-provided buffer will be utilized by the underlying basket.; ///; /// The basket number is used to estimate the required buffer size; /// and try to optimize memory usage and number of memory allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:458,optimiz,optimize,458,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['optimiz'],['optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return a pointer to the current file.; /// If no file is connected, the first file is automatically loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:186,load,loaded,186,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return a pointer to the current read cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:123,cache,cache,123,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return a pointer to the current write cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:124,cache,cache,124,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return a pointer to the dictionary loading function generated by; /// rootcint",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:121,load,loading,121,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return a space separated list of loaded shared libraries.; /// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; /// This list is of a format suitable for a linker, i.e it may contain; /// -Lpathname and/or -lNameOfLib.; /// Option can be any of:; /// - S: shared libraries loaded at the start of the executable, because; /// they were specified on the link line.; /// - D: shared libraries dynamically loaded after the start of the program.; /// - L: this option is ignored, and available for backward compatibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:119,load,loaded,119,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,3,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return all RooAbsArg components contained in cache element",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:131,cache,cache,131,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return all RooAbsArg components contained in this cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:136,cache,cache,136,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return an object from the list of enums *if and only if* is has already; /// been loaded in the list. This is an internal routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfEnums.cxx:168,load,loaded,168,core/meta/src/TListOfEnums.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfEnums.cxx,2,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return analytical integral represent by appropriate element of projection cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx:160,cache,cache,160,roofit/roofitcore/src/RooProjectedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; /// model support internal generation return and optimization convolution generation context; /// that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; /// context on the convoluted shape.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvPdf.cxx:226,optimiz,optimization,226,roofit/roofitcore/src/RooNumConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumConvPdf.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return base name component for cache components in this case 'PDF1_CONV_PDF2'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:117,cache,cache,117,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return base name component for cache components in this case; /// a string encoding the names of both end point p.d.f.s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx:117,cache,cache,117,roofit/roofit/src/RooIntegralMorph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooIntegralMorph.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return current value, normalized by integrating over; /// the observables in `nset`. If `nset` is 0, the unnormalized value; /// is returned. All elements of `nset` must be lvalues.; ///; /// Unnormalized values are not cached.; /// Doing so would be complicated as `_norm->getVal()` could; /// spoil the cache and interfere with returning the cached; /// return value. Since unnormalized calls are typically; /// done in integration calls, there is no performance hit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:306,cache,cached,306,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,4,"['cache', 'perform']","['cache', 'cached', 'performance']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return entry number corresponding to entry.; ///; /// if no TEntryList set returns entry; /// else returns entry \#entry from this entry list and; /// also computes the global entry number (loads all tree headers)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:276,load,loads,276,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['load'],['loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return entry number corresponding to major and minor number.; /// Note that this function returns only the entry number, not the data; /// To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; /// the BuildIndex function has created a table of Double_t* of sorted values; /// corresponding to val = major<<31 + minor;; /// The function performs binary search in this sorted table.; /// If it finds a pair that maches val, it returns directly the; /// index in the table, otherwise it returns -1.; ///; /// See also GetEntryNumberWithBestIndex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx:449,perform,performs,449,tree/treeplayer/src/TTreeIndex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return entry number corresponding to major and minor number.; /// Note that this function returns only the entry number, not the data; /// To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; /// the BuildIndex function has created a table of Double_t* of sorted values; /// corresponding to val = major<<31 + minor;; /// The function performs binary search in this sorted table.; /// If it finds a pair that maches val, it returns directly the; /// index in the table.; /// If an entry corresponding to major and minor is not found, the function; /// returns the index of the major,minor pair immediately lower than the; /// requested value, ie it will return -1 if the pair is lower than; /// the first entry in the index.; ///; /// See also GetEntryNumberWithIndex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx:449,perform,performs,449,tree/treeplayer/src/TTreeIndex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return entry number corresponding to major and minor number.; /// Note that this function returns only the entry number, not the data; /// To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; /// the BuildIndex function has created a table of Long64_t* of sorted values; /// corresponding to val = major<<31 + minor;; /// The function performs binary search in this sorted table.; /// If it finds a pair that matches val, it returns directly the; /// index in the table, otherwise it returns -1.; ///; /// See also GetEntryNumberWithBestIndex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:449,perform,performs,449,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return entry number corresponding to major and minor number.; /// Note that this function returns only the entry number, not the data; /// To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; /// the BuildIndex function has created a table of Long64_t* of sorted values; /// corresponding to val = major<<31 + minor;; /// The function performs binary search in this sorted table.; /// If it finds a pair that matches val, it returns directly the; /// index in the table.; /// If an entry corresponding to major and minor is not found, the function; /// returns the index of the major,minor pair immediately lower than the; /// requested value, ie it will return -1 if the pair is lower than; /// the first entry in the index.; ///; /// See also GetEntryNumberWithIndex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:449,perform,performs,449,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return event weights of all events in range [first, first+len).; /// If cacheValidEntries() has been called, out-of-range events will have a weight of 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:158,cache,cacheValidEntries,158,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['cache'],['cacheValidEntries']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return generator context optimized for generating events from product p.d.f.s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:111,optimiz,optimized,111,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return kTRUE if the element represent an entity that is not written; /// to the disk (transient members, cache allocator/deallocator, etc.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx:191,cache,cache,191,core/meta/src/TStreamerElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return list containing the TFunctions currently defined.; /// Since functions are created and deleted during execution of the; /// program, we need to update the list of functions every time we; /// execute this method. However, when calling this function in; /// a (tight) loop where no interpreter symbols will be created; /// you can set load=kFALSE (default).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:427,load,load,427,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return list containing the TGlobals currently defined.; /// Since globals are created and deleted during execution of the; /// program, we need to update the list of globals every time we; /// execute this method. However, when calling this function in; /// a (tight) loop where no interpreter symbols will be created; /// you can set load=kFALSE (default).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:421,load,load,421,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return list containing the TMethods of a class.; /// If load is true, the list is populated with all the defined function; /// and currently instantiated function template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:142,load,load,142,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return list of (partial) integrals whose product defines the integral of this; /// RooProduct over the observables in iset in range isetRange. If no such list; /// exists, create it now and store it in the cache for future use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:292,cache,cache,292,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return list of all RooAbsArgs in cache element",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:119,cache,cache,119,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return minimum dimensions of numeric integration for which values are cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:156,cache,cached,156,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return minimum/maximum value of the function; ///; /// To find the minimum on a range, first set this range via the SetRange function.; /// If a vector x of coordinate is passed it will be used as starting point for the minimum.; /// In addition on exit x will contain the coordinate values at the minimuma; ///; /// If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the; /// minimum location. The range of the function is divided into fNpx and fNpy; /// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; /// by SetNpx and SetNpy functions; ///; /// Then, a minimization is used with starting values found by the grid search; /// The minimizer algorithm used (by default Minuit) can be changed by callinga; /// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); /// Other option for the minimizer can be set using the static method of the MinimizerOptions class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:465,perform,performed,465,hist/hist/src/TF2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return minimum/maximum value of the function; ///; /// To find the minimum on a range, first set this range via the SetRange function; /// If a vector x of coordinate is passed it will be used as starting point for the minimum.; /// In addition on exit x will contain the coordinate values at the minimuma; /// If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the; /// minimum location. The range of the function is divided into fNpx and fNpy; /// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; /// by SetNpx and SetNpy functions; /// Then, a minimization is used with starting values found by the grid search; /// The minimizer algorithm used (by default Minuit) can be changed by callinga; /// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); /// Other option for the minimizer can be set using the static method of the MinimizerOptions class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx:459,perform,performed,459,hist/hist/src/TF2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF2.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return minimum/maximum value of the function; ///; /// To find the minimum on a range, first set this range via the SetRange function; /// If a vector x of coordinate is passed it will be used as starting point for the minimum.; /// In addition on exit x will contain the coordinate values at the minimuma; /// If x is NULL or x is inifinity or NaN, first, a grid search is performed to find the initial estimate of the; /// minimum location. The range of the function is divided into fNpx and fNpy; /// sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; /// by SetNpx and SetNpy functions; ///; /// Then, a minimization is used with starting values found by the grid search; /// The minimizer algorithm used (by default Minuit) can be changed by callinga; /// ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); /// Other option for the minimizer can be set using the static method of the MinimizerOptions class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx:460,perform,performed,460,hist/hist/src/TF3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF3.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return number of registered caches",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:114,cache,caches,114,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['cache'],['caches']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return observable in nset to be cached by RooAbsCachedPdf; /// this is always the x observable that is integrated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:118,cache,cached,118,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return pointer to RooDataHist cache histogram for given choice of observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:116,cache,cache,116,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return pointer to RooHistPdf cache pdf for given choice of observables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:115,cache,cache,115,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return pointer to global function by name. If proto != 0; /// it will also resolve overloading. If load is true force reading; /// of all currently defined global functions from CINT (more expensive).; /// The proto string must be of the form: ""int, char*, float"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:185,load,load,185,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return pointer to global function by name.; /// If params != 0 it will also resolve overloading other it returns the first; /// name match.; /// If params == 0 and load is true force reading of all currently defined; /// global functions from Cling.; /// The param string must be of the form: ""3189,\""aap\"",1.3"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:250,load,load,250,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return pointer to global variable by name. If load is true force; /// reading of all currently defined globals from CINT (more expensive).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:132,load,load,132,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return pointer to method without looking at parameters.; /// Does not look in (possible) base classes.; /// Has the side effect of loading all the TMethod object in the list; /// of the class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:217,load,loading,217,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return pointer to object identified by namecycle if and only if the actual; /// object is a type suitable to be stored as a pointer to a ""expectedClass""; /// If expectedClass is null, no check is performed.; ///; /// - namecycle has the format name;cycle; /// - name = * is illegal, cycle = * is illegal; /// - cycle = """" or cycle = 9999 ==> apply to a memory object; ///; /// ### Very important note; /// The calling application must cast the returned pointer to; /// the type described by the 2 arguments (i.e. cl):; ///; /// auto objPtr = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; ///; /// Note: We recommend using the method TDirectoryFile::Get<T>:; /// ~~~{.cpp}; /// auto objPtr = directory->Get<MyClass>(""some object inheriting from MyClass"");; /// if (objPtr) { ... we found what we are looking for ... }; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx:282,perform,performed,282,io/io/src/TDirectoryFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return pointer to object identified by namecycle if and only if the actual; /// object is a type suitable to be stored as a pointer to a ""expectedClass""; /// If expectedClass is null, no check is performed.; ///; /// namecycle has the format `name;cycle`; /// - name = * is illegal, cycle = * is illegal; /// - cycle = """" or cycle = 9999 ==> apply to a memory object; ///; /// VERY IMPORTANT NOTE:; ///; /// The calling application must cast the returned pointer to; /// the type described by the 2 arguments (i.e. cl):; /// ~~~ {.cpp}; /// MyClass *obj = (MyClass*)directory->GetObjectChecked(""some object of MyClass"",""MyClass""));; /// ~~~; /// Note: We recommend using the method TDirectory::GetObject:; /// ~~~ {.cpp}; /// MyClass *obj = nullptr;; /// directory->GetObject(""some object inheriting from MyClass"",obj);; /// if (obj) { ... we found what we are looking for ... }; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx:282,perform,performed,282,core/base/src/TDirectory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return proper archive file handler depending on passed url.; ///; /// The handler is loaded via the plugin manager and is triggered by; /// the extension of the archive file. In case no handler is found 0; /// is returned. The file argument is used to access the archive.; /// The archive should be specified as url with the member name as the; /// anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; /// where tpc.root is the file in the archive to be opened.; /// Alternatively the sub-file can be specified via its index number,; /// e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; /// This function is normally only called via TFile::Open().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TArchiveFile.cxx:171,load,loaded,171,io/io/src/TArchiveFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TArchiveFile.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return reference to VarInfo struct with cached histogram variable; /// information that is frequently used for histogram weights retrieval.; ///; /// If the `_varInfo` struct was not initialized yet, it will be initialized in; /// this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:126,cache,cached,126,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return registered cache object by index",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:104,cache,cache,104,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return specialized cache subclass for FFT calculations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:105,cache,cache,105,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the 'current' data cache area from the list of area to be used for; /// temporarily store 'missing' data members.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx:112,cache,cache,112,core/base/src/TBuffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the Figure of Merit (FOM) used in the parameter; /// optimization process",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/OptimizeConfigParameters.cxx:146,optimiz,optimization,146,tmva/tmva/src/OptimizeConfigParameters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/OptimizeConfigParameters.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the RooArgSet containing a snapshot of variables contained in the workspace; ///; /// Note that the variables of the objects in the snapshots are **copies** of the; /// variables in the workspace. To load the values of a snapshot in the workspace; /// variables, use loadSnapshot() instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:293,load,load,293,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,2,['load'],"['load', 'loadSnapshot']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the average collision rate. The higher the number the longer; /// the linked lists in the hashtable, the slower the lookup. If the number; /// is high, or lookup noticeably too slow, perform a Rehash().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx:276,perform,perform,276,core/cont/src/THashList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the camera eye point (vertex) in world space; /// Camera must have valid frustum cache - call Apply() after last modification, before using",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:174,cache,cache,174,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the current camera frustum. If asBox == kFALSE return; /// a true frustum (truncated square based pyramid). If asBox == kTRUE; /// return a true box, using the far clipping plane intersection projected; /// back to the near plane.; ///; /// Camera must have valid frustum cache - call Apply() after last modification, before using; ///; /// Note: TGLBoundingBox is not really valid when filled with truncated pyramid; /// - this is used as a visual debug aid only so ok.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:365,cache,cache,365,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the list of shared libraries loaded into the process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:122,load,loaded,122,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the module name for a given class.; /// Use the cached information from fDocEntityInfo.fClasses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx:141,cache,cached,141,html/src/THtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/src/THtml.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the number of axis labels.; ///; /// It is sometimes useful to know the number of labels on an axis. For instance; /// when changing the labels with TAxis::ChangeLabel. The number of labels is equal; /// to `the_number_of_divisions + 1`. By default the number of divisions is; /// optimised to show a coherent labeling of the main tick marks. After optimisation the; /// real number of divisions will be smaller or equal to number of divisions requested.; /// In order to turn off the labeling optimization, it is enough to give a negative; /// number of divisions to TAttAxis::SetNdivisions. The absolute value of this number will be use as; /// the exact number of divisions. This method takes the two cases (optimised or not) into; /// account.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TAxis.cxx:587,optimiz,optimization,587,hist/hist/src/TAxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TAxis.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the number of methods of this class; /// Note that in case the list of methods is not yet created, it will be done; /// by GetListOfMethods().; /// This will also load/populate the list of methods, to get 'just' the; /// number of currently loaded methods use:; /// cl->GetListOfMethods(false)->GetSize();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:256,load,load,256,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['load'],"['load', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the number of objects in array (i.e. number of non-empty slots).; /// This is a thread-unsafe version of GetEntriesFast. Use it only if sure; /// it will not be invoked concurrently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjArray.cxx:262,concurren,concurrently,262,core/cont/src/TObjArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjArray.cxx,1,['concurren'],['concurrently']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the observables to be cached given the normalization set nset.; ///; /// If the cache observable is in nset then this is; /// - the convolution observable plus; /// - any member of nset that is either a RooCategory,; /// - or was previously specified through setCacheObservables().; ///; /// In case the cache observable is *not* in nset, then it is; /// - the convolution observable plus; /// - all member of nset that are observables of this p.d.f.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:115,cache,cached,115,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,3,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the optimization flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:97,optimiz,optimization,97,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the parameters of the cache created by RooAbsCachedPdf.; /// These are always the input functions parameter, but never the; /// integrated variable x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:115,cache,cache,115,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the parameters on which the cache depends given normalization; /// set nset. For this p.d.f these are the parameters of the input p.d.f.; /// but never the convolution variable, in case it is not part of nset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:121,cache,cache,121,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the size in bytes of the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:118,cache,cache,118,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the size in bytes of the cache, if any; /// Return -1 if not used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:118,cache,cache,118,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the status of this session:; /// 0 idle; /// 1 running; /// 2 being terminated (currently unused); /// 3 queued; /// 4 idle timed-out (not set in here but in TIdleTOTimer::Notify); /// This is typically run in the reader thread, so access needs to be protected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:198,queue,queued,198,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['queue'],['queued']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the total number of public data members(currently loaded in the list; /// of DataMembers) in this class and all its base classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TViewPubDataMembers.cxx:143,load,loaded,143,core/meta/src/TViewPubDataMembers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TViewPubDataMembers.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return the total number of public methods (currently loaded in the list; /// of functions) in this class and all its base classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TViewPubFunctions.cxx:139,load,loaded,139,core/meta/src/TViewPubFunctions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TViewPubFunctions.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return true if ROOT has cxxmodules pcm for a given library name.; // FIXME: We need to be able to support lazy loading of pcm generated by ACLiC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:197,load,loading,197,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return true if the class needed by the branch is loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxyClassDescriptor.cxx:135,load,loaded,135,tree/treeplayer/src/TBranchProxyClassDescriptor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TBranchProxyClassDescriptor.cxx,2,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return true if the file has already been loaded by cint.; /// We will try in this order:; /// actual filename; /// filename as a path relative to; /// the include path; /// the shared library path",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:127,load,loaded,127,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return true if the set of rules has at least one rule that has the data; /// member named 'name' as a source.; /// If needingAlloc is true, only the rule that requires the data member to; /// be cached will be taken in consideration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TSchemaRuleSet.cxx:281,cache,cached,281,core/meta/src/TSchemaRuleSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TSchemaRuleSet.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return true if this data member object is pointing to a currently; /// loaded data member. If a function is unloaded after the TDataMember; /// is created, the TDataMember will be set to be invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TDataMember.cxx:157,load,loaded,157,core/meta/src/TDataMember.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TDataMember.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return true if this enum object is pointing to a currently; /// loaded enum. If a enum is unloaded after the TEnum; /// is created, the TEnum will be set to be invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TEnum.cxx:150,load,loaded,150,core/meta/src/TEnum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TEnum.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return true if this function object is pointing to a currently; /// loaded function. If a function is unloaded after the TFunction; /// is created, the TFunction will be set to be invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TFunction.cxx:154,load,loaded,154,core/meta/src/TFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TFunction.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return true if this function object is pointing to a currently; /// loaded function. If a function is unloaded after the TMethod; /// is created, the TMethod will be set to be invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TMethod.cxx:154,load,loaded,154,core/meta/src/TMethod.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TMethod.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return true if this function template object is pointing to a currently; /// loaded function. If a function is unloaded after the TFunction; /// is created, the TFunction will be set to be invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TFunctionTemplate.cxx:163,load,loaded,163,core/meta/src/TFunctionTemplate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TFunctionTemplate.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return true if this global object is pointing to a currently; /// loaded global. If a global is unloaded after the TGlobal; /// is created, the TGlobal will be set to be invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGlobal.cxx:152,load,loaded,152,core/meta/src/TGlobal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGlobal.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return unique name for RooAbsCachedPdf cache components; /// constructed from input function name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx:125,cache,cache,125,roofit/roofitcore/src/RooNumRunningInt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooNumRunningInt.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Return value of object. If the cache is clean, return the; /// cached value, otherwise recalculate on the fly and refill; /// the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:117,cache,cache,117,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,6,['cache'],"['cache', 'cached']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns a new TGraph containing the ROC curve. Sensitivity is on the x-axis,; /// specificity on the y-axis.; ///; /// @param num_points Granularity of the resulting curve. The curve will be subdivided; /// into num_points - 1 regions where the performance of the; /// classifier is sampled. Larger number means more accurate,; /// but more costly, evaluation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ROCCurve.cxx:331,perform,performance,331,tmva/tmva/src/ROCCurve.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/ROCCurve.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns all RooAbsArg objects contained in the cache element",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx:133,cache,cache,133,roofit/roofitcore/src/RooAbsCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedPdf.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns cpu load average and load info into the CpuInfo_t structure.; /// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; /// interval over which the CPU load will be measured, in ms (default 1000).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:98,load,load,98,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,3,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns index of array with the minimum element.; /// If more than one element is minimum returns first found.; ///; /// Implement here since this one is found to be faster (mainly on 64 bit machines); /// than stl generic implementation.; /// When performing the comparison, the STL implementation needs to de-reference both the array iterator; /// and the iterator pointing to the resulting minimum location",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/TMath.h:335,perform,performing,335,math/mathcore/inc/TMath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/TMath.h,1,['perform'],['performing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns kTRUE if draws should be display list cached; /// kFALSE otherwise.; ///; /// Here we check that:; /// a) fScene is set (Scene manages link to GL-context);; /// b) secondary selection is not in progress as different; /// render-path is usually taken in this case.; ///; /// Otherwise we return internal bool.; ///; /// Override this in sub-class if different behaviour is required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx:132,cache,cached,132,graf3d/gl/src/TGLLogicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLogicalShape.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns path of the indicated dataset. The extension is '.root' for all files; /// except for 'dsName==ls' which have extension '.txt'.; /// If 'local' is kTRUE the local cache path is returned instead in the form; /// `<cachedir>`/`<group>`.`<user>`.`<dsName>`.`<ext>`.; /// NB: contains a static TString for result, so copy result before using twice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx:257,cache,cache,257,proof/proof/src/TDataSetManagerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx,2,['cache'],"['cache', 'cachedir']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns scaling factor between screen points and GL viewport pixels.; /// This is what is returned by gVirtualX->GetOpenGLScalingFactor() but is; /// cached here to avoid a virtual function call as it is used quite often in; /// TGLPhysical shape when drawing the selection highlight.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx:236,cache,cached,236,graf3d/gl/src/TGLUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns the TMethod describing the method to be executed. This takes; /// all overriding and overloading into account (call TClass::GetMethod()).; /// Since finding the method is expensive the result is cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TMethodCall.cxx:289,cache,cached,289,core/meta/src/TMethodCall.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TMethodCall.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns the cached list of StreamerInfos used in this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:98,cache,cached,98,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns the number of events that have been received from the X server; /// but have not been removed from the event queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx:203,queue,queue,203,core/base/src/TVirtualX.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns the properties of the TClass as a bit field stored as a `Long_t` value.; ///; /// The bit values used for the return value are defined in the enum EProperty (in TDictionary.h); ///; /// Also sets `TObject::fBits` and `fStreamerType` to cache information about the; /// class. The bits stored in `TObject::fBits` are; /// ~~~ {.cpp}; /// kIsTObject : the class inherits from TObject; /// kStartWithTObject: TObject is the left-most class in the inheritance tree; /// kIsForeign : the class doe not have a Streamer method; /// ~~~; /// The value of `fStreamerType` are; /// ~~~ {.cpp}; /// kTObject : the class inherits from TObject; /// kForeign : the class does not have a Streamer method; /// kInstrumented: the class does have a Streamer method; /// kExternal: the class has a free standing way of streaming itself; /// kEmulatedStreamer: the class is missing its shared library.; /// ~~~; ///; /// Implementation note: the data member fProperty has the value -1; /// until it is initialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:330,cache,cache,330,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns the return type of the method. Either (unsigned) long,; /// int, short and char, or float and double or anything else.; /// Since finding the return type is expensive the result is cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TMethodCall.cxx:275,cache,cached,275,core/meta/src/TMethodCall.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TMethodCall.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns the total number of entries in the list.; /// If some lists have not been loaded, loads them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx:168,load,loaded,168,tree/tree/src/TEntryListFromFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListFromFile.cxx,2,['load'],"['loaded', 'loads']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns true if the implicit multi-threading in ROOT is enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:115,multi-thread,multi-threading,115,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['multi-thread'],['multi-threading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns true if there are no errors in TChain::LoadTree()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx:133,Load,LoadTree,133,tree/treeplayer/src/TSimpleAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx,1,['Load'],['LoadTree']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Returns true if this branch supports bulk IO, false otherwise.; ///; /// This will return true if all the various preconditions necessary hold true; /// to perform bulk IO (reasonable type, single TLeaf, etc); the bulk IO may; /// still fail, depending on the contents of the individual TBaskets loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:242,perform,perform,242,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,2,"['load', 'perform']","['loaded', 'perform']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Run an automatic scan until the desired accuracy is reached.; /// Start by default from the full interval (min,max) of the POI and then via bisection find the line crossing; /// the target line.; /// Optionally, a hint can be provided and the scan will be done closer to that value.; /// If by bisection the desired accuracy will not be reached, a fit to the points is performed.; /// \param[out] limit The limit.; /// \param[out] limitErr The error of the limit.; /// \param[in] absAccuracy Desired absolute accuracy.; /// \param[in] relAccuracy Desired relative accuracy.; /// \param[in] hint Hint to start from or nullptr for no hint.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx:455,perform,performed,455,roofit/roostats/src/HypoTestInverter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Runs authentication on socket s.; /// Invoked when dynamic loading is needed.; /// Returns 1 on success, 0 on failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TRootAuth.cxx:145,load,loading,145,net/auth/src/TRootAuth.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TRootAuth.cxx,1,['load'],['loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Save input data file from 'cachedir' into the sandbox or create a the file; /// with input data objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:113,cache,cachedir,113,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['cache'],['cachedir']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Save performance information from TPerfStats to file 'pf'.; /// If 'ref' is defined, do it for query 'ref'.; /// Return 0 on sucecss, -1 in case of any error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:91,perform,performance,91,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Save the block content in cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx:112,cache,cache,112,io/io/src/TFilePrefetch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Scan again along the dynamic path for library maps. Entries for the loaded; /// shared libraries are unloaded first. This can be useful after reseting; /// the dynamic path through TSystem::SetDynamicPath(); /// In case of error -1 is returned, 0 otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:154,load,loaded,154,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Scan the queries directory for the results of previous queries.; /// The headers of the query results found are loaded in fPreviousQueries.; /// The full query result can be retrieved via TProof::Retrieve.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TQueryResultManager.cxx:198,load,loaded,198,proof/proof/src/TQueryResultManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TQueryResultManager.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Scan through events in the cache which have not been used yet,; /// looking for the first accepted one which is added to the specified; /// container. Return a pointer to the accepted event, or else zero; /// if we use up the cache before we accept an event. The caller does; /// not own the event and it will be overwritten by a subsequent call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAcceptReject.cxx:113,cache,cache,113,roofit/roofitcore/src/RooAcceptReject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAcceptReject.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Scans TKey properties; /// in special cases load objects from the file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx:130,load,load,130,net/http/src/TRootSniffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Scans TKey properties; ///; /// in special cases load objects from the file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/httpsniff/src/TRootSnifferFull.cxx:135,load,load,135,net/httpsniff/src/TRootSnifferFull.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/httpsniff/src/TRootSnifferFull.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// See if we have already cached the TClass that correspond to this std::type_info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TIsAProxy.cxx:109,cache,cached,109,core/meta/src/TIsAProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TIsAProxy.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Send a file to master or slave servers. Returns number of slaves; /// the file was sent to, maybe 0 in case master and slaves have the same; /// file system image, -1 in case of error.; /// If defined, send to worker 'wrk' only.; /// If defined, the full path of the remote path will be rfile.; /// If rfile = ""cache"" the file is copied to the remote cache instead of the sandbox; /// (to copy to the cache on a different name use rfile = ""cache:newname"").; /// The mask 'opt' is an or of ESendFileOpt:; ///; /// kAscii (0x0) if set true ascii file transfer is used; /// kBinary (0x1) if set true binary file transfer is used; /// kForce (0x2) if not set an attempt is done to find out; /// whether the file really needs to be downloaded; /// (a valid copy may already exist in the cache; /// from a previous run); the bit is set by; /// UploadPackage, since the check is done elsewhere.; /// kForward (0x4) if set, ask server to forward the file to slave; /// or submaster (meaningless for slave servers).; /// kCpBin (0x8) Retrieve from the cache the binaries associated; /// with the file; /// kCp (0x10) Retrieve the files from the cache; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:397,cache,cache,397,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,7,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Send a file to the server. Return 0 on success, -1 in case of error.; /// If defined, the full path of the remote path will be rfile.; /// The mask 'opt' is an or of ESendFileOpt:; ///; /// kAscii (0x0) if set true ascii file transfer is used; /// kBinary (0x1) if set true binary file transfer is used; /// kForce (0x2) if not set an attempt is done to find out; /// whether the file really needs to be downloaded; /// (a valid copy may already exist in the cache; /// from a previous run); ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:545,cache,cache,545,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Send binary data via given websocket id. Returns:; ///; /// * -1 - in case of error; /// * 0 - when operation was executed immediately; /// * 1 - when send operation will be performed in different thread",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx:260,perform,performed,260,net/http/src/THttpWSHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Send binary data with text header via given websocket id. Returns:; ///; /// * -1 - in case of error,; /// * 0 - when operation was executed immediately,; /// * 1 - when send operation will be performed in different thread,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx:279,perform,performed,279,net/http/src/THttpWSHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Send data stored in the buffer. Returns:; ///; /// * 0 - when operation was executed immediately; /// * 1 - when send operation will be performed in different thread",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx:222,perform,performed,222,net/http/src/THttpWSHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Send message to server process to retrieve output value; /// If error were logged use logEvalError() on remote side; /// transfer those errors to the local eval error queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx:253,queue,queue,253,roofit/roofitcore/src/RooRealMPFE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealMPFE.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Send string via given websocket id. Returns:; ///; /// * -1 - in case of error,; /// * 0 - when operation was executed immediately,; /// * 1 - when send operation will be performed in different thread,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx:257,perform,performed,257,net/http/src/THttpWSHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSHandler.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Send the pattern through the optimizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPRegexp.cxx:115,optimiz,optimizer,115,core/base/src/TPRegexp.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPRegexp.cxx,1,['optimiz'],['optimizer']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Separation Gain:; /// the measure of how the quality of separation of the sample increases; /// by splitting the sample e.g. into a ""left-node"" and a ""right-node""; /// (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); /// this is then the quality criterion which is optimized for when trying; /// to increase the information in the system (making the best selection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SdivSqrtSplusB.cxx:372,optimiz,optimized,372,tmva/tmva/src/SdivSqrtSplusB.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/SdivSqrtSplusB.cxx,2,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set (or update) the which tree to read from, passing the name of a tree in a; /// directory.; ///; /// \param keyname - name of the tree in `dir`; /// \param dir - the `TDirectory` to load `keyname` from (or gDirectory if `nullptr`); /// \param entryList - the `TEntryList` to attach to the `TTreeReader`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:270,load,load,270,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set CacheControl http header to disable browser caching",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpCallArg.cxx:90,Cache,CacheControl,90,net/http/src/THttpCallArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpCallArg.cxx,1,['Cache'],['CacheControl']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set Globus authorization function. Automatically called when; /// libGlobusAuth is loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:169,load,loaded,169,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set ROOT::Internal::gFreeIfTMapFile on library load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:133,load,load,133,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set UP to the given value (see class TMinuit), and perform a MINOS minimisation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:137,perform,perform,137,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set a pointer to the read cache.; ///; /// <b>This relinquishes ownership</b> of the previous cache, so if you do not; /// already have a pointer to the previous cache (and there was a previous; /// cache), you ought to retrieve (and delete it if needed) using:; ///; /// TFileCacheRead *older = myfile->GetCacheRead();; ///; /// The action specifies how to behave when detaching a cache from the; /// the TFile. If set to (default) kDisconnect, the contents of the cache; /// will be flushed when it is removed from the file, and it will disconnect; /// the cache object from the file. In almost all cases, this is what you want.; /// If you want to disconnect the cache temporarily from this tree and re-attach; /// later to the same fil, you can set action to kDoNotDisconnect. This will allow; /// things like prefetching to continue in the background while it is no longer the; /// default cache for the TTree. Except for a few expert use cases, kDisconnect is; /// likely the correct setting.; ///; /// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:112,cache,cache,112,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,10,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set a pointer to the write cache.; ///; /// If file is null the existing write cache is deleted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:113,cache,cache,113,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set appropriate cache operation mode for integral depending on cache operation; /// mode of server objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx:102,cache,cache,102,roofit/roofitcore/src/RooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealIntegral.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set bin content of bin that was last loaded with get(std::size_t).; /// \param[in] binNumber Optional bin number to set. If empty, currently active bin is set.; /// \param[in] wgt New bin content.; /// \param[in] wgtErr Error of the new bin content. If the weight need not have an error, use 0. or a negative number.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:123,load,loaded,123,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set bin content of bin that was last loaded with get(std::size_t).; /// \param[in] wgt New bin content.; /// \param[in] wgtErr Optional error of the bin content.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:123,load,loaded,123,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set cache as finished.; /// There are three scenarios that a basket is set as finished:; /// 1. The basket has already been unzipped.; /// 2. The thread is aborted from unzipping process.; /// 3. To avoid other tasks/threads work on this basket,; /// main thread marks the basket as finished and designates itself; /// to unzip this basket.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:90,cache,cache,90,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set current entry.; ///; /// Returns -2 if entry does not exist (just as TChain::LoadTree()).; /// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; ///; /// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; ///; /// \note This function is overloaded in TChain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:167,Load,LoadTree,167,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,2,['Load'],['LoadTree']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set default level down to which visualization is performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoPainter.cxx:135,perform,performed,135,geom/geompainter/src/TGeoPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoPainter.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set font number used to draw axis labels.; /// - font : Text font code = 10*fontnumber + precision; /// - Font numbers must be between 1 and 14; /// - precision = 1 fast hardware fonts (steps in the size); /// - precision = 2 scalable and rotatable hardware fonts; /// The default font number is 62.; /// axis specifies which axis (""x"",""y"",""z""), default = ""x""; /// if axis=""xyz"" set all 3 axes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TStyle.cxx:312,scalab,scalable,312,core/base/src/TStyle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TStyle.cxx,1,['scalab'],['scalable']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set font number used to draw axis labels.; ///; /// font : Text font code = 10*fontnumber + precision; /// Font numbers must be between 1 and 14; /// precision = 1 fast hardware fonts (steps in the size); /// precision = 2 scalable and rotatable hardware fonts; ///; /// The default font number is 62.; /// axis specifies which axis (""x"",""y"",""z""), default = ""x""; /// if axis=""xyz"" set all 3 axes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/Haxis.cxx:309,scalab,scalable,309,hist/hist/src/Haxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/Haxis.cxx,1,['scalab'],['scalable']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set interpolation order of RooHistFunct representing cache histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx:139,cache,cache,139,roofit/roofitcore/src/RooAbsCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCachedReal.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set kerberos5 authorization function. Automatically called when; /// libKrb5Auth is loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:170,load,loaded,170,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set location of JSROOT to use with the server; ///; /// One could specify address like:; ///; /// * https://root.cern/js/7.6.0/; /// * https://jsroot.gsi.de/7.6.0/; ///; /// This allows to get new JSROOT features with old server,; /// reduce load on THttpServer instance, also startup time can be improved; /// When empty string specified (default), local copy of JSROOT is used (distributed with ROOT)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx:328,load,load,328,net/http/src/THttpServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set maximum size of the file cache .; //; /// - if cachesize = 0 the existing cache (if any) is deleted.; /// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; /// the Tree (default is 30 MBytes).; ///; /// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; ///; /// Returns:; /// - 0 size set, cache was created if possible; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:115,cache,cache,115,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,6,['cache'],"['cache', 'cacheSize', 'cachesize']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set optimization flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoAtt.cxx:90,optimiz,optimization,90,geom/geom/src/TGeoAtt.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoAtt.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set option to move objects/pads in a canvas.; ///; /// - set = 1 (default) graphics objects are moved in opaque mode; /// - set = 0 only the outline of objects is drawn when moving them; ///; /// The option opaque produces the best effect. It requires however a; /// a reasonably fast workstation or response time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx:386,response time,response time,386,graf2d/gpad/src/TCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx,1,['response time'],['response time']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set option to resize objects/pads in a canvas.; ///; /// - set = 1 (default) graphics objects are resized in opaque mode; /// - set = 0 only the outline of objects is drawn when resizing them; ///; /// The option opaque produces the best effect. It requires however a; /// a reasonably fast workstation or response time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx:392,response time,response time,392,graf2d/gpad/src/TCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx,1,['response time'],['response time']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set owner link on all object inserted into cache.; /// Also if cache mode optimization was requested, apply; /// it now to cache element being inserted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx:129,cache,cache,129,roofit/roofitcore/src/RooObjCacheManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooObjCacheManager.cxx,4,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set text font to specified name.; /// mode : loading flag; /// mode=0 : search if the font exist (kCheck); /// mode=1 : search the font and load it if it exists (kLoad); /// font : font name; ///; /// Set text font to specified name. This function returns 0 if; /// the specified font is found, 1 if not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:131,load,loading,131,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,4,['load'],"['load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set text font to specified name.; ///; /// \param [in] fontname font name; /// \param [in] mode loading flag; /// - mode=0 search if the font exist (kCheck); /// - mode=1 search the font and load it if it exists (kLoad); ///; /// Set text font to specified name. This function returns 0 if; /// the specified font is found, 1 if not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/TGX11.cxx:182,load,loading,182,graf2d/x11/src/TGX11.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/TGX11.cxx,2,['load'],"['load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the PROOF instance to be used for dataset operations, like releasing; /// cache ...; /// Use SetProofDS(0) to reset and using the default PROOF",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx:164,cache,cache,164,proof/proofbench/src/TProofBench.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofBench.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the cache size used by the matching TFile.; /// Note that the default is to use the same size as the default TTreeCache for; /// the input tree.; /// \param size Size of the cache.; /// \note If size=0, or if it does not match the fileCache buffer size, ; /// the fileCache will be deleted so that it be created later with the right size; /// (or not created if the size is 0) at the beginning of Exec.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx:94,cache,cache,94,tree/tree/src/TTreeCloner.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the file using this cache and reset the current blocks (if any).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:110,cache,cache,110,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the file using this cache.; /// Any write not yet flushed will be lost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx:110,cache,cache,110,io/io/src/TFileCacheWrite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheWrite.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the function to be used in performed fit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx:117,perform,performed,117,gui/fitpanel/src/TFitEditor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/src/TFitEditor.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the global branch kAutoDelete bit.; ///; /// When LoadTree loads a new Tree, the branches for which; /// the address is set will have the option AutoDelete set; /// For more details on AutoDelete, see TBranch::SetAutoDelete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:140,Load,LoadTree,140,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,2,"['Load', 'load']","['LoadTree', 'loads']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the initial size of the hashtable used to store object and class; /// references during writing. The default size is TBufferFile::kMapSize.; /// Increasing the default has the benefit that when writing many; /// small objects the hashtable does not get too many collisions; /// (the system is always dynamic, even with the default everything; /// will work, only a large number of collisions will cost performance).; /// For optimal performance hashsize should always be a prime.; /// This method can only be called directly after the creation of; /// the TBuffer, before any writing is done. Globally this option; /// can be changed using SetGlobalWriteParam().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferIO.cxx:492,perform,performance,492,io/io/src/TBufferIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferIO.cxx,2,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the input entry list (processing the entries of the chain will then be; /// limited to the entries in the list). This function creates a special kind; /// of entry list (TEntryListFromFile object) that loads lists, corresponding; /// to the chain elements, one by one, so that only one list is in memory at a time.; ///; /// If there is an error opening one of the files, this file is skipped and the; /// next file is loaded; ///; /// File naming convention:; ///; /// - by default, filename_elist.root is used, where filename is the; /// name of the chain element; /// - xxx$xxx.root - $ sign is replaced by the name of the chain element; ///; /// If the list name is not specified (by passing filename_elist.root/listname to; /// the TChain::SetEntryList() function, the first object of class TEntryList; /// in the file is taken.; ///; /// It is assumed, that there are as many list files, as there are elements in; /// the chain and they are in the same order",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:292,load,loads,292,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,2,['load'],"['loaded', 'loads']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the minimum and maximum entry number to be processed; /// this information helps to optimize the number of baskets to read; /// when prefetching the branch buffers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:174,optimiz,optimize,174,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['optimiz'],['optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the name of the class of the in-memory object into which the data will; /// loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:166,load,loaded,166,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the number of divisions for this axis.; ///; /// - if optim = kTRUE (default), the number of divisions will be; /// optimized around the specified value.; /// - if optim = kFALSE, or n < 0, the axis will be forced to use; /// exactly n divisions.; ///~~~ {.cpp}; /// n = n1 + 100*n2 + 10000*n3; ///~~~; /// Where n1 is the number of primary divisions,; /// n2 is the number of second order divisions and; /// n3 is the number of third order divisions.; ///; /// If the number of divisions is ""optimized"" (see above) n1, n2, n3 are; /// maximum values.; ///; /// Examples:; ///; /// - ndiv = 0: no tick marks.; /// - ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; /// - ndiv = 510: 10 primary divisions, 5 secondary divisions.; /// - ndiv = -10: exactly 10 primary divisions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttAxis.cxx:206,optimiz,optimized,206,core/base/src/TAttAxis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TAttAxis.cxx,2,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the path of the cache directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx:106,cache,cache,106,io/io/src/TFilePrefetch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the prefetching mode of this file.; ///; /// If 'setPrefetching', enable the asynchronous prefetching; /// (using TFilePrefetch) and if the gEnv and rootrc; /// variable Cache.Directory is set, also enable the local; /// caching of the prefetched blocks.; /// if 'setPrefetching', the old prefetcher is enabled is; /// the gEnv and rootrc variable is TFile.AsyncReading",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:260,Cache,Cache,260,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,1,['Cache'],['Cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the range of entries to be loaded by `Next()`; end will not be loaded.; ///; /// If end <= begin, `end` is ignored (set to `-1`, i.e. will run on all entries from `begin` onwards).; ///; /// Example:; ///; /// ~~~ {.cpp}; /// reader.SetEntriesRange(3, 5);; /// while (reader.Next()) {; /// // Will load entries 3 and 4.; /// }; /// ~~~; ///; /// Note that if a TEntryList is present, beginEntry and endEntry refer to the beginEntry-th/endEntry-th entries of the; /// TEntryList (or the main TEntryList in case it has sub-entrylists). In other words, SetEntriesRange can; /// be used to only loop over part of the TEntryList, but not to further restrict the actual TTree/TChain entry numbers; /// considered.; ///; /// \param beginEntry The first entry to be loaded by `Next()`.; /// \param endEntry The entry where `Next()` will return false, not loading it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:117,load,loaded,117,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,5,['load'],"['load', 'loaded', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the shape. Unreference the old and reference the new.; /// This is virtual so that sub-classes can perform other tasks; /// on change. This function should be called first from there.; ///; /// This is also called from destructor of the referenced physical; /// shape with 0 argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPShapeRef.cxx:189,perform,perform,189,graf3d/gl/src/TGLPShapeRef.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPShapeRef.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set the size of the file cache and create it if possible.; ///; /// If autocache is true:; /// this may be an autocreated cache, possibly enlarging an existing; /// autocreated cache. The size is calculated. The value passed in cacheSize:; /// - cacheSize = 0 make cache if default cache creation is enabled; /// - cacheSize = -1 make a default sized cache in any case; ///; /// If autocache is false:; /// this is a user requested cache. cacheSize is used to size the cache.; /// This cache should never be automatically adjusted.; ///; /// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; ///; /// Returns:; /// - 0 size set, or existing autosized cache almost large enough.; /// (cache was created if possible); /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:111,cache,cache,111,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,16,['cache'],"['cache', 'cacheSize']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set up packages, loaded macros, include and lib paths ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:103,load,loaded,103,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Set whether the learning period is started with a prefilling of the; /// cache and which type of prefilling is used.; /// The two value currently supported are:; /// - TTreeCache::kNoPrefill disable the prefilling; /// - TTreeCache::kAllBranches fill the cache with baskets from all branches.; /// The default prefilling behavior can be controlled by setting; /// TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:159,cache,cache,159,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Sets text font to specified name ""fontname"".This function returns 0 if; /// the specified font is found, 1 if it is not.; ///; /// \param [in] fontname font name; /// \param [in] mode loading flag; /// - mode = 0 search if the font exist (kCheck); /// - mode = 1 search the font and load it if it exists (kLoad)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx:270,load,loading,270,core/base/src/TVirtualX.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualX.cxx,2,['load'],"['load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Sets the directory where to locally stage/cache remote files.; /// If the directory is not writable by us return kFALSE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:128,cache,cache,128,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Sets the size for the unzipping cache... by default it should be; /// two times the size of the prefetching cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:118,cache,cache,118,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Sets the value, cache and constant attribute of any argument in our set; /// that also appears in the other set. Note that this function changes the; /// values of the elements in this collection, but is still marked `const` as; /// it does not change which elements this collection points to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCollection.cxx:102,cache,cache,102,roofit/roofitcore/src/RooAbsCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCollection.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Sets up the matrix for the main linear system in ""augmented system"" form. The; /// actual factorization is performed by a routine specific to either the sparse; /// or dense case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverBase.cxx:193,perform,performed,193,math/quadp/src/TQpLinSolverBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverBase.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Setup LOD-dependant values in scene-info.; /// We have to perform LOD quantization for all draw-elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx:144,perform,perform,144,graf3d/gl/src/TGLScene.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Setup the matrix as an elementary rotation.; /// Optimized versions of left/right multiplication with an elementary; /// rotation matrix are implemented in RotatePF/RotateLF.; /// Expects identity matrix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrans.cxx:135,Optimiz,Optimized,135,graf3d/eve/src/TEveTrans.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrans.cxx,2,['Optimiz'],['Optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Setup the tree to the load the specified entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeSQL.cxx:108,load,load,108,tree/tree/src/TTreeSQL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeSQL.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Short cut to call Modified() and Update() in a single call.; /// On Mac with Cocoa, it performs an additional ProcessEvents().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:173,perform,performs,173,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Show cached information matching uri",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx:91,cache,cached,91,proof/proof/src/TDataSetManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx,2,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Smooth bin contents of this 2-d histogram using kernel algorithms; /// similar to the ones used in the raster graphics community.; /// Bin contents in the active range are replaced by their smooth values.; /// The algorithm retains the input dimension by using Kernel Crop at the input boundaries.; /// Kernel Crop sets any pixel in the kernel that extends past the input to zero and adjusts the; /// normalization accordingly.; /// If Errors are defined via Sumw2, they are also scaled and computed.; /// However, note the resulting errors will be correlated between different-bins, so; /// the errors should not be used blindly to perform any calculation involving several bins,; /// like fitting the histogram. One would need to compute also the bin by bin correlation matrix.; ///; /// 3 kernels are proposed k5a, k5b and k3a.; /// k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); /// k5b is a bit more stronger in smoothing; /// k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; /// By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; /// via the option argument.; /// If TAxis::SetRange has been called on the x or/and y axis, only the bins; /// in the specified range are smoothed.; /// In the current implementation if the first argument is not used (default value=1).; ///; /// implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:719,perform,perform,719,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Lowess smoother; ///; /// This function performs the computations for the LOWESS smoother; /// (see the reference below). Lowess returns the output points; /// x and y which give the coordinates of the smooth.; ///; /// \param[in] grin Input graph; /// \param[in] option specific options; /// \param[in] span the smoother span. This gives the proportion of points in the plot; /// which influence the smooth at each value. Larger values give more smoothness.; /// \param[in] iter the number of robustifying iterations which should be performed.; /// Using smaller values of iter will make lowess run faster.; /// \param[in] delta values of x which lie within delta of each other replaced by a; /// single value in the output from lowess.; /// For delta = 0, delta will be calculated.; ///; /// References:; ///; /// - Cleveland, W. S. (1979) Robust locally weighted regression and smoothing; /// scatterplots. J. Amer. Statist. Assoc. 74, 829-836.; /// - Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots; /// by robust locally weighted regression.; /// The American Statistician, 35, 54.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:143,perform,performs,143,hist/hist/src/TGraphSmooth.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx,2,['perform'],"['performed', 'performs']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Sort bins with labels or set option(s) to draw axis with labels; /// \param[in] option; /// - ""a"" sort by alphabetic order; /// - "">"" sort by decreasing values; /// - ""<"" sort by increasing values; /// - ""h"" draw labels horizontal; /// - ""v"" draw labels vertical; /// - ""u"" draw labels up (end of label right adjusted); /// - ""d"" draw labels down (start of label left adjusted); ///; /// In case not all bins have labels sorting will work only in the case; /// the first `n` consecutive bins have all labels and sorting will be performed on; /// those label bins.; ///; /// \param[in] ax axis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:614,perform,performed,614,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Special version of RooAbsReal::createProjection that deals with; /// projections of projections. Instead of integrating twice, a new; /// RooProjectedPdf is returned that is configured to perform the; /// complete integration in one step",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx:274,perform,perform,274,roofit/roofitcore/src/RooProjectedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProjectedPdf.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Specify if the streamerinfos must be read at file opening.; ///; /// If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; /// when opening the file.; /// It may be interesting to set fgReadInfo to false to speedup the file; /// opening time or in case libraries containing classes referenced; /// by the file have not yet been loaded.; /// if fgReadInfo is false, one can still read the StreamerInfo with; /// myfile.ReadStreamerInfo();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:427,load,loaded,427,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Start of methods for the miss cache.; ////////////////////////////////////////////////////////////////////////////////; ////////////////////////////////////////////////////////////////////////////////; /// Enable / disable the miss cache.; ///; /// The first time this is called on a TTreeCache object, the corresponding; /// data structures will be allocated. Subsequent enable / disables will; /// simply turn the functionality on/off.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:116,cache,cache,116,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Static function returning the number of entries used to train the cache; /// see SetLearnEntries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:152,cache,cache,152,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Static function returning the total number of bytes written to all files.; /// Does not take into account what might still be in the write caches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:225,cache,caches,225,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['cache'],['caches']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Static function to compute reasonable axis limits; ///; /// Input parameters:; ///; /// \param[in] A1,A2 : Original axis limits; /// \param[in] BinLow,BinHigh : Optimized axis limits. They should be initialized by the; /// calling method for instance to 0.; /// \param[out] nold : Original number of divisions.; /// \param[out] nbins : Optimized number of divisions.; /// \param[out] BinWidth : Optimized bin width. It should be initialized by the; /// calling method for instance to 0.; /// \param[in] option : ""T"" means Time axis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx:247,Optimiz,Optimized,247,hist/hist/src/THLimitsFinder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/THLimitsFinder.cxx,3,['Optimiz'],['Optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Static function to retrieve enumerator from the ROOT's typesystem.; /// It has no side effect, except when the load flag is true. In this case,; /// the load of the library containing the scope of the enumerator is attempted.; /// There are two top level code paths: the enumerator is scoped or isn't.; /// If it is not, a lookup in the list of global enums is performed.; /// If it is, two lookups are carried out for its scope: one in the list of; /// classes and one in the list of protoclasses. If a scope with the desired name; /// is found, the enum is searched. If the scope is not found, and the load flag is; /// true, the aforementioned two steps are performed again after an autoload attempt; /// with the name of the scope as key is tried out.; /// If the interpreter lookup flag is false, the ListOfEnums objects are not treated; /// as such, but rather as THashList objects. This prevents any flow of information; /// from the interpreter into the ROOT's typesystem: a snapshot of the typesystem; /// status is taken.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TEnum.cxx:197,load,load,197,core/meta/src/TEnum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TEnum.cxx,5,"['load', 'perform']","['load', 'performed']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Static method returning maxmimal size of full cache,; /// which can be preserved by file instance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:132,cache,cache,132,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Static method returning pointer to TClass of the specified ClassInfo.; /// If load is true an attempt is made to obtain the class by loading; /// the appropriate shared library (directed by the rootmap file).; /// If silent is 'true', do not warn about missing dictionary for the class.; /// (typically used for class that are used only for transient members); /// Returns 0 in case class is not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:164,load,load,164,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['load'],"['load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Static method returning pointer to TClass of the specified class name.; /// If load is true, an attempt is made to obtain the class by loading; /// the appropriate shared library (directed by the rootmap file).; /// If silent is 'true', do not warn about missing dictionary for the class.; /// (typically used for classes that are used only for transient members); /// Returns `nullptr` in case class is not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:165,load,load,165,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['load'],"['load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Static method, set maxmimal size of full cache,; // which can be preserved by file instance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:127,cache,cache,127,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Stop the cache learning phase; ///; /// Returns:; /// - 0 learning phase stopped or not active; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:95,cache,cache,95,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Stream an object of TBaseClass. Triggers the calculation of the; /// cache variables to store them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TBaseClass.cxx:155,cache,cache,155,core/meta/src/TBaseClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TBaseClass.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Stream an object of TDataMember. Forces calculation of all cached; /// (and persistent) values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TDataMember.cxx:145,cache,cached,145,core/meta/src/TDataMember.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TDataMember.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Substitute matching part of s with r, dollar back-ref; /// substitution is performed if doDollarSubst is true (default).; /// Returns the number of substitutions made.; ///; /// After the substitution, another pass is made over the resulting; /// string and the following special tokens are interpreted:; /// - `\l` lowercase next char,; /// - `\u` uppercase next char,; /// - `\L` lowercase till `\E`,; /// - `\U` uppercase till `\E`, and; /// - `\E` end case modification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPRegexp.cxx:161,perform,performed,161,core/base/src/TPRegexp.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPRegexp.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Suffix for cache histogram (added in addition to suffix for cache name)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:97,cache,cache,97,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Switch ON/OFF edit mode.; /// If edit mode is ON it is possible:; ///; /// 1. embed other ROOT GUI application (a la ActiveX); ///; /// For example:; /// TGMainFrame *m = new TGMainFrame(gClient->GetRoot(), 500, 500);; /// m->SetEditable();; /// gSystem->Load(""$ROOTSYS/test/Aclock""); // load Aclock demo; /// Aclock a;; /// gROOT->Macro(""$ROOTSYS/tutorials/gui/guitest.C"");; /// m->SetEditable(0);; /// m->MapWindow();; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFrame.cxx:341,Load,Load,341,gui/gui/src/TGFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFrame.cxx,2,"['Load', 'load']","['Load', 'load']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Switch ON/OFF the real-time logging facility. When this option is; /// ON, log messages from processing are sent back as they come, instead of; /// being sent back at the end in one go. This may help debugging or monitoring; /// in some cases, but, depending on the amount of log, it may have significant; /// consequencies on the load over the network, so it must be used with care.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:417,load,load,417,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// TFormLeafInfo overload: Update (and propagate) cached information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfoReference.cxx:133,cache,cached,133,tree/treeplayer/src/TFormLeafInfoReference.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfoReference.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Tell users (TEveCaloViz instances using this data) that cell selection; /// has changed and they should update selection cache if necessary.; /// This is done by calling TEveCaloViz::CellSelectionChanged().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloData.cxx:207,cache,cache,207,graf3d/eve/src/TEveCaloData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloData.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Test if the block is in cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx:110,cache,cache,110,io/io/src/TFilePrefetch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// The 'suffix' will be appended to the name of a script loaded by ACLiC; /// and used to locate any eventual additional linkdef information that; /// ACLiC should used to produce the dictionary.; ///; /// So by default, when doing .L MyScript.cxx, ACLiC will look; /// for a file name MyScript_linkdef and having one of the .h (.hpp,; /// etc.) extensions. If such a file exist, it will be added to; /// the end of the linkdef file used to created the ACLiC dictionary.; /// This effectively enable the full customization of the creation; /// of the dictionary. It should be noted that the file is intended; /// as a linkdef `fragment`, so usually you would not list the; /// typical:; /// ~~~ {.cpp}; /// #pragma link off ....; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:140,load,loaded,140,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either TSelHist::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.; ///; /// The processing can be stopped by calling Abort().; ///; /// Use fStatus to set the return value of TTree::Process().; ///; /// The return value is currently not used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHist.cxx:279,load,loaded,279,proof/proofbench/src/TSelHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHist.cxx,2,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either TSelectorEntries::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.; ///; /// The processing can be stopped by calling Abort().; ///; /// Use fStatus to set the return value of TTree::Process().; ///; /// The return value is currently not used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorEntries.cxx:279,load,loaded,279,tree/treeplayer/src/TSelectorEntries.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorEntries.cxx,2,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either TTree::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelEvent.cxx:279,load,loaded,279,proof/proofbench/src/TSelEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelEvent.cxx,6,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either t01::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.; ///; /// The processing can be stopped by calling Abort().; ///; /// Use fStatus to set the return value of TTree::Process().; ///; /// The return value is currently not used.; ///; /// WARNING when a selector is used with a TChain, you must use; /// the pointer to the current TTree to call GetEntry(entry).; /// The entry is always the local entry number in the current tree.; /// Assuming that fChain is the pointer to the TChain being processed,; /// use: `fChain->GetTree()->GetEntry(entry)`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:279,load,loaded,279,tree/tree/src/TSelector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx,2,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// The code in filename is loaded (interpreted or compiled, see below),; /// filename must contain a valid class implementation derived from TSelector.; ///; /// If filename is of the form file.C, the file will be interpreted.; /// If filename is of the form file.C++, the file file.C will be compiled; /// and dynamically loaded. The corresponding binary file and shared; /// library will be deleted at the end of the function.; /// If filename is of the form file.C+, the file file.C will be compiled; /// and dynamically loaded. At next call, if file.C is older than file.o; /// and file.so, the file.C is not compiled, only file.so is loaded.; ///; /// The static function returns a pointer to a TSelector object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:110,load,loaded,110,tree/tree/src/TSelector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx,4,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// The db should be of the form: `<dbms>://<host>[:<port>][/<database>]`,; /// e.g.: `mysql://pcroot.cern.ch:3456/test`, `oracle://srv1.cern.ch/main`,; /// `pgsql://...` or `sqlite://<database>...`; /// The uid is the username and pw the password that should be used for; /// the connection. Depending on the `<dbms>` the shared library (plugin); /// for the selected system will be loaded. When the connection could not; /// be opened 0 is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSQLServer.cxx:466,load,loaded,466,net/net/src/TSQLServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSQLServer.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// The grid should be of the form: `<grid>://<host>[:<port>]`,; /// e.g.: alien://alice.cern.ch; /// The uid is the username and pw the password that should be used for; /// the connection. Depending on the `<grid>` the shared library (plugin); /// for the selected system will be loaded. When the connection could not; /// be opened 0 is returned. For AliEn the supported options are:; /// -domain=`<domain name>`; /// -debug=`<debug level from 1 to 10>`; /// Example: ""-domain=cern.ch -debug=5""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TGrid.cxx:364,load,loaded,364,net/net/src/TGrid.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TGrid.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// The name should be enough to explain the method.; /// The only additional comments is that the cache is cleaned before; /// the new learning phase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:181,cache,cache,181,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// The total efficiency of the 'miss cache' - defined as the ratio; /// of blocks found in the cache versus the number of blocks prefetched",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:120,cache,cache,120,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This function could be called TTreePlayer::UpdateFormulaLeaves, itself; /// called by TChain::LoadTree when a new Tree is loaded.; /// Because Trees in a TChain may have a different list of leaves, one; /// must update the leaves numbers in the TTreeFormula used by the TreePlayer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormulaManager.cxx:180,Load,LoadTree,180,tree/treeplayer/src/TTreeFormulaManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormulaManager.cxx,2,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This function is called TTreePlayer::UpdateFormulaLeaves, itself; /// called by TChain::LoadTree when a new Tree is loaded.; /// Because Trees in a TChain may have a different list of leaves, one; /// must update the leaves numbers in the TTreeFormula used by the TreePlayer.; ///; /// A safer alternative would be to recompile the whole thing .... However; /// currently compile HAS TO be called from the constructor!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:174,Load,LoadTree,174,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,2,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This function may be called after having filled some entries in a Tree.; /// Using the information in the existing branch buffers, it will reassign; /// new branch buffer sizes to optimize time and memory.; ///; /// The function computes the best values for branch buffer sizes such that; /// the total buffer sizes is less than maxMemory and nearby entries written; /// at the same time.; /// In case the branch compression factor for the data written so far is less; /// than compMin, the compression is disabled.; ///; /// if option =""d"" an analysis report is printed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:266,optimiz,optimize,266,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['optimiz'],['optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This function may be called at the start of a program to change; /// the default value for fAutoFlush.; ///; /// ### CASE 1 : autof > 0; ///; /// autof is the number of consecutive entries after which TTree::Fill will; /// flush all branch buffers to disk.; ///; /// ### CASE 2 : autof < 0; ///; /// When filling the Tree the branch buffers will be flushed to disk when; /// more than autof bytes have been written to the file. At the first FlushBaskets; /// TTree::Fill will replace fAutoFlush by the current value of fEntries.; ///; /// Calling this function with autof<0 is interesting when it is hard to estimate; /// the size of one entry. This value is also independent of the Tree.; ///; /// The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; /// the first AutoFlush will be done when 30 MBytes of data are written to the file.; ///; /// ### CASE 3 : autof = 0; ///; /// The AutoFlush mechanism is disabled.; ///; /// Flushing the buffers at regular intervals optimize the location of; /// consecutive entries on the disk by creating clusters of baskets.; ///; /// A cluster of baskets is a set of baskets that contains all; /// the data for a (consecutive) set of entries and that is stored; /// consecutively on the disk. When reading all the branches, this; /// is the minimum set of baskets that the TTreeCache will read.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:1075,optimiz,optimize,1075,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['optimiz'],['optimize']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This function searches for peaks in source spectrum in hin; /// The number of found peaks and their positions are written into; /// the members fNpeaks and fPositionX.; /// The search is performed in the current histogram range.; ///; /// Function parameters:; /// - hin: pointer to the histogram of source spectrum; /// - sigma: sigma of searched peaks, for details we refer to manual; /// - threshold: (default=0.05) peaks with amplitude less than; /// threshold*highest_peak are discarded. 0<threshold<1; ///; /// By default, the background is removed before deconvolution.; /// Specify the option ""nobackground"" to not remove the background.; ///; /// By default the ""Markov"" chain algorithm is used.; /// Specify the option ""noMarkov"" to disable this algorithm; /// Note that by default the source spectrum is replaced by a new spectrum; ///; /// By default a polymarker object is created and added to the list of; /// functions of the histogram. The histogram is drawn with the specified; /// option and the polymarker object drawn on top of the histogram.; /// The polymarker coordinates correspond to the npeaks peaks found in; /// the histogram.; /// A pointer to the polymarker object can be retrieved later via:; /// ~~~ {.cpp}; /// TList *functions = hin->GetListOfFunctions();; /// TPolyMarker *pm = (TPolyMarker*)functions->FindObject(""TPolyMarker""); /// ~~~; /// Specify the option ""goff"" to disable the storage and drawing of the; /// polymarker.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx:273,perform,performed,273,hist/spectrum/src/TSpectrum2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This function sets the following fitting parameters:; /// - xmin, xmax - fitting region; /// - numberIterations - # of desired iterations in the fit; /// - alpha - convergence coefficient, it should be positive number and <=1, for details see references; /// - statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; /// - alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; /// - power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; /// - fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrumFit.cxx:618,optimiz,optimization,618,hist/spectrum/src/TSpectrumFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrumFit.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This function sets the following fitting parameters:; /// - xmin, xmax, ymin, ymax - fitting region; /// - numberIterations - # of desired iterations in the fit; /// - alpha - convergence coefficient, it should be positive number and <=1, for details see references; /// - statisticType - type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood; /// - alphaOptim - optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal; /// - power - possible values kFitPower2,4,6,8,10,12, for details see references. It applies only for Awmi fitting function.; /// - fitTaylor - order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2Fit.cxx:630,optimiz,optimization,630,hist/spectrum/src/TSpectrum2Fit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/src/TSpectrum2Fit.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This function transfroms the given TEventList into a TEntryList; ///; /// NOTE, that this function loads all tree headers, because the entry numbers; /// in the TEventList are global and have to be recomputed, taking into account; /// the number of entries in each tree.; ///; /// The new TEntryList is owned by the TChain and gets deleted when the chain; /// is deleted. This TEntryList is returned by GetEntryList() function, and after; /// GetEntryList() function is called, the TEntryList is not owned by the chain; /// any more and will not be deleted with it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:185,load,loads,185,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['load'],['loads']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This inflates a basket in the cache.. passing the data to a new; /// buffer that will only wait there to be read...; /// This function is responsible to update corresponding elements in; /// fUnzipStatus, fUnzipChunks and fUnzipLen. Since we use atomic variables; /// in fUnzipStatus to exclusively unzip the basket, we must update; /// fUnzipStatus after fUnzipChunks and fUnzipLen and make sure fUnzipChunks; /// and fUnzipLen are ready before main thread fetch the data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:116,cache,cache,116,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This is a static function.; /// Set optimization option.; /// When this option is activated (default), consecutive data members; /// of the same type are merged into an array (faster).; /// Optimization must be off in TTree split mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TVirtualStreamerInfo.cxx:122,optimiz,optimization,122,core/meta/src/TVirtualStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TVirtualStreamerInfo.cxx,2,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This is the default LoadImage() procedure. It just tries to load the; /// image from a file in the local filesystem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlImage.cxx:106,Load,LoadImage,106,gui/guihtml/src/TGHtmlImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlImage.cxx,2,"['Load', 'load']","['LoadImage', 'load']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This method check for treat the case where expression contains $Atl and load up; /// both fAliases and fExpr.; /// We return:; /// - -1 in case of failure; /// - 0 in case we did not find $Alt; /// - the action number in case of success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:158,load,load,158,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This method compiles and loads a shared library containing; /// the code from the file ""filename"".; ///; /// The return value is true (1) in case of success and false (0); /// in case of error.; ///; /// The possible options are:; /// - k : keep the shared library after the session end.; /// - f : force recompilation.; /// - g : compile with debug symbol; /// - O : optimized the code; /// - c : compile only, do not attempt to load the library.; /// - s : silence all informational output; /// - v : output all information output; /// - d : debug ACLiC, keep all the output files.; /// - - : if buildir is set, use a flat structure (see buildir below); ///; /// If library_specified is specified, CompileMacro generates the file; /// ""library_specified"".soext where soext is the shared library extension for; /// the current platform.; ///; /// If build_dir is specified, it is used as an alternative 'root' for the; /// generation of the shared library. The library is stored in a sub-directories; /// of 'build_dir' including the full pathname of the script unless a flat; /// directory structure is requested ('-' option). With the '-' option the libraries; /// are created directly in the directory 'build_dir'; in particular this means that; /// 2 scripts with the same name in different source directory will over-write each; /// other's library.; /// See also TSystem::SetBuildDir.; ///; /// If dirmode is not zero and we need to create the target directory, the; /// file mode bit will be change to 'dirmode' using chmod.; ///; /// If library_specified is not specified, CompileMacro generate a default name; /// for library by taking the name of the file ""filename"" but replacing the; /// dot before the extension by an underscore and by adding the shared; /// library extension for the current platform.; /// For example on most platform, hsimple.cxx will generate hsimple_cxx.so; ///; /// It uses the ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:111,load,loads,111,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,3,"['load', 'optimiz']","['load', 'loads', 'optimized']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This method must be overridden to handle object notification (the base implementation is no-op).; ///; /// Different objects in ROOT use the `Notify` method for different purposes, in coordination; /// with other objects that call this method at the appropriate time.; ///; /// For example, `TLeaf` uses it to load class information; `TBranchRef` to load contents of; /// referenced branches `TBranchRef`; most notably, based on `Notify`, `TChain` implements a; /// callback mechanism to inform interested parties when it switches to a new sub-tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx:396,load,load,396,core/base/src/TObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx,2,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This will delete the list of buffers that are in the unzipping cache; /// and will reset certain values in the cache.; /// This name is ambiguos because the method doesn't reset the whole cache,; /// only the part related to the unzipping; /// Note: This method is completely different from TTreeCache::ResetCache(),; /// in that method we were cleaning the prefetching buffer while here we; /// delete the information about the unzipped buffers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:149,cache,cache,149,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This will indicate a sort of relative efficiency... a ratio of the; /// reads found in the cache to the number of reads so far",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:177,cache,cache,177,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// This will simply clear the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:113,cache,cache,113,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// To clean out all caches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:103,cache,caches,103,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['cache'],['caches']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// To read a TObject* from the file.; ///; /// The object associated to this key is read from the file into memory; /// Once the key structure is read (via Streamer) the class identifier; /// of the object is known.; /// Using the class identifier we find the TClass object for this class.; /// A TClass object contains a full description (i.e. dictionary) of the; /// associated class. In particular the TClass object can create a new; /// object of the class type it describes. This new object now calls its; /// Streamer function to rebuilt itself.; ///; /// Use TKey::ReadObjectAny to read any object non-derived from TObject; ///; /// ### Note; /// A C style cast can only be used in the case where the final class; /// of this object derives from TObject as a first inheritance, otherwise; /// one must use a dynamic_cast.; ///; /// #### Example1: simplified case; /// ~~~{.cpp}; /// class MyClass : public TObject, public AnotherClass; /// ~~~; /// then on return, one get away with using:; /// ~~~{.cpp}; /// MyClass *obj = (MyClass*)key->ReadObj();; /// ~~~; ///; /// #### Example2: Usual case (recommended unless performance is critical); /// ~~~{.cpp}; /// MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; /// ~~~; /// which support also the more complex inheritance like:; /// ~~~{.cpp}; /// class MyClass : public AnotherClass, public TObject; /// ~~~; ///; /// Of course, `dynamic_cast<>` can also be used in the example 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx:1206,perform,performance,1206,io/io/src/TKey.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// To use this optimization, the user should declare the full list of volumes; /// which may overlap with any of the physical nodes of the parallel world. Better; /// be done before misalignment",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:98,optimiz,optimization,98,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,2,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Tries to load a PCM from TFile; returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:95,load,load,95,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Tries to load a rdict PCM, issues diagnostics if it fails.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:95,load,load,95,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Try to load the ClassInfo if available. This function may require parsing; /// the header file and/or loading data from the clang pcm. If further calls to; /// this function cannot affect the value of fClassInfo, fCanLoadClassInfo is set; /// to false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:93,load,load,93,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['load'],"['load', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Try to shrink the cache to the desired size.; ///; /// With the clenupinterval you can specify the minimum amount of time after; /// the previous cleanup before the cleanup operation is repeated in; /// the cache directory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:104,cache,cache,104,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Un-zoom the image to original size.; /// UnZoom() - performs undo for Zoom,Crop,Scale actions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx:138,perform,performs,138,graf2d/asimage/src/TASImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Unbinned fit of one or more variable(s) from a Tree.; ///; /// funcname is a TF1 function.; ///; /// See TTree::Draw for explanations of the other parameters.; ///; /// Fit the variable varexp using the function funcname using the; /// selection cuts given by selection.; ///; /// The list of fit options is given in parameter option.; ///; /// - option = ""Q"" Quiet mode (minimum printing); /// - option = ""V"" Verbose mode (default is between Q and V); /// - option = ""E"" Perform better Errors estimation using Minos technique; /// - option = ""M"" More. Improve fit results; /// - option = ""D"" Draw the projected histogram with the fitted function; /// normalized to the number of selected rows; /// and multiplied by the bin width; ///; /// You can specify boundary limits for some or all parameters via; /// ~~~{.cpp}; /// func->SetParLimits(p_number, parmin, parmax);; /// ~~~; /// if parmin>=parmax, the parameter is fixed; ///; /// Note that you are not forced to fix the limits for all parameters.; /// For example, if you fit a function with 6 parameters, you can do:; /// ~~~{.cpp}; /// func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; /// func->SetParLimits(4,-10,-4);; /// func->SetParLimits(5, 1,1);; /// ~~~; /// With this setup, parameters 0->3 can vary freely; /// - Parameter 4 has boundaries [-10,-4] with initial value -8; /// - Parameter 5 is fixed to 100.; ///; /// For the fit to be meaningful, the function must be self-normalized.; ///; /// i.e. It must have the same integral regardless of the parameter; /// settings. Otherwise the fit will effectively just maximize the; /// area.; ///; /// It is mandatory to have a normalization variable; /// which is fixed for the fit. e.g.; /// ~~~{.cpp}; /// TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; /// f1->SetParameters(1, 3.1, 0.01);; /// f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; /// data->UnbinnedFit(""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:558,Perform,Perform,558,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Unbinned fit of one or more variable(s) from a tree.; ///; /// funcname is a TF1 function.; ///; /// \see TTree::Draw for explanations of the other parameters.; ///; /// Fit the variable varexp using the function funcname using the; /// selection cuts given by selection.; ///; /// The list of fit options is given in parameter option.; ///; /// - option = ""Q"" Quiet mode (minimum printing); /// - option = ""V"" Verbose mode (default is between Q and V); /// - option = ""E"" Perform better Errors estimation using Minos technique; /// - option = ""M"" More. Improve fit results; ///; /// You can specify boundary limits for some or all parameters via; /// ~~~ {.cpp}; /// func->SetParLimits(p_number, parmin, parmax);; /// ~~~; /// if parmin>=parmax, the parameter is fixed; ///; /// Note that you are not forced to fix the limits for all parameters.; /// For example, if you fit a function with 6 parameters, you can do:; /// ~~~ {.cpp}; /// func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; /// func->SetParLimits(4,-10,-4);; /// func->SetParLimits(5, 1,1);; /// ~~~; /// With this setup:; ///; /// - Parameters 0->3 can vary freely; /// - Parameter 4 has boundaries [-10,-4] with initial value -8; /// - Parameter 5 is fixed to 100.; ///; /// For the fit to be meaningful, the function must be self-normalized.; ///; /// i.e. It must have the same integral regardless of the parameter; /// settings. Otherwise the fit will effectively just maximize the; /// area.; ///; /// It is mandatory to have a normalization variable; /// which is fixed for the fit. e.g.; /// ~~~ {.cpp}; /// TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; /// f1->SetParameters(1, 3.1, 0.01);; /// f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; /// data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");; /// ~~~; /// 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit; ///; /// Return status:; ///; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:559,Perform,Perform,559,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['Perform'],['Perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Unload the library map entries coming from all the loaded shared libraries.; /// Returns 0 if succesful",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:137,load,loaded,137,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Update contents of cache histogram by resampling the input function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedReal.cxx:105,cache,cache,105,roofit/roofitcore/src/RooCachedReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedReal.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Update contents of cache histogram by resampling the input p.d.f. Note that; /// the cache is filled with normalized p.d.f values so that the RooHistPdf; /// that represents the cache contents can be explicitly declared as self normalized; /// eliminating the need for superfluous numeric calculations of unit normalization.s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx:105,cache,cache,105,roofit/roofitcore/src/RooCachedPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooCachedPdf.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Update element flags when geometry is loaded from a file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:124,load,loaded,124,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Update internally cached frustum values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:104,cache,cached,104,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Update pointer to current Tree and recompute pointers to the branches in the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:163,cache,cache,163,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Update setting and cache on data changed.; /// Called from REvecaloData::BroadcastDataChange()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveCalo.cxx:105,cache,cache,105,graf3d/eve7/src/REveCalo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveCalo.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Update setting and cache on data changed.; /// Called from TEvecaloData::BroadcastDataChange()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo.cxx:105,cache,cache,105,graf3d/eve/src/TEveCalo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCalo.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Update the coefficient values in the given cache element: calculate new remainder; /// fraction, normalize fractions obtained from extended ML terms to unity, and; /// multiply the various range and dimensional corrections needed in the; /// current use context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:129,cache,cache,129,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Update the coefficient values in the given cache element: calculate new remainder; /// fraction, normalize fractions obtained from extended ML terms to unity, and; /// multiply the various range and dimensional corrections needed in the; /// current use context.; ///; /// param[in] cache The cache element for the given normalization set that; /// stores the supplementary normalization values and; /// projection-related objects.; /// param[in] nset The set of variables to normalize over.; /// param[in] syncCoefValues If the initial values of the coefficients still; /// need to be copied from the `_coefList` elements to; /// the `_coefCache`. True by default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx:129,cache,cache,129,roofit/roofitcore/src/RooAddPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddPdf.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Update the internally cached volume and axes vectors - these are retained; /// for efficiency - many more reads than modifications",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx:108,cache,cached,108,graf3d/gl/src/TGLBoundingBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Update the values of every widget entry in the editor. The new values; /// are loaded from the current selected style.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:165,load,loaded,165,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Updates all reve-browsers having the node in their contents.; /// All 3D-pads updated if any change found.; ///; /// Should (could?) be optimized with some assumptions about; /// volume/node structure (search for parent, know the same node can not; /// reoccur on lower level once found).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveGeoNode.cxx:222,optimiz,optimized,222,graf3d/eve/src/TEveGeoNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveGeoNode.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Updates all reve-browsers having the volume in their contents.; /// All 3D-pads updated if any change found.; ///; /// Should (could?) be optimized with some assumptions about; /// volume/node structure (search for parent, know the same node can not; /// reoccur on lower level once found).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveGeoNode.cxx:224,optimiz,optimized,224,graf3d/eve/src/TEveGeoNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveGeoNode.cxx,1,['optimiz'],['optimized']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Updates the parent formulae.; /// Called by TChain::LoadTree when the parent chain changes it's tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TChainIndex.cxx:138,Load,LoadTree,138,tree/treeplayer/src/TChainIndex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TChainIndex.cxx,1,['Load'],['LoadTree']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Used for automatic sizing of the cache.; ///; /// Estimates a suitable size for the tree cache based on AutoFlush.; /// A cache sizing factor is taken from the configuration. If this yields zero; /// and withDefault is true the historical algorithm for default size is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:119,cache,cache,119,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,3,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Used to read a chunk from a block previously fetched. It will call FillBuffer; /// even if the cache lookup succeeds, because it will try to prefetch the next block; /// as soon as we start reading from the current block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:181,cache,cache,181,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Used to sort slaves by performance index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx:109,perform,performance,109,proof/proof/src/TSlave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Utility function for plotOn(), perform general sanity check on frame to ensure safe plotting operations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:117,perform,perform,117,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Utility function that determines if all clients of object 'var'; /// appear in given list of cached nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx:179,cache,cached,179,roofit/roofitcore/src/RooAbsData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsData.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Verify that the normalization integral cached with this PDF; /// is valid for given set of normalization observables.; ///; /// If not, the cached normalization integral (if any) is deleted; /// and a new integral is constructed for use with 'nset'.; /// Elements in 'nset' can be discrete and real, but must be lvalues.; ///; /// For functions that declare to be self-normalized by overloading the; /// selfNormalized() function, a unit normalization is always constructed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:125,cache,cached,125,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,2,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Virtual function to be called after a new event is loaded.; /// It iterates over the list of registered commands; /// (fNewEventCommands) and executes them in given order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveEventManager.cxx:137,load,loaded,137,graf3d/eve/src/TEveEventManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveEventManager.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Virtual function to destroy a physical. Sub-classes might have; /// special checks to perform.; /// Caller should also invalidate the draw-list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx:172,perform,perform,172,graf3d/gl/src/TGLScene.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// We always create the TBuffer for the basket but it hold the buffer from the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:162,cache,cache,162,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// We reloading all cached information in case the underlying class; /// information has changed (for example when changing from the 'emulated'; /// class to the real class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx:103,cache,cached,103,tree/treeplayer/src/TFormLeafInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx,7,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// We try to read a buffer that has already been unzipped; /// Returns -1 in case of read failure, 0 in case it's not in the; /// cache and n>0 in case read from cache (number of bytes copied).; /// pos and len are the original values as were passed to ReadBuffer; /// but instead we will return the inflated buffer.; /// Note!! : If *buf == 0 we will allocate the buffer and it will be the; /// responsibility of the caller to free it... it is useful for example; /// to pass it to the creator of TBuffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:213,cache,cache,213,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// When clicking in the browser, the following action is performed; /// on this macro, depending the content of the variable TMacro.Browse.; /// TMacro.Browse can be set in the system.rootrc or .rootrc file like:; /// ~~~ {.cpp}; /// TMacro.Browse : Action; /// ~~~; /// or set via gEnv->SetValue, eg; /// ~~~ {.cpp}; /// gEnv->SetValue(""TMacro.Browse"",""Print"");; /// ~~~; /// By default TMacro.Browse=""""; /// -if TMacro.Browse ="""" the macro is executed; /// -if TMacro.Browse =""Print"" the macro is printed in stdout; /// -if TMacro.Browse is of the form ""mymacro.C""; /// the macro void mymacro.C(TMacro *m) is called where m=this macro; /// An example of macro.C saving the macro into a file and viewing it; /// with emacs is shown below:; /// ~~~ {.cpp}; /// void mymacro(TMacro *m) {; /// m->SaveSource(""xx.log"");; /// gSystem->Exec(""emacs xx.log&"");; /// }; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMacro.cxx:140,perform,performed,140,core/base/src/TMacro.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMacro.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// When specified, _autoload attribute will be always add; /// to top element of h.json/h.hml requests; /// Used to instruct browser automatically load special code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx:230,load,load,230,net/http/src/TRootSniffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// When the kBypassStreamer bit is set, the automatically; /// generated Streamer can call directly TClass::WriteBuffer.; /// Bypassing the Streamer improves the performance when writing/reading; /// the objects in the TClonesArray. However there is a drawback:; /// When a TClonesArray is written with split=0 bypassing the Streamer,; /// the StreamerInfo of the class in the array being optimized,; /// one cannot use later the TClonesArray with split>0. For example,; /// there is a problem with the following scenario:; /// 1. A class Foo has a TClonesArray of Bar objects; /// 2. The Foo object is written with split=0 to Tree T1.; /// In this case the StreamerInfo for the class Bar is created; /// in optimized mode in such a way that data members of the same type; /// are written as an array improving the I/O performance.; /// 3. In a new program, T1 is read and a new Tree T2 is created; /// with the object Foo in split>1; /// 4. When the T2 branch is created, the StreamerInfo for the class Bar; /// is created with no optimization (mandatory for the split mode).; /// The optimized Bar StreamerInfo is going to be used to read; /// the TClonesArray in T1. The result will be Bar objects with; /// data member values not in the right sequence.; /// The solution to this problem is to call BypassStreamer(kFALSE); /// for the TClonesArray. In this case, the normal Bar::Streamer function; /// will be called. The Bar::Streamer function works OK independently; /// if the Bar StreamerInfo had been generated in optimized mode or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx:245,perform,performance,245,core/cont/src/TClonesArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClonesArray.cxx,7,"['optimiz', 'perform']","['optimization', 'optimized', 'performance']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Wipes logicals in refresh-cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx:112,cache,cache,112,graf3d/gl/src/TGLScene.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Write buffer via cache. Returns 0 if cache is not active, 1 in case; /// write via cache was successful, 2 in case write via cache failed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:103,cache,cache,103,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,4,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Write object to I/O buffer.; /// This function assumes that the value of 'actualObjectStart' is the actual start of; /// the object of class 'actualClass'; /// If 'cacheReuse' is true (default) upon seeing an object address a second time,; /// we record the offset where its was written the first time rather than streaming; /// the object a second time.; /// If 'cacheReuse' is false, we always stream the object. This allows the (re)use; /// of temporary object to store different data in the same buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:250,cache,cacheReuse,250,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,2,['cache'],['cacheReuse']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Write, compile and load code and instantiate object for a RooAbsPdf; /// implementation. The difference to makeFunctionInstance() is the base; /// class of the written class (RooAbsPdf instead of RooAbsReal).; ///; /// \see RooClassFactory::makeFunctionInstance(const char*, const char*, RooArgList const&, const char*)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx:105,load,load,105,roofit/roofitcore/src/RooClassFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Write, compile and load code and instantiate object for a; /// RooAbsPdf implementation with class name 'name', taking all; /// elements of 'vars' as constructor arguments. The initial value; /// expression is taken to be 'expression' which can be any one-line; /// C++ expression in terms of variables that occur in 'vars'.; ///; /// The returned object is an instance of the object you just defined; /// connected to the variables listed in 'vars'. The name of the; /// object is 'name', its class name Roo<name>Class.; ///; /// This function is an effective compiled replacement of RooGenericPdf; ///; /// You can add optional expressions for analytical integrals to be; /// advertised by your class in the syntax; /// ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; /// where ""<intObsName>"" a name of the observable integrated over and; /// ""<CPPAnaIntExpression>"" is the C++ expression that calculates that; /// integral.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx:105,load,load,105,roofit/roofitcore/src/RooClassFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Write, compile and load code and instantiate object for a; /// RooAbsReal implementation with class name 'name', taking all; /// elements of 'vars' as constructor arguments. The initial value; /// expression is taken to be 'expression' which can be any one-line; /// C++ expression in terms of variables that occur in 'vars'.; ///; /// The returned object is an instance of the object you just defined; /// connected to the variables listed in 'vars'. The name of the; /// object is 'name', its class name Roo<name>Class.; ///; /// This function is an effective compiled replacement of RooFormulaVar; ///; /// You can add optional expressions for analytical integrals to be; /// advertised by your class in the syntax; /// ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; /// where ""<intObsName>"" a name of the observable integrated over and; /// ""<CPPAnaIntExpression>"" is the C++ expression that calculates that; /// integral.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx:105,load,load,105,roofit/roofitcore/src/RooClassFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx,2,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// Write, compile and load code for a RooAbsReal implementation with; /// class name 'name', taking all elements of 'vars' as constructor; /// arguments. The initial value expression is taken to be; /// 'expression' which can be any one-line C++ expression in terms of; /// variables that occur in 'vars'. You can add optional expressions; /// for analytical integrals to be advertised by your class in the; /// syntax; /// ""<intObsName>:<CPPAnaIntExpression>;<intObsName,intObsName>:<CPPAnaIntExpression>""; /// where ""<intObsName>"" a name of the observable integrated over and; /// ""<CPPAnaIntExpression>"" is the C++ expression that calculates that; /// integral.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx:105,load,load,105,roofit/roofitcore/src/RooClassFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// \brief Merge implementation of TStatistic; /// \param[in] in Other TStatistic objects to be added to the current one; ///; /// The function merges the statistics of all objects together to form a new one.; /// Merging quantities is done via simple addition for the following class data members:; /// - number of entries fN; /// - the sum of weights fW; /// - the sum of squared weights fW2; /// - the sum of (value*weight) fM; ///; /// The sum of squared (value*weight) pairs fM2 is updated using the same formula as in; /// TStatistic::Fill() function.; ///; /// The minimum(maximum) is updated by checking that the minimum(maximum) of; /// the next TStatistic object in the queue is either less(greater) than the current minimum(maximum).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TStatistic.cxx:762,queue,queue,762,math/mathcore/src/TStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TStatistic.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer with byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller should be able to access the contents of buf as they; /// are with:; ///; /// ~~~{.cpp}; /// static_cast<T*>(buf.GetCurrent()); /// ~~~; ///; /// where T is the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; /// ; /// ~~~{.cpp}; /// TLeaf *leaf = static_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetEntriesSerialized() for an alternative that does not; /// perform byte swapping (useful to save one pass over data in some cases).; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1400,perform,perform,1400,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// \brief Read a basket of events into the given buffer without byte swapping.; ///; /// \return On success, the number of events of the type held by this branch; /// that have been read into the buffer. -1 on failure.; ///; /// On success, the caller still need to deserialize the content. For example for; /// a scalar branch and `N` the return value (i.e. number of entries); ///; /// ~~~{.cpp}; /// rawdata = static_cast<char*>(buf.GetCurrent());; /// for (std::size_t i = 0u; i < N; ++i, ++target); /// frombuf(rawdata, target); // `frombuf` also advances the `rawdata` pointer; /// ~~~; ///; /// where target is a pointer or array to the type stored on this branch.; ///; /// When `count_buf` points to a valid TBuffer and the branch has a branch count,; /// `count_buf` will be filled (via a call to GetEntriesSerialized()) with the data; /// from the branchCount. After deserialization those value can be used to calculate; /// the number of elements corresponding to each entries.; ///; /// For each entry the number of elements is the multiplication of; ///; /// ~~~{.cpp}; /// TLeaf *leaf = dynamic_cast<TLeaf*>(branch->GetListOfLeaves()->At(0));; /// auto len = leaf->GetLen();; /// ~~~; ///; /// and the value in the BranchCount corresponding to that entry (can be obtained; /// from `branch->GetBranchCount()`).; ///; /// \note This interface is not meant to be exposed to end users, but rather it should; /// be wrapped by higher-level interfaces.; ///; /// \note See TBranch::GetBulkEntries() for an alternative that also performs byte swapping.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:1621,perform,performs,1621,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// \brief Set the input entry list (processing the entries of the chain will; /// then be limited to the entries in the list).; ///; /// \param[in] elist The entry list to be assigned to this chain.; /// \param[in] opt An option string. Possible values are:; /// - """" (default): both the file names of the chain elements and the file; /// names of the TEntryList sublists are expanded to full path name.; /// - ""ne"": the file names are taken as they are and not expanded; /// - ""sync"": the TChain will go through the TEntryList in lockstep with the; /// trees in the chain rather than performing a lookup based on; /// treename and filename. This is mostly useful when the TEntryList; /// has multiple sublists for the same tree and filename.; /// \throws std::runtime_error If option ""sync"" was chosen and either:; /// - \p elist doesn't have sub entry lists.; /// - the number of sub entry lists in \p elist is different than the; /// number of trees in the chain.; /// - any of the sub entry lists in \p elist doesn't correspond to the; /// tree of the chain with the same index (i.e. it doesn't share the; /// same tree name and file name).; ///; /// This function finds correspondence between the sub-lists of the TEntryList; /// and the trees of the TChain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:668,perform,performing,668,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['perform'],['performing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// \brief Static function creating a color palette based on an input text file.; ///; /// Every color in the file will take the same amount of space in the palette.; ///; /// \see https://doi.org/10.1038/s41467-020-19160-7; /// \note This function is designed to load into ROOT the colour-vision; /// deficiency friendly and perceptually uniform colour maps specially designed; /// in https://doi.org/10.5281/zenodo.4491293, namely the .txt files stored; /// in the subfolders of ScientificColourMaps7.zip, e.g. batlow/batlow.txt; ///; /// \param fileName: Name of a .txt file (ASCII) containing three floats per; /// line, separated by spaces, namely the r g b fractions of the color, each; /// value being in the range [0,1].; /// \param alpha the global opacity for all colors within this palette; /// \return a positive value on success and -1 on error.; /// \author Fernando Hueso-González",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:346,load,load,346,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// \class TMethodBrowsable; /// \ingroup tree; ///; /// This helper object allows the browsing of methods of objects stored in; /// branches. They will be depicted by a leaf (or a branch, in case the method; /// returns an object) with a red exclamation mark. Only a subset of all; /// methods will be shown in the browser (see IsMethodBrowsable for the; /// criteria a method has to satisfy).; ///; /// Obviously, methods are only available if the library is loaded which; /// contains the dictionary for the class to be browsed!; ///; /// If a branch contains a collection, TMethodBrowsable tries to find out; /// what the contained element is (it will only create methods for the; /// contained elements, but never for the collection). If it fails to extract; /// the type of the contained elements, or if there is no guarantee that the; /// type has any other common denominator than TObject (e.g. in the case of; /// a TObjArray, which can hold any object deriving from TObject) no methods; /// will be added.; ////////////////////////////////////////////////////////////////////////////////; /// Constructor.; /// Links a TBranchElement to a TMethod, allowing the TBrowser to; /// browse simple methods.; ///; /// The c'tor sets the name for a method ""Class::Method(params) const""; /// to ""Method(params)"", title to TMethod::GetPrototype",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:543,load,loaded,543,tree/tree/src/TBranchBrowsable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// \class TNonSplitBrowsable; /// \ingroup tree; ///; /// Allows a TBrowser to browse non-split branches as if they were split. The; /// generator extracts the necessary information from the streamer info in; /// memory (which does not have to be the same as the one on file, in case; /// a library was loaded containing the dictionary for this type), i.e. it; /// also works without loading the class's library.; ///; /// Just as with TMethodBrowsables, if the generator finds a collection it; /// only takes the contained objects into account, not the collections. If; /// it identifies a collection, but cannot extract the contained type, or the; /// contained type can be anything deriving from a TObject (like for TObjArray); /// or is not limited at all, no browser helper objects are created.; ////////////////////////////////////////////////////////////////////////////////; /// Constructor. Creates a TNonSplitBrowsable from a TStreamerElement, containing branch; /// and (if applicable) parent TVirtualBranchBrowsable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx:386,load,loaded,386,tree/tree/src/TBranchBrowsable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchBrowsable.cxx,2,['load'],"['loaded', 'loading']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// \note This method does not perform any generation. To generate according to generations specification call RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; ///; /// Details copied from RooAbsPdf::generate():; /// --------------------------------------------; /// \copydetails RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:113,perform,perform,113,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// add an individual (a set of variables) to the population; /// if there is a set of variables which is known to perform good, they can be given as a hint to the population",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticPopulation.cxx:197,perform,perform,197,tmva/tmva/src/GeneticPopulation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticPopulation.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// are we actually generating anything? (the cache always contains at least our function value)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFoamGenerator.cxx:128,cache,cache,128,roofit/roofitcore/src/RooFoamGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFoamGenerator.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// cache stuff about x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooKeysPdf.cxx:86,cache,cache,86,roofit/roofit/src/RooKeysPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooKeysPdf.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// call the Optimizer with the set of parameters and ranges that; /// are meant to be tuned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:95,Optimiz,Optimizer,95,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,2,"['Optimiz', 'tune']","['Optimizer', 'tuned']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// clear all cached pdf objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:96,cache,cached,96,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// clear the cache obtained from the pdf used for speeding the toy and global observables generation; /// needs to be called every time the model pdf (fPdf) changes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx:96,cache,cache,96,roofit/roostats/src/ToyMCSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// define the options (their key words) that can be set in the option string; ///; /// know options:; ///; /// - TrainingMethod `<string>` Training method; /// available values are:; /// - BP Back-Propagation `<default>`; /// - GA Genetic Algorithm (takes a LONG time); ///; /// - LearningRate `<float>` NN learning rate parameter; /// - DecayRate `<float>` Decay rate for learning parameter; /// - TestRate `<int>` Test for overtraining performed at each #%th epochs; ///; /// - BPMode `<string>` Back-propagation learning mode; /// available values are:; /// - sequential `<default>`; /// - batch; ///; /// - BatchSize `<int>` Batch size: number of events/batch, only set if in Batch Mode,; /// - -1 for BatchSize=number_of_events",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:521,perform,performed,521,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// do the actual optimization using a simple scan method,; /// i.e. calculate the FOM for; /// different tuning paraemters and remember which one is; /// gave the best FOM",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/OptimizeConfigParameters.cxx:100,optimiz,optimization,100,tmva/tmva/src/OptimizeConfigParameters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/OptimizeConfigParameters.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// internal methdod performing the projection to 1D histogram; /// called from other TH3::DoProject1D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:103,perform,performing,103,hist/hist/src/TH3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx,1,['perform'],['performing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// internal method performing the projection to 1D histogram; /// called from TH3::Project3D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,perform,performing,102,hist/hist/src/TH3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx,1,['perform'],['performing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// internal method performing the projection to a 2D histogram; /// called from TH3::Project3D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:102,perform,performing,102,hist/hist/src/TH3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx,1,['perform'],['performing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// load the snapshot from ws if it exists",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx:86,load,load,86,roofit/roofitcore/src/ModelConfig.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/ModelConfig.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// lock message queue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:99,queue,queue,99,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// perform conversion of structure to sql statements; /// first tries convert it to normal form; /// if fails, produces data for raw table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/sql/src/TSQLStructure.cxx:86,perform,perform,86,io/sql/src/TSQLStructure.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/sql/src/TSQLStructure.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// performes an orthogonality check and finds if the matrix is a reflection; /// Warning(""CheckMatrix"", ""orthogonality check not performed yet"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx:86,perform,performes,86,geom/geom/src/TGeoMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMatrix.cxx,2,['perform'],"['performed', 'performes']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// performs TMlpANN training; /// available learning methods:; ///; /// - TMultiLayerPerceptron::kStochastic; /// - TMultiLayerPerceptron::kBatch; /// - TMultiLayerPerceptron::kSteepestDescent; /// - TMultiLayerPerceptron::kRibierePolak; /// - TMultiLayerPerceptron::kFletcherReeves; /// - TMultiLayerPerceptron::kBFGS; ///; /// TMultiLayerPerceptron wants test and training tree at once; /// so merge the training and testing trees from the MVA factory first:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodTMlpANN.cxx:86,perform,performs,86,tmva/tmva/src/MethodTMlpANN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodTMlpANN.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// performs the fit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MinuitFitter.cxx:86,perform,performs,86,tmva/tmva/src/MinuitFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MinuitFitter.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// performs the fit by calling Run(pars)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MinuitFitter.cxx:86,perform,performs,86,tmva/tmva/src/MinuitFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MinuitFitter.cxx,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// process the next query from the queue of submitted jobs.; /// to be called on the top master only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:118,queue,queue,118,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// protected function to perform the merge operation of a graph",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:108,perform,perform,108,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// rebuild temporary textfile from xml weightfile and load this; /// file into MLP",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodTMlpANN.cxx:137,load,load,137,tmva/tmva/src/MethodTMlpANN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodTMlpANN.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// retrieve the cache object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx:99,cache,cache,99,roofit/roofit/src/RooLagrangianMorphFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// return the tree if fTree is defined. If not, the method try to load the tree; /// from fTreeFileName.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoord.cxx:149,load,load,149,tree/treeviewer/src/TParallelCoord.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoord.cxx,1,['load'],['load']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// return true if a cache object is present, false otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx:103,cache,cache,103,roofit/roofit/src/RooLagrangianMorphFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// returns a pointer to the TVirtualStreamerInfo object for version; /// If the object does not exist, it is created; ///; /// Note: There are two special version numbers:; ///; /// - 0: Use the class version from the currently loaded class library.; /// - -1: Assume no class library loaded (emulated class).; ///; /// Warning: If we create a new streamer info, whether or not the build; /// optimizes is controlled externally to us by a global variable!; /// Don't call us unless you have set that variable properly; /// with TStreamer::Optimize()!; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:311,load,loaded,311,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,4,"['Optimiz', 'load', 'optimiz']","['Optimize', 'loaded', 'optimizes']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// set default level down to which visualization is performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:135,perform,performed,135,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// specify the parameter points to perform the construction.; /// allow ability to profile on some nuisance parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FeldmanCousins.cxx:118,perform,perform,118,roofit/roostats/src/FeldmanCousins.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/FeldmanCousins.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// standard constructor; ///; /// option string: ""n_training_cycles:n_hidden_layers""; ///; /// default is: n_training_cycles = 5000, n_layers = 4; ///; /// * note that the number of hidden layers in the NN is:; /// n_hidden_layers = n_layers - 2; ///; /// * since there is one input and one output layer. The number of; /// nodes (neurons) is predefined to be:; ///; /// n_nodes[i] = nvars + 1 - i (where i=1..n_layers); ///; /// with nvars being the number of variables used in the NN.; ///; /// Hence, the default case is:; ///; /// n_neurons(layer 1 (input)) : nvars; /// n_neurons(layer 2 (hidden)): nvars-1; /// n_neurons(layer 3 (hidden)): nvars-1; /// n_neurons(layer 4 (out)) : 2; ///; /// This artificial neural network usually needs a relatively large; /// number of cycles to converge (8000 and more). Overtraining can; /// be efficiently tested by comparing the signal and background; /// output of the NN for the events that were used for training and; /// an independent data sample (with equal properties). If the separation; /// performance is significantly better for the training sample, the; /// NN interprets statistical effects, and is hence overtrained. In; /// this case, the number of cycles should be reduced, or the size; /// of the training sample increased.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCFMlpANN.cxx:1128,perform,performance,1128,tmva/tmva/src/MethodCFMlpANN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCFMlpANN.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// static function returning true if optimization can be on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TVirtualStreamerInfo.cxx:120,optimiz,optimization,120,core/meta/src/TVirtualStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TVirtualStreamerInfo.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// static function to set the maximum value of 3 parameters; ///; /// - maxop : maximum number of operations; /// - maxpar : maximum number of parameters; /// - maxconst : maximum number of constants; ///; /// None of these parameters cannot be less than 10 (default is 1000); /// call this function to increase one or all maxima when processing; /// very complex formula, eg TFormula::SetMaxima(100000,1000,1000000);; /// If you process many functions with a small number of operations/parameters; /// you may gain some memory and performance by decreasing these values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:615,perform,performance,615,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// static methdod performing the projection to 1D histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:101,perform,performing,101,hist/hist/src/TH3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx,1,['perform'],['performing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// static methdod performing the projection to 2D histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:101,perform,performing,101,hist/hist/src/TH3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx,1,['perform'],['performing']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/OptimizeConfigParameters.cxx:113,Optimiz,OptimizeConfigParameters,113,tmva/tmva/src/OptimizeConfigParameters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/OptimizeConfigParameters.cxx,1,['Optimiz'],['OptimizeConfigParameters']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// this function is called by GeneticANN for GA optimization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx:131,optimiz,optimization,131,tmva/tmva/src/MethodMLP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodMLP.cxx,1,['optimiz'],['optimization']
Performance,"////////////////////////////////////////////////////////////////////////////////; /// this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves; /// when a new Tree is loaded.; /// Because Trees in a TChain may have a different list of leaves, one; /// must update the leaves numbers in the TTreeFormula used by the TreeIndex.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx:121,Load,LoadTree,121,tree/treeplayer/src/TTreeIndex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeIndex.cxx,2,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// this function is called by TChain::LoadTree when a new Tree is loaded.; /// Because Trees in a TChain may have a different list of leaves, one; /// must update the leaves numbers in the TTreeFormula used by the TreePlayer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:121,Load,LoadTree,121,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,2,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,"////////////////////////////////////////////////////////////////////////////////; /// unlock message queue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:101,queue,queue,101,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,1,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///; /// F(x,y) = 100 (y-x^2)^2 + (1-x)^2; ///; /// start point: F(-1.2,1.0) = 24.20; /// minimum : F(1.0,1.0) = 0.; ///; /// This narrow, parabolic valley is probably the best known of all test cases. The floor; /// of the valley follows approximately the parabola y = x^2+1/200 .; /// There is a region where the covariance matrix is not positive-definite and even a path; /// where it is singular . Stepping methods tend to perform at least as well as gradient; /// method for this function .; /// [Reference: Comput. J. 3,175 (1960).]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressFit.cxx:509,perform,perform,509,test/stressFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressFit.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///; /// Process a cache miss; (pos, len) isn't in the buffer.; ///; /// The first time we have a miss, we buffer as many baskets we can (up to the; /// maximum size of the TTreeCache) in memory from all branches that are not in; /// the prefetch list.; ///; /// Subsequent times, we fetch all the buffers corresponding to branches that; /// had previously seen misses. If it turns out the (pos, len) isn't in the; /// list of branches, we treat this as if it was the first miss.; ///; /// Returns true if we were able to pull the data into the miss cache.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:101,cache,cache,101,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,2,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///; /// Return value of x (in range xmin,xmax) at which function equals yval.; /// (Calculation is performed with Brent root finding algorithm)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:182,perform,performed,182,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///; /// \class TQpDataBase; ///; /// Data for the general QP formulation; ///; /// The Data class stores the data defining the problem and provides; /// methods for performing the operations with this data required by; /// the interior-point algorithms. These operations include assembling; /// the linear systems (5) or (7), performing matrix-vector operations; /// with the data, calculating norms of the data, reading input into the; /// data structure from various sources, generating random problem; /// instances, and printing the data.; ///; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpDataBase.cxx:248,perform,performing,248,math/quadp/src/TQpDataBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpDataBase.cxx,2,['perform'],['performing']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///Cache all data for TH2Poly object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLH2PolyPainter.cxx:85,Cache,Cache,85,graf3d/gl/src/TGLH2PolyPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLH2PolyPainter.cxx,1,['Cache'],['Cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///Creates the fftw-plan; ///; ///NOTE: input and output arrays are overwritten during initialisation,; /// so don't set any points, before running this function!!!!!; ///; /// #### 1st parameter:; /// Possible flag_options:; ///; /// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; /// performance; /// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; /// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; /// - ""EX"" (from ""exhaustive"") - the most optimal way is found; ///; /// This option should be chosen depending on how many transforms of the same size and; /// type are going to be done. Planning is only done once, for the first transform of this; /// size and type.; ///; /// #### 2nd parameter:; /// is dummy and doesn't need to be specified; ///; /// #### 3rd parameter:; /// transform kind for each dimension; /// 4 different kinds of sine and cosine transforms are available; /// - DCT-I - kind=0; /// - DCT-II - kind=1; /// - DCT-III - kind=2; /// - DCT-IV - kind=3; /// - DST-I - kind=4; /// - DST-II - kind=5; /// - DSTIII - kind=6; /// - DSTIV - kind=7",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTReal.cxx:410,perform,performance,410,math/fftw/src/TFFTReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTReal.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///Creates the fftw-plan; ///; ///NOTE: input and output arrays are overwritten during initialisation,; /// so don't set any points, before running this function!!!!!; ///; ///2nd parameter: +1; ///; ///Argument kind is dummy and doesn't need to be specified; ///; ///Possible flag_options:; /// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; /// performance; /// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; /// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; /// - ""EX"" (from ""exhaustive"") - the most optimal way is found; ///This option should be chosen depending on how many transforms of the same size and; ///type are going to be done. Planning is only done once, for the first transform of this; ///size and type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTComplex.cxx:471,perform,performance,471,math/fftw/src/TFFTComplex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTComplex.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///Creates the fftw-plan; ///; ///NOTE: input and output arrays are overwritten during initialisation,; /// so don't set any points, before running this function!!!!!; ///; ///Arguments sign and kind are dummy and not need to be specified; ///Possible flag_options:; ///; /// - ""ES"" (from ""estimate"") - no time in preparing the transform, but probably sub-optimal; /// performance; /// - ""M"" (from ""measure"") - some time spend in finding the optimal way to do the transform; /// - ""P"" (from ""patient"") - more time spend in finding the optimal way to do the transform; /// - ""EX"" (from ""exhaustive"") - the most optimal way is found; ///; ///This option should be chosen depending on how many transforms of the same size and; ///type are going to be done. Planning is only done once, for the first transform of this; ///size and type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTComplexReal.cxx:451,perform,performance,451,math/fftw/src/TFFTComplexReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fftw/src/TFFTComplexReal.cxx,2,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///From original version.; /// Main event loop waiting till time arrives to pop down logo; /// or when forced by button press event.; ///From me: this even loop seems to be quite twisted and ugly.; ///The original code does not work now though - event queue is; ///growing and at some point you already not able to extract a; ///button press event (for example) and close a splashscreen window.; ///With my first version I also had problems - somehow I was missing; ///the first expose event (from time to time).; ///Now I empty the event queue on every iteration (selecting; ///interesting events only).; ///Why original version ignore this - I have no idea.; ///We have at least NoExpose events in a queue (generated by XCopyArea); ///and somebody obviously have to remove them eventually.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootxx.cxx:334,queue,queue,334,rootx/src/rootxx.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/rootx/src/rootxx.cxx,3,['queue'],['queue']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///Loading Dataset from DataInputHandler for subseed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataLoader.cxx:85,Load,Loading,85,tmva/tmva/src/DataLoader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataLoader.cxx,1,['Load'],['Loading']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///Returns a pointer to a sine or cosine transform of requested size and kind; ///; ///Parameters:; /// \param [in] ndim number of transform dimensions; /// \param [in] n sizes of each dimension (an array at least ndim long); /// \param [in] r2rkind transform kind for each dimension; /// 4 different kinds of sine and cosine transforms are available; /// - DCT-I - kind=0; /// - DCT-II - kind=1; /// - DCT-III - kind=2; /// - DCT-IV - kind=3; /// - DST-I - kind=4; /// - DST-II - kind=5; /// - DST-III - kind=6; /// - DST-IV - kind=7; /// \param [in] option : consists of 2 parts; /// - flag option and an option to create a new TVirtualFFT; /// - flag option: choosing how much time should be spent in planning the transform:; /// Possible options:; /// - ""ES"" (from ""estimate"") - no time in preparing the transform,; /// but probably sub-optimal performance; /// - ""M"" (from ""measure"") - some time spend in finding the optimal way; /// to do the transform; /// - ""P"" (from ""patient"") - more time spend in finding the optimal way; /// to do the transform; /// - ""EX"" (from ""exhaustive"") - the most optimal way is found; /// This option should be chosen depending on how many transforms of the; /// same size and type are going to be done.; /// Planning is only done once, for the first transform of this size and type.; /// - option allowing to choose between the global fgFFT and a new TVirtualFFT object; /// - """" - default, changes and returns the global fgFFT variable; /// - ""K"" (from ""keep"")- without touching the global fgFFT,; /// creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; /// Examples of valid options: ""ES K"", ""EX"", etc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualFFT.cxx:931,perform,performance,931,core/base/src/TVirtualFFT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualFFT.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///Returns a pointer to the FFT of requested size and type.; ///; /// \param[in] ndim number of transform dimensions; /// \param[in] n sizes of each dimension (an array at least ndim long); /// \param [in] option consists of 3 parts - flag option and an option to create a new TVirtualFFT; /// 1. transform type option:; /// Available transform types are:; /// C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; /// see class description for details; /// 2. flag option: choosing how much time should be spent in planning the transform:; /// Possible options:; /// - ""ES"" (from ""estimate"") - no time in preparing the transform,; /// but probably sub-optimal performance; /// - ""M"" (from ""measure"") - some time spend in finding the optimal way; /// to do the transform; /// - ""P"" (from ""patient"") - more time spend in finding the optimal way; /// to do the transform; /// - ""EX"" (from ""exhaustive"") - the most optimal way is found; /// This option should be chosen depending on how many transforms of the; /// same size and type are going to be done.; /// Planning is only done once, for the first transform of this size and type.; /// 3. option allowing to choose between the global fgFFT and a new TVirtualFFT object; /// """" - default, changes and returns the global fgFFT variable; /// ""K"" (from ""keep"")- without touching the global fgFFT,; /// creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; ///; /// Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualFFT.cxx:741,perform,performance,741,core/base/src/TVirtualFFT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TVirtualFFT.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///Set the coordinate `#ndim` of all points (the column `#ndim` of the data matrix); ///After setting all the data columns, proceed by calling Build() function; ///Note, that calling this function after Build() is not possible; ///Note also, that no checks on the array sizes is performed anywhere",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTree.cxx:361,perform,performed,361,math/mathcore/src/TKDTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTree.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///\returns true if the module map was loaded, false on error or if the map was; /// already loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:121,load,loaded,121,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,2,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///\returns true if the module was loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:117,load,loaded,117,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['load'],['loaded']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///interface to TTreeCache to set the cache entry range; ///; /// Returns:; /// - 0 entry range set; /// - -1 on error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:120,cache,cache,120,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////////; ///update pointer to current Tree and recompute pointers to the branches in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:162,cache,cache,162,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['cache'],['cache']
Performance,"///////////////////////////////////////////////////////////////////////////////; /// Helper to load a single object from a file-resident TFolder, while; /// avoiding memory leaks.; /// @tparam AObjType Type of object to load.; /// @param inFile input file to load from. Expected to be a valid pointer; /// @param folderName Name of the TFolder to load from the file; /// @param objName Name of the object to load; /// @param notFoundError If set, print a detailed error if we didn't find something; /// @return Returns a pointer to a clone of the loaded object. Ownership assigned to the caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx:95,load,load,95,roofit/roofit/src/RooLagrangianMorphFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx,6,['load'],"['load', 'loaded']"
Performance,"///////////////////////////////////////////////////////////////////////////////; /// Label OK'ed components with cache-and-track",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx:113,cache,cache-and-track,113,roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,1,['cache'],['cache-and-track']
Performance,"///////////////////////////////////////////////////////////////////////////////; /// Load a TFolder from a file while ensuring it owns its content.; /// This avoids memory leaks. Note that when fetching objects; /// from this folder, you need to clone them to prevent deletion.; /// Also recursively updates nested subfolders accordingly; /// @param inFile: Input file to read - assumed to be a valid pointer; /// @param folderName: Name of the folder to read from the file; /// @return a unique_ptr to the folder. Nullptr if not found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx:85,Load,Load,85,roofit/roofit/src/RooLagrangianMorphFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooLagrangianMorphFunc.cxx,1,['Load'],['Load']
Performance,"///////////////////////////////////////////////////////////////////////////////; /// Load all libraries known to ROOT via the rootmap system.; /// Returns the number of top level libraries successfully loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:85,Load,Load,85,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,2,"['Load', 'load']","['Load', 'loaded']"
Performance,"///////////////////////////////////////////////////////////////////////////////; /// Retrieve the minimum and maximum values in the histogram; ///; /// This will not return a cached value and will always search the; /// histogram for the min and max values. The user can condition whether; /// or not to call this with the GetMinimumStored() and GetMaximumStored(); /// methods. If the cache is empty, then the value will be -1111. Users; /// can then use the SetMinimum() or SetMaximum() methods to cache the results.; /// For example, the following recipe will make efficient use of this method; /// and the cached minimum and maximum values.; //; /// \code{.cpp}; /// Double_t currentMin = pHist->GetMinimumStored();; /// Double_t currentMax = pHist->GetMaximumStored();; /// if ((currentMin == -1111) || (currentMax == -1111)) {; /// pHist->GetMinimumAndMaximum(currentMin, currentMax);; /// pHist->SetMinimum(currentMin);; /// pHist->SetMaximum(currentMax);; /// }; /// \endcode; ///; /// \param min reference to variable that will hold found minimum value; /// \param max reference to variable that will hold found maximum value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:175,cache,cached,175,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,4,['cache'],"['cache', 'cached']"
Performance,"///////////////////////////////////////////////////////////////////////////////; /// Unserialize Python object; ///; /// \param[in] path Path to serialized Python object; /// \param[in] obj Python object where the unserialized Python object is loaded; /// \return Error code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/PyMethodBase.cxx:244,load,loaded,244,tmva/pymva/src/PyMethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/PyMethodBase.cxx,1,['load'],['loaded']
Performance,"///////////////////////////////////////////////////////////////////////////////; //; // PROFILE LIKELIHOOD CALCULATOR HYPOTHESIS TEST - ON / OFF MODEL; //; // Perform a hypothesis test using the ProfileLikelihoodCalculator on the; // on/off model. Reference values and test values are both computed with the; // ProfileLikelihoodCalculator. As such, this test can only confirm if the; // ProfileLikelihoodCalculator has the same behaviour across different; // computing platforms or RooStats revisions.; //; // ModelConfig (explicit) : Poisson On / Off Model; // built in stressRooStats_models.cxx; //; // For a detailed description of the on/off model, see the paper: ""Evaluation; // of three methods for calculating statistical significance when incorporating; // a systematic uncertainty into a test of the background-only hypothesis for; // a Poisson process"" by Robert D. Cousins, James T. Linnemann, Jordan Tucker; //; // 04/2012 - Ioan Gabriel Bucur; //; ///////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h:159,Perform,Perform,159,roofit/roostats/test/stressRooStats_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h,1,['Perform'],['Perform']
Performance,"//////////////////////////////////////////////////////////////////////////////; /// Globally enables the parallel branch processing, which is a case of; /// implicit multi-threading (IMT) in ROOT, activating the required locks.; /// This IMT use case, implemented in TTree::GetEntry, spawns a task for; /// each branch of the tree. Therefore, a task takes care of the reading,; /// decompression and deserialisation of a given branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:166,multi-thread,multi-threading,166,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['multi-thread'],['multi-threading']
Performance,"//////////////////////////////////////////////////////////////////////////////; /// Post process http request; ///; /// Normally requests from client does not replied directly for longpoll socket; /// Therefore one can use such request to send data, which was submitted before to the queue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpLongPollEngine.cxx:284,queue,queue,284,net/http/src/THttpLongPollEngine.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpLongPollEngine.cxx,1,['queue'],['queue']
Performance,"//////////////////////////////////////////////////////////////////////////////; /// Taylor expanding given function in terms of observables around; /// observableValues. Supports expansions upto order 2.; /// \param[in] func Function of variables that is taylor expanded.; /// \param[in] observables Set of variables to perform the expansion.; /// It's type is RooArgList to ensure that it is always ordered the; /// same as the observableValues vector. However, duplicate; /// observables are still not allowed.; /// \param[in] order Order of the expansion (0,1,2 supported).; /// \param[in] observableValues Coordinates around which expansion is; /// performed. If empty, the nominal observable values are taken, if; /// the size matches the size of the observables RooArgSet, the; /// values are mapped to the observables in matching order. If it; /// contains only one element, the same single value is used for all; /// observables.; /// \param[in] eps1 Precision for first derivative and second derivative.; /// \param[in] eps2 Precision for second partial derivative of cross-derivative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooPolyFunc.cxx:320,perform,perform,320,roofit/roofitcore/src/RooPolyFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooPolyFunc.cxx,2,['perform'],"['perform', 'performed']"
Performance,"/////////////////////////////////////////////////////////////////////////////; /// Refresh the cached read entry number from the original tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFriendProxy.cxx:95,cache,cached,95,tree/treeplayer/src/TFriendProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFriendProxy.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////; // //; // TTabCom //; // //; // This class performs basic tab completion. //; // You should be able to hit [TAB] to complete a partially typed: //; // //; // username //; // environment variable //; // preprocessor directive //; // pragma //; // filename (with a context-sensitive path) //; // public member function or data member //; // global variable, function, or class name //; // //; // Also, something like gWhatever->Func([TAB] will print the appropriate //; // list of prototypes. For a list of some limitations see the source. //; // //; ////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/inc/TTabCom.h:121,perform,performs,121,core/rint/inc/TTabCom.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/inc/TTabCom.h,1,['perform'],['performs']
Performance,"////////////////////////////////////////////////////////////////////////////; /// As the database is read-only, locks for concurrent access are no-ops and always succeeds",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:122,concurren,concurrent,122,tree/dataframe/src/RSqliteDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx,3,['concurren'],['concurrent']
Performance,"////////////////////////////////////////////////////////////////////////////; /// Returns the SELECT queries names. The column names have been cached in the constructor.; /// For expressions, the column name is the string of the expression unless the query defines a column name with as; /// like in ""SELECT 1 + 1 as mycolumn FROM table""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:143,cache,cached,143,tree/dataframe/src/RSqliteDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////; /// Returns the cached file size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx:94,cache,cached,94,tree/dataframe/src/RSqliteDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSqliteDS.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////; /// \anchor optimisationInterface; /// \name Optimisation interface; /// These functions allow RooFit to optimise a computation graph, to keep track; /// of cached values, and to invalidate caches.; /// @{; // Cache mode optimization (tracks changes & do lazy evaluation vs evaluate always)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h:235,cache,cached,235,roofit/roofitcore/inc/RooAbsArg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h,4,"['Cache', 'cache', 'optimiz']","['Cache', 'cached', 'caches', 'optimization']"
Performance,"////////////////////////////////////////////////////////////////////////////; /// \brief Append a filter to the call graph.; /// \param[in] f Function, lambda expression, functor class or any other callable object. It must return a `bool`; /// signalling whether the event has passed the selection (true) or not (false).; /// \param[in] columns Names of the columns/branches in input to the filter function.; /// \param[in] name Optional name of this filter. See `Report`.; /// \return the filter node of the computation graph.; ///; /// Append a filter node at the point of the call graph corresponding to the; /// object this method is called on.; /// The callable `f` should not have side-effects (e.g. modification of an; /// external or static variable) to ensure correct results when implicit; /// multi-threading is active.; ///; /// RDataFrame only evaluates filters when necessary: if multiple filters; /// are chained one after another, they are executed in order and the first; /// one returning false causes the event to be discarded.; /// Even if multiple actions or transformations depend on the same filter,; /// it is executed once per entry. If its result is requested more than; /// once, the cached result is served.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // C++ callable (function, functor class, lambda...) that takes two parameters of the types of ""x"" and ""y""; /// auto filtered = df.Filter(myCut, {""x"", ""y""});; ///; /// // String: it must contain valid C++ except that column names can be used instead of variable names; /// auto filtered = df.Filter(""x*y > 0"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Filter(""Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Filter(""return Sum(Map(vec, [](f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:804,multi-thread,multi-threading,804,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['multi-thread'],['multi-threading']
Performance,"////////////////////////////////////////////////////////////////////////////; /// \brief Cast any RDataFrame node to a common type ROOT::RDF::RNode.; /// Different RDataFrame methods return different C++ types. All nodes, however,; /// can be cast to this common type at the cost of a small performance penalty.; /// This allows, for example, storing RDataFrame nodes in a vector, or passing them; /// around via (non-template, C++11) helper functions.; /// Example usage:; /// ~~~{.cpp}; /// // a function that conditionally adds a Range to a RDataFrame node.; /// RNode MaybeAddRange(RNode df, bool mustAddRange); /// {; /// return mustAddRange ? df.Range(1) : df;; /// }; /// // use as :; /// ROOT::RDataFrame df(10);; /// auto maybeRanged = MaybeAddRange(df, true);; /// ~~~; /// Note that it is not a problem to pass RNode's by value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:291,perform,performance,291,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////////////////////////////; /// \brief Implementation of cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:107,cache,cache,107,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['cache'],['cache']
Performance,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \param[in] columnList columns to be cached in memory.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// See the previous overloads for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:163,cache,cached,163,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,2,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \param[in] columnList columns to be cached in memory; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// See the previous overloads for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:163,cache,cached,163,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,2,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////////; /// \brief Save selected columns in memory.; /// \param[in] columnNameRegexp The regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is implicitly assumed if they are not specified. The dialect supported is PCRE via the TPRegexp class. An empty string signals the selection of all columns.; /// \return a `RDataFrame` that wraps the cached dataset.; ///; /// The existing columns are matched against the regular expression. If the string provided; /// is empty, all columns are selected. See the previous overloads for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:477,cache,cached,477,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['cache'],['cached']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // Bytes //; // //; // A set of inline byte handling routines. //; // //; // The set of tobuf() and frombuf() routines take care of packing a //; // basic type value into a buffer in network byte order (i.e. they //; // perform byte swapping when needed). The buffer does not have to //; // start on a machine (long) word boundary. //; // //; // For __GNUC__ on linux on i486 processors and up //; // use the `bswap' opcode provided by the GNU C Library. //; // //; // The set of host2net() and net2host() routines convert a basic type //; // value from host to network byte order and vice versa. On BIG ENDIAN //; // machines this is a no op. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Bytes.h:303,perform,perform,303,core/base/inc/Bytes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Bytes.h,1,['perform'],['perform']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // RegressionVariance //; // //; // Calculate the ""SeparationGain"" for Regression analysis //; // separation criteria used in various training algorithms //; // //; // There are two things: the Separation Index, and the Separation Gain //; // Separation Index: //; // Measure of the ""Variance"" of a sample. //; // //; // Separation Gain: //; // the measure of how the quality of separation of the sample increases //; // by splitting the sample e.g. into a ""left-node"" and a ""right-node"" //; // (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right) //; // this is then the quality criteria which is optimized for when trying //; // to increase the information in the system (making the best selection //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RegressionVariance.h:697,optimiz,optimized,697,tmva/tmva/inc/TMVA/RegressionVariance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RegressionVariance.h,1,['optimiz'],['optimized']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // SeparationBase //; // //; // An interface to calculate the ""SeparationGain"" for different //; // separation criteria used in various training algorithms //; // //; // There are two things: the Separation Index, and the Separation Gain //; // Separation Index: //; // Measure of the ""purity"" of a sample. If all elements (events) in the //; // sample belong to the same class (e.g. signal or background), than the//; // separation index is 0 (meaning 100% purity (or 0% purity as it is //; // symmetric. The index becomes maximal, for perfectly mixed samples //; // eg. purity=50% , N_signal = N_bkg //; // //; // Separation Gain: //; // the measure of how the quality of separation of the sample increases //; // by splitting the sample e.g. into a ""left-node"" and a ""right-node"" //; // (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right) //; // this is then the quality criterion which is optimized for when trying//; // to increase the information in the system (making the best selection //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/SeparationBase.h:993,optimiz,optimized,993,tmva/tmva/inc/TMVA/SeparationBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/SeparationBase.h,1,['optimiz'],['optimized']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TBranchCacheInfo //; // //; // Hold info about which basket are in the cache and if they //; // have been retrieved from the cache. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:157,cache,cache,157,tree/tree/inc/TBranchCacheInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h,2,['cache'],['cache']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TDavixFile //; // //; // A TDavixFile is like a normal TFile except that it uses //; // libdavix to read/write remote files. //; // It supports HTTP and HTTPS in a number of dialects and options //; // e.g. S3 is one of them //; // Other caracteristics come from the full support of Davix, //; // e.g. full redirection support in any circumstance //; // //; // Authors: Adrien Devresse (CERN IT/SDC) //; // Tigran Mkrtchyan (DESY) //; // //; // Checks, refactoring and ROOT5 porting: //; // Fabrizio Furano (CERN IT/SDC) //; // //; // September 2013 //; // //; //////////////////////////////////////////////////////////////////////////; //; // Parameters that influence the behavior of TDavixFile/TDavixSystem. The names should be self-explanatory; //; //Davix.Debug; //Davix.GSI.UserProxy; //Davix.GSI.UserCert; //Davix.GSI.UserKey; //Davix.GSI.CAdir; //Davix.GSI.CACheck; //Davix.GSI.GridMode; //; //Davix.S3.AccessKey; //Davix.S3.SecretKey; //Davix.S3.Region; //Davix.S3.Token; //; // Environment variables:; // X509_USER_CERT, X509_USER_KEY, X509_USER_PROXY ... usual meaning for the X509 Grid things. gEnv vars have higher priority.; // S3_ACCESS_KEY, S3_SECRET_KEY, S3_REGION, S3_TOKEN. gEnv vars have higher priority.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/davix/inc/TDavixFile.h:951,CAChe,CACheck,951,net/davix/inc/TDavixFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/davix/inc/TDavixFile.h,1,['CAChe'],['CACheck']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TFTP //; // //; // This class provides all infrastructure for a performant file //; // transfer protocol. It works in conjuction with the rootd daemon //; // and can use parallel sockets to improve performance over fat pipes. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TFTP.h:150,perform,performant,150,net/net/inc/TFTP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TFTP.h,2,['perform'],"['performance', 'performant']"
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TFileStager //; // //; // Abstract base class defining an interface to a stager. //; // //; // To open a connection to a stager use the static method //; // Open(""<stager>""), where <stager> contains a keyword allowing to load //; // the relevant plug-in, e.g. //; // TFileStager::Open(""root://lxb6064.cern.ch"") //; // will load TNetNXGFileStager and initialize it for the redirector at //; // lxb6046.cern.ch . //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TFileStager.h:307,load,load,307,net/net/inc/TFileStager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TFileStager.h,2,['load'],['load']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TGLClip //; // //; // Abstract clipping shape - derives from TGLPhysicalShape //; // Adds clip mode (inside/outside) and pure virtual method to //; // approximate shape as set of planes. This plane set is used to perform//; // interactive clipping using OpenGL clip planes. //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLClip.h:299,perform,perform,299,graf3d/gl/inc/TGLClip.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLClip.h,1,['perform'],['perform']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TGLStopwatch //; // //; // Stopwatch object for timing GL work. We do not use the TStopwatch as //; // we need to perform GL flushing to get accurate times + we record //; // timing overheads here. //; //; // MT: Bypassed all of the overhead stuff. It does not seem reasonable; // anyway. Besides it was being initialized outside of a valid GL; // context and coused random crashes (especially on 64-bit machines with; // nvidia cards).; //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLStopwatch.h:200,perform,perform,200,graf3d/gl/inc/TGLStopwatch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLStopwatch.h,1,['perform'],['perform']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TPServerSocket //; // //; // This class implements parallel server sockets. A parallel server //; // socket waits for requests to come in over the network. It performs //; // some operation based on that request and then possibly returns a //; // full duplex parallel socket to the requester. The actual work is //; // done via the TSystem class (either TUnixSystem or TWinNTSystem). //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TPServerSocket.h:245,perform,performs,245,net/net/inc/TPServerSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TPServerSocket.h,1,['perform'],['performs']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TPSocket //; // //; // This class implements parallel client sockets. A parallel socket is //; // an endpoint for communication between two machines. It is parallel //; // because several TSockets are open at the same time to the same //; // destination. This especially speeds up communication over Big Fat //; // Pipes (i.e. high bandwidth, high latency WAN connections). //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TPSocket.h:434,latency,latency,434,net/net/inc/TPSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TPSocket.h,1,['latency'],['latency']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TPacketizer //; // //; // This class generates packets to be processed on PROOF slave servers. //; // A packet is an event range (begin entry and number of entries) or //; // object range (first object and number of objects) in a TTree //; // (entries) or a directory (objects) in a file. //; // Packets are generated taking into account the performance of the //; // remote machine, the time it took to process a previous packet on //; // the remote machine, the locality of the database files, etc. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizer.h:428,perform,performance,428,proof/proofplayer/inc/TPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizer.h,1,['perform'],['performance']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TPacketizerAdaptive //; // //; // This packetizer is based on TPacketizer but uses different //; // load-balancing algorithms and data structures. //; // Two main improvements in the load-balancing strategy: //; // - First one was to change the order in which the files are assigned //; // to the computing nodes in such a way that network transfers are //; // evenly distributed in the query time. Transfer of the remote files //; // was often becoming a bottleneck at the end of a query. //; // - The other improvement is the use of time-based packet size. We //; // measure the processing rate of all the nodes and calculate the //; // packet size, so that it takes certain amount of time. In this way //; // packetizer prevents the situation where the query can't finish //; // because of one slow node. //; // //; // The data structures: TFileStat, TFileNode and TSlaveStat are //; // enriched + changed and TFileNode::Compare method is changed. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizerAdaptive.h:186,load,load-balancing,186,proof/proofplayer/inc/TPacketizerAdaptive.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizerAdaptive.h,3,"['bottleneck', 'load']","['bottleneck', 'load-balancing']"
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TPacketizerUnit //; // //; // This packetizer generates packets of generic units, representing the //; // number of times an operation cycle has to be repeated by the worker //; // node, e.g. the number of Monte carlo events to be generated. //; // Packets sizes are generated taking into account the performance of //; // worker nodes, based on the time needed to process previous packets, //; // with the goal of having all workers ending at the same time. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizerUnit.h:387,perform,performance,387,proof/proofplayer/inc/TPacketizerUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizerUnit.h,1,['perform'],['performance']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TProofBenchRunDataRead //; // //; // I/O-intensive PROOF benchmark test reads in event files distributed //; // on the cluster. Number of events processed per second and size of //; // events processed per second are plotted against number of active //; // workers. Performance rate for unit packets and performance rate //; // for query are plotted. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchRunDataRead.h:352,Perform,Performance,352,proof/proofbench/inc/TProofBenchRunDataRead.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofBenchRunDataRead.h,2,"['Perform', 'perform']","['Performance', 'performance']"
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TProofPerfAnalysis //; // //; // Set of tools to analyse the performance tree //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofPerfAnalysis.h:147,perform,performance,147,proof/proofbench/inc/TProofPerfAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TProofPerfAnalysis.h,1,['perform'],['performance']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TProofServLite //; // //; // TProofServLite is the version of the PROOF worker server for local //; // running. The client starts directly the desired number of these //; // workers; the master and daemons are eliminated, optimizing the number//; // of messages exchanged and created / destroyed. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofServLite.h:308,optimiz,optimizing,308,proof/proof/inc/TProofServLite.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProofServLite.h,1,['optimiz'],['optimizing']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TSQLServer //; // //; // Abstract base class defining interface to a SQL server. //; // //; // To open a connection to a server use the static method Connect(). //; // The db argument of Connect() is of the form: //; // <dbms>://<host>[:<port>][/<database>], e.g. //; // mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ... //; // Depending on the <dbms> specified an appropriate plugin library //; // will be loaded which will provide the real interface. //; // //; // Related classes are TSQLStatement, TSQLResult and TSQLRow. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSQLServer.h:509,load,loaded,509,net/net/inc/TSQLServer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TSQLServer.h,1,['load'],['loaded']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TSelEvent //; // //; // PROOF selector for I/O benchmark test. //; // For I/O benchmark, event files are read in and histograms are filled.//; // For memory clean-up, dedicated files large enough to clean up memory //; // cache on the machine are read in. Or memory clean-up can be //; // accompolished by system call on Linux machine inside SlaveBegin(..) //; // which should be much faster the reading in large files. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TSelEvent.h:308,cache,cache,308,proof/proofbench/inc/TSelEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TSelEvent.h,1,['cache'],['cache']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TSelHandleDataSet //; // //; // PROOF selector for file cache release. //; // List of files to be cleaned for each node is provided by client. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TSelHandleDataSet.h:142,cache,cache,142,proof/proofbench/inc/TSelHandleDataSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/inc/TSelHandleDataSet.h,1,['cache'],['cache']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TServerSocket //; // //; // This class implements server sockets. A server socket waits for //; // requests to come in over the network. It performs some operation //; // based on that request and then possibly returns a full duplex socket //; // to the requester. The actual work is done via the TSystem class //; // (either TUnixSystem or TWinNTSystem). //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TServerSocket.h:226,perform,performs,226,net/net/inc/TServerSocket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TServerSocket.h,1,['perform'],['performs']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TSlave //; // //; // This class describes a PROOF slave server. //; // It contains information like the slaves host name, ordinal number, //; // performance index, socket, etc. Objects of this class can only be //; // created via TProof member functions. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TSlave.h:231,perform,performance,231,proof/proof/inc/TSlave.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TSlave.h,1,['perform'],['performance']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TThreadPool //; // This class implement a simple Thread Pool pattern. //; // So far it supports only one type of queue - FIFO //; // //; // Please see the tutorial ""tutorials/thread/threadPool.C"" for //; // more details on how to use TThreadPool. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/TThreadPool.h:199,queue,queue,199,core/thread/inc/TThreadPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/TThreadPool.h,1,['queue'],['queue']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TTreePerfStats //; // //; // TTree I/O performance measurement //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreePerfStats.h:125,perform,performance,125,tree/treeplayer/inc/TTreePerfStats.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreePerfStats.h,1,['perform'],['performance']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TVirtualMutex //; // //; // This class implements a mutex interface. The actual work is done via //; // TMutex which is available as soon as the thread library is loaded. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualMutex.h:249,load,loaded,249,core/base/inc/TVirtualMutex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualMutex.h,1,['load'],['loaded']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TVirtualPacketizer //; // //; // Packetizer is a load balancing object created for each query. //; // It generates packets to be processed on PROOF worker servers. //; // A packet is an event range (begin entry and number of entries) or //; // object range (first object and number of objects) in a TTree //; // (entries) or a directory (objects) in a file. //; // Packets are generated taking into account the performance of the //; // remote machine, the time it took to process a previous packet on //; // the remote machine, the locality of the database files, etc. //; // //; // TVirtualPacketizer includes common parts of PROOF packetizers. //; // Look in subclasses for details. //; // The default packetizer is TPacketizerAdaptive. //; // To use an alternative one, for instance - the TPacketizer, call: //; // proof->SetParameter(""PROOF_Packetizer"", ""TPacketizer""); //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TVirtualPacketizer.h:135,load,load,135,proof/proof/inc/TVirtualPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TVirtualPacketizer.h,2,"['load', 'perform']","['load', 'performance']"
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // TVirtualPerfStats //; // //; // Provides the interface for the PROOF internal performance measurment //; // and event tracing. //; // //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualPerfStats.h:164,perform,performance,164,core/base/inc/TVirtualPerfStats.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TVirtualPerfStats.h,1,['perform'],['performance']
Performance,"//////////////////////////////////////////////////////////////////////////; // //; // class TGenBitsetProxy; //; // Local optimization class.; //; // Collection proxies get copied. On copy we switch the type of the; // proxy to the concrete STL type. The concrete types are optimized; // for element access.; //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx:122,optimiz,optimization,122,io/io/src/TGenCollectionProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx,2,['optimiz'],"['optimization', 'optimized']"
Performance,"//////////////////////////////////////////////////////////////////////////; // TEntryListFromFile; //; // Manages entry lists from different files, when they are not loaded; // in memory at the same time.; //; // This entry list should only be used when processing a TChain (see; // TChain::SetEntryList() function). File naming convention:; // - by default, filename_elist.root is used, where filename is the; // name of the chain element.; // - xxx$xxx.root - $ sign is replaced by the name of the chain element; // If the list name is not specified (by passing filename_elist.root/listname to; // the TChain::SetEntryList() function, the first object of class TEntryList; // in the file is taken.; // It is assumed that there are as many lists, as there are chain elements,; // and they are in the same order.; //; // If one of the list files can't be opened, or there is an error reading a list; // from the file, this list is skipped and the entry loop continues on the next; // list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListFromFile.h:166,load,loaded,166,tree/tree/inc/TEntryListFromFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListFromFile.h,1,['load'],['loaded']
Performance,"//////////////////////////////////////////////////////////////////////////; /// Load the required tree and evaluate the processing range",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TMPWorkerTree.cxx:80,Load,Load,80,tree/treeplayer/src/TMPWorkerTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TMPWorkerTree.cxx,1,['Load'],['Load']
Performance,"//////////////////////////////////////////////////////////////////////////; /// Receive message from a socket.; /// This standalone function can be used to read a message that; /// has been sent via MPSend(). The smart pointer contained in the returned; /// ::MPCodeBufPair is null if the message does not contain an object,; /// otherwise it points to a TBufferFile.; /// To retrieve the object from the buffer different methods must be used; /// depending on the type of the object to be read:\n; /// * non-pointer built-in types: TBufferFile::operator>> must be used\n; /// * c-strings: TBufferFile::ReadString must be used\n; /// * class types: TBufferFile::ReadObjectAny must be used\n; /// \param s a pointer to a valid TSocket. No validity checks are performed\n; /// \return ::MPCodeBufPair, i.e. an std::pair containing message code and (possibly) object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/src/MPSendRecv.cxx:758,perform,performed,758,core/multiproc/src/MPSendRecv.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/src/MPSendRecv.cxx,1,['perform'],['performed']
Performance,"//////////////////////////////////////////////////////////////////////////; /// Run canvas functionality for the given time (in seconds); /// Used to process canvas-related actions in the appropriate thread context.; /// Must be regularly called when canvas created and used in extra thread.; /// Time parameter specifies minimal execution time in seconds - if default value 0 is used,; /// just all pending actions will be performed.; /// When canvas is not yet displayed - just performs sleep for given time interval.; ///; /// Example of usage:; ///; /// ~~~ {.cpp}; /// void draw_canvas(bool &run_loop, std::make_shared<RH1D> hist); /// {; /// auto canvas = RCanvas::Create(""Canvas title"");; /// canvas->Draw(hist)->SetLineColor(RColor::kBlue);; /// canvas->Show();; /// while (run_loop) {; /// pHist->Fill(1);; /// canvas->Modified();; /// canvas->Update();; /// canvas->Run(0.1); // process canvas events; /// }; ///; /// canvas->Remove();; /// }; ///; /// int main(); /// {; /// RAxisConfig xaxis(100, -10., 10.);; /// auto pHist = std::make_shared<RH1D>(xaxis);; /// bool run_loop = true;; ///; /// std::thread thrd(draw_canvas, run_loop, pHist);; /// std::this_thread::sleep_for(std::chrono::seconds(100));; /// run_loop = false;; /// thrd.join();; /// return 0;; /// }; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RCanvas.cxx:424,perform,performed,424,graf2d/gpadv7/src/RCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RCanvas.cxx,2,['perform'],"['performed', 'performs']"
Performance,"//////////////////////////////////////////////////////////////////////////; /// Send a message with the specified code on the specified socket.; /// This standalone function can be used to send a code; /// on a given socket. It does not check whether the socket connection is; /// in a valid state. The message code can then be retrieved via MPRecv().\n; /// **Note:** only objects the headers of which have been parsed by; /// cling can be sent by MPSend(). User-defined types can be made available to; /// cling via a call like `gSystem->ProcessLine(""#include \""header.h\"""")`.; /// Pointer types are not supported (with the exception of const char*),; /// but the user can simply dereference the pointer and send the; /// pointed object instead.\n; /// **Note:** for readability, codes should be enumerated as in EMPCode.\n; /// \param s a pointer to a valid TSocket. No validity checks are performed\n; /// \param code the code to be sent; /// \return the number of bytes sent, as per TSocket::SendRaw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/src/MPSendRecv.cxx:893,perform,performed,893,core/multiproc/src/MPSendRecv.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/src/MPSendRecv.cxx,1,['perform'],['performed']
Performance,"//////////////////////////////////////////////////////////////////////////; /// To resolve problem with storing of shared pointers; /// Call this method when reading canvas from the file; /// Can be called many times - after reinitialization of shared pointers no changes will be performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RCanvas.cxx:280,perform,performed,280,graf2d/gpadv7/src/RCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RCanvas.cxx,1,['perform'],['performed']
Performance,"//////////////////////////////////////////////////////////////////////////; /// Tree cache handling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TMPWorkerTree.cxx:85,cache,cache,85,tree/treeplayer/src/TMPWorkerTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TMPWorkerTree.cxx,1,['cache'],['cache']
Performance,"//////////////////////////////////////////////////////////////////////////; /// \brief Execute a function `nTimes` (Map) and accumulate the results into a single value (Reduce).; /// Benefits from partial reduction into `nChunks` intermediate results if the execution policy is multithreaded.; /// Otherwise, <b>it ignores the nChunks argument</b> and performs a normal MapReduce operation.; ///; /// \param func Function to be executed. Must take an element of the sequence passed as second argument as a parameter.; /// \param nTimes Number of times function should be called.; /// \param redfunc Reduction function to combine the results of the calls to `func` into partial results, and these; /// into a final result. Must return the same type as `func` and should be callable with `const std::vector<T>` where T; /// is the output of `func`.; /// \param nChunks Number of chunks to split the input data for processing.; /// \return A value result of ""reducing"" the vector returned by the Map operation into a single object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx:352,perform,performs,352,core/imt/inc/ROOT/TExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx,1,['perform'],['performs']
Performance,"//////////////////////////////////////////////////////////////////////////; /// \brief Execute a function over a sequence of indexes (Map) and accumulate the results into a single value (Reduce).; /// Benefits from partial reduction into `nChunks` intermediate results if the execution policy is multithreaded.; /// Otherwise, <b>it ignores the nChunks argument</b> and performs a normal MapReduce operation.; ///; /// \param func Function to be executed. Must take an element of the sequence passed assecond argument as a parameter.; /// \param args Sequence of indexes to execute `func` on.; /// \param redfunc Reduction function to combine the results of the calls to `func` into partial results, and these; /// into a final result. Must return the same type as `func` and should be callable with `std::vector<T>` where T is the; /// output of `func`.; /// \param nChunks Number of chunks to split the input data for processing.; /// \return A value result of ""reducing"" the vector returned by the Map operation into a single object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx:370,perform,performs,370,core/imt/inc/ROOT/TExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx,1,['perform'],['performs']
Performance,"//////////////////////////////////////////////////////////////////////////; /// \brief Execute a function over the elements of a vector (Map) and accumulate the results into a single value; /// (Reduce). Benefits from partial reduction into `nChunks` intermediate results if the execution policy is; /// multithreaded. Otherwise, <b>it ignores the nChunks argument</b> and performs a normal MapReduce operation.; ///; /// \param func Function to be executed. Must take an element of the sequence passed assecond argument as a parameter.; /// \param args Vector of elements passed as an argument to `func`.; /// \param redfunc Reduction function to combine the results of the calls to `func` into partial results, and these; /// into a final result. Must return the same type as `func` and should be callable with `const std::vector<T>` where T; /// is the output of `func`.; /// \param nChunks Number of chunks to split the input data for processing.; /// \return A value result of ""reducing"" the vector returned by the Map operation into a single object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx:373,perform,performs,373,core/imt/inc/ROOT/TExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx,1,['perform'],['performs']
Performance,"//////////////////////////////////////////////////////////////////////////; /// \brief Execute a function over the elements of an immutable vector (Map) and accumulate the results into a single; /// value (Reduce). Benefits from partial reduction into `nChunks` intermediate results if the execution policy is; /// multithreaded. Otherwise, <b>it ignores the nChunks argument</b> and performs a normal MapReduce operation.; ///; /// \param func Function to be executed. Must take an element of the sequence passed assecond argument as a parameter.; /// \param args Immutable vector, whose elements are passed as an argument to `func`.; /// \param redfunc Reduction function to combine the results of the calls to `func` into partial results, and these; /// into a final result. Must return the same type as `func` and should be callable with `const std::vector<T>` where T; /// is the output of `func`.; /// \param nChunks Number of chunks to split the input data for processing.; /// \return A value result of ""reducing"" the vector returned by the Map operation into a single object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx:384,perform,performs,384,core/imt/inc/ROOT/TExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx,1,['perform'],['performs']
Performance,"//////////////////////////////////////////////////////////////////////////; /// \brief Execute a function over the elements of an initializer_list (Map) and accumulate the results into a single; /// value (Reduce). Benefits from partial reduction into `nChunks` intermediate results if the execution policy is; /// multithreaded. Otherwise, <b>it ignores the nChunks argument</b> and performs a normal MapReduce operation.; ///; /// \param func Function to be executed. Must take an element of the sequence passed as second argument as a parameter.; /// \param args initializer_list for a vector to apply `func` on.; /// \param redfunc Reduction function to combine the results of the calls to `func` into partial results, and these; /// into a final result. Must return the same type as `func` and should be callable with `const std::vector<T>` where T; /// is the output of `func`.; /// \param nChunks Number of chunks to split the input data for processing.; /// \return A value result of ""reducing"" the vector returned by the Map operation into a single object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx:384,perform,performs,384,core/imt/inc/ROOT/TExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TExecutor.hxx,1,['perform'],['performs']
Performance,"//////////////////////////////////////////////////////////////////////////; ///; /// \class TMPWorker; ///; /// This class works in conjuction with TMPClient, reacting to messages; /// received from it as specified by the Notify and HandleInput methods.; /// When TMPClient::Fork is called, a TMPWorker instance is passed to it; /// which will take control of the ROOT session in the children processes.; ///; /// After forking, every time a message is sent or broadcast to the workers,; /// TMPWorker::Notify is called and the message is retrieved.; /// Messages exchanged between TMPClient and TMPWorker should be sent with; /// the MPSend() standalone function.\n; /// If the code of the message received is above 1000 (i.e. it is an MPCode); /// the qualified TMPWorker::HandleInput method is called, that takes care; /// of handling the most generic type of messages. Otherwise the unqualified; /// (possibly overridden) version of HandleInput is called, allowing classes; /// that inherit from TMPWorker to manage their own protocol.\n; /// An application's worker class should inherit from TMPWorker and implement; /// a HandleInput method that overrides TMPWorker's.\n; ///; //////////////////////////////////////////////////////////////////////////; //////////////////////////////////////////////////////////////////////////; /// This method is called by children processes right after forking.; /// Initialization of worker properties that must be delayed until after; /// forking must be done here.\n; /// For example, Init saves the pid into fPid, and adds the TMPWorker to; /// the main eventloop (as a TFileHandler).\n; /// Make sure this operations are performed also by overriding implementations,; /// e.g. by calling TMPWorker::Init explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/src/TMPWorker.cxx:1668,perform,performed,1668,core/multiproc/src/TMPWorker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/src/TMPWorker.cxx,1,['perform'],['performed']
Performance,"//////////////////////////////////////////////////////////////////////////; ///; /// \class TMPWorkerExecutor; ///; /// This class works together with TProcessExecutor to allow the execution of; /// functions in server processes. Depending on the exact task that the; /// worker is required to execute, a different version of the class; /// can be called.; ///; /// ### TMPWorkerExecutor<F, T, R>; /// The most general case, used by; /// TProcessExecutor::MapReduce(F func, T& args, R redfunc).; /// This worker is build with:; /// * a function of signature F (the one to be executed); /// * a collection of arguments of type T on which to apply the function; /// * a reduce function with signature R to be used to squash many; /// returned values together.; ///; /// ### Partial specializations; /// A few partial specializations are provided for less general cases:; /// * TMPWorkerExecutor<F, T, void> handles the case of a function that takes; /// one argument and does not perform reduce operations; /// (TProcessExecutor::Map(F func, T& args)).; /// * TMPWorkerExecutor<F, void, R> handles the case of a function that takes; /// no arguments, to be executed a specified amount of times, which; /// returned values are squashed together (reduced); /// (TProcessExecutor::Map(F func, unsigned nTimes, R redfunc)); /// * TMPWorkerExecutor<F, void, void> handles the case of a function that takes; /// no arguments and whose arguments are not ""reduced""; /// (TProcessExecutor::Map(F func, unsigned nTimes)); ///; /// Since all the important data are passed to TMPWorkerExecutor at construction; /// time, the kind of messages that client and workers have to exchange; /// are usually very simple.; ///; //////////////////////////////////////////////////////////////////////////; // Quick guide to TMPWorkerExecutor:; // For each TProcessExecutor::Map and TProcessExecutor::MapReduce signature; // there's a corresponding; // specialization of TMPWorkerExecutor:; // * Map(func, nTimes) --> TMPWorker",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/inc/TMPWorkerExecutor.h:978,perform,perform,978,core/multiproc/inc/TMPWorkerExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/inc/TMPWorkerExecutor.h,1,['perform'],['perform']
Performance,"//////////////////////////////////////////////////////////////////////////; //; // TGLColor; //; // Encapsulate color in preferred GL format - UChar_t RGBA array.; // Color index is also cached for easier interfacing with the; // traditional ROOT graphics.; //; //////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h:187,cache,cached,187,graf3d/gl/inc/TGLUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/inc/TGLUtil.h,1,['cache'],['cached']
Performance,"//////////////////////////////////////////////////////////////////////////; //; // The Linear Fitter - fitting functions that are LINEAR IN PARAMETERS; //; // Linear fitter is used to fit a set of data points with a linear; // combination of specified functions. Note, that ""linear"" in the name; // stands only for the model dependency on parameters, the specified; // functions can be nonlinear.; // The general form of this kind of model is; //; // y(x) = a[0] + a[1]*f[1](x)+...a[n]*f[n](x); //; // Functions f are fixed functions of x. For example, fitting with a; // polynomial is linear fitting in this sense.; //; // The fitting method; //; // The fit is performed using the Normal Equations method with Cholesky; // decomposition.; //; // Why should it be used?; //; // The linear fitter is considerably faster than general non-linear; // fitters and doesn't require to set the initial values of parameters.; //; // Using the fitter:; //; // 1.Adding the data points:; // 1.1 To store or not to store the input data?; // - There are 2 options in the constructor - to store or not; // store the input data. The advantages of storing the data; // are that you'll be able to reset the fitting model without; // adding all the points again, and that for very large sets; // of points the chisquare is calculated more precisely.; // The obvious disadvantage is the amount of memory used to; // keep all the points.; // - Before you start adding the points, you can change the; // store/not store option by StoreData() method.; // 1.2 The data can be added:; // - simply point by point - AddPoint() method; // - an array of points at once:; // If the data is already stored in some arrays, this data; // can be assigned to the linear fitter without physically; // coping bytes, thanks to the Use() method of; // TVector and TMatrix classes - AssignData() method; //; // 2.Setting the formula; // 2.1 The linear formula syntax:; // -Additive parts are separated by 2 plus signs ""++""; // --for example",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TLinearFitter.h:662,perform,performed,662,math/minuit/inc/TLinearFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/inc/TLinearFitter.h,1,['perform'],['performed']
Performance,"/////////////////////////////////////////////////////////////////////////; /// Clear internal objects cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowserData.cxx:102,cache,cache,102,gui/browserv7/src/RBrowserData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowserData.cxx,1,['cache'],['cache']
Performance,"/////////////////////////////////////////////////////////////////////////; /// Remove object from cache; /// If nullptr specified - removes no-longer-valid elements; /// Returns true if any element was removed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowserData.cxx:98,cache,cache,98,gui/browserv7/src/RBrowserData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowserData.cxx,1,['cache'],['cache']
Performance,"/////////////////////////////////////////////////////////////////////////; /// Remove path (and all sub-paths) from cache; /// Returns true if any element was removed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowserData.cxx:116,cache,cache,116,gui/browserv7/src/RBrowserData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowserData.cxx,1,['cache'],['cache']
Performance,"/////////////////////////////////////////////////////////////////////////; /// Returns sub-element starting from top, using cached data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowserData.cxx:124,cache,cached,124,gui/browserv7/src/RBrowserData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowserData.cxx,1,['cache'],['cached']
Performance,"////////////////////////////////////////////////////////////////////////; /// calculate the function for ScanTau(); ///; /// \param[in] mode the variable to be calculated; /// \param[in] distribution distribution for which the variable; /// is to be calculated; /// \param[in] axisSteering detailed steering for selecting bins on; /// the axes of the distribution (see method GetRhoItotal()); ///; /// return value: the scan result for the given choice of tau (for; /// which the unfolding was performed prior to calling this method); /// <br/>; /// In ScanTau() the unfolding is repeated for various choices of tau.; /// For each tau, after unfolding, GetScanVariable() is called to; /// determine the scan result for this choice of tau.; /// <br/>; /// the following modes are implemented; /// <ul>; /// <li>kEScanTauRhoAvg : average (stat+bgr) global correlation</li>; /// <li>kEScanTauRhoSquaredAvg : average (stat+bgr) global correlation squared</li>; /// <li>kEScanTauRhoMax : maximum (stat+bgr) global correlation</li>; /// <li>kEScanTauRhoAvgSys : average (stat+bgr+sys) global correlation</li>; /// <li>kEScanTauRhoAvgSquaredSys : average (stat+bgr+sys) global correlation squared</li>; /// <li>kEScanTauRhoMaxSys : maximum (stat+bgr+sys) global; /// correlation</li>; /// </ul>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx:494,perform,performed,494,hist/unfold/src/TUnfoldDensity.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx,1,['perform'],['performed']
Performance,"////////////////////////////////////////////////////////////////////////; /// get the inverse or pseudo-inverse of a positive, sparse matrix; ///; /// \param[in] A the sparse matrix to be inverted, has to be positive; /// \param[inout] rankPtr if zero, suppress calculation of pseudo-inverse; /// otherwise the rank of the matrix is returned in *rankPtr; ///; /// return value: 0 or a new sparse matrix; /// <ul>; /// <li>if(rankPtr==nullptr) return the inverse if it exists, or return 0</li>; /// <li>else return a (pseudo-)inverse and store the rank of the matrix in; /// *rankPtr </li>; /// </ul>; ///; /// the matrix inversion is optimized in performance for the case; /// where a large submatrix of A is diagonal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:634,optimiz,optimized,634,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,2,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"////////////////////////////////////////////////////////////////////////; /// perform background subtraction; ///; /// This prepares the data members for the base class TUnfold, such; /// that the background is properly taken into account.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx:78,perform,perform,78,hist/unfold/src/TUnfoldSys.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldSys.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////; /// perform the unfolding for a given input and regularisation; ///; /// \param[in] tau_reg regularisation parameter; /// \param[in] input input distribution with uncertainties; /// \param[in] scaleBias (default=0.0) scale factor applied to the bias; ///; /// This is a shortcut for { SetInput(input,scaleBias); DoUnfold(tau); }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:78,perform,perform,78,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////; /// perform the unfolding for a given regularisation parameter tau; ///; /// \param[in] tau regularisation parameter; ///; /// this method sets tau and then calls the core unfolding algorithm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:78,perform,perform,78,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['perform'],['perform']
Performance,"////////////////////////////////////////////////////////////////////////; /// scan a function wrt tau and determine the minimum; ///; /// \param[in] nPoint number of points to be scanned; /// \param[in] tauMin smallest tau value to study; /// \param[in] tauMax largest tau value to study; /// \param[out] scanResult the scanned function wrt log(tau); /// \param[in] mode 1st parameter for the scan function; /// \param[in] distribution 2nd parameter for the scan function; /// \param[in] projectionMode 3rd parameter for the scan function; /// \param[out] lCurvePlot for monitoring, shows the L-curve; /// \param[out] logTauXPlot for monitoring, L-curve(X) as a function of log(tau); /// \param[out] logTauYPlot for monitoring, L-curve(Y) as a function of log(tau); ///; /// Return value: the coordinate number on the curve <b>scanResult</b>; /// which corresponds to the minimum; /// <br/>; /// The function is scanned by repeating the following steps <b>nPoint</b>; /// times; /// <ol>; /// <li>Choose a value of tau</li>; /// <li>Perform the unfolding for this choice of tau, DoUnfold(tau)</li>; /// <li>Determinethe scan variable GetScanVariable()</li>; /// </ol>; /// The method GetScanVariable() defines scans of correlation; /// coefficients, where <b>mode</b> is chosen from the enum; /// EScanTauMode. In addition one may set <b>distribution</b>; /// and/or <b>projectionMode</b> to refine the calculation of; /// correlations (e.g. restrict the calcuation to the signal; /// distribution and/or exclude underflow and overflow bins).; /// See the documentation of GetScanVariable() for details.; /// Alternative scan variables may be defined by overriding the; /// GetScanVariable() method.; /// <br>; /// Automatic choice of scan range: if (tauMin,tauMax) do not; /// correspond to a valid tau range (e.g. tauMin=tauMax=0.0) then; /// the tau range is determined automatically. Use with care!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx:1033,Perform,Perform,1033,hist/unfold/src/TUnfoldDensity.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfoldDensity.cxx,1,['Perform'],['Perform']
Performance,"/////////////////////////////////////////////////////////////////////; // Implementation of Dropout for multi-threaded CPU architectures. //; /////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Dropout.hxx:104,multi-thread,multi-threaded,104,tmva/tmva/src/DNN/Architectures/Cpu/Dropout.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DNN/Architectures/Cpu/Dropout.hxx,1,['multi-thread'],['multi-threaded']
Performance,"/////////////////////////////////////////////////////////////////////; /// Clear cached data, need to be clear when connection broken",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx:81,cache,cached,81,geom/webviewer/src/RGeomData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx,1,['cache'],['cached']
Performance,"/////////////////////////////////////////////////////////////////////; /// Produce JSON string which can be directly used with `build`; /// function from JSROOT to create three.js model of configured geometry; ///; /// Collect all information required to draw geometry on the client; /// This includes list of each visible nodes, meshes and matrixes; /// If @param all_nodes is true, all existing nodes will be provided,; /// which allows to create complete nodes hierarchy on client side; ///; /// Example of usage:; ///; /// void geom() {; /// auto f = TFile::Open(""file_name.root"");; /// auto vol = f->Get<TGeoVolume>(""object_name"");; /// ROOT::RGeomDescription desc;; /// desc.Build(vol);; /// std::ofstream fout(""geom.json"");; /// fout << desc.ProduceJson();; /// }; ///; /// In JSROOT one loads data from JSON file and call `build` function to; /// produce three.js model. Also see example in tutorials/webgui/geom/ folder",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx:795,load,loads,795,geom/webviewer/src/RGeomData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx,1,['load'],['loads']
Performance,"/////////////////////////////////////////////////////////////////////; /// return true when node used in main geometry drawing and does not have childs; /// for such nodes one could provide optimize toggling of visibility flags",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx:190,optimiz,optimize,190,geom/webviewer/src/RGeomData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx,1,['optimiz'],['optimize']
Performance,"///////////////////////////////////////////////////////////////////; // Animated Text with cool wave effect.; //; // ROOT implementation of the hello world example borrowed; // from the Qt hello world example.; //; // To run this example do the following:; // $ root; // root [0] gSystem.Load(""Hello""); // root [1] Hello h; // <enjoy>; // root [2] .q; //; // Other ROOT fun examples: Tetris, Aclock ...; ///////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Hello.h:288,Load,Load,288,test/Hello.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Hello.h,1,['Load'],['Load']
Performance,"///////////////////////////////////////////////////////////////////; // ROOT implementation of the X11 xclock.; //; // To run this example do the following:; // $ root; // root [0] gSystem.Load(""Aclock""); // root [1] Aclock a; // <enjoy>; // root [2] .q; //; // Other ROOT fun examples: Tetris, Hello ...; ///////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Aclock.h:189,Load,Load,189,test/Aclock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Aclock.h,1,['Load'],['Load']
Performance,"///////////////////////////////////////////////////////////////////; // ROOT implementation of the simple Tetris game; // Layout and some hints were taken from Qt /examples/tetris; //; // To run this game do the following:; // $ root; // root [0] gSystem.Load(""Tetris""); // root [1] Tetris t; // <play game>; // root [2] .q; //; // Other ROOT fun examples: Hello, Aclock ...; ///////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.h:255,Load,Load,255,test/Tetris.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Tetris.h,1,['Load'],['Load']
Performance,"///////////////////////////////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1036,perform,performed,1036,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['perform'],['performed']
Performance,"/////////////////////////////////////////////////////////////////; // Test function call performance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressInterpreter.cxx:89,perform,performance,89,test/stressInterpreter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressInterpreter.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////////////////; //; // TSPectrum test suite; // ====================; //; // This stress program tests many elements of the TSpectrum, TSpectrum2 classes.; //; // To run in batch, do; // stressSpectrum : run 100 experiments with graphics (default); // stressSpectrum 1000 : run 1000 experiments with graphics; // stressSpectrum -b 200 : run 200 experiments in batch mode; // stressSpectrum -b : run 100 experiments in batch mode; //; // To run interactively, do; // root -b; // Root > .x stressSpectrum.cxx : run 100 experiments with graphics (default); // Root > .x stressSpectrum.cxx(20) : run 20 experiments; // Root > .x stressSpectrum.cxx+(30) : run 30 experiments via ACLIC; //; // Several tests are run sequentially. Each test will produce one line (Test OK or Test FAILED) .; // At the end of the test a table is printed showing the global results; // Real Time and Cpu Time.; // One single number (ROOTMARKS) is also calculated showing the relative; // performance of your machine compared to a reference machine; // a Pentium IV 3.0 Ghz) with 512 MBytes of memory; // and 120 GBytes IDE disk.; //; // An example of output when all the tests run OK is shown below:; //; //////////////////////////////////////////////////////////////////////////; // //; //****************************************************************************; //* Starting stress S P E C T R U M *; //****************************************************************************; //Peak1 : found = 70.21/ 73.75, good = 65.03/ 68.60, ghost = 8.54/ 8.39,--- OK; //Peak2 : found =163/300, good =163, ghost =8,---------------------------- OK; //****************************************************************************; //stressSpectrum: Real Time = 19.86 seconds Cpu Time = 19.04 seconds; //****************************************************************************; //* ROOTMARKS = 810.9 * Root5.09/01 20051216/1229; //***********************************************************",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressSpectrum.cxx:1134,perform,performance,1134,test/stressSpectrum.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressSpectrum.cxx,1,['perform'],['performance']
Performance,"////////////////////////////////////////; /// This function computes, to an attempted specified accuracy, the value of; /// the integral; ///; /// \param[in] n Number of dimensions [2,15]; /// \param[in] a,b One-dimensional arrays of length >= N . On entry A[i], and B[i],; /// contain the lower and upper limits of integration, respectively.; /// \param[in] maxpts Maximum number of function evaluations to be allowed.; /// maxpts >= 2^n +2*n*(n+1) +1; /// if maxpts<minpts, maxpts is set to 10*minpts; /// \param[in] epsrel Specified relative accuracy.; /// \param[in] epsabs Specified absolute accuracy.; /// The integration algorithm will attempt to reach either the relative or the absolute accuracy.; /// In case the maximum function called is reached the algorithm will stop earlier without having reached; /// the desired accuracy; ///; /// \param[out] relerr Contains, on exit, an estimation of the relative accuracy of the result.; /// \param[out] nfnevl number of function evaluations performed.; /// \param[out] ifail; /// \parblock; /// 0 Normal exit. At least minpts and at most maxpts calls to the function were performed.; ///; /// 1 maxpts is too small for the specified accuracy eps. The result and relerr contain the values obtainable for the; /// specified value of maxpts.; ///; /// 3 n<2 or n>15; /// \endparblock; ///; /// Method:; ///; /// The default method used is the Genz-Mallik adaptive multidimensional algorithm; /// using the class ROOT::Math::AdaptiveIntegratorMultiDim (see the reference documentation of the class); ///; /// Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); /// to different integrators.; /// Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; /// Possible methods are : Vegas, Miser or Plain; /// IN case of MC integration the accuracy is determined by the number of function calls, one should be; /// careful not to use a too large value of maxpts; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:1167,perform,performed,1167,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['perform'],['performed']
Performance,"//////////////////////////////////////; /// Constructor of TMVA Executor class; /// Explicit specify the number of threads. In this case if nthreads is > 1 a multi-threaded executor will be created and; /// TMVA will run in MT.; /// If nthreads = 1 instead TMVA will run in sequential mode; /// If nthreads = 0 TMVA will use the default thread pool size; ////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Executor.h:158,multi-thread,multi-threaded,158,tmva/tmva/inc/TMVA/Executor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Executor.h,1,['multi-thread'],['multi-threaded']
Performance,"//////////////////////////////////////; /// Default constructor of TMVA Executor class; /// if ROOT::EnableImplicitMT has not been called then by default a serial executor will be created; /// A user can create a thread pool and enable multi-thread excution by calling; /// ; /// ~~~{.cpp}; /// TMVA::Config::Instance()::%EnableMT(int nthreads);; /// ~~~; ///; /// For releasing the thread pool used by TMVA one can do it by calling; ///; /// TMVA::Config::Instance()::%DisableMT();; ////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Executor.h:236,multi-thread,multi-thread,236,tmva/tmva/inc/TMVA/Executor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Executor.h,1,['multi-thread'],['multi-thread']
Performance,"////////////////////////////////; /// \brief Append a filter to the call graph.; /// \param[in] f Function, lambda expression, functor class or any other callable object. It must return a `bool`; /// signalling whether the event has passed the selection (true) or not (false).; /// \param[in] columns Names of the columns/branches in input to the filter function.; /// \param[in] name Optional name of this filter. See `Report`.; /// \return the filter node of the computation graph.; ///; /// Append a filter node at the point of the call graph corresponding to the; /// object this method is called on.; /// The callable `f` should not have side-effects (e.g. modification of an; /// external or static variable) to ensure correct results when implicit; /// multi-threading is active.; ///; /// RDataFrame only evaluates filters when necessary: if multiple filters; /// are chained one after another, they are executed in order and the first; /// one returning false causes the event to be discarded.; /// Even if multiple actions or transformations depend on the same filter,; /// it is executed once per entry. If its result is requested more than; /// once, the cached result is served.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// // C++ callable (function, functor class, lambda...) that takes two parameters of the types of ""x"" and ""y""; /// auto filtered = df.Filter(myCut, {""x"", ""y""});; ///; /// // String: it must contain valid C++ except that column names can be used instead of variable names; /// auto filtered = df.Filter(""x*y > 0"");; /// ~~~; ///; /// \note If the body of the string expression contains an explicit `return` statement (even if it is in a nested; /// scope), RDataFrame _will not_ add another one in front of the expression. So this will not work:; /// ~~~{.cpp}; /// df.Filter(""Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~; /// but instead this will:; /// ~~~{.cpp}; /// df.Filter(""return Sum(Map(vec, [](float e) { return e*e > 0.5; }))""); /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1211,cache,cached,1211,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['cache'],['cached']
Performance,"///////////////////////////; //Loading Training Data //; ///////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/src/RMethodBase.cxx:31,Load,Loading,31,tmva/rmva/src/RMethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/src/RMethodBase.cxx,1,['Load'],['Loading']
Performance,"////////////////////////; //Loading Test Data //; ////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/src/RMethodBase.cxx:28,Load,Loading,28,tmva/rmva/src/RMethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/rmva/src/RMethodBase.cxx,1,['Load'],['Loading']
Performance,"////===- SampleProfileLoadBaseImpl.h - Profile loader base impl --*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for the sampled PGO profile loader base; /// implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:47,load,loader,47,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,2,['load'],['loader']
Performance,"////===- SampleProfileLoadBaseUtil.h - Profile loader util func --*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the utility functions for the sampled PGO loader base; /// implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h:47,load,loader,47,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,2,['load'],['loader']
Performance,"///; /// Design of OpenMP reductions on the GPU; ///; /// Consider a typical OpenMP program with one or more reduction; /// clauses:; ///; /// float foo;; /// double bar;; /// #pragma omp target teams distribute parallel for \; /// reduction(+:foo) reduction(*:bar); /// for (int i = 0; i < N; i++) {; /// foo += A[i]; bar *= B[i];; /// }; ///; /// where 'foo' and 'bar' are reduced across all OpenMP threads in; /// all teams. In our OpenMP implementation on the NVPTX device an; /// OpenMP team is mapped to a CUDA threadblock and OpenMP threads; /// within a team are mapped to CUDA threads within a threadblock.; /// Our goal is to efficiently aggregate values across all OpenMP; /// threads such that:; ///; /// - the compiler and runtime are logically concise, and; /// - the reduction is performed efficiently in a hierarchical; /// manner as follows: within OpenMP threads in the same warp,; /// across warps in a threadblock, and finally across teams on; /// the NVPTX device.; ///; /// Introduction to Decoupling; ///; /// We would like to decouple the compiler and the runtime so that the; /// latter is ignorant of the reduction variables (number, data types); /// and the reduction operators. This allows a simpler interface; /// and implementation while still attaining good performance.; ///; /// Pseudocode for the aforementioned OpenMP program generated by the; /// compiler is as follows:; ///; /// 1. Create private copies of reduction variables on each OpenMP; /// thread: 'foo_private', 'bar_private'; /// 2. Each OpenMP thread reduces the chunk of 'A' and 'B' assigned; /// to it and writes the result in 'foo_private' and 'bar_private'; /// respectively.; /// 3. Call the OpenMP runtime on the GPU to reduce within a team; /// and store the result on the team master:; ///; /// __kmpc_nvptx_parallel_reduce_nowait_v2(...,; /// reduceData, shuffleReduceFn, interWarpCpyFn); ///; /// where:; /// struct ReduceData {; /// double *foo;; /// double *bar;; /// } reduceData; /// reduc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:795,perform,performed,795,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['perform'],['performed']
Performance,///; ///}}; /// Emit a remark generically; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function provided by the caller that; /// takes a RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:176,Optimiz,OptimizationRemark,176,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,6,"['Optimiz', 'optimiz']","['OptimizationRemark', 'OptimizationRemarkAnalysis', 'OptimizationRemarkMissed', 'optimization']"
Performance,///< A pointer to the cache of @llvm.assume calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:22,cache,cache,22,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['cache'],['cache']
Performance,"///< Assume contents is unit normalized (for use as pdf cache)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHistPdf.h:56,cache,cache,56,roofit/roofitcore/inc/RooHistPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHistPdf.h,1,['cache'],['cache']
Performance,"///< Cache for current value of object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:5,Cache,Cache,5,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['Cache'],['Cache']
Performance,"///< Cache for expensive objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWorkspace.h:5,Cache,Cache,5,roofit/roofitcore/inc/RooWorkspace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWorkspace.h,1,['Cache'],['Cache']
Performance,"///< Cache integral if numeric",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealIntegral.h:5,Cache,Cache,5,roofit/roofitcore/inc/RooRealIntegral.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealIntegral.h,1,['Cache'],['Cache']
Performance,"///< Cache manager for generic caches that contain RooAbsArg objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooObjCacheManager.h:5,Cache,Cache,5,roofit/roofitcore/inc/RooObjCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooObjCacheManager.h,2,"['Cache', 'cache']","['Cache', 'caches']"
Performance,"///< Cache size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TMPWorkerTree.h:5,Cache,Cache,5,tree/treeplayer/inc/TMPWorkerTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TMPWorkerTree.h,1,['Cache'],['Cache']
Performance,"///< Cache tensor used for speeding-up the forward pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/CNN/ConvLayer.h:5,Cache,Cache,5,tmva/tmva/inc/TMVA/DNN/CNN/ConvLayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/CNN/ConvLayer.h,1,['Cache'],['Cache']
Performance,"///< Cache that set before the TTreeCloner ctor for the 'from' TTree if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h:5,Cache,Cache,5,tree/tree/inc/TTreeCloner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h,1,['Cache'],['Cache']
Performance,"///< Cached copy of fField->GetValueSize()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:5,Cache,Cached,5,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['Cache'],['Cached']
Performance,"///< Cached covariance matrix (NxN)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TBackCompFitter.h:5,Cache,Cached,5,hist/hist/inc/TBackCompFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TBackCompFitter.h,1,['Cache'],['Cached']
Performance,"///< Cached font metrics",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGFont.h:5,Cache,Cached,5,gui/gui/inc/TGFont.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGFont.h,1,['Cache'],['Cached']
Performance,"///< Cached picture",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGFileBrowser.h:5,Cache,Cached,5,gui/gui/inc/TGFileBrowser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGFileBrowser.h,1,['Cache'],['Cached']
Performance,"///< Cached picture name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGFileBrowser.h:5,Cache,Cached,5,gui/gui/inc/TGFileBrowser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGFileBrowser.h,1,['Cache'],['Cached']
Performance,"///< Caches the weight size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TKDE.h:5,Cache,Caches,5,hist/hist/inc/TKDE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TKDE.h,1,['Cache'],['Caches']
Performance,"///< Calculate the appropriate miss cache to fetch; helper function for FillMissCache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:36,cache,cache,36,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///< Check the miss cache for a particular buffer, fetching if deemed necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:20,cache,cache,20,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///< Control usage of the tree cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TMPWorkerTree.h:31,cache,cache,31,tree/treeplayer/inc/TMPWorkerTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TMPWorkerTree.h,1,['cache'],['cache']
Performance,"///< File Cache used to reduce the number of individual reads",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h:10,Cache,Cache,10,tree/tree/inc/TTreeCloner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h,1,['Cache'],['Cache']
Performance,"///< Fill the miss cache from the current set of active branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:19,cache,cache,19,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///< Flags whether a valid fit has been performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TFractionFitter.h:40,perform,performed,40,hist/hist/inc/TFractionFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TFractionFitter.h,1,['perform'],['performed']
Performance,"///< GD path: error rate (or performance)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h:29,perform,performance,29,tmva/tmva/inc/TMVA/RuleFitParams.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h,1,['perform'],['performance']
Performance,"///< If std::nullopt, waits until; ///< child has terminated.; ///< If a value, this specifies the amount of time to wait for the child; ///< process. If the time expires, and \p Polling is false, the child is; ///< killed and this < function returns. If the time expires and \p; ///< Polling is true, the child is resumed.; ///<; ///< If zero, this function will perform a non-blocking; ///< wait on the child process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:364,perform,perform,364,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['perform'],['perform']
Performance,"///< Indicator on how LoadTree was called 'last' time.; /// TTree and TChain will notify this object upon LoadTree, leading to a call to TTreeReader::Notify().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:22,Load,LoadTree,22,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,2,['Load'],['LoadTree']
Performance,"///< Instance where we should write data into when load() is called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooVectorDataStore.h:51,load,load,51,roofit/roofitcore/inc/RooVectorDataStore.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooVectorDataStore.h,1,['load'],['load']
Performance,"///< Interpolation order for cache histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCachedReal.h:29,cache,cache,29,roofit/roofitcore/inc/RooAbsCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCachedReal.h,1,['cache'],['cache']
Performance,"///< Keep an attached clone of the source in the cache for fast operation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedReal.h:49,cache,cache,49,roofit/roofitcore/inc/RooCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedReal.h,1,['cache'],['cache']
Performance,///< Load/Store offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:5,Load,Load,5,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['Load'],['Load']
Performance,"///< LoadTree return less than -6, likely a 'newer' error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:5,Load,LoadTree,5,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,1,['Load'],['LoadTree']
Performance,///< Matching loads to consecutive memory addresses,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:14,load,loads,14,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['loads']
Performance,"///< Method cache for containee constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h:12,cache,cache,12,io/io/inc/TGenCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h,1,['cache'],['cache']
Performance,"///< Method cache for containee delete",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h:12,cache,cache,12,io/io/inc/TGenCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h,1,['cache'],['cache']
Performance,"///< Method cache for containee destructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h:12,cache,cache,12,io/io/inc/TGenCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h,1,['cache'],['cache']
Performance,"///< Method cache for container accessors: clear container",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h:12,cache,cache,12,io/io/inc/TGenCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h,1,['cache'],['cache']
Performance,"///< Missing expected branch when loading new tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:34,load,loading,34,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,1,['load'],['loading']
Performance,"///< Name of RooAbsArg object that is associated to cache contents",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooExpensiveObjectCache.h:52,cache,cache,52,roofit/roofitcore/inc/RooExpensiveObjectCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooExpensiveObjectCache.h,1,['cache'],['cache']
Performance,"///< Name of binning to be used for cache histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumRunningInt.h:36,cache,cache,36,roofit/roofitcore/inc/RooNumRunningInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumRunningInt.h,1,['cache'],['cache']
Performance,"///< Name of the binning specification to be used to perform the mapping",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooBinningCategory.h:53,perform,perform,53,roofit/roofitcore/inc/RooBinningCategory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooBinningCategory.h,1,['perform'],['perform']
Performance,"///< Next prototype event to load according to LUT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsGenContext.h:29,load,load,29,roofit/roofitcore/inc/RooAbsGenContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsGenContext.h,1,['load'],['load']
Performance,///< No deduplication is performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Comdat.h:25,perform,performed,25,interpreter/llvm-project/llvm/include/llvm/IR/Comdat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Comdat.h,2,['perform'],['performed']
Performance,///< Node latency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:10,latency,latency,10,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['latency'],['latency']
Performance,"///< Non-convolution observables that are also cached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFFTConvPdf.h:47,cache,cached,47,roofit/roofitcore/inc/RooFFTConvPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFFTConvPdf.h,1,['cache'],['cached']
Performance,///< Nonvolatile load/Store instructions that may alias.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:17,load,load,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['load'],['load']
Performance,///< Nonvolatile load/Store instructions that must alias.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:17,load,load,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['load'],['load']
Performance,"///< Notify/LoadTree was last called from SetEntryBase",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:12,Load,LoadTree,12,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,1,['Load'],['LoadTree']
Performance,"///< Number of blocks read and found in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:44,cache,cache,44,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///< Number of blocks read and not found in either cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:51,cache,cache,51,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///< Number of blocks read and not found in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:48,cache,cache,48,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///< Number of blocks read into the secondary (""miss"") cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:55,cache,cache,55,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///< Number of blocks read, not found in the primary cache, and found in the secondary cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:53,cache,cache,53,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,2,['cache'],['cache']
Performance,"///< Number of bytes (overhead) of the read-ahead cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreePerfStats.h:50,cache,cache,50,tree/treeplayer/inc/TTreePerfStats.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreePerfStats.h,1,['cache'],['cache']
Performance,"///< Number of bytes read by basket to fill cached tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheRead.h:44,cache,cached,44,io/io/inc/TFileCacheRead.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheRead.h,1,['cache'],['cached']
Performance,"///< Number of bytes read for this cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheRead.h:35,cache,cache,35,io/io/inc/TFileCacheRead.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheRead.h,1,['cache'],['cache']
Performance,"///< Number of read calls by basket to fill cached tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheRead.h:44,cache,cached,44,io/io/inc/TFileCacheRead.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheRead.h,1,['cache'],['cached']
Performance,"///< Number of read calls for this cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheRead.h:35,cache,cache,35,io/io/inc/TFileCacheRead.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheRead.h,1,['cache'],['cache']
Performance,"///< Number of steps performed in the current training session",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DLMinimizers.h:21,perform,performed,21,tmva/tmva/inc/TMVA/DNN/DLMinimizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/DLMinimizers.h,2,['perform'],['performed']
Performance,"///< Number of times the basket was put in the secondary cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreePerfStats.h:57,cache,cache,57,tree/treeplayer/inc/TTreePerfStats.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreePerfStats.h,1,['cache'],['cache']
Performance,"///< Number of words per point in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TVirtualFitter.h:38,cache,cache,38,hist/hist/inc/TVirtualFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TVirtualFitter.h,1,['cache'],['cache']
Performance,"///< Observable to be cached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedPdf.h:22,cache,cached,22,roofit/roofitcore/inc/RooCachedPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedPdf.h,1,['cache'],['cached']
Performance,"///< Optimization switch =1,2 for variance or maximum weight optimization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoam.h:5,Optimiz,Optimization,5,math/foam/inc/TFoam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/foam/inc/TFoam.h,2,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"///< Optimization: Keep proxies once they were created",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h:5,Optimiz,Optimization,5,io/io/inc/TGenCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h,1,['Optimiz'],['Optimization']
Performance,"///< Optimization: Keep staged array once they were created",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h:5,Optimiz,Optimization,5,io/io/inc/TGenCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h,1,['Optimiz'],['Optimization']
Performance,///< Positive indirect load relocation. Modifiable instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:23,load,load,23,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['load'],['load']
Performance,///< Positive load address relocation. Modifiable instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:14,load,load,14,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['load'],['load']
Performance,"///< Protects concurrent access to fThrIDSlotMap, fObjPointers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:14,concurren,concurrent,14,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['concurren'],['concurrent']
Performance,"///< Proxy to function being cached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedReal.h:29,cache,cached,29,roofit/roofitcore/inc/RooCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedReal.h,1,['cache'],['cached']
Performance,"///< Proxy to p.d.f being cached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedPdf.h:26,cache,cached,26,roofit/roofitcore/inc/RooCachedPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedPdf.h,1,['cache'],['cached']
Performance,///< Queue id of node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:5,Queue,Queue,5,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['Queue'],['Queue']
Performance,"///< Range of data currently loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGTable.h:29,load,loaded,29,gui/gui/inc/TGTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGTable.h,1,['load'],['loaded']
Performance,"///< Read-ahead cache size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreePerfStats.h:16,cache,cache,16,tree/treeplayer/inc/TTreePerfStats.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreePerfStats.h,1,['cache'],['cache']
Performance,///< Reciprocal throughput.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:16,throughput,throughput,16,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['throughput'],['throughput']
Performance,///< Relative to the TOC or to the thread-local storage base; ///< relocation. Compilers are not permitted to generate this; ///< relocation type. It is the result of a reversible; ///< transformation by the linker of an R_TOC relation that turned a; ///< load instruction into an add-immediate instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:256,load,load,256,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['load'],['load']
Performance,"///< Requested size of the file cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h:32,cache,cache,32,tree/tree/inc/TTreeCloner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCloner.h,1,['cache'],['cache']
Performance,///< Scalable SIMD vector type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Type.h:5,Scalab,Scalable,5,interpreter/llvm-project/llvm/include/llvm/IR/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Type.h,1,['Scalab'],['Scalable']
Performance,"///< Seek value of first block in cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheWrite.h:34,cache,cache,34,io/io/inc/TFileCacheWrite.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheWrite.h,1,['cache'],['cache']
Performance,"///< Set by GetReadVLimits and then cached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/ROOT/RRawFileNetXNG.hxx:36,cache,cached,36,net/netxng/inc/ROOT/RRawFileNetXNG.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/inc/ROOT/RRawFileNetXNG.hxx,1,['cache'],['cached']
Performance,"///< Set by the descriptor builder; /**; * Once constructed by an RNTupleDescriptorBuilder, the descriptor is mostly immutable except for set of; * active the page locations. During the lifetime of the descriptor, page location information for clusters; * can be added or removed. When this happens, the generation should be increased, so that users of the; * descriptor know that the information changed. The generation is increased, e.g., by the page source's; * exclusive lock guard around the descriptor. It is used, e.g., by the descriptor cache in RNTupleReader.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:545,cache,cache,545,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,1,['cache'],['cache']
Performance,"///< Set to true once `LoadStructure()` is called",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:23,Load,LoadStructure,23,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['Load'],['LoadStructure']
Performance,"///< SetEntryBase is in the process of calling TChain/TTree::%LoadTree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:62,Load,LoadTree,62,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,1,['Load'],['LoadTree']
Performance,"///< Specify parameters to be tuned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodSVM.h:30,tune,tuned,30,tmva/tmva/inc/TMVA/MethodSVM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodSVM.h,1,['tune'],['tuned']
Performance,"///< Stores which calculation is supposed to be performed as specified by user option",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/inc/TRatioPlot.h:48,perform,performed,48,graf2d/gpad/inc/TRatioPlot.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/inc/TRatioPlot.h,1,['perform'],['performed']
Performance,"///< Switch do (de)activate dirty state propagation when loading a data point",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsDataStore.h:57,load,loading,57,roofit/roofitcore/inc/RooAbsDataStore.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsDataStore.h,1,['load'],['loading']
Performance,"///< TOC relative indirect load relocation. Similar to R_TOC,; ///< but not modifiable instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:27,load,load,27,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['load'],['load']
Performance,"///< The Beta1 constant used by the optimizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h:36,optimiz,optimizer,36,tmva/tmva/inc/TMVA/DNN/Adam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h,1,['optimiz'],['optimizer']
Performance,"///< The Beta2 constant used by the optimizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h:36,optimiz,optimizer,36,tmva/tmva/inc/TMVA/DNN/Adam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h,1,['optimiz'],['optimizer']
Performance,"///< The Rho constant used by the optimizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h:34,optimiz,optimizer,34,tmva/tmva/inc/TMVA/DNN/Adadelta.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h,2,['optimiz'],['optimizer']
Performance,"///< The accumulation of the past Biases for performing updates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h:45,perform,performing,45,tmva/tmva/inc/TMVA/DNN/RMSProp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h,1,['perform'],['performing']
Performance,"///< The accumulation of the past Weights for performing updates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h:46,perform,performing,46,tmva/tmva/inc/TMVA/DNN/RMSProp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h,1,['perform'],['performing']
Performance,///< The cast is not used with a load/store of any kind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:33,load,load,33,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,///< The cast is used with a masked load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,load,load,36,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,///< The cast is used with a normal load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,load,load,36,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,///< The cast is used with a reversed load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:38,load,load,38,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,///< The cast is used with an interleaved load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:42,load,load,42,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,"///< The data that should be loaded in the batches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h:29,load,loaded,29,tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h,2,['load'],['loaded']
Performance,"///< The host buffers used to load the input, output and weight data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h:30,load,load,30,tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/TensorDataLoader.h,1,['load'],['load']
Performance,///< The latency of instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:9,latency,latency,9,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['latency'],['latency']
Performance,///< The weighted sum of size and latency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:34,latency,latency,34,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['latency'],['latency']
Performance,"///< This field should contain 0. When a loaded; ///< program is being debugged, the memory image of; ///< this field may be modified by a debugger to; ///< insert a trap instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h:41,load,loaded,41,interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/XCOFFObjectFile.h,1,['load'],['loaded']
Performance,"///< To synchronize multi-threads",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TROOT.h:20,multi-thread,multi-threads,20,core/base/inc/TROOT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TROOT.h,1,['multi-thread'],['multi-threads']
Performance,"///< Total size of cached blocks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheWrite.h:19,cache,cached,19,io/io/inc/TFileCacheWrite.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFileCacheWrite.h,1,['cache'],['cached']
Performance,"///< True if during the LoadTree execution triggered by SetEntryBase.; // Flag to activate or deactivate warnings in case the friend trees have; // more entries than the main one. In some cases we may want to deactivate; // this behaviour, notably in multithreaded runs where we have to partition; // the main tree but keep the entire friend trees in every thread to ensure; // alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:24,Load,LoadTree,24,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,1,['Load'],['LoadTree']
Performance,///< Tune debug info for SCE targets (e.g. PS4).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:5,Tune,Tune,5,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['Tune'],['Tune']
Performance,///< Tune debug info for dbx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:5,Tune,Tune,5,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['Tune'],['Tune']
Performance,///< Tune debug info for gdb.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:5,Tune,Tune,5,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['Tune'],['Tune']
Performance,///< Tune debug info for lldb.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:5,Tune,Tune,5,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['Tune'],['Tune']
Performance,///< Uniform return value optimization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:26,optimiz,optimization,26,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['optimiz'],['optimization']
Performance,///< Unique return value optimization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:25,optimiz,optimization,25,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['optimiz'],['optimization']
Performance,"///< Unknown (analysis not performed, don't lower)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:27,perform,performed,27,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['perform'],['performed']
Performance,///< Used for shortcut/cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h:23,cache,cache,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineModuleInfo.h,2,['cache'],['cache']
Performance,"///< User code called LoadTree directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:22,Load,LoadTree,22,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,1,['Load'],['LoadTree']
Performance,"///< Variables to be cached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedReal.h:21,cache,cached,21,roofit/roofitcore/inc/RooCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedReal.h,1,['cache'],['cached']
Performance,"///< Whether cache is in learning phase",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TMPWorkerTree.h:13,cache,cache,13,tree/treeplayer/inc/TMPWorkerTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TMPWorkerTree.h,1,['cache'],['cache']
Performance,"///< With ShowHeaderIncludes, show; /// also includes that were skipped; /// due to the ""include guard; /// optimization"" or #pragma once.; /// The format of header information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h:108,optimiz,optimization,108,interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DependencyOutputOptions.h,1,['optimiz'],['optimization']
Performance,"///< X axis division optimization check box",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TStyleManager.h:21,optimiz,optimization,21,gui/ged/inc/TStyleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TStyleManager.h,1,['optimiz'],['optimization']
Performance,"///< Y axis division optimization check box",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TStyleManager.h:21,optimiz,optimization,21,gui/ged/inc/TStyleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TStyleManager.h,1,['optimiz'],['optimization']
Performance,"///< Z axis division optimization check box",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TStyleManager.h:21,optimiz,optimization,21,gui/ged/inc/TStyleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TStyleManager.h,1,['optimiz'],['optimization']
Performance,"///< cache this for fast access",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h:5,cache,cache,5,tmva/tmva/inc/TMVA/MethodANNBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodANNBase.h,2,['cache'],['cache']
Performance,"///< cached activation gradient (input of backward) as T x B x S",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h:5,cache,cached,5,tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h,3,['cache'],['cached']
Performance,"///< cached gradient on the input (output of backward) as T x B x I",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h:5,cache,cached,5,tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h,3,['cache'],['cached']
Performance,"///< cached input tensor as T x B x I",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h:5,cache,cached,5,tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h,3,['cache'],['cached']
Performance,"///< cached output tensor as T x B x S",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h:5,cache,cached,5,tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RNN/GRULayer.h,3,['cache'],['cached']
Performance,"///< custom scripts to load",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/inc/TWebSnapshot.h:23,load,load,23,gui/webgui6/inc/TWebSnapshot.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/inc/TWebSnapshot.h,1,['load'],['load']
Performance,"///< do or do not perform automatic pre-selection of 100% eff. cuts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBDT.h:18,perform,perform,18,tmva/tmva/inc/TMVA/MethodBDT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodBDT.h,1,['perform'],['perform']
Performance,"///< file can be loaded by the system loader, but it is; ///< ignored by the linker if it is a member of an archive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:17,load,loaded,17,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,2,['load'],"['loaded', 'loader']"
Performance,///< file is dynamically loadable and; ///< executable (equivalent to F_EXEC on AIX),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:25,load,loadable,25,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['load'],['loadable']
Performance,"///< file is executable (i.e., it; ///< has a loader section)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:46,load,loader,46,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,1,['load'],['loader']
Performance,"///< first event index for performance evaluation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h:27,perform,performance,27,tmva/tmva/inc/TMVA/RuleFitParams.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h,1,['perform'],['performance']
Performance,"///< flag to indicate if class manages the function pointers; //mutable double fX[1]; ///<! cached vector for using TF1::EvalPar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuranContDist.h:92,cache,cached,92,math/unuran/inc/TUnuranContDist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/inc/TUnuranContDist.h,1,['cache'],['cached']
Performance,"///< instance of the tree cache for the tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TMPWorkerTree.h:26,cache,cache,26,tree/treeplayer/inc/TMPWorkerTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TMPWorkerTree.h,1,['cache'],['cache']
Performance,"///< internal cached of external values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimTransformFunction.h:14,cache,cached,14,math/mathcore/inc/Math/MinimTransformFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimTransformFunction.h,1,['cache'],['cached']
Performance,"///< last event index for performance evaluation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h:26,perform,performance,26,tmva/tmva/inc/TMVA/RuleFitParams.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h,1,['perform'],['performance']
Performance,"///< last optimized event",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/SVWorkingSet.h:10,optimiz,optimized,10,tmva/tmva/inc/TMVA/SVWorkingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/SVWorkingSet.h,2,['optimiz'],['optimized']
Performance,"///< library loaded successfully",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h:13,load,loaded,13,interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,1,['load'],['loaded']
Performance,"///< library was already loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h:25,load,loaded,25,interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,1,['load'],['loaded']
Performance,"///< loading the library failed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h:5,load,loading,5,interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,1,['load'],['loading']
Performance,"///< map with cached lower bound values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/LikelihoodInterval.h:14,cache,cached,14,roofit/roostats/inc/RooStats/LikelihoodInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/LikelihoodInterval.h,1,['cache'],['cached']
Performance,"///< map with cached upper bound values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/LikelihoodInterval.h:14,cache,cached,14,roofit/roostats/inc/RooStats/LikelihoodInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/LikelihoodInterval.h,1,['cache'],['cached']
Performance,"///< min number of separation gain to perform node splitting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h:38,perform,perform,38,tmva/tmva/inc/TMVA/DecisionTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DecisionTree.h,1,['perform'],['perform']
Performance,"///< no entry has been loaded yet",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h:23,load,loaded,23,tree/treeplayer/inc/TTreeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReader.h,1,['load'],['loaded']
Performance,"///< number of binary tree levels used for optimization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodKNN.h:43,optimiz,optimization,43,tmva/tmva/inc/TMVA/MethodKNN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodKNN.h,1,['optimiz'],['optimization']
Performance,"///< number of fonts loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/inc/TTF.h:21,load,loaded,21,graf2d/graf/inc/TTF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/inc/TTF.h,1,['load'],['loaded']
Performance,"///< optimization of convergence algorithm, possible values kFitAlphaHalving, kFitAlphaOptimal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h:5,optimiz,optimization,5,hist/spectrum/inc/TSpectrum2Fit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/spectrum/inc/TSpectrum2Fit.h,2,['optimiz'],['optimization']
Performance,"///< optimization parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/SVEvent.h:5,optimiz,optimization,5,tmva/tmva/inc/TMVA/SVEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/SVEvent.h,1,['optimiz'],['optimization']
Performance,"///< path to the cache directory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFilePrefetch.h:17,cache,cache,17,io/io/inc/TFilePrefetch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFilePrefetch.h,1,['cache'],['cache']
Performance,"///< performs fitting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/inc/TFitEditor.h:5,perform,performs,5,gui/fitpanel/inc/TFitEditor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/inc/TFitEditor.h,1,['perform'],['performs']
Performance,"///< pointer to currently loaded pad editor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TRootCanvas.h:26,load,loaded,26,gui/gui/inc/TRootCanvas.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TRootCanvas.h,1,['load'],['loaded']
Performance,"///< points to perform the construction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/FeldmanCousins.h:15,perform,perform,15,roofit/roostats/inc/RooStats/FeldmanCousins.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/FeldmanCousins.h,1,['perform'],['perform']
Performance,"///< random or importance sampling (not all events are taken) !! Bool_t are stored ( no std::vector<bool> taken for speed (performance) issues )",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSet.h:123,perform,performance,123,tmva/tmva/inc/TMVA/DataSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSet.h,1,['perform'],['performance']
Performance,"///< test for overtraining performed at each #th epochs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodMLP.h:27,perform,performed,27,tmva/tmva/inc/TMVA/MethodMLP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodMLP.h,1,['perform'],['performed']
Performance,"///< tick optimization check box",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TAxisEditor.h:10,optimiz,optimization,10,gui/ged/inc/TAxisEditor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TAxisEditor.h,1,['optimiz'],['optimization']
Performance,"///< used to test optimized signal efficiency",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCuts.h:18,optimiz,optimized,18,tmva/tmva/inc/TMVA/MethodCuts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCuts.h,3,['optimiz'],['optimized']
Performance,"///< value of POI points to perform the construction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/FeldmanCousins.h:28,perform,perform,28,roofit/roostats/inc/RooStats/FeldmanCousins.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/FeldmanCousins.h,1,['perform'],['perform']
Performance,"///< variables don't need caches",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealVar.h:26,cache,caches,26,roofit/roofitcore/inc/RooRealVar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealVar.h,1,['cache'],['caches']
Performance,"///< when dividing the dataset to blocks, sets whether; ///< the certain block is in the Training set or else; ///< in the validation set; ///< boolean are stored, taken std::vector<Char_t> for performance reasons (instead of std::vector<Bool_t>)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSet.h:194,perform,performance,194,tmva/tmva/inc/TMVA/DataSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DataSet.h,1,['perform'],['performance']
Performance,"///< when double-click was performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/inc/TWebPadOptions.h:27,perform,performed,27,gui/webgui6/inc/TWebPadOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/inc/TWebPadOptions.h,1,['perform'],['performed']
Performance,"///<! Actual data in the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:25,cache,cache,25,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! Address of user branch pointer (to updated upon loading a file)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChainElement.h:54,load,loading,54,tree/tree/inc/TChainElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChainElement.h,1,['load'],['loading']
Performance,"///<! Assume contents is unit normalized (for use as pdf cache)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHistFunc.h:57,cache,cache,57,roofit/roofitcore/inc/RooHistFunc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHistFunc.h,1,['cache'],['cache']
Performance,"///<! Cache accelerating the GetRealInstance function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormula.h:6,Cache,Cache,6,tree/treeplayer/inc/TTreeFormula.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormula.h,1,['Cache'],['Cache']
Performance,"///<! Cache all integrals with given numeric dimension",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealIntegral.h:6,Cache,Cache,6,roofit/roofitcore/inc/RooRealIntegral.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealIntegral.h,1,['Cache'],['Cache']
Performance,"///<! Cache contents for misses",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:6,Cache,Cache,6,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['Cache'],['Cache']
Performance,"///<! Cache for arrays of partial bin volumes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h:6,Cache,Cache,6,roofit/roofitcore/inc/RooDataHist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h,1,['Cache'],['Cache']
Performance,"///<! Cache for sum of entries ;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h:6,Cache,Cache,6,roofit/roofitcore/inc/RooDataHist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h,1,['Cache'],['Cache']
Performance,"///<! Cache of collection/array sizes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h:6,Cache,Cache,6,tree/tree/inc/TLeaf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeaf.h,1,['Cache'],['Cache']
Performance,"///<! Cache of the EDataType of deserialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafElement.h:6,Cache,Cache,6,tree/tree/inc/TLeafElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafElement.h,1,['Cache'],['Cache']
Performance,"///<! Cache of the type of deserialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafElement.h:6,Cache,Cache,6,tree/tree/inc/TLeafElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TLeafElement.h,1,['Cache'],['Cache']
Performance,"///<! Cache owner",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooVectorDataStore.h:6,Cache,Cache,6,roofit/roofitcore/inc/RooVectorDataStore.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooVectorDataStore.h,1,['Cache'],['Cache']
Performance,"///<! Cached pointer to branch object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:6,Cache,Cached,6,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,1,['Cache'],['Cached']
Performance,"///<! Cached pointer to reference proxy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:6,Cache,Cached,6,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,1,['Cache'],['Cached']
Performance,"///<! Cached variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TFormula.h:6,Cache,Cached,6,hist/hist/inc/TFormula.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TFormula.h,1,['Cache'],['Cached']
Performance,"///<! Cached vector with sum of the weight used to compute integral",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/SamplingDistribution.h:6,Cache,Cached,6,roofit/roostats/inc/RooStats/SamplingDistribution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/SamplingDistribution.h,1,['Cache'],['Cached']
Performance,"///<! Cached vector with sum of the weight used to compute integral error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/SamplingDistribution.h:6,Cache,Cached,6,roofit/roostats/inc/RooStats/SamplingDistribution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/SamplingDistribution.h,1,['Cache'],['Cached']
Performance,"///<! Description of buffers in the miss cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:41,cache,cache,41,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! External variables cached with this data set",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h:25,cache,cached,25,roofit/roofitcore/inc/RooAbsData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h,1,['cache'],['cached']
Performance,"///<! Given a file read not in the miss cache, handle (possibly) loading the data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:40,cache,cache,40,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,2,"['cache', 'load']","['cache', 'loading']"
Performance,"///<! Helper for performing bulk IO",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h:17,perform,performing,17,tree/tree/inc/TBranch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h,1,['perform'],['performing']
Performance,"///<! Hold info about which basket are in the cache and if they have been retrieved from the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h:46,cache,cache,46,tree/tree/inc/TBranch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h,2,['cache'],['cache']
Performance,"///<! If true, the current entry has not been loaded yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormula.h:46,load,loaded,46,tree/treeplayer/inc/TTreeFormula.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormula.h,1,['load'],['loaded']
Performance,"///<! Is cache sum valid? Needs to be Int_t instead of CacheSumState_t for subclasses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h:9,cache,cache,9,roofit/roofitcore/inc/RooDataHist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h,1,['cache'],['cache']
Performance,"///<! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:72,Load,LoadTree,72,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['Load'],['LoadTree']
Performance,"///<! List of branches to be stored in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:43,cache,cache,43,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! List of nodes that are cached as constant expressions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.h:29,cache,cached,29,roofit/roofitcore/src/RooAbsOptTestStatistic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsOptTestStatistic.h,1,['cache'],['cached']
Performance,"///<! Manager of cache with coefficient projections and transformations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAddModel.h:17,cache,cache,17,roofit/roofitcore/inc/RooAddModel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAddModel.h,1,['cache'],['cache']
Performance,"///<! Manager of cache with integrals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAddModel.h:17,cache,cache,17,roofit/roofitcore/inc/RooAddModel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAddModel.h,1,['cache'],['cache']
Performance,"///<! Number of branches in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:32,cache,cache,32,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! Optimization cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooVectorDataStore.h:6,Optimiz,Optimization,6,roofit/roofitcore/inc/RooVectorDataStore.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooVectorDataStore.h,2,"['Optimiz', 'cache']","['Optimization', 'cache']"
Performance,"///<! Request for forced cache update",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooVectorDataStore.h:25,cache,cache,25,roofit/roofitcore/inc/RooVectorDataStore.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooVectorDataStore.h,1,['cache'],['cache']
Performance,"///<! Return value of TChain::LoadTree(); 0 means success",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChainElement.h:30,Load,LoadTree,30,tree/tree/inc/TChainElement.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TChainElement.h,1,['Load'],['LoadTree']
Performance,"///<! RooAddPdf cache element",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAddGenContext.h:16,cache,cache,16,roofit/roofitcore/inc/RooAddGenContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAddGenContext.h,1,['cache'],['cache']
Performance,"///<! The cache manager",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCachedReal.h:10,cache,cache,10,roofit/roofitcore/inc/RooAbsCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCachedReal.h,3,['cache'],['cache']
Performance,"///<! The integration cache manager",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/RooStats/HistFactory/ParamHistFunc.h:22,cache,cache,22,roofit/histfactory/inc/RooStats/HistFactory/ParamHistFunc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/inc/RooStats/HistFactory/ParamHistFunc.h,3,['cache'],['cache']
Performance,"///<! This caches the physical number of element in the leaf or data member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormula.h:11,cache,caches,11,tree/treeplayer/inc/TTreeFormula.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormula.h,1,['cache'],['caches']
Performance,"///<! Transient cache manager",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooMomentMorphFuncND.h:16,cache,cache,16,roofit/roofit/inc/RooMomentMorphFuncND.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooMomentMorphFuncND.h,2,['cache'],['cache']
Performance,"///<! Transient cache with transformed values of coefficients",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAddModel.h:16,cache,cache,16,roofit/roofitcore/inc/RooAddModel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAddModel.h,2,['cache'],['cache']
Performance,"///<! True if CreateTrianglesDataStructure() and FindHull() have been performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TGraphDelaunay.h:70,perform,performed,70,hist/hist/inc/TGraphDelaunay.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TGraphDelaunay.h,1,['perform'],['performed']
Performance,"///<! True if FindAllTriangles() has been performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Delaunay2D.h:42,perform,performed,42,math/mathcore/inc/Math/Delaunay2D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Delaunay2D.h,1,['perform'],['performed']
Performance,"///<! True if FindAllTriangles() has been performed on fGraph2D",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TGraphDelaunay.h:42,perform,performed,42,hist/hist/inc/TGraphDelaunay.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TGraphDelaunay.h,1,['perform'],['performed']
Performance,"///<! True if we executed one boolean optimization since the last time instance number 0 was evaluated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormula.h:38,optimiz,optimization,38,tree/treeplayer/inc/TTreeFormula.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeFormula.h,1,['optimiz'],['optimization']
Performance,"///<! cache enabled for cached reading",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:6,cache,cache,6,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,2,['cache'],"['cache', 'cached']"
Performance,"///<! cache for set of parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealIntegral.h:6,cache,cache,6,roofit/roofitcore/inc/RooRealIntegral.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooRealIntegral.h,1,['cache'],['cache']
Performance,"///<! cached variable for optimisation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGPack.h:6,cache,cached,6,gui/gui/inc/TGPack.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/inc/TGPack.h,1,['cache'],['cached']
Performance,"///<! callback invoked when tree draw performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/webviewer/inc/ROOT/RTreeViewer.hxx:38,perform,performed,38,tree/webviewer/inc/ROOT/RTreeViewer.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/webviewer/inc/ROOT/RTreeViewer.hxx,1,['perform'],['performed']
Performance,"///<! current file number (if file extensions); /// Object to be notified when loading a Tree.; /// TTree::LoadTree() and TChain::LoadTree() will call fNotify->Notify().; /// Usually points to a TNotifyLink if this is a TChain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:79,load,loading,79,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,3,"['Load', 'load']","['LoadTree', 'loading']"
Performance,"///<! current lowest entry number in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:41,cache,cache,41,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! custom JavaScript code or URL on JavaScript files to load before start drawing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/inc/TWebCanvas.h:59,load,load,59,gui/webgui6/inc/TWebCanvas.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/inc/TWebCanvas.h,1,['load'],['load']
Performance,"///<! first entry in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:25,cache,cache,25,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! hash table containing loaded plugins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/inc/TASImage.h:28,load,loaded,28,graf2d/asimage/inc/TASImage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/inc/TASImage.h,1,['load'],['loaded']
Performance,"///<! how many send operation can be performed without confirmation from other side",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindow.hxx:37,perform,performed,37,gui/webdisplay/inc/ROOT/RWebWindow.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindow.hxx,1,['perform'],['performed']
Performance,"///<! internal array used to cached the sample data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/DistSampler.h:29,cache,cached,29,math/mathcore/inc/Math/DistSampler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/DistSampler.h,1,['cache'],['cached']
Performance,"///<! is handler runs in synchronous mode (default, no multi-threading)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpWSHandler.h:55,multi-thread,multi-threading,55,net/http/inc/THttpWSHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpWSHandler.h,1,['multi-thread'],['multi-threading']
Performance,"///<! last entry in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:24,cache,cache,24,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! list of branch names in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:34,cache,cache,34,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! locked styles of the objects and pad until streaming is performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPadDisplayItem.hxx:62,perform,performed,62,graf2d/gpadv7/inc/ROOT/RPadDisplayItem.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPadDisplayItem.hxx,1,['perform'],['performed']
Performance,"///<! next entry number where cache must be filled",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:30,cache,cache,30,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! number of blocks that were found in the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCacheUnzip.h:46,cache,cache,46,tree/tree/inc/TTreeCacheUnzip.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCacheUnzip.h,1,['cache'],['cache']
Performance,"///<! number of blocks that were not found in the cache and were unzipped",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCacheUnzip.h:50,cache,cache,50,tree/tree/inc/TTreeCacheUnzip.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCacheUnzip.h,1,['cache'],['cache']
Performance,"///<! optimize drawing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistDrawable.hxx:6,optimiz,optimize,6,hist/histdrawv7/inc/ROOT/RHistDrawable.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histdrawv7/inc/ROOT/RHistDrawable.hxx,1,['optimiz'],['optimize']
Performance,"///<! output queue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindow.hxx:13,queue,queue,13,gui/webdisplay/inc/ROOT/RWebWindow.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindow.hxx,1,['queue'],['queue']
Performance,"///<! performing send operation in other thread",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSEngine.h:6,perform,performing,6,net/http/src/THttpWSEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpWSEngine.h,1,['perform'],['performing']
Performance,"///<! plot of limits; // performance counter: remember how many toys have been thrown",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverter.h:25,perform,performance,25,roofit/roostats/inc/RooStats/HypoTestInverter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/HypoTestInverter.h,1,['perform'],['performance']
Performance,"///<! response header like ContentEncoding, Cache-Control and so on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpCallArg.h:44,Cache,Cache-Control,44,net/http/inc/THttpCallArg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpCallArg.h,1,['Cache'],['Cache-Control']
Performance,"///<! send queue for the connection",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/canvaspainter/src/RCanvasPainter.cxx:11,queue,queue,11,gui/canvaspainter/src/RCanvasPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/canvaspainter/src/RCanvasPainter.cxx,1,['queue'],['queue']
Performance,"///<! send queue, processed after sending draw data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/inc/TWebCanvas.h:11,queue,queue,11,gui/webgui6/inc/TWebCanvas.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/inc/TWebCanvas.h,1,['queue'],['queue']
Performance,"///<! signal emitted when simple mouse click performed on the pad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/inc/TWebCanvas.h:45,perform,performed,45,gui/webgui6/inc/TWebCanvas.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/inc/TWebCanvas.h,2,['perform'],['performed']
Performance,"///<! the stepsize for optimizing the pruning strength parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/ExpectedErrorPruneTool.h:23,optimiz,optimizing,23,tmva/tmva/inc/TMVA/ExpectedErrorPruneTool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/ExpectedErrorPruneTool.h,1,['optimiz'],['optimizing']
Performance,"///<! to optimize GetEntry() in a loop",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h:9,optimiz,optimize,9,tree/tree/inc/TEntryListBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryListBlock.h,2,['optimiz'],['optimize']
Performance,"///<! transient member: cache the mapping",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMappedCategory.h:24,cache,cache,24,roofit/roofitcore/inc/RooMappedCategory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooMappedCategory.h,1,['cache'],['cache']
Performance,"///<! true if cache auto creation or resize check is needed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:14,cache,cache,14,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['cache'],['cache']
Performance,"///<! true if cache is StopLearningPhase was used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:14,cache,cache,14,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! true if cache is in learning mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:14,cache,cache,14,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! true if cache is prefetching whole clusters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:14,cache,cache,14,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['cache'],['cache']
Performance,"///<! true if cache was automatically created",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:14,cache,cache,14,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,1,['cache'],['cache']
Performance,"///<! true if implicit multi-threading is enabled for this tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:23,multi-thread,multi-threading,23,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['multi-thread'],['multi-threading']
Performance,"///<! true if the cache setting was explicitly given by user",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:18,cache,cache,18,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['cache'],['cache']
Performance,"///<! true if we are in the process of executing LearnPrefill; // These members hold cached data for missed branches when miss optimization; // is enabled. Pointers are only initialized if the miss cache is enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:85,cache,cached,85,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,3,"['cache', 'optimiz']","['cache', 'cached', 'optimization']"
Performance,"///<! true if we should optimize cache misses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h:24,optimiz,optimize,24,tree/tree/inc/TTreeCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTreeCache.h,2,"['cache', 'optimiz']","['cache', 'optimize']"
Performance,"///<! true when performing send operation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindow.hxx:16,perform,performing,16,gui/webdisplay/inc/ROOT/RWebWindow.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindow.hxx,1,['perform'],['performing']
Performance,"///<! used to optimize GetEntry() function from a loop",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryList.h:14,optimiz,optimize,14,tree/tree/inc/TEntryList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TEntryList.h,2,['optimiz'],['optimize']
Performance,"///<!; // objects below cache information and are mutable and non-persistent",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ToyMCSampler.h:24,cache,cache,24,roofit/roostats/inc/RooStats/ToyMCSampler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ToyMCSampler.h,1,['cache'],['cache']
Performance,"///<!Cached list of the streamer infos in this file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:5,Cache,Cached,5,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,1,['Cache'],['Cached']
Performance,"///<!Pointer to the read cache (if any)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:25,cache,cache,25,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,2,['cache'],['cache']
Performance,"///<!Pointer to the write cache (if any)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:26,cache,cache,26,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,1,['cache'],['cache']
Performance,"///<!Seek offset cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:17,cache,cache,17,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,1,['cache'],['cache']
Performance,"///<!number of optimized elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfo.h:15,optimiz,optimized,15,io/io/inc/TStreamerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TStreamerInfo.h,1,['optimiz'],['optimized']
Performance,"///<; ///< An array of optional paths. Should have a size of zero or three.; ///< If the array is empty, no redirections are performed.; ///< Otherwise, the inferior process's stdin(0), stdout(1), and stderr(2); ///< will be redirected to the corresponding paths, if the optional path; ///< is present (not \c std::nullopt).; ///< When an empty path is passed in, the corresponding file descriptor; ///< will be disconnected (ie, /dev/null'd) in a portable way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:125,perform,performed,125,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['perform'],['performed']
Performance,"///<Indicates, to force all READ to CACHEREAD",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:36,CACHE,CACHEREAD,36,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,1,['CACHE'],['CACHEREAD']
Performance,"///<Indicates, we trust in the files in the cache dir without stat on the cached file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:44,cache,cache,44,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,2,['cache'],"['cache', 'cached']"
Performance,"///<Number of read calls ( not counting the cache calls )",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:44,cache,cache,44,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,1,['cache'],['cache']
Performance,"///<[fNevBuf] Offset of entries in fBuffer(TKey); generated at runtime. Special value; /// of `-1` indicates that the offset generation MUST be performed on first read.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:144,perform,performed,144,tree/tree/inc/TBasket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h,1,['perform'],['performed']
Performance,"///===- MachineOptimizationRemarkEmitter.cpp - Opt Diagnostic -*- C++ -*---===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp:396,Optimiz,Optimization,396,interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOptimizationRemarkEmitter.cpp,1,['Optimiz'],['Optimization']
Performance,"///===- MachineOptimizationRemarkEmitter.h - Opt Diagnostics -*- C++ -*----===//; ///; /// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; /// See https://llvm.org/LICENSE.txt for license information.; /// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; ///; ///===---------------------------------------------------------------------===//; /// \file; /// Optimization diagnostic interfaces for machine passes. It's packaged as an; /// analysis pass so that by using this service passes become dependent on MBFI; /// as well. MBFI is used to compute the ""hotness"" of the diagnostic message.; ///; ///===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:396,Optimiz,Optimization,396,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,1,['Optimiz'],['Optimization']
Performance,"///@{; /// \name Mutation API; ///; /// These methods provide the core API for updating the call graph in the; /// presence of (potentially still in-flight) DFS-found RefSCCs and SCCs.; ///; /// Note that these methods sometimes have complex runtimes, so be careful; /// how you call them.; /// Make an existing internal ref edge into a call edge.; ///; /// This may form a larger cycle and thus collapse SCCs into TargetN's SCC.; /// If that happens, the optional callback \p MergedCB will be invoked (if; /// provided) on the SCCs being merged away prior to actually performing; /// the merge. Note that this will never include the target SCC as that; /// will be the SCC functions are merged into to resolve the cycle. Once; /// this function returns, these merged SCCs are not in a valid state but; /// the pointers will remain valid until destruction of the parent graph; /// instance for the purpose of clearing cached information. This function; /// also returns 'true' if a cycle was formed and some SCCs merged away as; /// a convenience.; ///; /// After this operation, both SourceN's SCC and TargetN's SCC may move; /// position within this RefSCC's postorder list. Any SCCs merged are; /// merged into the TargetN's SCC in order to preserve reachability analyses; /// which took place on that SCC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:569,perform,performing,569,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,2,"['cache', 'perform']","['cached', 'performing']"
Performance,"///@{; /// \name Mutation APIs; ///; /// These methods provide APIs for submitting updates to the DominatorTree and; /// the PostDominatorTree.; ///; /// Note: There are two strategies to update the DominatorTree and the; /// PostDominatorTree:; /// 1. Eager UpdateStrategy: Updates are submitted and then flushed; /// immediately.; /// 2. Lazy UpdateStrategy: Updates are submitted but only flushed when you; /// explicitly call Flush APIs. It is recommended to use this update strategy; /// when you submit a bunch of updates multiple times which can then; /// add up to a large number of updates between two queries on the; /// DominatorTree. The incremental updater can reschedule the updates or; /// decide to recalculate the dominator tree in order to speedup the updating; /// process depending on the number of updates.; ///; /// Although GenericDomTree provides several update primitives,; /// it is not encouraged to use these APIs directly.; /// Submit updates to all available trees.; /// The Eager Strategy flushes updates immediately while the Lazy Strategy; /// queues the updates.; ///; /// Note: The ""existence"" of an edge in a CFG refers to the CFG which DTU is; /// in sync with + all updates before that single update.; ///; /// CAUTION!; /// 1. It is required for the state of the LLVM IR to be updated; /// *before* submitting the updates because the internal update routine will; /// analyze the current state of the CFG to determine whether an update; /// is valid.; /// 2. It is illegal to submit any update that has already been submitted,; /// i.e., you are supposed not to insert an existent edge or delete a; /// nonexistent edge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:1077,queue,queues,1077,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,1,['queue'],['queues']
Performance,"///@{; /// \name Pre-SCC Mutation API; ///; /// These methods are only valid to call prior to forming any SCCs for this; /// call graph. They can be used to update the core node-graph during; /// a node-based inorder traversal that precedes any SCC-based traversal.; ///; /// Once you begin manipulating a call graph's SCCs, most mutation of the; /// graph must be performed via a RefSCC method. There are some exceptions; /// below.; /// Update the call graph after inserting a new edge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:365,perform,performed,365,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['perform'],['performed']
Performance,"///@}; /** @name Backward Propagation in Max Pooling Layer; */; ///@{; /** Perform the complete backward propagation step in a Max Pooling Layer. Based on the; * winning indices stored in the index matrix, it just forwards the activation; * gradients to the previous layer. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h:75,Perform,Perform,75,tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h,1,['Perform'],['Perform']
Performance,"///@}; /** @name Backward Propagation in Max Pooling Layer; */; ///@{; /** Perform the complete backward propagation step in a Pooling Layer. Based on the; * input to and output from the MaxPoolLayer, the gradients for the winning pixels; * are computed. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/TCudnn.h:75,Perform,Perform,75,tmva/tmva/inc/TMVA/DNN/Architectures/TCudnn.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/TCudnn.h,1,['Perform'],['Perform']
Performance,"///@}; /** @name Backward Propagation in Max Pooling Layer; */; ///@{; /** Perform the complete backward propagation step in a Pooling Layer. Based on the; * winning indices stored in the index matrix, it just forwards the activation; * gradients to the previous layer. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h:75,Perform,Perform,75,tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Cpu.h,2,['Perform'],['Perform']
Performance,"///@}; /** @name Backward Propagation; * Low-level functions required for the forward propagation of activations; * through the network.; */; ///@{; /** Perform the complete backward propagation step. If the provided; * \p activationGradientsBackward matrix is not empty, compute the; * gradients of the objective function with respect to the activations; * of the previous layer (backward direction).; * Also compute the weight and the bias gradients. Modifies the values; * in \p df and thus produces only a valid result, if it is applied the; * first time after the corresponding forward propagation has been per-; * formed. */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h:153,Perform,Perform,153,tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h,1,['Perform'],['Perform']
Performance,"///@}; ////////////////////////////////////////////////////////////////////////////////////////////////////////////; /// Structure to cache information on the histogram variable that is; /// frequently used for histogram weights retrieval.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h:134,cache,cache,134,roofit/roofitcore/inc/RooDataHist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h,1,['cache'],['cache']
Performance,"///Setting up model for evaluation; /// Add here some needed optimizations like disabling eager execution",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:61,optimiz,optimizations,61,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,1,['optimiz'],['optimizations']
Performance,"///\brief Actions that need to be performed on occurance of a comment.; ///; /// That is useful when the comments are meaningful for the interpreter. For; /// example when we run in -verify mode.; ///; ///\param[in] comment - The comment to act on.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h:34,perform,performed,34,interpreter/cling/include/cling/MetaProcessor/MetaSema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h,1,['perform'],['performed']
Performance,"///\brief Actions to be performed on a given file. Loads the given file and; /// calls a function with the name of the file.; ///; /// If the function needs arguments they are specified after the filename in; /// parenthesis.; ///; ///\param[in] file - The filename to load.; ///\param[in] args - The optional list of arguments.; ///\param[out] result - If not NULL, will hold the value of the last; /// expression.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h:24,perform,performed,24,interpreter/cling/include/cling/MetaProcessor/MetaSema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h,3,"['Load', 'load', 'perform']","['Loads', 'load', 'performed']"
Performance,"///\brief Actions to be performed on add include path. It registers new; /// folder where header files can be searched. If \c path is empty print the; /// list of include paths.; ///; ///\param[in] path - The path to add to header search.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h:24,perform,performed,24,interpreter/cling/include/cling/MetaProcessor/MetaSema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h,1,['perform'],['performed']
Performance,"///\brief Actions to be performed on quit.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h:24,perform,performed,24,interpreter/cling/include/cling/MetaProcessor/MetaSema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h,1,['perform'],['performed']
Performance,"///\brief Actions to be performed on request to cancel continuation.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h:24,perform,performed,24,interpreter/cling/include/cling/MetaProcessor/MetaSema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h,1,['perform'],['performed']
Performance,"///\brief Actions to be performed on unload command.; ///; ///\param[in] file - The file to unload.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h:24,perform,performed,24,interpreter/cling/include/cling/MetaProcessor/MetaSema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h,1,['perform'],['performed']
Performance,"///\brief Cache of compiled destructors wrappers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:10,Cache,Cache,10,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,1,['Cache'],['Cache']
Performance,"///\brief Compile (and cache) destructor calls for a record decl. Used by ~Value.; /// They are of type extern ""C"" void()(void* pObj).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:23,cache,cache,23,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,1,['cache'],['cache']
Performance,"///\brief Concatenates current include paths and the system include paths; /// and performs a lookup for the filename. If still not found it tries to; /// add the platform-specific extensions (such as so, dll, dylib) and; /// retries the lookup (from lookupLibInPaths); /// See more information for RPATH and RUNPATH: https://en.wikipedia.org/wiki/Rpath; ///\param[in] filename - The filename being looked up; ///\param[in] RPath - RPATH as provided by loader library, searching for libStem; ///\param[in] RunPath - RUNPATH as provided by loader library, searching for libStem; ///\param[in] libLoader - The library that loads libStem. Use """" for main program.; ///; ///\returns the canonical path to the file or empty string if not found; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h:83,perform,performs,83,interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,4,"['load', 'perform']","['loader', 'loads', 'performs']"
Performance,"///\brief Concatenates current include paths and the system include paths; /// and performs a lookup for the filename.; /// See more information for RPATH and RUNPATH: https://en.wikipedia.org/wiki/Rpath; ///\param[in] libStem - The filename being looked up; ///\param[in] RPath - RPATH as provided by loader library, searching for libStem; ///\param[in] RunPath - RUNPATH as provided by loader library, searching for libStem; ///\param[in] libLoader - The library that loads libStem. Use """" for main program.; ///; ///\returns the canonical path to the file or empty string if not found; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h:83,perform,performs,83,interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,4,"['load', 'perform']","['loader', 'loads', 'performs']"
Performance,"///\brief Constructor for IncrementalCUDADeviceCompiler; ///; ///\param [in] filePath - All files will generated in the folder of the; /// filePath, except the fatbin file, if it have another path. Have; /// to end with a separator. Can be empty.; ///\param [in] optLevel - The optimization level of the interpreter; /// instance.; /// The value will be copied, because a change of it is not allowed.; ///\param [in] invocationOptions - Contains values for the arguments of; /// the interpreter instance and the NVIDIA tool fatbinary.; ///\param [in] CI - Will be used for m_CuArgs and the include path handling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/IncrementalCUDADeviceCompiler.h:278,optimiz,optimization,278,interpreter/cling/include/cling/Interpreter/IncrementalCUDADeviceCompiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/IncrementalCUDADeviceCompiler.h,1,['optimiz'],['optimization']
Performance,"///\brief Describes the result of loading a library.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h:34,load,loading,34,interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,1,['load'],['loading']
Performance,"///\brief DynamicLibraries loaded by this Interpreter.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h:27,load,loaded,27,interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,1,['load'],['loaded']
Performance,"///\brief Emit a llvm::Module to the JIT.; ///; /// @param[in] module - The module to pass to the execution engine.; /// @param[in] optLevel - The optimization level to be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.h:147,optimiz,optimization,147,interpreter/cling/lib/Interpreter/IncrementalExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.h,1,['optimiz'],['optimization']
Performance,"///\brief Flag toggling the optimization level to be used.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:28,optimiz,optimization,28,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,1,['optimiz'],['optimization']
Performance,"///\brief Function that collects the files which we must reread from disk.; ///; /// For example: We must uncache the cached include, which brought a; /// declaration or a macro directive definition in the AST.; ///\param[in] Loc - The source location of the unloaded declaration.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.h:118,cache,cached,118,interpreter/cling/lib/Interpreter/DeclUnloader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.h,1,['cache'],['cached']
Performance,"///\brief Interface to support locking the interpreter state in case of; /// concurrent usage.; ///; /// Cling assumes that any of its function is invoked in a locked context,; /// but before invoking user code (e.g. static initialization or value; /// printing) cling will calling `EnteringUserCode()`, and once; /// done call `ReturnedFromUserCode()`. Typically the user provided locks; /// would be unlock by `EnteringUserCode()` and lock back in; /// `ReturnedFromUserCode()`. State can be returned from EnteringUserCode; /// and made use of in ReturnedFromUserCode(), to identify pairs of these; /// calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h:77,concurren,concurrent,77,interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h,1,['concurren'],['concurrent']
Performance,"///\brief Invalidate cached TCling information for the given declaration, and; /// removed it from the appropriate object list.; ///\param[in] Lists - std::tuple<TListOfDataMembers&, TListOfFunctions&,; /// TListOfFunctionTemplates&, TListOfEnums&>; /// of pointers to the (global/class) object lists.; ///\param[in] D - Decl to discard.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:21,cache,cached,21,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['cache'],['cached']
Performance,"///\brief Invalidate cached TCling information for the given global declaration.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:21,cache,cached,21,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['cache'],['cached']
Performance,"///\brief L command includes the given file or loads the given library. If; /// \c file is empty print the list of library paths.; ///; ///\param[in] file - The file/library to be loaded.; ///\param[out] transaction - Transaction containing the loaded file.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h:47,load,loads,47,interpreter/cling/include/cling/MetaProcessor/MetaSema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h,3,['load'],"['loaded', 'loads']"
Performance,"///\brief Loads a shared library.; ///; ///\param [in] filename - The file to loaded.; ///\param [in] lookup - Whether to try to resolve the filepath; ///; ///\returns kMoreInputExpected is returned when file could not be found; /// otherwise kSuccess or kFailure; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:10,Load,Loads,10,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,2,"['Load', 'load']","['Loads', 'loaded']"
Performance,"///\brief Loads a shared library.; ///; ///\param [in] libStem - The file to load.; ///\param [in] permanent - If false, the file can be unloaded later.; ///\param [in] resolved - Whether libStem is an absolute path or resolved; /// from a previous call to DynamicLibraryManager::lookupLibrary; ///; ///\returns kLoadLibSuccess on success, kLoadLibAlreadyLoaded if the library; /// was already loaded, kLoadLibError if the library cannot be found or any; /// other error was encountered.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h:10,Load,Loads,10,interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,3,"['Load', 'load']","['Loads', 'load', 'loaded']"
Performance,"///\brief Loads header file or shared library.; ///; ///\param [in] filename - The file to be loaded.; ///\param [in] allowSharedLib - Whether to try to load the file as shared; /// library.; ///\param [out] T - Transaction containing the loaded file.; ///\returns result of the compilation.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:10,Load,Loads,10,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,4,"['Load', 'load']","['Loads', 'load', 'loaded']"
Performance,"///\brief Loads header file; ///; ///\param [in] filename - The file to loaded.; ///\param [out] T - Transaction containing the loaded file.; ///\returns result of the compilation.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:10,Load,Loads,10,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,3,"['Load', 'load']","['Loads', 'loaded']"
Performance,"///\brief Lock a region of compilation that is executed by the interpreter; /// during user code execution.; ///; /// When cling is used in multi-threaded environments, all calls to cling; /// are expected to be locked by the caller. Cling will release that lock; /// using `EnteringUserCode()` and re-instate that lock using; /// `ReturnedFromUserCode()` for the duration of the execution of the user; /// code. But that user code can trigger calls to the interpreter itself.; /// These calls are due to instrumented parts of the user code, e.g.; /// `printValue()` calls and `cling::runtime::internal::LifetimeHandler`; /// calls. For those, cling needs to be locked with a mechanism compatible; /// with the mechanism used for `EnteringUserCode()` /; /// `ReturnedFromUserCode()` to avoid deadlocks. Before entering compilation; /// triggered by user code, cling will call; /// `LockCompilationDuringUserCodeExecution()`; after the execution of that; /// code has finished it will call; /// `UnlockCompilationDuringUserCodeExecution()`.; /// Note that after the compilation of that code cling will call; /// `EnteringUserCode()` (before executing) and `ReturnedFromUserCode()`; /// (after execution that code).; ///; /// \returns An optional state object needed for the call to; /// `UnlockCompilationDuringUserCodeExecution(state)`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h:140,multi-thread,multi-threaded,140,interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/InterpreterCallbacks.h,1,['multi-thread'],['multi-threaded']
Performance,"///\brief Look for given symbol in all modules loaded by the current process; ///; /// \returns The adress of the symbol or null if not found; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Utils/Platform.h:47,load,loaded,47,interpreter/cling/include/cling/Utils/Platform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Utils/Platform.h,1,['load'],['loaded']
Performance,"///\brief Looks up a library taking into account the current include paths; /// and the system include paths.; /// See more information for RPATH and RUNPATH: https://en.wikipedia.org/wiki/Rpath; ///\param[in] libStem - The filename being looked up; ///\param[in] RPath - RPATH as provided by loader library, searching for libStem; ///\param[in] RunPath - RUNPATH as provided by loader library, searching for libStem; ///\param[in] libLoader - The library that loads libStem. Use """" for main program.; ///\param[in] variateLibStem - If this param is true, and libStem is ""L"", then; /// we search for ""L"", ""libL"", ""L.so"", ""libL.so"""", etc.; ///; ///\returns the canonical path to the file or empty string if not found; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h:293,load,loader,293,interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,3,['load'],"['loader', 'loads']"
Performance,"///\brief O command prints the current optimization level.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h:39,optimiz,optimization,39,interpreter/cling/include/cling/MetaProcessor/MetaSema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h,1,['optimiz'],['optimization']
Performance,"///\brief O command sets the optimization level.; ///; ///\param[in] optLevel - The optimization level to set.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h:29,optimiz,optimization,29,interpreter/cling/include/cling/MetaProcessor/MetaSema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/MetaProcessor/MetaSema.h,2,['optimiz'],['optimization']
Performance,"///\brief Optimization level.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/CompilationOptions.h:10,Optimiz,Optimization,10,interpreter/cling/include/cling/Interpreter/CompilationOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/CompilationOptions.h,1,['Optimiz'],['Optimization']
Performance,"///\brief Parses input line, which doesn't contain statements. Code; /// generation needed to make the module functional.; ///; /// Same as declare without most of the codegening. Only a few; /// things, like inline function are codegened. Useful when a; /// library is loaded and the header files need to be imported.; ///; ///\param[in] input - The input containing the declarations.; ///; ///\returns Whether the operation was fully successful.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:270,load,loaded,270,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,1,['load'],['loaded']
Performance,"///\brief Parses input line, which doesn't contain statements. No code; /// generation is done.; ///; /// Same as declare without codegening. Useful when a library is loaded and; /// the header files need to be imported.; ///; ///\param[in] input - The input containing the declarations.; ///; ///\returns true if parsing of the input was correct",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/IncrementalCUDADeviceCompiler.h:167,load,loaded,167,interpreter/cling/include/cling/Interpreter/IncrementalCUDADeviceCompiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/IncrementalCUDADeviceCompiler.h,1,['load'],['loaded']
Performance,"///\brief Parses input line, which doesn't contain statements. No code; /// generation is done.; ///; /// Same as declare without codegening. Useful when a library is loaded and; /// the header files need to be imported.; ///; ///\param[in] input - The input containing the declarations.; ///\param[out] T - The cling::Transaction of the parsed input.; ///; ///\returns Whether the operation was fully successful.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:167,load,loaded,167,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,1,['load'],['loaded']
Performance,"///\brief Performs semantic checking on a newly-extracted tag declaration.; ///; /// This routine performs all of the type-checking required for a tag; /// declaration once it has been built. It is used both to check tags before; /// they have been moved onto the global scope.; ///; /// Sets NewTD->isInvalidDecl if an error was encountered.; ///; ///\returns true if the tag declaration is redeclaration.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.h:10,Perform,Performs,10,interpreter/cling/lib/Interpreter/DeclExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.h,2,"['Perform', 'perform']","['Performs', 'performs']"
Performance,"///\brief Performs the insertions of the context in the expression just; /// before evaluation. To be used only at runtime.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicExprInfo.h:10,Perform,Performs,10,interpreter/cling/include/cling/Interpreter/DynamicExprInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicExprInfo.h,1,['Perform'],['Performs']
Performance,"///\brief Prints the current library paths and loaded libraries.; ///; ///\param[in] S - stream to dump to or nullptr for default (cling::outs); ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:47,load,loaded,47,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,1,['load'],['loaded']
Performance,"///\brief Reflection information query interface. The class performs lookups; /// in the currently loaded information in the AST, using the same Parser,; /// Sema and Preprocessor objects.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/LookupHelper.h:60,perform,performs,60,interpreter/cling/include/cling/Interpreter/LookupHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/LookupHelper.h,2,"['load', 'perform']","['loaded', 'performs']"
Performance,"///\brief Returns true if the file was a dynamic library and it was already; /// loaded.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h:81,load,loaded,81,interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,1,['load'],['loaded']
Performance,"///\brief Unloaded declaration contains a SourceLocation, representing a; /// place in the file where it was seen. Clang caches that file and even if; /// a declaration is removed and the file is edited we hit the cached entry.; /// This ADT keeps track of the files from which the unloaded declarations; /// came from so that in the end they could be removed from clang's cache.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.h:121,cache,caches,121,interpreter/cling/lib/Interpreter/DeclUnloader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.h,3,['cache'],"['cache', 'cached', 'caches']"
Performance,"///\brief Whether or not to generate executable (LLVM IR) code for the input; /// or to cache the incoming declarations in a queue; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/CompilationOptions.h:88,cache,cache,88,interpreter/cling/include/cling/Interpreter/CompilationOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/CompilationOptions.h,2,"['cache', 'queue']","['cache', 'queue']"
Performance,"///\brief cling runtime ""Cannot find cling_PrintValue(...)"" cache.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinterSynthesizer.h:60,cache,cache,60,interpreter/cling/lib/Interpreter/ValuePrinterSynthesizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinterSynthesizer.h,1,['cache'],['cache']
Performance,"///\brief cling::runtime::gCling variable cache.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h:42,cache,cache,42,interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h,1,['cache'],['cache']
Performance,"///\brief cling::runtime::internal::copyArray cache.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h:46,cache,cache,46,interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h,1,['cache'],['cache']
Performance,"///\brief cling::runtime::internal::setValueNoAlloc cache.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h:52,cache,cache,52,interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h,1,['cache'],['cache']
Performance,"///\brief cling::runtime::internal::setValueWithAlloc cache.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h:54,cache,cache,54,interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.h,1,['cache'],['cache']
Performance,"///\brief cling_runtime_internal_throwIfInvalidPointer cache.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/NullDerefProtectionTransformer.cpp:55,cache,cache,55,interpreter/cling/lib/Interpreter/NullDerefProtectionTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/NullDerefProtectionTransformer.cpp,1,['cache'],['cache']
Performance,"///\class TBulkBranchRead; /// Helper class for reading many branch entries at once to optimize throughput.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h:87,optimiz,optimize,87,tree/tree/inc/TBranch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranch.h,2,"['optimiz', 'throughput']","['optimize', 'throughput']"
Performance,"///\name Generator functions; ///\{; /// Open a file with `name` for reading.; ///; /// \note: Synchronizes multi-threaded accesses through locks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:108,multi-thread,multi-threaded,108,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['multi-thread'],['multi-threaded']
Performance,"///\returns true if the module was loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:35,load,loaded,35,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['load'],['loaded']
Performance,"///\{; ///\name Global Palettes; /// Register a palette in the set of global palettes, making it available to `GetPalette()`.; /// This function is not thread safe; any concurrent call to global Palette manipulation must be synchronized!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPalette.hxx:169,concurren,concurrent,169,graf2d/gpadv7/inc/ROOT/RPalette.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPalette.hxx,1,['concurren'],['concurrent']
Performance,"///\}; /// Add two histograms.; ///; /// This operation may currently only be performed if the two histograms have; /// the same axis configuration, use the same precision, and if `from` records; /// at least the same statistics as `to` (recording more stats is fine).; ///; /// Adding histograms with incompatible axis binning will be reported at runtime; /// with an `std::runtime_error`. Insufficient statistics in the source; /// histogram will be detected at compile-time and result in a compiler error.; ///; /// In the future, we may either adopt a more relaxed definition of histogram; /// addition or provide a mechanism to convert from one histogram type to; /// another. We currently favor the latter path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx:78,perform,performed,78,hist/histv7/inc/ROOT/RHist.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RHist.hxx,1,['perform'],['performed']
Performance,"///\}; /// Set the new directory used for cached reads, returns the old directory.; ///; /// \note: Synchronizes multi-threaded accesses through locks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:42,cache,cached,42,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,2,"['cache', 'multi-thread']","['cached', 'multi-threaded']"
Performance,"///return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h:32,perform,performed,32,math/mathcore/inc/Math/Minimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Minimizer.h,1,['perform'],['performed']
Performance,"///set Minos errors computation to be performed after fitting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitConfig.h:38,perform,performed,38,math/mathcore/inc/Fit/FitConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitConfig.h,1,['perform'],['performed']
Performance,///}; /// Map to cache isGuaranteedToTransferExecutionToSuccessor results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:17,cache,cache,17,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['cache'],['cache']
Performance,"//; // * Debuggers must implement the GDB JIT interface (gdb, udb, lldb 12+).; // * Debug support is currently limited to ELF on x86-64 platforms that run; // Unix-like systems.; // * There is a test for this example and it ships an IR file that is prepared; // for the instructions below.; //; //; // The following command line session provides a complete walkthrough of the; // feature using LLDB 12:; //; // [Terminal 1] Prepare a debuggable out-of-process JIT session:; //; // > cd llvm-project/build; // > ninja LLJITWithRemoteDebugging llvm-jitlink-executor; // > cp ../llvm/test/Examples/OrcV2Examples/Inputs/argc_sub1_elf.ll .; // > bin/LLJITWithRemoteDebugging --wait-for-debugger argc_sub1_elf.ll; // Found out-of-process executor: bin/llvm-jitlink-executor; // Launched executor in subprocess: 65535; // Attach a debugger and press any key to continue.; //; //; // [Terminal 2] Attach a debugger to the child process:; //; // (lldb) log enable lldb jit; // (lldb) settings set plugin.jit-loader.gdb.enable on; // (lldb) settings set target.source-map Inputs/ \; // /path/to/llvm-project/llvm/test/Examples/OrcV2Examples/Inputs/; // (lldb) attach -p 65535; // JITLoaderGDB::SetJITBreakpoint looking for JIT register hook; // JITLoaderGDB::SetJITBreakpoint setting JIT breakpoint; // Process 65535 stopped; // (lldb) b sub1; // Breakpoint 1: no locations (pending).; // WARNING: Unable to resolve breakpoint to any actual locations.; // (lldb) c; // Process 65535 resuming; //; //; // [Terminal 1] Press a key to start code generation and execution:; //; // Parsed input IR code from: argc_sub1_elf.ll; // Initialized LLJIT for remote executor; // Running: argc_sub1_elf.ll; //; //; // [Terminal 2] Breakpoint hits; we change the argc value from 1 to 42:; //; // (lldb) JITLoaderGDB::JITDebugBreakpointHit hit JIT breakpoint; // JITLoaderGDB::ReadJITDescriptorImpl registering JIT entry at 0x106b34000; // 1 location added to breakpoint 1; // Process 65535 stopped; // * thread #1, queue = 'c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp:1508,load,loader,1508,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithRemoteDebugging/LLJITWithRemoteDebugging.cpp,1,['load'],['loader']
Performance,"//; // At the top level, we read one byte to determine the type of the record to; // create. This byte will comprise of the following bits:; //; // - offset 0: A '1' indicates a metadata record, a '0' indicates a function; // record.; // - offsets 1-7: For metadata records, this will indicate the kind of; // metadata record should be loaded.; //; // We read first byte, then create the appropriate type of record to consume; // the rest of the bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp:336,load,loaded,336,interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/FDRRecordProducer.cpp,1,['load'],['loaded']
Performance,"//; // Author: Sergey Linev 4.03.2014; /*************************************************************************; * Copyright (C) 1995-2019, Rene Brun and Fons Rademakers. *; * All rights reserved. *; * *; * For the licensing terms see $ROOTSYS/LICENSE. *; * For the list of contributors see $ROOTSYS/README/CREDITS. *; *************************************************************************/; /**; \class TBufferJSON; \ingroup IO. Class for serializing object to and from JavaScript Object Notation (JSON) format.; It creates such object representation, which can be directly; used in JavaScript ROOT (JSROOT) for drawing. TBufferJSON implements TBuffer interface, therefore most of; ROOT and user classes can be converted into JSON.; There are certain limitations for classes with custom streamers,; which should be equipped specially for this purposes (see TCanvas::Streamer(); as example). To perform conversion into JSON, one should use TBufferJSON::ToJSON method:; ~~~{.cpp}; TH1 *h1 = new TH1I(""h1"", ""title"", 100, 0, 10);; h1->FillRandom(""gaus"",10000);; TString json = TBufferJSON::ToJSON(h1);; ~~~. To reconstruct object from the JSON string, one should do:; ~~~{.cpp}; TH1 *hnew = nullptr;; TBufferJSON::FromJSON(hnew, json);; if (hnew) hnew->Draw(""hist"");; ~~~; JSON does not include stored class version, therefore schema evolution; (reading of older class versions) is not supported. JSON should not be used as; persistent storage for object data - only for live applications. All STL containers by default converted into JSON Array. Vector of integers:; ~~~{.cpp}; std::vector<int> vect = {1,4,7};; auto json = TBufferJSON::ToJSON(&vect);; ~~~; Will produce JSON code ""[1, 4, 7]"". There are special handling for map classes like `map` and `multimap`.; They will create Array of pair objects with ""first"" and ""second"" as data members. Code:; ~~~{.cpp}; std::map<int,string> m;; m[1] = ""number 1"";; m[2] = ""number 2"";; auto json = TBufferJSON::ToJSON(&m);; ~~~; Will generate json string",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx:900,perform,perform,900,io/io/src/TBufferJSON.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx,1,['perform'],['perform']
Performance,"//; // Check whether the container type is still the same; // to support schema evolution; what is written on the file; // may no longer match the class code which is loaded.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:167,load,loaded,167,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['load'],['loaded']
Performance,"//; // Check whether we should try to optimize for local files",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:38,optimiz,optimize,38,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['optimiz'],['optimize']
Performance,//; // Do the transformation of an aggr load/copy/set to a loop; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXLowerAggrCopies.cpp,1,['load'],['load']
Performance,"//; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for cases (a) and (b) to work the sequence %x-%y above has; // to be preserved by the IR passes.; //; // However, several optimization passes might sink `load` instruction; // or hoist `getelementptr` instruction so that the instructions are; // no longer in sequence. Examples of such passes are:; // SimplifyCFGPass, InstCombinePass, GVNPass.; // After such modification the verifier would reject the BPF program.; //; // To avoid this issue the patterns like (load/store (getelementptr ...)); // are replaced by calls to BPF specific intrinsic functions:; // - llvm.bpf.getelementptr.and.load; // - llvm.bpf.getelementptr.and.store; //; // These calls are lowered back to (load/store (getelementptr ...)); // by BPFCheckAndAdjustIR pass right before the translation from IR to; // machine instructions.; //; // The transformation is split into the following steps:; // - When IR is generated from AST the calls to intrinsic function; // llvm.preserve.static.offset are inserted.; // - BPFPreserveStaticOffsetPass is executed as early as possible; // with AllowPatial set to true, this handles marked GEP chains; // with constant offsets.; // - BPFPreserveStaticOffsetPass is executed at ScalarOptimizerLateEPCallback; // with AllowPatial set to false, this handles marked GEP chains; // with offsets that became constant after loop unrolling, e.g.; // to handle the following code:; //; // struct context { int x[4]; } __attribute__((preserve_static_",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:2460,load,load,2460,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,1,['load'],['load']
Performance,//; // Emit code to use overflow area; //; // Load the overflow_area address into a register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:46,Load,Load,46,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Load'],['Load']
Performance,"//; // Fixup cached streamer info if necessary.; //; // FIXME: What if the class code was unloaded/reloaded since we were cached?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:13,cache,cached,13,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,2,['cache'],['cached']
Performance,//; // Handling intrinsics for circular load and bitreverse load.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,2,['load'],['load']
Performance,"//; // Handling of scalar operations.; //; // All operations default to ""legal"", except:; // - indexed loads and stores (pre-/post-incremented),; // - ANY_EXTEND_VECTOR_INREG, ATOMIC_CMP_SWAP_WITH_SUCCESS, CONCAT_VECTORS,; // ConstantFP, DEBUGTRAP, FCEIL, FCOPYSIGN, FEXP, FEXP2, FFLOOR, FGETSIGN,; // FLOG, FLOG2, FLOG10, FMAXNUM, FMINNUM, FNEARBYINT, FRINT, FROUND, TRAP,; // FTRUNC, PREFETCH, SIGN_EXTEND_VECTOR_INREG, ZERO_EXTEND_VECTOR_INREG,; // which default to ""expand"" for at least one type.; // Misc operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:103,load,loads,103,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['load'],['loads']
Performance,"//; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that performs optimization on SIMD instructions; // with high latency by splitting them into more efficient series of; // instructions.; //; // 1. Rewrite certain SIMD instructions with vector element due to their; // inefficiency on some targets.; //; // For example:; // fmla v0.4s, v1.4s, v2.s[1]; //; // Is rewritten into:; // dup v3.4s, v2.s[1]; // fmla v0.4s, v1.4s, v3.4s; //; // 2. Rewrite interleaved memory access instructions due to their; // inefficiency on some targets.; //; // For example:; // st2 {v0.4s, v1.4s}, addr; //; // Is rewritten into:; // zip1 v2.4s, v0.4s, v1.4s; // zip2 v3.4s, v0.4s, v1.4s; // stp q2, q3, addr; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:332,perform,performs,332,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,3,"['latency', 'optimiz', 'perform']","['latency', 'optimization', 'performs']"
Performance,//; // Pattern optimization methods; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp:15,optimiz,optimization,15,interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,1,['optimiz'],['optimization']
Performance,//; // Perform the actual substitution.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp:7,Perform,Perform,7,interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp,1,['Perform'],['Perform']
Performance,"//; // Recalculate long jump for Boolean optimize; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:41,optimiz,optimize,41,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['optimiz'],['optimize']
Performance,"//; // S2 is normally saved if the stub is for a function which; // returns a float or double value and is not otherwise. This is; // because more work is required after the function the stub; // is calling completes, and so the stub cannot directly return; // and the stub has no stack space to store the return address so; // S2 is used for that purpose.; // In order to take advantage of not saving S2, we need to also; // optimize the call in the stub and this requires some further; // functionality in MipsAsmPrinter which we don't have yet.; // So for now we always save S2. The optimization will be done; // in a follow-on patch.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:426,optimiz,optimize,426,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,2,['optimiz'],"['optimization', 'optimize']"
Performance,//; // Step 1: Randomize the order of the optimizer passes.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:42,optimiz,optimizer,42,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,1,['optimiz'],['optimizer']
Performance,//; // Step 2: Run optimizer passes on the program and check for success.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:19,optimiz,optimizer,19,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,1,['optimiz'],['optimizer']
Performance,//; // Step 3: Compile the optimized code.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:27,optimiz,optimized,27,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,1,['optimiz'],['optimized']
Performance,"//; // The Mips16 hard float is a crazy quilt inherited from gcc. I have a much; // cleaner way to do all of this but it will have to wait until the traditional; // gcc mechanism is completed.; //; // For Pic, in order for Mips16 code to call Mips32 code which according the abi; // have either arguments or returned values placed in floating point registers,; // we use a set of helper functions. (This includes functions which return type; // complex which on Mips are returned in a pair of floating point registers).; //; // This is an encoding that we inherited from gcc.; // In Mips traditional O32, N32 ABI, floating point numbers are passed in; // floating point argument registers 1,2 only when the first and optionally; // the second arguments are float (sf) or double (df).; // For Mips16 we are only concerned with the situations where floating point; // arguments are being passed in floating point registers by the ABI, because; // Mips16 mode code cannot execute floating point instructions to load those; // values and hence helper functions are needed.; // The possibilities are (), (sf), (sf, sf), (sf, df), (df), (df, sf), (df, df); // the helper function suffixs for these are:; // 0, 1, 5, 9, 2, 6, 10; // this suffix can then be calculated as follows:; // for a given argument Arg:; // Arg1x, Arg2x = 1 : Arg is sf; // 2 : Arg is df; // 0: Arg is neither sf or df; // So this stub is the string for number Arg1x + Arg2x*4.; // However not all numbers between 0 and 10 are possible, we check anyway and; // assert if the impossible exists.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp:1008,load,load,1008,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16ISelLowering.cpp,1,['load'],['load']
Performance,"//; // The following three utility classes manage the state of the; // work to be performed and the slaves involved in the process.; // A list of TFileNode(s) describes the hosts with files, each; // has a list of TFileStat(s) keeping the state for each TDSet; // element (file).; //; // The list of TSlaveStat(s) keep track of the work (being) done; // by each slave; //; //------------------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx:82,perform,performed,82,proof/proofplayer/src/TPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx,2,['perform'],['performed']
Performance,"//; // The following utility class manage the state of the; // work to be performed and the slaves involved in the process.; //; // The list of TSlaveStat(s) keep track of the work (being) done; // by each slave; //; //------------------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerUnit.cxx:74,perform,performed,74,proof/proofplayer/src/TPacketizerUnit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerUnit.cxx,1,['perform'],['performed']
Performance,"//; // There are three types of lines in the function body.; //; // * Sampled line represents the profile information of a source location.; // * Callsite line represents the profile information of a callsite.; // * Metadata line represents extra metadata of the function.; //; // Each sampled line may contain several items. Some are optional (marked; // below):; //; // a. Source line offset. This number represents the line number; // in the function where the sample was collected. The line number is; // always relative to the line where symbol of the function is; // defined. So, if the function has its header at line 280, the offset; // 13 is at line 293 in the file.; //; // Note that this offset should never be a negative number. This could; // happen in cases like macros. The debug machinery will register the; // line number at the point of macro expansion. So, if the macro was; // expanded in a line before the start of the function, the profile; // converter should emit a 0 as the offset (this means that the optimizers; // will not be able to associate a meaningful weight to the instructions; // in the macro).; //; // b. [OPTIONAL] Discriminator. This is used if the sampled program; // was compiled with DWARF discriminator support; // (http://wiki.dwarfstd.org/index.php?title=Path_Discriminators).; // DWARF discriminators are unsigned integer values that allow the; // compiler to distinguish between multiple execution paths on the; // same source line location.; //; // For example, consider the line of code ``if (cond) foo(); else bar();``.; // If the predicate ``cond`` is true 80% of the time, then the edge; // into function ``foo`` should be considered to be taken most of the; // time. But both calls to ``foo`` and ``bar`` are at the same source; // line, so a sample count at that line is not sufficient. The; // compiler needs to know which part of that line is taken more; // frequently.; //; // This is what discriminators provide. In this case, the calls to; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h:3366,optimiz,optimizers,3366,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,1,['optimiz'],['optimizers']
Performance,"//; // This function is located here to allow inlining by the optimizer.; //; ////////////////////////////////////////////////////////////////////////////////; /// Get streamer info for the branch class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:62,optimiz,optimizer,62,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['optimiz'],['optimizer']
Performance,"//; // This is the multi-threaded multiclass version; //; // Note: we only need to update the predicted probabilities every; // `nClasses` tree. Let's call a set of `nClasses` trees a ""round"". Thus; // the algortihm is split in two parts `update_residuals` and; // `update_residuals_last` where the latter is inteded to be run instead; // of the former for the last tree in a ""round"".; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:19,multi-thread,multi-threaded,19,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,1,['multi-thread'],['multi-threaded']
Performance,"//; // optimize booleans; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx:7,optimiz,optimize,7,hist/hist/src/TFormula_v5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula_v5.cxx,1,['optimiz'],['optimize']
Performance,"//; /// By default range [8800..9800] is used; ///; /// One also can bind HTTP server socket to loopback address,; /// In that case only connection from localhost will be available:; ///; /// WebGui.HttpLoopback: yes; ///; /// Or one could specify hostname which should be used for binding of server socket; ///; /// WebGui.HttpBind: hostname | ipaddress; ///; /// To use secured protocol, following parameter should be specified; ///; /// WebGui.UseHttps: yes; /// WebGui.ServerCert: sertificate_filename.pem; ///; /// Alternatively, one can specify unix socket to handle requests:; ///; /// WebGui.UnixSocket: /path/to/unix/socket; /// WebGui.UnixSocketMode: 0700; ///; /// Typically one used unix sockets together with server mode like `root --web=server:/tmp/root.socket` and; /// then redirect it via ssh tunnel (e.g. using `rootssh`) to client node; ///; /// All incoming requests processed in THttpServer in timer handler with 10 ms timeout.; /// One may decrease value to improve latency or increase value to minimize CPU load; ///; /// WebGui.HttpTimer: 10; ///; /// To processing incoming http requests and websockets, THttpServer allocate 10 threads; /// One have to increase this number if more simultaneous connections are expected:; ///; /// WebGui.HttpThrds: 10; ///; /// One also can configure usage of special thread of processing of http server requests; ///; /// WebGui.HttpThrd: no; ///; /// Extra threads can be used to send data to different clients via websocket (default no); ///; /// WebGui.SenderThrds: no; ///; /// If required, one could change websocket timeouts (default is 10000 ms); ///; /// WebGui.HttpWSTmout: 10000; ///; /// By default, THttpServer created in restricted mode which only allows websocket handlers; /// and processes only very few other related http requests. For security reasons such mode; /// should be always enabled. Only if it is really necessary to process all other kinds; /// of HTTP requests, one could specify no for following parameter (de",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx:1439,latency,latency,1439,gui/webdisplay/src/RWebWindowsManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx,2,"['latency', 'load']","['latency', 'load']"
Performance,"//; //; // The Adadelta Optimizer Class - Implementation; //_________________________________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h:24,Optimiz,Optimizer,24,tmva/tmva/inc/TMVA/DNN/Adadelta.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adadelta.h,1,['Optimiz'],['Optimizer']
Performance,"//; //; // The Adagrad Optimizer Class - Implementation; //_________________________________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adagrad.h:23,Optimiz,Optimizer,23,tmva/tmva/inc/TMVA/DNN/Adagrad.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adagrad.h,1,['Optimiz'],['Optimizer']
Performance,"//; //; // The Adam Optimizer Class - Implementation; //_________________________________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h:20,Optimiz,Optimizer,20,tmva/tmva/inc/TMVA/DNN/Adam.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Adam.h,1,['Optimiz'],['Optimizer']
Performance,"//; //; // The General Optimizer Class - Implementation; //_________________________________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Optimizer.h:23,Optimiz,Optimizer,23,tmva/tmva/inc/TMVA/DNN/Optimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Optimizer.h,1,['Optimiz'],['Optimizer']
Performance,"//; //; // The RMSProp Optimizer Class - Implementation; //_________________________________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h:23,Optimiz,Optimizer,23,tmva/tmva/inc/TMVA/DNN/RMSProp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/RMSProp.h,1,['Optimiz'],['Optimizer']
Performance,"//; //; // The Stochastic Gradient Descent Optimizer Class - Implementation; //_________________________________________________________________________________________________",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/SGD.h:43,Optimiz,Optimizer,43,tmva/tmva/inc/TMVA/DNN/SGD.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/SGD.h,1,['Optimiz'],['Optimizer']
Performance,"//; //tuneParameters.insert(std::pair<TString,Interval*>(""NodePurityLimit"",new Interval(.4,.6,3))); // stepsize .1; //tuneParameters.insert(std::pair<TString,Interval*>(""BaggedSampleFraction"",new Interval(.4,.9,6))); // stepsize .1; // method-specific parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:6,tune,tuneParameters,6,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,2,['tune'],['tuneParameters']
Performance,"//=- CachePruning.h - Helper to manage the pruning of a cache dir -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements pruning of a directory intended for cache storage, using; // various policies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:5,Cache,CachePruning,5,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,3,"['Cache', 'cache']","['CachePruning', 'cache']"
Performance,"//=- WebAssemblySetP2AlignOperands.cpp - Set alignments on loads and stores -=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file sets the p2align operands on load and store instructions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySetP2AlignOperands.cpp:59,load,loads,59,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySetP2AlignOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblySetP2AlignOperands.cpp,2,['load'],"['load', 'loads']"
Performance,"//=- llvm/CodeGen/GlobalISel/RegBankSelect.h - Reg Bank Selector --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file describes the interface of the MachineFunctionPass; /// responsible for assigning the generic virtual registers to register bank.; ///; /// By default, the reg bank selector relies on local decisions to; /// assign the register bank. In other words, it looks at one instruction; /// at a time to decide where the operand of that instruction should live.; ///; /// At higher optimization level, we could imagine that the reg bank selector; /// would use more global analysis and do crazier thing like duplicating; /// instructions and so on. This is future work.; ///; /// For now, the pass uses a greedy algorithm to decide where the operand; /// of an instruction should live. It asks the target which banks may be; /// used for each operand of the instruction and what is the cost. Then,; /// it chooses the solution which minimize the cost of the instruction plus; /// the cost of any move that may be needed to the values into the right; /// register bank.; /// In other words, the cost for an instruction on a register bank RegBank; /// is: Cost of I on RegBank plus the sum of the cost for bringing the; /// input operands from their current register bank to RegBank.; /// Thus, the following formula:; /// cost(I, RegBank) = cost(I.Opcode, RegBank) +; /// sum(for each arg in I.arguments: costCrossCopy(arg.RegBank, RegBank)); ///; /// E.g., Let say we are assigning the register bank for the instruction; /// defining v2.; /// v0(A_REGBANK) = ...; /// v1(A_REGBANK) = ...; /// v2 = G_ADD i32 v0, v1 <-- MI; ///; /// The target may say it can generate G_ADD i32 on register bank A and B; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:779,optimiz,optimization,779,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,1,['optimiz'],['optimization']
Performance,"//=- llvm/LTO/SummaryBasedOptimizations.h -Link time optimizations-*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/SummaryBasedOptimizations.h:53,optimiz,optimizations,53,interpreter/llvm-project/llvm/include/llvm/LTO/SummaryBasedOptimizations.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/SummaryBasedOptimizations.h,1,['optimiz'],['optimizations']
Performance,"//== BoolAssignmentChecker.cpp - Boolean assignment checker -----*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines BoolAssignmentChecker, a builtin check in ExprEngine that; // performs checks for assignment of non-Boolean values to Boolean variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BoolAssignmentChecker.cpp:458,perform,performs,458,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BoolAssignmentChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BoolAssignmentChecker.cpp,1,['perform'],['performs']
Performance,"//== DivZeroChecker.cpp - Division by zero checker --------------*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines DivZeroChecker, a builtin check in ExprEngine that performs; // checks for division by zeros.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DivZeroChecker.cpp:447,perform,performs,447,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DivZeroChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DivZeroChecker.cpp,1,['perform'],['performs']
Performance,"//== ObjCContainersChecker.cpp - Path sensitive checker for CFArray *- C++ -*=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Performs path sensitive checks of Core Foundation static containers like; // CFArray.; // 1) Check for buffer overflows:; // In CFArrayGetArrayAtIndex( myArray, index), if the index is outside the; // index space of theArray (0 to N-1 inclusive (where N is the count of; // theArray), the behavior is undefined.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp:383,Perform,Performs,383,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersChecker.cpp,1,['Perform'],['Performs']
Performance,"//== ObjCSelfInitChecker.cpp - Checker for 'self' initialization -*- C++ -*--=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines ObjCSelfInitChecker, a builtin check that checks for uses of; // 'self' before proper initialization.; //; //===----------------------------------------------------------------------===//; // This checks initialization methods to verify that they assign 'self' to the; // result of an initialization call (e.g. [super init], or [self initWith..]); // before using 'self' or any instance variable.; //; // To perform the required checking, values are tagged with flags that indicate; // 1) if the object is the one pointed to by 'self', and 2) if the object; // is the result of an initializer (e.g. [super init]).; //; // Uses of an object that is true for 1) but not 2) trigger a diagnostic.; // The uses that are currently checked are:; // - Using instance variables.; // - Returning the object.; //; // Note that we don't check for an invalid 'self' that is the receiver of an; // obj-c message expression to cut down false positives where logging functions; // get information from self (like its class) or doing ""invalidation"" on self; // when the initialization fails.; //; // Because the object that 'self' points to gets invalidated when a call; // receives a reference to 'self', the checker keeps track and passes the flags; // for 1) and 2) to the new object that 'self' points to after the call.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:804,perform,perform,804,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,1,['perform'],['perform']
Performance,"//== TestAfterDivZeroChecker.cpp - Test after division by zero checker --*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines TestAfterDivZeroChecker, a builtin check that performs checks; // for division by zero where the division occurs before comparison with zero.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp:442,perform,performs,442,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/TestAfterDivZeroChecker.cpp,1,['perform'],['performs']
Performance,"//== WebAssemblyMemIntrinsicResults.cpp - Optimize memory intrinsic results ==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements an optimization pass using memory intrinsic results.; ///; /// Calls to memory intrinsics (memcpy, memmove, memset) return the destination; /// address. They are in the form of; /// %dst_new = call @memcpy %dst, %src, %len; /// where %dst and %dst_new registers contain the same value.; ///; /// This is to enable an optimization wherein uses of the %dst register used in; /// the parameter can be replaced by uses of the %dst_new register used in the; /// result, making the %dst register more likely to be single-use, thus more; /// likely to be useful to register stackifying, and potentially also exposing; /// the call instruction itself to register stackifying. These both can reduce; /// local.get/local.set traffic.; ///; /// The LLVM intrinsics for these return void so they can't use the returned; /// attribute and consequently aren't handled by the OptimizeReturned pass.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp:42,Optimiz,Optimize,42,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyMemIntrinsicResults.cpp,4,"['Optimiz', 'optimiz']","['Optimize', 'OptimizeReturned', 'optimization']"
Performance,"//== llvm/CodeGen/GlobalISel/LoadStoreOpt.h - LoadStoreOpt -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// This is an optimization pass for GlobalISel generic memory operations.; /// Specifically, it focuses on merging stores and loads to consecutive; /// addresses.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h:29,Load,LoadStoreOpt,29,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,4,"['Load', 'load', 'optimiz']","['LoadStoreOpt', 'loads', 'optimization']"
Performance,"//==- AArch64PromoteConstant.cpp - Promote constant to global for AArch64 --==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AArch64PromoteConstant pass which promotes constants; // to global variables when this is likely to be more efficient. Currently only; // types related to constant vector (i.e., constant vector, array of constant; // vectors, constant structure with a constant vector field, etc.) are promoted; // to global variables. Constant vectors are likely to be lowered in target; // constant pool during instruction selection already; therefore, the access; // will remain the same (memory load), but the structure types are not split; // into different constant pool accesses for each field. A bonus side effect is; // that created globals may be merged by the global merge pass.; //; // FIXME: This pass may be useful for other targets too.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp:890,load,load,890,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp,1,['load'],['load']
Performance,"//==- ConstantHoisting.h - Prepare code for expensive constants --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h:1553,perform,perform,1553,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/ConstantHoisting.h,3,"['load', 'optimiz', 'perform']","['load', 'optimization', 'perform']"
Performance,"//==- MemProfContextDisambiguation.h - Context Disambiguation ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements support for context disambiguation of allocation calls for profile; // guided heap optimization using memprof metadata. See implementation file for; // details.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h:477,optimiz,optimization,477,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/MemProfContextDisambiguation.h,1,['optimiz'],['optimization']
Performance,"//==- RegAllocGreedy.h ------- greedy register allocator ----------*-C++-*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines the RAGreedy function pass for register allocation in; // optimized builds.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:454,optimiz,optimized,454,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,1,['optimiz'],['optimized']
Performance,"//==- RegAllocScore.h - evaluate regalloc policy quality ----------*-C++-*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// Calculate a measure of the register allocation policy quality. This is used; /// to construct a reward for the training of the ML-driven allocation policy.; /// Currently, the score is the sum of the machine basic block frequency-weighed; /// number of loads, stores, copies, and remat instructions, each factored with; /// a relative weight.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.h:632,load,loads,632,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.h,1,['load'],['loads']
Performance,"//==- SymbolCache.h - Cache of native symbols and ids ------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h:22,Cache,Cache,22,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,1,['Cache'],['Cache']
Performance,"//==- SystemZMachineScheduler.h - SystemZ Scheduler Interface ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:652,optimiz,optimize,652,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['optimiz'],['optimize']
Performance,"//==- TLSVariableHoist.h ------ Remove Redundant TLS Loads -------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminates Redundant TLS Loads if related option is set.; // For example:; // static __thread int x;; // int g();; // int f(int c) {; // int *px = &x;; // while (c--); // *px += g();; // return *px;; // }; //; // will generate Redundant TLS Loads by compiling it with; // clang++ -fPIC -ftls-model=global-dynamic -O2 -S; //; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // movl %eax, %ebp; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // addl _ZL1x@DTPOFF(%rax), %ebp; // movl %ebp, _ZL1x@DTPOFF(%rax); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; // .LBB0_4: # %entry.while.end_crit_edge; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // movl _ZL1x@DTPOFF(%rax), %ebp; //; // The Redundant TLS Loads will hurt the performance, especially in loops.; // So we try to eliminate/move them if required by customers, let it be:; //; // # %bb.0: # %entry; // ...; // movl %edi, %ebx; // leaq _ZL1x@TLSLD(%rip), %rdi; // callq __tls_get_addr@PLT; // leaq _ZL1x@DTPOFF(%rax), %r14; // testl %ebx, %ebx; // je .LBB0_1; // .LBB0_2: # %while.body; // # =>This Inner Loop Header: Depth=1; // callq _Z1gv@PLT; // addl (%r14), %eax; // movl %eax, (%r14); // addl $-1, %ebx; // jne .LBB0_2; // jmp .LBB0_3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h:53,Load,Loads,53,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/TLSVariableHoist.h,5,"['Load', 'perform']","['Loads', 'performance']"
Performance,"//==- X86IndirectThunks.cpp - Construct indirect call/jump thunks for x86 --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Pass that injects an MI thunk that is used to lower indirect calls in a way; /// that prevents speculation on some x86 processors and can be used to mitigate; /// security vulnerabilities due to targeted speculative execution and side; /// channels such as CVE-2017-5715.; ///; /// Currently supported thunks include:; /// - Retpoline -- A RET-implemented trampoline that lowers indirect calls; /// - LVI Thunk -- A CALL/JMP-implemented thunk that forces load serialization; /// before making an indirect call/jump; ///; /// Note that the reason that this is implemented as a MachineFunctionPass and; /// not a ModulePass is that ModulePasses at this point in the LLVM X86 pipeline; /// serialize all transformations, which can consume lots of memory.; ///; /// TODO(chandlerc): All of this code could use better comments and; /// documentation.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp:850,load,load,850,interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86IndirectThunks.cpp,1,['load'],['load']
Performance,"//==-- ConstantFold.h - DL-independent Constant Folding Interface -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the DataLayout-independent constant folding interface.; // When possible, the DataLayout-aware constant folding interface in; // Analysis/ConstantFolding.h should be preferred.; //; // These interfaces are used by the ConstantExpr::get* methods to automatically; // fold constants when possible.; //; // These operators may return a null object if they don't know how to perform; // the specified operation on the specified constant types.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantFold.h:772,perform,perform,772,interpreter/llvm-project/llvm/include/llvm/IR/ConstantFold.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantFold.h,1,['perform'],['perform']
Performance,"//==-- MemProfContextDisambiguation.cpp - Disambiguate contexts -------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements support for context disambiguation of allocation; // calls for profile guided heap optimization. Specifically, it uses Memprof; // profiles which indicate context specific allocation behavior (currently; // distinguishing cold vs hot memory allocations). Cloning is performed to; // expose the cold allocation call contexts, and the allocation calls are; // subsequently annotated with an attribute for later transformation.; //; // The transformations can be performed either directly on IR (regular LTO), or; // on a ThinLTO index (and later applied to the IR during the ThinLTO backend).; // Both types of LTO operate on a the same base graph representation, which; // uses CRTP to support either IR or Index formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:487,optimiz,optimization,487,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,3,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"//==-- X86LoadValueInjectionLoadHardening.cpp - LVI load hardening for x86 --=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// Description: This pass finds Load Value Injection (LVI) gadgets consisting; /// of a load from memory (i.e., SOURCE), and any operation that may transmit; /// the value loaded from memory over a covert channel, or use the value loaded; /// from memory to determine a branch/call target (i.e., SINK). After finding; /// all such gadgets in a given function, the pass minimally inserts LFENCE; /// instructions in such a manner that the following property is satisfied: for; /// all SOURCE+SINK pairs, all paths in the CFG from SOURCE to SINK contain at; /// least one LFENCE instruction. The algorithm that implements this minimal; /// insertion is influenced by an academic paper that minimally inserts memory; /// fences for high-performance concurrent programs:; /// http://www.cs.ucr.edu/~lesani/companion/oopsla15/OOPSLA15.pdf; /// The algorithm implemented in this pass is as follows:; /// 1. Build a condensed CFG (i.e., a GadgetGraph) consisting only of the; /// following components:; /// - SOURCE instructions (also includes function arguments); /// - SINK instructions; /// - Basic block entry points; /// - Basic block terminators; /// - LFENCE instructions; /// 2. Analyze the GadgetGraph to determine which SOURCE+SINK pairs (i.e.,; /// gadgets) are already mitigated by existing LFENCEs. If all gadgets have been; /// mitigated, go to step 6.; /// 3. Use a heuristic or plugin to approximate minimal LFENCE insertion.; /// 4. Insert one LFENCE along each CFG edge that was cut in step 3.; /// 5. Go to step 2.; /// 6. If any LFENCEs were inserted, return `true` from runOnMachineFunction(); /// to tell",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp:52,load,load,52,interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LoadValueInjectionLoadHardening.cpp,5,"['Load', 'load']","['Load', 'load', 'loaded']"
Performance,"//==-- handle_llvm.cpp - Helper function for Clang fuzzers -----------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements HandleLLVM for use by the Clang fuzzers. First runs a loop; // vectorizer optimization pass over the given IR code. Then mimics lli on both; // versions to JIT the generated code and execute it. Currently, functions are ; // executed on dummy inputs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp:468,optimiz,optimization,468,interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-fuzzer/handle-llvm/handle_llvm.cpp,1,['optimiz'],['optimization']
Performance,"//==-- llvm/CodeGen/ExecutionDomainFix.h - Execution Domain Fix -*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Execution Domain Fix pass.; ///; /// Some X86 SSE instructions like mov, and, or, xor are available in different; /// variants for different operand types. These variant instructions are; /// equivalent, but on Nehalem and newer cpus there is extra latency; /// transferring data between integer and floating point domains. ARM cores; /// have similar issues when they are configured with both VFP and NEON; /// pipelines.; ///; /// This pass changes the variant instructions to minimize domain crossings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:639,latency,latency,639,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,1,['latency'],['latency']
Performance,"//==--- MachineLateInstrsCleanup.cpp - Late Instructions Cleanup Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This simple pass removes any identical and redundant immediate or address; // loads to the same register. The immediate loads removed can originally be; // the result of rematerialization, while the addresses are redundant frame; // addressing anchor points created during Frame Indices elimination.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:461,load,loads,461,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,2,['load'],['loads']
Performance,"//==------ UpdateCompilerUsed.h - LLVM Link Time Optimizer Utility --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares a helper class to update llvm.compiler_used metadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/UpdateCompilerUsed.h:49,Optimiz,Optimizer,49,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/UpdateCompilerUsed.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/UpdateCompilerUsed.h,1,['Optimiz'],['Optimizer']
Performance,"//==-LTOInternalize.cpp - LLVM Link Time Optimizer Internalization Utility -==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a helper to run the internalization part of LTO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp:41,Optimiz,Optimizer,41,interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/UpdateCompilerUsed.cpp,1,['Optimiz'],['Optimizer']
Performance,"//==-SummaryBasedOptimizations.cpp - Optimizations based on ThinLTO summary-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements optimizations that are based on the module summaries.; // These optimizations are performed during the thinlink phase of the; // compilation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp:37,Optimiz,Optimizations,37,interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/SummaryBasedOptimizations.cpp,4,"['Optimiz', 'optimiz', 'perform']","['Optimizations', 'optimizations', 'performed']"
Performance,"//=== A15SDOptimizerPass.cpp - Optimize DPR and SPR register accesses on A15==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The Cortex-A15 processor employs a tracking scheme in its register renaming; // in order to process each instruction's micro-ops speculatively and; // out-of-order with appropriate forwarding. The ARM architecture allows VFP; // instructions to read and write 32-bit S-registers. Each S-register; // corresponds to one half (upper or lower) of an overlaid 64-bit D-register.; //; // There are several instruction patterns which can be used to provide this; // capability which can provide higher performance than other, potentially more; // direct patterns, specifically around when one micro-op reads a D-register; // operand that has recently been written as one or more S-register results.; //; // This file defines a pre-regalloc pass which looks for SPR producers which; // are going to be used by a DPR (or QPR) consumers and creates the more; // optimized access pattern.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp:31,Optimiz,Optimize,31,interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,3,"['Optimiz', 'optimiz', 'perform']","['Optimize', 'optimized', 'performance']"
Performance,"//=== AArch64PostLegalizerLowering.cpp --------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Post-legalization lowering for instructions.; ///; /// This is used to offload pattern matching from the selector.; ///; /// For example, this combiner will notice that a G_SHUFFLE_VECTOR is actually; /// a G_ZIP, G_UZP, etc.; ///; /// General optimization combines should be handled by either the; /// AArch64PostLegalizerCombiner or the AArch64PreLegalizerCombiner.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp:640,optimiz,optimization,640,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,1,['optimiz'],['optimization']
Performance,"//=== AArch64PostSelectOptimize.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass does post-instruction-selection optimizations in the GlobalISel; // pipeline, before the rest of codegen runs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostSelectOptimize.cpp:425,optimiz,optimizations,425,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostSelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostSelectOptimize.cpp,1,['optimiz'],['optimizations']
Performance,"//=== AnyCall.h - Abstraction over different callables --------*- C++ -*--//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A utility class for performing generic operations over different callables.; //; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/AnyCall.h:399,perform,performing,399,interpreter/llvm-project/clang/include/clang/Analysis/AnyCall.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/AnyCall.h,1,['perform'],['performing']
Performance,"//=== UndefResultChecker.cpp ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines UndefResultChecker, a builtin check in ExprEngine that; // performs checks for undefined results of non-assignment binary operators.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp:455,perform,performs,455,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefResultChecker.cpp,1,['perform'],['performs']
Performance,"//=== VLASizeChecker.cpp - Undefined dereference checker --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines VLASizeChecker, a builtin check in ExprEngine that; // performs checks for declaration of VLA of undefined or zero size.; // In addition, VLASizeChecker is responsible for defining the extent; // of the MemRegion that represents a VLA.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp:451,perform,performs,451,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/VLASizeChecker.cpp,1,['perform'],['performs']
Performance,"//===- AArch64ExpandPseudoInsts.cpp - Expand pseudo instructions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling and other late optimizations. This; // pass should be run after register allocation but before the post-regalloc; // scheduling pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp:513,optimiz,optimizations,513,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp,1,['optimiz'],['optimizations']
Performance,"//===- AArch64FalkorHWPFFix.cpp - Avoid HW prefetcher pitfalls on Falkor --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file For Falkor, we want to avoid HW prefetcher instruction tag collisions; /// that may inhibit the HW prefetching. This is done in two steps. Before; /// ISel, we mark strided loads (i.e. those that will likely benefit from; /// prefetching) with metadata. Then, after opcodes have been finalized, we; /// insert MOVs and re-write loads to prevent unintentional tag collisions.; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp:559,load,loads,559,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp,2,['load'],['loads']
Performance,"//===- AArch64LoadStoreOptimizer.cpp - AArch64 load/store opt. pass -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that performs load / store related peephole; // optimizations. This pass should be run after register allocation.; //; // The pass runs after the PrologEpilogInserter where we emit the CFI; // instructions. In order to preserve the correctness of the unwind informaiton,; // the pass should not change the order of any two instructions, one of which; // has the FrameSetup/FrameDestroy flag or, alternatively, apply an add-hoc fix; // to unwind information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp:47,load,load,47,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp,4,"['load', 'optimiz', 'perform']","['load', 'optimizations', 'performs']"
Performance,"//===- AArch64LoopIdiomTransform.cpp - Loop idiom recognition -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements a pass that recognizes certain loop idioms and; // transforms them into more optimized versions of the same loop. In cases; // where this happens, it can be a significant performance win.; //; // We currently only recognize one loop that finds the first mismatched byte; // in an array and returns the index, i.e. something like:; //; // while (++i != n) {; // if (a[i] != b[i]); // break;; // }; //; // In this example we can actually vectorize the loop despite the early exit,; // although the loop vectorizer does not support it. It requires some extra; // checks to deal with the possibility of faulting loads when crossing page; // boundaries. However, even with these checks it is still profitable to do the; // transformation.; //; //===----------------------------------------------------------------------===//; //; // TODO List:; //; // * Add support for the inverse case where we scan for a matching element.; // * Permit 64-bit induction variable types.; // * Recognize loops that increment the IV *after* comparing bytes.; // * Allow 32-bit sign-extends of the IV used by the GEP.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp:481,optimiz,optimized,481,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LoopIdiomTransform.cpp,3,"['load', 'optimiz', 'perform']","['loads', 'optimized', 'performance']"
Performance,"//===- AArch64MIPeepholeOpt.cpp - AArch64 MI peephole optimization pass ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs below peephole optimizations on MIR level.; //; // 1. MOVi32imm + ANDWrr ==> ANDWri + ANDWri; // MOVi64imm + ANDXrr ==> ANDXri + ANDXri; //; // 2. MOVi32imm + ADDWrr ==> ADDWRi + ADDWRi; // MOVi64imm + ADDXrr ==> ANDXri + ANDXri; //; // 3. MOVi32imm + SUBWrr ==> SUBWRi + SUBWRi; // MOVi64imm + SUBXrr ==> SUBXri + SUBXri; //; // The mov pseudo instruction could be expanded to multiple mov instructions; // later. In this case, we could try to split the constant operand of mov; // instruction into two immediates which can be directly encoded into; // *Wri/*Xri instructions. It makes two AND/ADD/SUB instructions instead of; // multiple `mov` + `and/add/sub` instructions.; //; // 4. Remove redundant ORRWrs which is generated by zero-extend.; //; // %3:gpr32 = ORRWrs $wzr, %2, 0; // %4:gpr64 = SUBREG_TO_REG 0, %3, %subreg.sub_32; //; // If AArch64's 32-bit form of instruction defines the source operand of; // ORRWrs, we can remove the ORRWrs because the upper 32 bits of the source; // operand are set to zero.; //; // 5. %reg = INSERT_SUBREG %reg(tied-def 0), %subreg, subidx; // ==> %reg:subidx = SUBREG_TO_REG 0, %subreg, subidx; //; // 6. %intermediate:gpr32 = COPY %src:fpr128; // %dst:fpr128 = INSvi32gpr %dst_vec:fpr128, dst_index, %intermediate:gpr32; // ==> %dst:fpr128 = INSvi32lane %dst_vec:fpr128, dst_index, %src:fpr128, 0; //; // In cases where a source FPR is copied to a GPR in order to be copied; // to a destination FPR, we can directly copy the values between the FPRs,; // eliminating the use of the Integer unit. When we match a pattern of; // INSvi[X]gpr that is preced",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp:54,optimiz,optimization,54,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp,3,"['optimiz', 'perform']","['optimization', 'optimizations', 'performs']"
Performance,"//===- AArch64SpeculationHardening.cpp - Harden Against Missspeculation --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass to insert code to mitigate against side channel; // vulnerabilities that may happen under control flow miss-speculation.; //; // The pass implements tracking of control flow miss-speculation into a ""taint""; // register. That taint register can then be used to mask off registers with; // sensitive data when executing under miss-speculation, a.k.a. ""transient; // execution"".; // This pass is aimed at mitigating against SpectreV1-style vulnarabilities.; //; // It also implements speculative load hardening, i.e. using the taint register; // to automatically mask off loaded data.; //; // As a possible follow-on improvement, also an intrinsics-based approach as; // explained at https://lwn.net/Articles/759423/ could be implemented on top of; // the current design.; //; // For AArch64, the following implementation choices are made to implement the; // tracking of control flow miss-speculation into a taint register:; // Some of these are different than the implementation choices made in; // the similar pass implemented in X86SpeculativeLoadHardening.cpp, as; // the instruction set characteristics result in different trade-offs.; // - The speculation hardening is done after register allocation. With a; // relative abundance of registers, one register is reserved (X16) to be; // the taint register. X16 is expected to not clash with other register; // reservation mechanisms with very high probability because:; // . The AArch64 ABI doesn't guarantee X16 to be retained across any call.; // . The only way to request X16 to be used as a programmer is through; // inline assembly. In",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:901,load,load,901,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,2,['load'],"['load', 'loaded']"
Performance,"//===- ADCE.cpp - Code to perform dead code elimination -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Aggressive Dead Code Elimination pass. This pass; // optimistically assumes that all instructions are dead until proven otherwise,; // allowing it to eliminate dead computations that other DCE passes do not; // catch, particularly involving loop computations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:26,perform,perform,26,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['perform'],['perform']
Performance,"//===- AMDGPUAnnotateKernelFeaturesPass.cpp -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This pass propagates the uniform-work-group-size attribute from; /// kernels to leaf functions when possible. It also adds additional attributes; /// to hint ABI lowering optimizations later.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAnnotateKernelFeatures.cpp:561,optimiz,optimizations,561,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAnnotateKernelFeatures.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAnnotateKernelFeatures.cpp,1,['optimiz'],['optimizations']
Performance,"//===- AMDGPULibCalls.cpp -------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file does AMD library function optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:431,optimiz,optimizations,431,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['optimiz'],['optimizations']
Performance,"//===- AMDGPUOpenCLEnqueuedBlockLowering.cpp - Lower enqueued block -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // This post-linking pass replaces the function pointer of enqueued; // block kernel with a global variable (runtime handle) and adds; // ""runtime-handle"" attribute to the enqueued block kernel.; //; // In LLVM CodeGen the runtime-handle metadata will be translated to; // RuntimeHandle metadata in code object. Runtime allocates a global buffer; // for each kernel with RuntimeHandle metadata and saves the kernel address; // required for the AQL packet into the buffer. __enqueue_kernel function; // in device library knows that the invoke function pointer in the block; // literal is actually runtime handle and loads the kernel address from it; // and put it into AQL packet for dispatching.; //; // This cannot be done in FE since FE cannot create a unique global variable; // with external linkage across LLVM modules. The global variable with internal; // linkage does not work since optimization passes will try to replace loads; // of the global variable with its initialization value.; //; // It also identifies the kernels directly or indirectly enqueues kernels; // and adds ""calls-enqueue-kernel"" function attribute to them, which will; // be used to determine whether to emit runtime metadata for the kernel; // enqueue related hidden kernel arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUOpenCLEnqueuedBlockLowering.cpp:1005,load,loads,1005,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUOpenCLEnqueuedBlockLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUOpenCLEnqueuedBlockLowering.cpp,3,"['load', 'optimiz']","['loads', 'optimization']"
Performance,"//===- AMDGPUPerfHintAnalysis.cpp - analysis of functions memory traffic --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// \brief Analyzes if a function potentially memory bound and if a kernel; /// kernel may benefit from limiting number of waves to reduce cache thrashing.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp:530,cache,cache,530,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.cpp,1,['cache'],['cache']
Performance,"//===- AMDGPUPerfHintAnalysis.h ---- analysis of memory traffic -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// \brief Analyzes if a function potentially memory bound and if a kernel; /// kernel may benefit from limiting number of waves to reduce cache thrashing.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.h:530,cache,cache,530,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPerfHintAnalysis.h,1,['cache'],['cache']
Performance,"//===- APFixedPoint.h - Fixed point constant handling -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the fixed point number interface.; /// This is a class for abstracting various operations performed on fixed point; /// types.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h:494,perform,performed,494,interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,1,['perform'],['performed']
Performance,"//===- ARCExpandPseudosPass - ARC expand pseudo loads -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass expands stores with large offsets into an appropriate sequence.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCExpandPseudos.cpp:48,load,loads,48,interpreter/llvm-project/llvm/lib/Target/ARC/ARCExpandPseudos.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCExpandPseudos.cpp,1,['load'],['loads']
Performance,"//===- ARCInstKind.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines several utility functions used by various ARC; /// optimizations which are IMHO too big to be in a header file.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:34,Optimiz,Optimization,34,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,2,"['Optimiz', 'optimiz']","['Optimization', 'optimizations']"
Performance,"//===- ARCOptAddrMode.cpp ---------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass folds LD/ST + ADD pairs into Pre/Post-increment form of; /// load/store instructions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCOptAddrMode.cpp:462,load,load,462,interpreter/llvm-project/llvm/lib/Target/ARC/ARCOptAddrMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCOptAddrMode.cpp,1,['load'],['load']
Performance,"//===- ARCRuntimeEntryPoints.h - ObjC ARC Optimization ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains a class ARCRuntimeEntryPoints for use in; /// creating/managing references to entry points to the arc objective c runtime.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h:42,Optimiz,Optimization,42,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,1,['Optimiz'],['Optimization']
Performance,"//===- ARMLoadStoreOptimizer.cpp - ARM load / store opt. pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This file contains a pass that performs load / store related peephole; /// optimizations. This pass should be run after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:39,load,load,39,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,4,"['load', 'optimiz', 'perform']","['load', 'optimizations', 'performs']"
Performance,"//===- ARMParallelDSP.cpp - Parallel DSP Pass -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Armv6 introduced instructions to perform 32-bit SIMD operations. The; /// purpose of this pass is do some IR pattern matching to create ACLE; /// DSP intrinsics, which map on these 32-bit SIMD operations.; /// This pass runs only when unaligned accesses is supported/enabled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:428,perform,perform,428,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,1,['perform'],['perform']
Performance,"//===- ASTReaderDecl.cpp - Decl Deserialization ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ASTReader::readDeclRecord method, which is the; // entrypoint for loading a decl.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:474,load,loading,474,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['load'],['loading']
Performance,"//===- ASTStructuralEquivalence.cpp ---------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement StructuralEquivalenceContext class and helper functions; // for layout matching.; //; // The structural equivalence check could have been implemented as a parallel; // BFS on a pair of graphs. That must have been the original approach at the; // beginning.; // Let's consider this simple BFS algorithm from the `s` source:; // ```; // void bfs(Graph G, int s); // {; // Queue<Integer> queue = new Queue<Integer>();; // marked[s] = true; // Mark the source; // queue.enqueue(s); // and put it on the queue.; // while (!q.isEmpty()) {; // int v = queue.dequeue(); // Remove next vertex from the queue.; // for (int w : G.adj(v)); // if (!marked[w]) // For every unmarked adjacent vertex,; // {; // marked[w] = true;; // queue.enqueue(w);; // }; // }; // }; // ```; // Indeed, it has it's queue, which holds pairs of nodes, one from each graph,; // this is the `DeclsToCheck` member. `VisitedDecls` plays the role of the; // marking (`marked`) functionality above, we use it to check whether we've; // already seen a pair of nodes.; //; // We put in the elements into the queue only in the toplevel decl check; // function:; // ```; // static bool IsStructurallyEquivalent(StructuralEquivalenceContext &Context,; // Decl *D1, Decl *D2);; // ```; // The `while` loop where we iterate over the children is implemented in; // `Finish()`. And `Finish` is called only from the two **member** functions; // which check the equivalency of two Decls or two Types. ASTImporter (and; // other clients) call only these functions.; //; // The `static` implementation functions are called from `Finish`, these push",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp:773,Queue,Queue,773,interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTStructuralEquivalence.cpp,7,"['Queue', 'queue']","['Queue', 'queue']"
Performance,"//===- AddressSanitizer.cpp - memory error detector -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of AddressSanitizer, an address basic correctness; // checker.; // Details of the algorithm:; // https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:618,scalab,scalable,618,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['scalab'],['scalable']
Performance,"//===- ArgumentPromotion.cpp - Promote by-reference arguments -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; // practice, this means looking for internal functions that have pointer; // arguments. If it can prove, through the use of alias analysis, that an; // argument is *only* loaded, then it can pass the value into the function; // instead of the address of the value. This can cause recursive simplification; // of code and lead to the elimination of allocas (especially in C++ template; // code like the STL).; //; // This pass also handles aggregate arguments that are passed into a function,; // scalarizing them if the elements of the aggregate are only loaded. Note that; // by default it refuses to scalarize aggregates which would require passing in; // more than three operands to the function, because passing thousands of; // operands for a large array or structure is unprofitable! This limit can be; // configured or disabled, however.; //; // Note that this transformation could also be done for arguments that are only; // stored to (returning the value instead), but does not currently. This case; // would be best handled when and if LLVM begins supporting multiple return; // values from functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:630,load,loaded,630,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,2,['load'],['loaded']
Performance,"//===- AssumeBundleBuilder.h - utils to build assume bundles ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contain tools to preserve informations. They should be used before; // performing a transformation that may move and delete instructions as those; // transformation may destroy or worsen information that can be derived from the; // IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h:464,perform,performing,464,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,1,['perform'],['performing']
Performance,"//===- AssumptionCache.cpp - Cache finding @llvm.assume calls -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that keeps track of @llvm.assume intrinsics in; // the functions of a module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:29,Cache,Cache,29,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,1,['Cache'],['Cache']
Performance,"//===- AtomicExpandPass.cpp - Expand atomic instructions ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass (at IR level) to replace atomic instructions with; // __atomic_* library calls, or target specific instruction which implement the; // same semantics in a way which better fits the target backend. This can; // include the use of (intrinsic-based) load-linked/store-conditional loops,; // AtomicCmpXchg, or type coercions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:656,load,load-linked,656,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['load'],['load-linked']
Performance,"//===- BalancedPartitioning.h ---------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements BalancedPartitioning, a recursive balanced graph; // partitioning algorithm.; //; // The algorithm is used to find an ordering of FunctionNodes while optimizing; // a specified objective. The algorithm uses recursive bisection; it starts; // with a collection of unordered FunctionNodes and tries to split them into; // two sets (buckets) of equal cardinality. Each bisection step is comprised of; // iterations that greedily swap the FunctionNodes between the two buckets while; // there is an improvement of the objective. Once the process converges, the; // problem is divided into two sub-problems of half the size, which are; // recursively applied for the two buckets. The final ordering of the; // FunctionNodes is obtained by concatenating the two (recursively computed); // orderings.; //; // In order to speed up the computation, we limit the depth of the recursive; // tree by a specified constant (SplitDepth) and apply at most a constant; // number of greedy iterations per split (IterationsPerSplit). The worst-case; // time complexity of the implementation is bounded by O(M*log^2 N), where; // N is the number of FunctionNodes and M is the number of; // FunctionNode-UtilityNode edges; (assuming that any collection of D; // FunctionNodes contains O(D) UtilityNodes). Notice that the two different; // recursive sub-problems are independent and thus can be efficiently processed; // in parallel.; //; // Reference:; // * Optimizing Function Layout for Mobile Applications,; // https://arxiv.org/abs/2211.09285; //; //===-------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h:554,optimiz,optimizing,554,interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,1,['optimiz'],['optimizing']
Performance,"//===- BasicBlockUtils.cpp - BasicBlock Utilities --------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform manipulations on basic blocks, and; // instructions contained within basic blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:408,perform,perform,408,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['perform'],['perform']
Performance,"//===- BugDriver.cpp - Top-Level BugPoint class implementation ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp:505,optimiz,optimizations,505,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.cpp,1,['optimiz'],['optimizations']
Performance,"//===- BugDriver.h - Top-Level BugPoint class -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class contains all of the shared state and information that is used by; // the BugPoint tool to track down errors in optimizations. This class is the; // main driver class that invokes all sub-functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:505,optimiz,optimizations,505,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['optimiz'],['optimizations']
Performance,"//===- BuildLibCalls.h - Utility builder for libcalls -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to build some C language libcalls for; // optimization passes that need to call the various functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h:456,optimiz,optimization,456,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,1,['optimiz'],['optimization']
Performance,"//===- BypassSlowDivision.cpp - Bypass slow division ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an optimization for div and rem on architectures that; // execute short instructions significantly faster than longer instructions.; // For example, on Intel Atom 32-bit divides are slow enough that during; // runtime it is profitable to check the value of the operands, and if they are; // positive and less than 256 use an unsigned 8-bit divide.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:405,optimiz,optimization,405,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,1,['optimiz'],['optimization']
Performance,"//===- CGSCCPassManager.h - Call graph pass management ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing passes over SCCs of the call; /// graph. These passes form an important component of LLVM's interprocedural; /// optimizations. Because they operate on the SCCs of the call graph, and they; /// traverse the graph in post-order, they can effectively do pair-wise; /// interprocedural optimizations for all call edges in the program while; /// incrementally refining it and improving the context of these pair-wise; /// optimizations. At each call site edge, the callee has already been; /// optimized as much as is possible. This in turn allows very accurate; /// analysis of it for IPO.; ///; /// A secondary more general goal is to be able to isolate optimization on; /// unrelated parts of the IR module. This is useful to ensure our; /// optimizations are principled and don't miss oportunities where refinement; /// of one part of the module influences transformations in another part of the; /// module. But this is also useful if we want to parallelize the optimizations; /// across common large module graph shapes which tend to be very wide and have; /// large regions of unrelated cliques.; ///; /// To satisfy these goals, we use the LazyCallGraph which provides two graphs; /// nested inside each other (and built lazily from the bottom-up): the call; /// graph proper, and a reference graph. The reference graph is super set of; /// the call graph and is a conservative approximation of what could through; /// scalar or CGSCC transforms *become* the call graph. Using this allows us to; /// ensure we optimize functions prior to them being introduced",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:551,optimiz,optimizations,551,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,4,['optimiz'],"['optimizations', 'optimized']"
Performance,"//===- CSKYConstantIslandPass.cpp - Emit PC Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //; // Loading constants inline is expensive on CSKY and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16/32 bit load instruction like lrw.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp:53,load,loads,53,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYConstantIslandPass.cpp,4,"['Load', 'load']","['Loading', 'load', 'loaded', 'loads']"
Performance,"//===- Caching.h - LLVM Local File Cache ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the CachedFileStream and the localCache function, which; // simplifies caching files on the local filesystem in a directory whose; // contents are managed by a CachePruningPolicy.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h:35,Cache,Cache,35,interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,3,['Cache'],"['Cache', 'CachePruningPolicy', 'CachedFileStream']"
Performance,"//===- CallGraph.h - Build a Module's call graph ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides interfaces used to build and manipulate a call graph,; /// which is a very useful tool for interprocedural optimization.; ///; /// Every function in a module is represented as a node in the call graph. The; /// callgraph node keeps track of which functions are called by the function; /// corresponding to the node.; ///; /// A call graph may contain nodes where the function that they correspond to; /// is null. These 'external' nodes are used to represent control flow that is; /// not represented (or analyzable) in the module. In particular, this; /// analysis builds one external node such that:; /// 1. All functions in the module without internal linkage will have edges; /// from this external node, indicating that they could be called by; /// functions outside of the module.; /// 2. All functions whose address is used for something more than a direct; /// call, for example being stored into a memory location will also have; /// an edge from this external node. Since they may be called by an; /// unknown caller later, they must be tracked as such.; ///; /// There is a second external node added for calls that leave this module.; /// Functions have a call edge to the external node iff:; /// 1. The function is external, reflecting the fact that they could call; /// anything without internal linkage or that has its address taken.; /// 2. The function contains an indirect function call.; ///; /// As an extension in the future, there may be multiple nodes with a null; /// function. These will be used when we can prove (through pointer analysis); /// that an indirec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:522,optimiz,optimization,522,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,1,['optimiz'],['optimization']
Performance,"//===- CanonicalizeAliases.cpp - ThinLTO Support: Canonicalize Aliases ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Currently this file implements partial alias canonicalization, to; // flatten chains of aliases (also done by GlobalOpt, but not on for; // O0 compiles). E.g.; // @a = alias i8, i8 *@b; // @b = alias i8, i8 *@g; //; // will be converted to:; // @a = alias i8, i8 *@g <-- @a is now an alias to base object @g; // @b = alias i8, i8 *@g; //; // Eventually this file will implement full alias canonicalization, so that; // all aliasees are private anonymous values. E.g.; // @a = alias i8, i8 *@g; // @g = global i8 0; //; // will be converted to:; // @0 = private global; // @a = alias i8, i8* @0; // @g = alias i8, i8* @0; //; // This simplifies optimization and ThinLTO linking of the original symbols.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp:1027,optimiz,optimization,1027,interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp,1,['optimiz'],['optimization']
Performance,"//===- CodeLayout.cpp - Implementation of code layout algorithms ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation su",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:404,cache,cache-aware,404,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,4,"['cache', 'optimiz']","['cache', 'cache-aware', 'optimization', 'optimizing']"
Performance,"//===- CodeMoverUtils.cpp - CodeMover Utilities ----------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform movements on basic blocks, and instructions; // contained within a function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:408,perform,perform,408,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,1,['perform'],['perform']
Performance,"//===- CompilationDatabase.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface and multiple implementations for; // CompilationDatabases.; //; // While C++ refactoring and analysis tools are not compilers, and thus; // don't run as part of the build system, they need the exact information; // of a build in order to be able to correctly understand the C++ code of; // the project. This information is provided via the CompilationDatabase; // interface.; //; // To create a CompilationDatabase from a build directory one can call; // CompilationDatabase::loadFromDirectory(), which deduces the correct; // compilation database from the root of the build tree.; //; // See the concrete subclasses of CompilationDatabase for currently supported; // formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:891,load,loadFromDirectory,891,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,1,['load'],['loadFromDirectory']
Performance,"//===- ComplexDeinterleavingPass.cpp --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Identification:; // This step is responsible for finding the patterns that can be lowered to; // complex instructions, and building a graph to represent the complex; // structures. Starting from the ""Converging Shuffle"" (a shuffle that; // reinterleaves the complex components, with a mask of <0, 2, 1, 3>), the; // operands are evaluated and identified as ""Composite Nodes"" (collections of; // instructions that can potentially be lowered to a single complex; // instruction). This is performed by checking the real and imaginary components; // and tracking the data flow for each component while following the operand; // pairs. Validity of each node is expected to be done upon creation, and any; // validation errors should halt traversal and prevent further graph; // construction.; // Instead of relying on Shuffle operations, vector interleaving and; // deinterleaving can be represented by vector.interleave2 and; // vector.deinterleave2 intrinsics. Scalable vectors can be represented only by; // these intrinsics, whereas, fixed-width vectors are recognized for both; // shufflevector instruction and intrinsics.; //; // Replacement:; // This step traverses the graph built up by identification, delegating to the; // target to validate and generate the correct intrinsics, and plumbs them; // together connecting each end of the new intrinsics graph to the existing; // use-def chain. This step is assumed to finish successfully, as all; // information is expected to be correct by this point.; //; //; // Internal data structure:; // ComplexDeinterleavingGraph:; // Keeps references to all the valid Compos",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:869,perform,performed,869,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['perform'],['performed']
Performance,"//===- ConcurrentHashtable.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:7,Concurren,ConcurrentHashtable,7,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['Concurren'],['ConcurrentHashtable']
Performance,"//===- ConstantHoisting.cpp - Prepare code for expensive constants --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies expensive constants to hoist and coalesces them to; // better prepare it for SelectionDAG-based code generation. This works around; // the limitations of the basic-block-at-a-time approach.; //; // First it scans all instructions for integer constants and calculates its; // cost. If the constant can be folded into the instruction (the cost is; // TCC_Free) or the cost is just a simple operation (TCC_BASIC), then we don't; // consider it expensive and leave it alone. This is the default behavior and; // the default implementation of getIntImmCostInst will always return TCC_Free.; //; // If the cost is more than TCC_BASIC, then the integer constant can't be folded; // into the instruction and it might be beneficial to hoist the constant.; // Similar constants are coalesced to reduce register pressure and; // materialization code.; //; // When a constant is hoisted, it is also hidden behind a bitcast to force it to; // be live-out of the basic block. Otherwise the constant would be just; // duplicated and each basic block would have its own copy in the SelectionDAG.; // The SelectionDAG recognizes such constants as opaque and doesn't perform; // certain transformations on them, which would create a new expensive constant.; //; // This optimization is only applied to integer constants in instructions and; // simple (this means not nested) constant cast expressions. For example:; // %0 = load i64* inttoptr (i64 big_constant to i64*); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:1553,perform,perform,1553,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,3,"['load', 'optimiz', 'perform']","['load', 'optimization', 'perform']"
Performance,"//===- CoroFrame.cpp - Builds and manipulates coroutine frame -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file contains classes used to discover if for a particular value; // there from sue to definition that crosses a suspend block.; //; // Using the information discovered we form a Coroutine Frame structure to; // contain those values. All uses of those values are replaced with appropriate; // GEP + load from the coroutine frame. At the point of the definition we spill; // the value into the coroutine frame.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:683,load,load,683,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['load'],['load']
Performance,"//===- CoroSplit.cpp - Converts a coroutine into a state machine ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass builds the coroutine frame and outlines resume and destroy parts; // of the coroutine into separate functions.; //; // We present a coroutine to an LLVM as an ordinary function with suspension; // points marked up with intrinsics. We let the optimizer party on the coroutine; // as a single function for as long as possible. Shortly before the coroutine is; // eligible to be inlined into its callers, we split up the coroutine into parts; // corresponding to an initial, resume and destroy invocations of the coroutine,; // add them to the current SCC and restart the IPO pipeline to optimize the; // coroutine subfunctions we extracted before proceeding to the caller of the; // coroutine.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:631,optimiz,optimizer,631,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,2,['optimiz'],"['optimize', 'optimizer']"
Performance,"//===- CostModel.cpp ------ Cost Model Analysis ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the cost model analysis. It provides a very basic cost; // estimation for LLVM-IR. This analysis uses the services of the codegen; // to approximate the cost of any IR instruction when lowered to machine; // instructions. The cost results are unit-less and the cost number represents; // the throughput of the machine assuming that all loads hit the cache, all; // branches are predicted, etc. The cost numbers can be added in order to; // compare two or more transformation alternatives.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp:693,throughput,throughput,693,interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CostModel.cpp,3,"['cache', 'load', 'throughput']","['cache', 'loads', 'throughput']"
Performance,"//===- DAGISelMatcherOpt.cpp - Optimize a DAG Matcher ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the DAG Matcher optimizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp:31,Optimiz,Optimize,31,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherOpt.cpp,2,"['Optimiz', 'optimiz']","['Optimize', 'optimizer']"
Performance,"//===- DCE.cpp - Code to perform dead code elimination --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead inst elimination and dead code elimination.; //; // Dead Inst Elimination performs a single pass over the function removing; // instructions that are obviously dead. Dead Code Elimination is similar, but; // it rechecks instructions that were used by removed instructions to see if; // they are newly dead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp:25,perform,perform,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp,2,['perform'],"['perform', 'performs']"
Performance,"//===- DataFlowSanitizer.cpp - dynamic data flow analysis -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of DataFlowSanitizer, a generalised dynamic data flow; /// analysis.; ///; /// Unlike other Sanitizer tools, this tool is not designed to detect a specific; /// class of bugs on its own. Instead, it provides a generic dynamic data flow; /// analysis framework to be used by clients to help detect application-specific; /// issues within their own code.; ///; /// The analysis is based on automatic propagation of data flow labels (also; /// known as taint labels) through a program as it performs computation.; ///; /// Argument and return value labels are passed through TLS variables; /// __dfsan_arg_tls and __dfsan_retval_tls.; ///; /// Each byte of application memory is backed by a shadow memory byte. The; /// shadow byte can represent up to 8 labels. On Linux/x86_64, memory is then; /// laid out as follows:; ///; /// +--------------------+ 0x800000000000 (top of memory); /// | application 3 |; /// +--------------------+ 0x700000000000; /// | invalid |; /// +--------------------+ 0x610000000000; /// | origin 1 |; /// +--------------------+ 0x600000000000; /// | application 2 |; /// +--------------------+ 0x510000000000; /// | shadow 1 |; /// +--------------------+ 0x500000000000; /// | invalid |; /// +--------------------+ 0x400000000000; /// | origin 3 |; /// +--------------------+ 0x300000000000; /// | shadow 3 |; /// +--------------------+ 0x200000000000; /// | origin 2 |; /// +--------------------+ 0x110000000000; /// | invalid |; /// +--------------------+ 0x100000000000; /// | shadow 2 |; /// +--------------------+ 0x010000000000; /// | application 1 |; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:903,perform,performs,903,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['perform'],['performs']
Performance,"//===- Debugify.cpp - Check debug info preservation in optimizations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file In the `synthetic` mode, the `-debugify` attaches synthetic debug info; /// to everything. It can be used to create targeted tests for debug info; /// preservation. In addition, when using the `original` mode, it can check; /// original debug info preservation. The `synthetic` mode is default one.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:55,optimiz,optimizations,55,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,1,['optimiz'],['optimizations']
Performance,"//===- Debugify.h - Check debug info preservation in optimizations --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file Interface to the `debugify` synthetic/original debug info testing; /// utility.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h:53,optimiz,optimizations,53,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Debugify.h,1,['optimiz'],['optimizations']
Performance,"//===- DependencyAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp:41,Optimiz,Optimization,41,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.cpp,2,['Optimiz'],"['Optimization', 'Optimizations']"
Performance,"//===- DependencyAnalysis.h - ObjC ARC Optimization ---*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file declares special dependency analysis routines used in Objective C; /// ARC Optimizations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h:39,Optimiz,Optimization,39,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/DependencyAnalysis.h,2,['Optimiz'],"['Optimization', 'Optimizations']"
Performance,"//===- DevelopmentModeInlineAdvisor.cpp - runtime-loadable model runner --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a model runner using TFLite, allowing the; // loading of a model from a command line option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp:50,load,loadable,50,interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DevelopmentModeInlineAdvisor.cpp,2,['load'],"['loadable', 'loading']"
Performance,"//===- EPCGenericDylibManager.h -- Generic EPC Dylib management -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements dylib loading and searching by making calls to; // ExecutorProcessControl::callWrapper.; //; // This simplifies the implementaton of new ExecutorProcessControl instances,; // as this implementation will always work (at the cost of some performance; // overhead for the calls).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericDylibManager.h:400,load,loading,400,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericDylibManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericDylibManager.h,2,"['load', 'perform']","['loading', 'performance']"
Performance,"//===- EPCGenericJITLinkMemoryManager.h - EPC-based mem manager -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements JITLinkMemoryManager by making remove calls via; // ExecutorProcessControl::callWrapperAsync.; //; // This simplifies the implementaton of new ExecutorProcessControl instances,; // as this implementation will always work (at the cost of some performance; // overhead for the calls).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.h:636,perform,performance,636,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericJITLinkMemoryManager.h,1,['perform'],['performance']
Performance,"//===- EPCGenericMemoryAccess.h - Generic EPC MemoryAccess impl -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements ExecutorProcessControl::MemoryAccess by making calls to; // ExecutorProcessControl::callWrapperAsync.; //; // This simplifies the implementaton of new ExecutorProcessControl instances,; // as this implementation will always work (at the cost of some performance; // overhead for the calls).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericMemoryAccess.h:644,perform,performance,644,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericMemoryAccess.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericMemoryAccess.h,1,['perform'],['performance']
Performance,"//===- EarlyCSE.cpp - Simple and fast CSE pass ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs a simple dominator tree walk that eliminates trivially; // redundant instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:393,perform,performs,393,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['perform'],['performs']
Performance,"//===- ElimAvailExtern.h - Optimize Global Variables ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transform is designed to eliminate available external global; // definitions from the program, turning them into declarations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/ElimAvailExtern.h:27,Optimiz,Optimize,27,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/ElimAvailExtern.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/ElimAvailExtern.h,1,['Optimiz'],['Optimize']
Performance,"//===- ErlangGCPrinter.cpp - Erlang/OTP frametable emitter ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the compiler plugin that is used in order to emit; // garbage collection information in a convenient layout for parsing and; // loading in the Erlang/OTP runtime.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:532,load,loading,532,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,1,['load'],['loading']
Performance,"//===- FastISel.cpp - Implementation of the FastISel class ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the implementation of the FastISel class.; //; // ""Fast"" instruction selection is designed to emit very poor code quickly.; // Also, it is not designed to be able to do much lowering, so most illegal; // types (e.g. i64 on 32-bit targets) and operations are not supported. It is; // also not intended to be able to do much optimization, except in a few cases; // where doing optimizations reduces overall compile time. For example, folding; // constants into immediate fields is often done, because it's cheap and it; // reduces the number of instructions later phases have to examine.; //; // ""Fast"" instruction selection is able to fail gracefully and transfer; // control to the SelectionDAG selector for operations that it doesn't; // support. In many cases, this allows us to avoid duplicating a lot of; // the complicated lowering logic that SelectionDAG currently has.; //; // The intended use for ""fast"" instruction selection is ""-O0"" mode; // compilation, where the quality of the generated code is irrelevant when; // weighed against the speed at which the code can be generated. Also,; // at -O0, the LLVM optimizers are not running, and this makes the; // compile time of codegen a much higher portion of the overall compile; // time. Despite its limitations, ""fast"" instruction selection is able to; // handle enough code on its own to provide noticeable overall speedups; // in -O0 compiles.; //; // Basic operations are supported in a target-independent way, by reading; // the same instruction descriptions that the SelectionDAG selector reads,; // and identifying simple arithmetic ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:725,optimiz,optimization,725,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,2,['optimiz'],"['optimization', 'optimizations']"
Performance,"//===- FileHeaderReader.h - XRay Trace File Header Reading Function -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares functions that can load an XRay log header from various; // sources.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h:421,load,load,421,interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h,1,['load'],['load']
Performance,"//===- FixItRewriter.cpp - Fix-It Rewriter Diagnostic Client --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a diagnostic client adaptor that performs rewrites as; // suggested by code modification hints attached to diagnostics. It; // then forwards any diagnostics to the adapted diagnostic client.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp:424,perform,performs,424,interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/FixItRewriter.cpp,1,['perform'],['performs']
Performance,"//===- FixItRewriter.h - Fix-It Rewriter Diagnostic Client ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a diagnostic client adaptor that performs rewrites as; // suggested by code modification hints attached to diagnostics. It; // then forwards any diagnostics to the adapted diagnostic client.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:424,perform,performs,424,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,1,['perform'],['performs']
Performance,"//===- FlatternCFG.cpp - Code to perform CFG flattening -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Reduce conditional branches in CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:33,perform,perform,33,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,1,['perform'],['perform']
Performance,"//===- FunctionImportUtils.h - Importing support utilities -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the FunctionImportGlobalProcessing class which is used; // to perform the necessary global value handling for function importing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:462,perform,perform,462,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,1,['perform'],['perform']
Performance,"//===- GCDAntipatternChecker.cpp ---------------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines GCDAntipatternChecker which checks against a common; // antipattern when synchronous API is emulated from asynchronous callbacks; // using a semaphore:; //; // dispatch_semaphore_t sema = dispatch_semaphore_create(0);; //; // AnyCFunctionCall(^{; // // code…; // dispatch_semaphore_signal(sema);; // }); // dispatch_semaphore_wait(sema, *); //; // Such code is a common performance problem, due to inability of GCD to; // properly handle QoS when a combination of queues and semaphores is used.; // Good code would either use asynchronous API (when available), or perform; // the necessary action in asynchronous callback.; //; // Currently, the check is performed using a simple heuristical AST pattern; // matching.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:771,perform,performance,771,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,4,"['perform', 'queue']","['perform', 'performance', 'performed', 'queues']"
Performance,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:1062,perform,performed,1062,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,1,['perform'],['performed']
Performance,"//===- GVMaterializer.h - Interface for GV materializers --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an abstract interface for loading a module from some; // place. This interface allows incremental or random access loading of; // functions from the file. This is useful for applications like JIT compilers; // or interprocedural optimizers that do not need the entire program in memory; // at the same time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GVMaterializer.h:428,load,loading,428,interpreter/llvm-project/llvm/include/llvm/IR/GVMaterializer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GVMaterializer.h,3,"['load', 'optimiz']","['loading', 'optimizers']"
Performance,"//===- GVN.cpp - Eliminate redundant values and loads ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global value numbering to eliminate fully redundant; // instructions. It also performs simple dead load elimination.; //; // Note that this pass does the value numbering itself; it does not use the; // ValueNumbering analysis passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:48,load,loads,48,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,4,"['load', 'perform']","['load', 'loads', 'performs']"
Performance,"//===- GVN.h - Eliminate redundant values and loads -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides the interface for LLVM's Global Value Numbering pass; /// which eliminates fully redundant instructions. It also does somewhat Ad-Hoc; /// PRE and dead load elimination.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:46,load,loads,46,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,2,['load'],"['load', 'loads']"
Performance,"//===- GVNHoist.cpp - Hoist scalar and load expressions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists expressions from branches to a common dominator. It uses; // GVN (global value numbering) to discover expressions computing the same; // values. The primary goals of code-hoisting are:; // 1. To reduce the code size.; // 2. In some cases reduce critical path (by exposing more ILP).; //; // The algorithm factors out the reachability of values such that multiple; // queries to find reachability of values are fast. This is based on finding the; // ANTIC points in the CFG which do not change during hoisting. The ANTIC points; // are basically the dominance-frontiers in the inverse graph. So we introduce a; // data structure (CHI nodes) to keep track of values flowing out of a basic; // block. We only do this for values with multiple occurrences in the function; // as they are the potential hoistable candidates. This approach allows us to; // hoist instructions to a basic block with more than two successors, as well as; // deal with infinite loops in a trivial way.; //; // Limitations: This pass does not hoist fully redundant expressions because; // they are already handled by GVN-PRE. It is advisable to run gvn-hoist before; // and after gvn-pre because gvn-pre creates opportunities for more instructions; // to be hoisted.; //; // Hoisting may affect the performance in some cases. To mitigate that, hoisting; // is disabled in the following cases.; // 1. Scalars across calls.; // 2. geps when corresponding load/store cannot be hoisted.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:39,load,load,39,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,3,"['load', 'perform']","['load', 'performance']"
Performance,"//===- GenericDomTreeConstruction.h - Dominator Calculation ------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Generic dominator tree construction - this file provides routines to; /// construct immediate dominator information for a flow-graph based on the; /// Semi-NCA algorithm described in this dissertation:; ///; /// [1] Linear-Time Algorithms for Dominators and Related Problems; /// Loukas Georgiadis, Princeton University, November 2005, pp. 21-23:; /// ftp://ftp.cs.princeton.edu/reports/2005/737.pdf; ///; /// Semi-NCA algorithm runs in O(n^2) worst-case time but usually slightly; /// faster than Simple Lengauer-Tarjan in practice.; ///; /// O(n^2) worst cases happen when the computation of nearest common ancestors; /// requires O(n) average time, which is very unlikely in real world. If this; /// ever turns out to be an issue, consider implementing a hybrid algorithm; /// that uses SLT to perform full constructions and SemiNCA for incremental; /// updates.; ///; /// The file uses the Depth Based Search algorithm to perform incremental; /// updates (insertion and deletions). The implemented algorithm is based on; /// this publication:; ///; /// [2] An Experimental Study of Dynamic Dominators; /// Loukas Georgiadis, et al., April 12 2016, pp. 5-7, 9-10:; /// https://arxiv.org/pdf/1604.02711.pdf; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:1193,perform,perform,1193,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,2,['perform'],['perform']
Performance,"//===- GlobalOpt.cpp - Optimize Global Variables --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:23,Optimiz,Optimize,23,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['Optimiz'],['Optimize']
Performance,"//===- GlobalOpt.h - Optimize Global Variables ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalOpt.h:21,Optimiz,Optimize,21,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalOpt.h,1,['Optimiz'],['Optimize']
Performance,"//===- GlobalSplit.cpp - global variable splitter -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass uses inrange annotations on GEP indices to split globals where; // beneficial. Clang currently attaches these annotations to references to; // virtual table globals under the Itanium ABI for the benefit of the; // whole-program virtual call optimization and control flow integrity passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:634,optimiz,optimization,634,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,1,['optimiz'],['optimization']
Performance,"//===- GlobalSplit.h - global variable splitter -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass uses inrange annotations on GEP indices to split globals where; // beneficial. Clang currently attaches these annotations to references to; // virtual table globals under the Itanium ABI for the benefit of the; // whole-program virtual call optimization and control flow integrity passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalSplit.h:634,optimiz,optimization,634,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalSplit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalSplit.h,1,['optimiz'],['optimization']
Performance,"//===- GuardWidening.cpp - ---- Guard widening ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the guard widening pass. The semantics of the; // @llvm.experimental.guard intrinsic lets LLVM transform it so that it fails; // more often that it did before the transform. This optimization is called; // ""widening"" and can be used hoist and common runtime checks in situations like; // these:; //; // %cmp0 = 7 u< Length; // call @llvm.experimental.guard(i1 %cmp0) [ ""deopt""(...) ]; // call @unknown_side_effects(); // %cmp1 = 9 u< Length; // call @llvm.experimental.guard(i1 %cmp1) [ ""deopt""(...) ]; // ...; //; // =>; //; // %cmp0 = 9 u< Length; // call @llvm.experimental.guard(i1 %cmp0) [ ""deopt""(...) ]; // call @unknown_side_effects(); // ...; //; // If %cmp0 is false, @llvm.experimental.guard will ""deoptimize"" back to a; // generic implementation of the same function, which will have the correct; // semantics from that point onward. It is always _legal_ to deoptimize (so; // replacing %cmp0 with false is ""correct""), though it may not always be; // profitable to do so.; //; // NB! This pass is a work in progress. It hasn't been tuned to be ""production; // ready"" yet. It is known to have quadriatic running time and will not scale; // to large numbers of guards; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:583,optimiz,optimization,583,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,2,"['optimiz', 'tune']","['optimization', 'tuned']"
Performance,"//===- GuardWidening.h - ----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Guard widening is an optimization over the @llvm.experimental.guard intrinsic; // that (optimistically) combines multiple guards into one to have fewer checks; // at runtime.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GuardWidening.h:404,optimiz,optimization,404,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GuardWidening.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GuardWidening.h,1,['optimiz'],['optimization']
Performance,"//===- HexagonCFGOptimizer.cpp - CFG optimizations ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp:37,optimiz,optimizations,37,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCFGOptimizer.cpp,1,['optimiz'],['optimizations']
Performance,"//===- HexagonExpandCondsets.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Replace mux instructions with the corresponding legal instructions.; // It is meant to work post-SSA, but still on virtual registers. It was; // originally placed between register coalescing and machine instruction; // scheduler.; // In this place in the optimization sequence, live interval analysis had; // been performed, and the live intervals should be preserved. A large part; // of the code deals with preserving the liveness information.; //; // Liveness tracking aside, the main functionality of this pass is divided; // into two steps. The first step is to replace an instruction; // %0 = C2_mux %1, %2, %3; // with a pair of conditional transfers; // %0 = A2_tfrt %1, %2; // %0 = A2_tfrf %1, %3; // It is the intention that the execution of this pass could be terminated; // after this step, and the code generated would be functionally correct.; //; // If the uses of the source values %1 and %2 are kills, and their; // definitions are predicable, then in the second step, the conditional; // transfers will then be rewritten as predicated instructions. E.g.; // %0 = A2_or %1, %2; // %3 = A2_tfrt %99, killed %0; // will be rewritten as; // %3 = A2_port %99, %1, %2; //; // This replacement has two variants: ""up"" and ""down"". Consider this case:; // %0 = A2_or %1, %2; // ... [intervening instructions] ...; // %3 = A2_tfrt %99, killed %0; // variant ""up"":; // %3 = A2_port %99, %1, %2; // ... [intervening instructions, %0->vreg3] ...; // [deleted]; // variant ""down"":; // [deleted]; // ... [intervening instructions] ...; // %3 = A2_port %99, %1, %2; //; // Both, one or none of these variants may be valid",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:634,optimiz,optimization,634,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,2,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"//===- HexagonHardwareLoops.cpp - Identify and generate hardware loops ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies loops where we can generate the Hexagon hardware; // loop instruction. The hardware loop can perform loop branches with a; // zero-cycle overhead.; //; // The pattern that defines the induction variable can changed depending on; // prior optimizations. For example, the IndVarSimplify phase run by 'opt'; // normalizes induction variables, and the Loop Strength Reduction pass; // run by 'llc' may also make changes to the induction variable.; // The pattern detected by this phase is due to running Strength Reduction.; //; // Criteria for hardware loops:; // - Countable loops (w/ ind. var for a trip count); // - Assumes loops are normalized by IndVarSimplify; // - Try inner-most loops first; // - No function calls in loops.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:497,perform,perform,497,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,2,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"//===- HexagonOptAddrMode.cpp ---------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This implements a Hexagon-specific pass to optimize addressing mode for; // load/store instructions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:422,optimiz,optimize,422,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,2,"['load', 'optimiz']","['load', 'optimize']"
Performance,"//===- HexagonStoreWidening.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Replace sequences of ""narrow"" stores to adjacent memory locations with; // a fewer ""wide"" stores that have the same effect.; // For example, replace:; // S4_storeirb_io %100, 0, 0 ; store-immediate-byte; // S4_storeirb_io %100, 1, 0 ; store-immediate-byte; // with; // S4_storeirh_io %100, 0, 0 ; store-immediate-halfword; // The above is the general idea. The actual cases handled by the code; // may be a bit more complex.; // The purpose of this pass is to reduce the number of outstanding stores,; // or as one could say, ""reduce store queue pressure"". Also, wide stores; // mean fewer stores, and since there are only two memory instructions allowed; // per packet, it also means fewer packets, and ultimately fewer cycles.; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:919,queue,queue,919,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,1,['queue'],['queue']
Performance,"//===- HexagonVExtract.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass will replace multiple occurrences of V6_extractw from the same; // vector register with a combination of a vector store and scalar loads.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp:520,load,loads,520,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVExtract.cpp,1,['load'],['loads']
Performance,"//===- IPO/OpenMPOpt.h - Collection of OpenMP optimizations -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/OpenMPOpt.h:46,optimiz,optimizations,46,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/OpenMPOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/OpenMPOpt.h,1,['optimiz'],['optimizations']
Performance,"//===- IRSimilarityIdentifier.h - Find similarity in a module --------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // Interface file for the IRSimilarityIdentifier for identifying similarities in; // IR including the IRInstructionMapper, which maps an Instruction to unsigned; // integers.; //; // Two sequences of instructions are called ""similar"" if they perform the same; // series of operations for all inputs.; //; // \code; // %1 = add i32 %a, 10; // %2 = add i32 %a, %1; // %3 = icmp slt icmp %1, %2; // \endcode; //; // and; //; // \code; // %1 = add i32 11, %a; // %2 = sub i32 %a, %1; // %3 = icmp sgt icmp %2, %1; // \endcode; //; // ultimately have the same result, even if the inputs, and structure are; // slightly different.; //; // For instructions, we do not worry about operands that do not have fixed; // semantic meaning to the program. We consider the opcode that the instruction; // has, the types, parameters, and extra information such as the function name,; // or comparison predicate. These are used to create a hash to map instructions; // to integers to be used in similarity matching in sequences of instructions; //; // Terminology:; // An IRSimilarityCandidate is a region of IRInstructionData (wrapped; // Instructions), usually used to denote a region of similarity has been found.; //; // A SimilarityGroup is a set of IRSimilarityCandidates that are structurally; // similar to one another.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:632,perform,perform,632,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,1,['perform'],['perform']
Performance,"//===- ImplicitNullChecks.cpp - Fold null checks into memory accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns explicit null checks of the form; //; // test %r10, %r10; // je throw_npe; // movl (%r10), %esi; // ...; //; // to; //; // faulting_load_op(""movl (%r10), %esi"", throw_npe); // ...; //; // With the help of a runtime that understands the .fault_maps section,; // faulting_load_op branches to throw_npe if executing movl (%r10), %esi incurs; // a page fault.; // Store and LoadStore are also supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:769,Load,LoadStore,769,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['Load'],['LoadStore']
Performance,"//===- InMemoryModuleCache.cpp - Cache for loaded memory buffers ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/InMemoryModuleCache.cpp:33,Cache,Cache,33,interpreter/llvm-project/clang/lib/Serialization/InMemoryModuleCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/InMemoryModuleCache.cpp,2,"['Cache', 'load']","['Cache', 'loaded']"
Performance,"//===- InMemoryModuleCache.h - In-memory cache for modules ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h:41,cache,cache,41,interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h,1,['cache'],['cache']
Performance,"//===- IndirectCallPromotion.cpp - Optimizations based on value profiling -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that promotes indirect calls to; // conditional direct calls when the indirect-call value profile metadata is; // available.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:35,Optimiz,Optimizations,35,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,1,['Optimiz'],['Optimizations']
Performance,"//===- InferAddressSpace.cpp - --------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // CUDA C/C++ includes memory space designation as variable type qualifers (such; // as __global__ and __shared__). Knowing the space of a memory access allows; // CUDA compilers to emit faster PTX loads and stores. For example, a load from; // shared memory can be translated to `ld.shared` which is roughly 10% faster; // than a generic `ld` on an NVIDIA Tesla K40c.; //; // Unfortunately, type qualifiers only apply to variable declarations, so CUDA; // compilers must infer the memory space of an address expression from; // type-qualified variables.; //; // LLVM IR uses non-zero (so-called) specific address spaces to represent memory; // spaces (e.g. addrspace(3) means shared memory). The Clang frontend; // places only type-qualified variables in specific address spaces, and then; // conservatively `addrspacecast`s each type-qualified variable to addrspace(0); // (so-called the generic address space) for other instructions to use.; //; // For example, the Clang translates the following CUDA code; // __shared__ float a[10];; // float v = a[i];; // to; // %0 = addrspacecast [10 x float] addrspace(3)* @a to [10 x float]*; // %1 = gep [10 x float], [10 x float]* %0, i64 0, i64 %i; // %v = load float, float* %1 ; emits ld.f32; // @a is in addrspace(3) since it's type-qualified, but its use from %1 is; // redirected to %0 (the generic version of @a).; //; // The optimization implemented in this file propagates specific address spaces; // from type-qualified variable declarations to its users. For example, it; // optimizes the above IR to; // %1 = gep [10 x float] addrspace(3)* @a, i64 0, i64 %i; // %v",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:578,load,loads,578,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,2,['load'],"['load', 'loads']"
Performance,"//===- InferAlignment.cpp -------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Infer alignment for load, stores and other memory operations based on; // trailing zero known bits information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAlignment.cpp:403,load,load,403,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAlignment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAlignment.cpp,1,['load'],['load']
Performance,"//===- InferAlignment.h -----------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Infer alignment for load, stores and other memory operations based on; // trailing zero known bits information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InferAlignment.h:403,load,load,403,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InferAlignment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/InferAlignment.h,1,['load'],['load']
Performance,"//===- InlineFunction.cpp - Code to perform function inlining -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements inlining of a function into a call site, resolving; // parameters and the return value as appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:36,perform,perform,36,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['perform'],['perform']
Performance,"//===- InstCombineLoadStoreAlloca.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the visit functions for load, store and alloca.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:428,load,load,428,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['load'],['load']
Performance,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:800,perform,performed,800,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,2,['perform'],['performed']
Performance,"//===- InstructionNamer.cpp - Give anonymous instructions names -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a little utility pass that gives instructions names, this is mostly; // useful when diffing the effect of an optimization because deleting an; // unnamed instruction can change all other instruction numbering, making the; // diff very noisy.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InstructionNamer.cpp:500,optimiz,optimization,500,interpreter/llvm-project/llvm/lib/Transforms/Utils/InstructionNamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InstructionNamer.cpp,1,['optimiz'],['optimization']
Performance,"//===- InterleavedAccessPass.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Interleaved Access pass, which identifies; // interleaved memory accesses and transforms them into target specific; // intrinsics.; //; // An interleaved load reads data from memory into several vectors, with; // DE-interleaving the data on a factor. An interleaved store writes several; // vectors to memory with RE-interleaving the data on a factor.; //; // As interleaved accesses are difficult to identified in CodeGen (mainly; // because the VECTOR_SHUFFLE DAG node is quite different from the shufflevector; // IR), we identify and transform them to intrinsics in this pass so the; // intrinsics can be easily matched into target specific instructions later in; // CodeGen.; //; // E.g. An interleaved load (Factor = 2):; // %wide.vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <0, 2, 4, 6>; // %v1 = shuffle <8 x i32> %wide.vec, <8 x i32> poison, <1, 3, 5, 7>; //; // It could be transformed into a ld2 intrinsic in AArch64 backend or a vld2; // intrinsic in ARM backend.; //; // In X86, this can be further optimized into a set of target; // specific loads followed by an optimized sequence of shuffles.; //; // E.g. An interleaved store (Factor = 3):; // %i.vec = shuffle <8 x i32> %v0, <8 x i32> %v1,; // <0, 4, 8, 1, 5, 9, 2, 6, 10, 3, 7, 11>; // store <12 x i32> %i.vec, <12 x i32>* %ptr; //; // It could be transformed into a st3 intrinsic in AArch64 backend or a vst3; // intrinsic in ARM backend.; //; // Similarly, a set of interleaved stores can be transformed into an optimized; // sequence of shuffles followed by a set of tar",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:562,load,load,562,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,1,['load'],['load']
Performance,"//===- InterleavedLoadCombine.cpp - Combine Interleaved Loads ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; //; // This file defines the interleaved-load-combine pass. The pass searches for; // ShuffleVectorInstruction that execute interleaving loads. If a matching; // pattern is found, it adds a combined load and further instructions in a; // pattern that is detectable by InterleavedAccesPass. The old instructions are; // left dead to be removed later. The pass is specifically designed to be; // executed just before InterleavedAccesPass to find any left-over instances; // that are not detected within former passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:56,Load,Loads,56,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,4,"['Load', 'load']","['Loads', 'load', 'load-combine', 'loads']"
Performance,"//===- KillTheDoctor - Prevent Dr. Watson from stopping tests ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program provides an extremely hacky way to stop Dr. Watson from starting; // due to unhandled exceptions in child processes.; //; // This simply starts the program named in the first positional argument with; // the arguments following it under a debugger. All this debugger does is catch; // any unhandled exceptions thrown in the child process and close the program; // (and hopefully tells someone about it).; //; // This also provides another really hacky method to prevent assert dialog boxes; // from popping up. When --no-user32 is passed, if any process loads user32.dll,; // we assume it is trying to call MessageBoxEx and terminate it. The proper way; // to do this would be to actually set a break point, but there's quite a bit; // of code involved to get the address of MessageBoxEx in the remote process's; // address space due to Address space layout randomization (ASLR). This can be; // added if it's ever actually needed.; //; // If the subprocess exits for any reason other than successful termination, -1; // is returned. If the process exits normally the value it returned is returned.; //; // I hate Windows.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp:950,load,loads,950,interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,1,['load'],['loads']
Performance,"//===- LCSSA.h - Loop-closed SSA transform Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h:966,optimiz,optimizations,966,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LCSSA.h,1,['optimiz'],['optimizations']
Performance,"//===- LICM.h - Loop Invariant Code Motion Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary alloca'd variable. We then use; // the SSAUpdater to construct the appropriate SSA form for the value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:383,perform,performs,383,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,6,"['load', 'perform']","['load', 'loads', 'performs']"
Performance,"//===- LazyCallGraph.h - Analysis of a Module's call graph ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Implements a lazy call graph analysis and related passes for the new pass; /// manager.; ///; /// NB: This is *not* a traditional call graph! It is a graph which models both; /// the current calls and potential calls. As a consequence there are many; /// edges in this call graph that do not correspond to a 'call' or 'invoke'; /// instruction.; ///; /// The primary use cases of this graph analysis is to facilitate iterating; /// across the functions of a module in ways that ensure all callees are; /// visited prior to a caller (given any SCC constraints), or vice versa. As; /// such is it particularly well suited to organizing CGSCC optimizations such; /// as inlining, outlining, argument promotion, etc. That is its primary use; /// case and motivates the design. It may not be appropriate for other; /// purposes. The use graph of functions or some other conservative analysis of; /// call instructions may be interesting for optimizations and subsequent; /// analyses which don't work in the context of an overly specified; /// potential-call-edge graph.; ///; /// To understand the specific rules and nature of this call graph analysis,; /// see the documentation of the \c LazyCallGraph below.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1036,optimiz,optimizations,1036,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,2,['optimiz'],['optimizations']
Performance,"//===- LegacyPassManager.h - Legacy Container for Passes --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the legacy PassManager class. This class is used to hold,; // maintain, and optimize execution of Passes. The PassManager class ensures; // that analysis results are available before a pass runs, and that Pass's are; // destroyed when the PassManager is destroyed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h:477,optimiz,optimize,477,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h,1,['optimiz'],['optimize']
Performance,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:487,cache,caches,487,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,2,['cache'],"['cache', 'caches']"
Performance,"//===- LoadStoreOpt.cpp ----------- Generic memory optimizations -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file implements the LoadStoreOpt optimization pass.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:7,Load,LoadStoreOpt,7,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,4,"['Load', 'optimiz']","['LoadStoreOpt', 'optimization', 'optimizations']"
Performance,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h:7,Load,LoadStoreVectorizer,7,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h,2,['Load'],"['Load', 'LoadStoreVectorizer']"
Performance,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:7,Load,LoadStoreVectorizer,7,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,7,"['Load', 'load']","['Load', 'LoadStoreVectorizer', 'load', 'loads']"
Performance,"//===- Loads.cpp - Local load analysis ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:7,Load,Loads,7,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,3,"['Load', 'load']","['Loads', 'load']"
Performance,"//===- Loads.h - Local load analysis --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:7,Load,Loads,7,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,3,"['Load', 'load']","['Loads', 'load']"
Performance,"//===- Local.cpp - Functions to perform local transformations -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Local.cpp:32,perform,perform,32,interpreter/llvm-project/llvm/lib/Analysis/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Local.cpp,4,['perform'],['perform']
Performance,"//===- Local.h - Functions to perform local transformations -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h:30,perform,perform,30,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h,4,['perform'],['perform']
Performance,"//===- LoopCacheAnalysis.cpp - Loop Cache Analysis -------------------------==//; //; // The LLVM Compiler Infrastructure; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the implementation for the loop cache analysis.; /// The implementation is largely based on the following paper:; ///; /// Compiler Optimizations for Improving Data Locality; /// By: Steve Carr, Katherine S. McKinley, Chau-Wen Tseng; /// http://www.cs.utexas.edu/users/mckinley/papers/asplos-1994.pdf; ///; /// The general approach taken to estimate the number of cache lines used by the; /// memory references in an inner loop is:; /// 1. Partition memory references that exhibit temporal or spacial reuse; /// into reference groups.; /// 2. For each loop L in the a loop nest LN:; /// a. Compute the cost of the reference group; /// b. Compute the loop cost by summing up the reference groups costs; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:36,Cache,Cache,36,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,4,"['Cache', 'Optimiz', 'cache']","['Cache', 'Optimizations', 'cache']"
Performance,"//===- LoopIdiomRecognize.cpp - Loop idiom recognition --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements an idiom recognizer that transforms simple loops into a; // non-loop form. In cases that this kicks in, it can be a significant; // performance win.; //; // If compiling for code size we avoid idiom recognition if the resulting; // code could be larger than the code for the original loop. One way this could; // happen is if the loop is not removable after idiom recognition due to the; // presence of non-idiom instructions. The initial implementation of the; // heuristics applies to idioms in multi-block loops.; //; //===----------------------------------------------------------------------===//; //; // TODO List:; //; // Future loop memory idioms to recognize:; // memcmp, strlen, etc.; // Future floating point idioms to recognize in -ffast-math mode:; // fpowi; //; // This could recognize common matrix multiplies and dot product idioms and; // replace them with calls to BLAS (if linked in??).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:536,perform,performance,536,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['perform'],['performance']
Performance,"//===- LoopIdiomRecognize.h - Loop Idiom Recognize Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements an idiom recognizer that transforms simple loops into a; // non-loop form. In cases that this kicks in, it can be a significant; // performance win.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h:536,perform,performance,536,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h,1,['perform'],['performance']
Performance,"//===- LoopInstSimplify.cpp - Loop Instruction Simplification Pass --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs lightweight instruction simplification on loop bodies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:393,perform,performs,393,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,1,['perform'],['performs']
Performance,"//===- LoopInstSimplify.h - Loop Inst Simplify Pass -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs lightweight instruction simplification on loop bodies.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h:393,perform,performs,393,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h,1,['perform'],['performs']
Performance,"//===- LoopInterchange.cpp - Loop interchange pass-------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This Pass handles loop interchange transform.; // This pass interchanges loops to provide a more cache-friendly memory access; // patterns.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:480,cache,cache-friendly,480,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['cache'],['cache-friendly']
Performance,"//===- LoopLoadElimination.cpp - Loop Load Elimination Pass ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implement a loop-aware load elimination pass.; //; // It uses LoopAccessAnalysis to identify loop-carried dependences with a; // distance of one between stores and loads. These form the candidates for the; // transformation. The source value of each store then propagated to the user; // of the corresponding load. This makes the load dead.; //; // The pass can also version the loop and add memchecks in order to prove that; // may-aliasing stores can't change the value in memory before it's read by the; // load.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:38,Load,Load,38,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,6,"['Load', 'load']","['Load', 'load', 'loads']"
Performance,"//===- LoopLoadElimination.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This header defines the LoopLoadEliminationPass object. This pass forwards; /// loaded values around loop backedges to allow their use in subsequent; /// iterations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h:475,load,loaded,475,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h,1,['load'],['loaded']
Performance,"//===- LoopPass.cpp - Loop Pass and Loop Pass Manager ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements LoopPass and LPPassManager. All loop optimization; // and transformation passes are derived from LoopPass. LPPassManager is; // responsible for managing LoopPasses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:441,optimiz,optimization,441,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,1,['optimiz'],['optimization']
Performance,"//===- LoopPass.h - LoopPass class ----------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines LoopPass class. All loop optimization; // and transformation passes are derived from LoopPass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:426,optimiz,optimization,426,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,1,['optimiz'],['optimization']
Performance,"//===- LoopPassManager.h - Loop pass management -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing a pipeline of passes over loops; /// in LLVM IR.; ///; /// The primary loop pass pipeline is managed in a very particular way to; /// provide a set of core guarantees:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of Loop-specific analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; /// 4) All loop passes preserve #1 (where possible), #2, and #3.; /// 5) Loop passes run over each loop in the loop nest from the innermost to; /// the outermost. Specifically, all inner loops are processed before; /// passes run over outer loops. When running the pipeline across an inner; /// loop creates new inner loops, those are added and processed in this; /// order as well.; ///; /// This process is designed to facilitate transformations which simplify,; /// reduce, and remove loops. For passes which are more oriented towards; /// optimizing loops, especially optimizing loop *nests* instead of single; /// loops in isolation, this framework is less interesting.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:1394,optimiz,optimizing,1394,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,2,['optimiz'],['optimizing']
Performance,"//===- LoopRotationUtils.h - Utilities to perform loop rotation -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides utilities to convert a loop into a loop with bottom test.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h:42,perform,perform,42,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h,1,['perform'],['perform']
Performance,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:393,perform,performs,393,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['perform'],['performs']
Performance,"//===- LoopSimplify.h - Loop Canonicalization Pass --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h:393,perform,performs,393,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopSimplify.h,1,['perform'],['performs']
Performance,"//===- LoopSimplifyCFG.cpp - Loop CFG Simplification Pass -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop SimplifyCFG Pass. This pass is responsible for; // basic loop CFG cleanup, primarily to assist other loop passes. If you; // encounter a noncanonical CFG construct that causes another loop pass to; // perform suboptimally, this is the place to fix it up.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h:614,perform,perform,614,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h,1,['perform'],['perform']
Performance,"//===- LoopStrengthReduce.cpp - Strength Reduce IVs in Loops --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; // Terminology note: this code has a lot of handling for ""post-increment"" or; // ""post-inc"" users. This is not talking about post-increment addressing modes;; // it is instead talking about code like this:; //; // %i = phi [ 0, %entry ], [ %i.next, %latch ]; // ...; // %i.next = add %i, 1; // %c = icmp eq %i.next, %n; //; // The SCEV for %i is {0,+,1}<%L>. The SCEV for %i.next is {1,+,1}<%L>, however; // it's useful to think about these as the same register, with some uses using; // the value of the register before the add and some using it after. In this; // example, the icmp is a post-increment user, since it uses %i.next, which is; // the value of the induction variable after the increment. The other common; // case of post-increment users is users outside the loop.; //; // TODO: More sophistication in the way Formulae are generated and filtered.; //; // TODO: Handle multiple loops at a time.; //; // TODO: Should the addressing mode BaseGV be changed to a ConstantExpr instead; // of a GlobalValue?; //; // TODO: When truncation is free, truncate ICmp users' operands",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:573,perform,performs,573,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,3,"['optimiz', 'perform']","['optimizations', 'performs']"
Performance,"//===- LoopStrengthReduce.h - Loop Strength Reduce Pass ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation analyzes and transforms the induction variables (and; // computations derived from them) into forms suitable for efficient execution; // on the target.; //; // This pass performs a strength reduction on array references inside loops that; // have as one or more of their components the loop induction variable, it; // rewrites expressions to take advantage of scaled-index addressing modes; // available on the target, and it performs a variety of other optimizations; // related to loop induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:573,perform,performs,573,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,3,"['optimiz', 'perform']","['optimizations', 'performs']"
Performance,"//===- LoopTransformWarning.cpp - ----------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Emit warnings if forced code transformations have not been performed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp:441,perform,performed,441,interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp,1,['perform'],['performed']
Performance,"//===- LoopUnrollAnalyzer.cpp - Unrolling Effect Estimation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements UnrolledInstAnalyzer class. It's used for predicting; // potential effects that loop unrolling might have, such as enabling constant; // propagation and other optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp:563,optimiz,optimizations,563,interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopUnrollAnalyzer.cpp,1,['optimiz'],['optimizations']
Performance,"//===- LoopVectorizationPlanner.h - Planner for LoopVectorization ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file provides a LoopVectorizationPlanner class.; /// InnerLoopVectorizer vectorizes loops which contain only one basic; /// LoopVectorizationPlanner - drives the vectorization process after having; /// passed Legality checks.; /// The planner builds and optimizes the Vectorization Plans which record the; /// decisions how to vectorize the given loop. In particular, represent the; /// control-flow of the vectorized version, the replication of instructions that; /// are to be scalarized, and interleave access groups.; ///; /// Also provides a VPlan-based builder utility analogous to IRBuilder.; /// It provides an instruction-level API for generating VPInstructions while; /// abstracting away the Recipe manipulation details.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:655,optimiz,optimizes,655,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,1,['optimiz'],['optimizes']
Performance,"//===- LoopVersioning.cpp - Utility to version a loop ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a utility class to perform loop versioning. The versioned; // loop speculates that otherwise may-aliasing memory accesses don't overlap and; // emits checks to prove this.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp:420,perform,perform,420,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,1,['perform'],['perform']
Performance,"//===- LoopVersioning.h - Utility to version a loop -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a utility class to perform loop versioning. The versioned; // loop speculates that otherwise may-aliasing memory accesses don't overlap and; // emits checks to prove this.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h:420,perform,perform,420,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,1,['perform'],['perform']
Performance,"//===- MCLinkerOptimizationHint.h - LOH interface ---------------*- C++ -*-===//; //; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares some helpers classes to handle Linker Optimization Hint; // (LOH).; //; // FIXME: LOH interface supports only MachO format at the moment.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h:444,Optimiz,Optimization,444,interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,1,['Optimiz'],['Optimization']
Performance,"//===- MLInlineAdvisor.cpp - machine learned InlineAdvisor ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface between the inliner and a learned model.; // It delegates model evaluation to either the AOT compiled model (the; // 'release' mode) or a runtime-loaded model (the 'development' case).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp:564,load,loaded,564,interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MLInlineAdvisor.cpp,1,['load'],['loaded']
Performance,"//===- MVELaneInterleaving.cpp - Inverleave for MVE instructions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass interleaves around sext/zext/trunc instructions. MVE does not have; // a single sext/zext or trunc instruction that takes the bottom half of a; // vector and extends to a full width, like NEON has with MOVL. Instead it is; // expected that this happens through top/bottom instructions. So the MVE; // equivalent VMOVLT/B instructions take either the even or odd elements of the; // input and extend them to the larger type, producing a vector with half the; // number of elements each of double the bitwidth. As there is no simple; // instruction, we often have to turn sext/zext/trunc into a series of lane; // moves (or stack loads/stores, which we do not do yet).; //; // This pass takes vector code that starts at truncs, looks for interconnected; // blobs of operations that end with sext/zext (or constants/splats) of the; // form:; // %sa = sext v8i16 %a to v8i32; // %sb = sext v8i16 %b to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // And adds shuffles to allow the use of VMOVL/VMOVN instrctions:; // %sha = shuffle v8i16 %a, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sa = sext v8i16 %sha to v8i32; // %shb = shuffle v8i16 %b, undef, <0, 2, 4, 6, 1, 3, 5, 7>; // %sb = sext v8i16 %shb to v8i32; // %add = add v8i32 %sa, %sb; // %r = trunc %add to v8i16; // %shr = shuffle v8i16 %r, undef, <0, 4, 1, 5, 2, 6, 3, 7>; // Which can then be split and lowered to MVE instructions efficiently:; // %sa_b = VMOVLB.s16 %a; // %sa_t = VMOVLT.s16 %a; // %sb_b = VMOVLB.s16 %b; // %sb_t = VMOVLT.s16 %b; // %add_b = VADD.i32 %sa_b, %sb_b; // %add_t = VADD.i32 %sa_t, %sb_t; // %r = VMOVNT.i16",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp:1021,load,loads,1021,interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVELaneInterleavingPass.cpp,1,['load'],['loads']
Performance,"//===- MVETailPredication.cpp - MVE Tail Predication ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Armv8.1m introduced MVE, M-Profile Vector Extension, and low-overhead; /// branches to help accelerate DSP applications. These two extensions,; /// combined with a new form of predication called tail-predication, can be used; /// to provide implicit vector predication within a low-overhead loop.; /// This is implicit because the predicate of active/inactive lanes is; /// calculated by hardware, and thus does not need to be explicitly passed; /// to vector instructions. The instructions responsible for this are the; /// DLSTP and WLSTP instructions, which setup a tail-predicated loop and the; /// the total number of data elements processed by the loop. The loop-end; /// LETP instruction is responsible for decrementing and setting the remaining; /// elements to be processed and generating the mask of active lanes.; ///; /// The HardwareLoops pass inserts intrinsics identifying loops that the; /// backend will attempt to convert into a low-overhead loop. The vectorizer is; /// responsible for generating a vectorized loop in which the lanes are; /// predicated upon an get.active.lane.mask intrinsic. This pass looks at these; /// get.active.lane.mask intrinsic and attempts to convert them to VCTP; /// instructions. This will be picked up by the ARM Low-overhead loop pass later; /// in the backend, which performs the final transformation to a DLSTP or WLSTP; /// tail-predicated loop.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:1715,perform,performs,1715,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,1,['perform'],['performs']
Performance,"//===- MachineBlockPlacement.cpp - Basic Block Code Layout optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements basic block placement transformations using the CFG; // structure and branch probability estimates.; //; // The pass strives to preserve the structure of the CFG (that is, retain; // a topological ordering of basic blocks) in the absence of a *strong* signal; // to the contrary from probabilities. However, within the CFG structure, it; // attempts to choose an ordering which favors placing more likely sequences of; // blocks adjacent to each other.; //; // The algorithm works from the inner-most loop within a function outward, and; // at each stage walks through the basic blocks, trying to coalesce them into; // sequential chains where allowed by the CFG (or demanded by heavy; // probabilities). Finally, it walks the blocks in topological order, and the; // first time it reaches a chain of basic blocks, it schedules them in the; // function in-order.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:59,optimiz,optimization,59,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['optimiz'],['optimization']
Performance,"//===- MachineCSE.cpp - Machine Common Subexpression Elimination Pass -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs global common subexpression elimination on machine; // instructions using a scoped hash table based value numbering scheme. It; // must be run while the machine function is still in SSA form.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:393,perform,performs,393,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['perform'],['performs']
Performance,"//===- MachineLICM.cpp - Machine Loop Invariant Code Motion Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion on machine instructions. We; // attempt to remove as much code from the body of a loop as possible.; //; // This pass is not intended to be a replacement or a complete alternative; // for the LLVM-IR-level LICM pass. It is only designed to hoist simple; // constructs that are not exposed before lowering and instruction selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:393,perform,performs,393,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['perform'],['performs']
Performance,"//===- MachinePipeliner.cpp - Machine Software Pipeliner Pass -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // An implementation of the Swing Modulo Scheduling (SMS) software pipeliner.; //; // This SMS implementation is a target-independent back-end pass. When enabled,; // the pass runs just prior to the register allocation pass, while the machine; // IR is in SSA form. If software pipelining is successful, then the original; // loop is replaced by the optimized loop. The optimized loop contains one or; // more prolog blocks, the pipelined kernel, and one or more epilog blocks. If; // the instructions cannot be scheduled in a given MII, we increase the MII by; // one and try again.; //; // The SMS implementation is an extension of the ScheduleDAGInstrs class. We; // represent loop carried dependences in the DAG as order edges to the Phi; // nodes. We also perform several passes over the DAG to eliminate unnecessary; // edges that inhibit the ability to pipeline. The implementation uses the; // DFAPacketizer class to compute the minimum initiation interval and the check; // where an instruction may be inserted in the pipelined schedule.; //; // In order for the SMS pass to work, several target specific hooks need to be; // implemented to get information about the loop structure and to rewrite; // instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:730,optimiz,optimized,730,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,3,"['optimiz', 'perform']","['optimized', 'perform']"
Performance,"//===- MachineSizeOpts.cpp - code size optimization related code ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared machine IR code size optimization related; // code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp:39,optimiz,optimization,39,interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSizeOpts.cpp,2,['optimiz'],['optimization']
Performance,"//===- MachineSizeOpts.h - machine size optimization ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared machine IR code size optimization related; // code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h:40,optimiz,optimization,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineSizeOpts.h,2,['optimiz'],['optimization']
Performance,"//===- MemCpyOptimizer.cpp - Optimize use of memcpy and friends -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs various transformations related to eliminating memcpy; // calls, or transforming sets of stores into memset's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:29,Optimiz,Optimize,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,2,"['Optimiz', 'perform']","['Optimize', 'performs']"
Performance,"//===- MemCpyOptimizer.h - memcpy optimization ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs various transformations related to eliminating memcpy; // calls, or transforming sets of stores into memset's.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h:34,optimiz,optimization,34,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h,2,"['optimiz', 'perform']","['optimization', 'performs']"
Performance,"//===- MemorySSA.h - Build Memory SSA ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file exposes an interface to building/using memory SSA to; /// walk memory instructions using a use/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the Mem",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:617,load,loads,617,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['load'],['loads']
Performance,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:490,perform,performs,490,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,2,"['load', 'perform']","['loads', 'performs']"
Performance,"//===- MemorySanitizer.cpp - detector of uninitialized reads --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of MemorySanitizer, a detector of uninitialized; /// reads.; ///; /// The algorithm of the tool is similar to Memcheck; /// (http://goo.gl/QKbem). We associate a few shadow bits with every; /// byte of the application memory, poison the shadow of the malloc-ed; /// or alloca-ed memory, load the shadow bits on every memory read,; /// propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisone",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:702,load,load,702,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['load'],['load']
Performance,"//===- MergeICmps.cpp - Optimize chains of integer comparisons ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass turns chains of integer comparisons into memcmp (the memcmp is; // later typically inlined as a chain of efficient hardware comparisons). This; // typically benefits c++ member or nonmember operator==().; //; // The basic idea is to replace a longer chain of integer comparisons loaded; // from contiguous memory locations into a shorter chain of larger integer; // comparisons. Benefits are double:; // - There are less jumps, and therefore less opportunities for mispredictions; // and I-cache misses.; // - Code size is smaller, both because jumps are removed and because the; // encoding of a 2*n byte compare is smaller than that of two n-byte; // compares.; //; // Example:; //; // struct S {; // int a;; // char b;; // char c;; // uint16_t d;; // bool operator==(const S& o) const {; // return a == o.a && b == o.b && c == o.c && d == o.d;; // }; // };; //; // Is optimized as :; //; // bool S::operator==(const S& o) const {; // return memcmp(this, &o, 8) == 0;; // }; //; // Which will later be expanded (ExpandMemCmp) as a single 8-bytes icmp.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:24,Optimiz,Optimize,24,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,4,"['Optimiz', 'cache', 'load', 'optimiz']","['Optimize', 'cache', 'loaded', 'optimized']"
Performance,"//===- MergedLoadStoreMotion.cpp - merge and hoist/sink load/stores -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. New tail/footer block may be; // insterted if the tail/footer block has more predecessors (not only the two; // predecessors that are forming the diamond). It hoists / sinks when it thinks; // it safe to do so. This optimization helps with eg. hiding load latencies,; // triggering if-conversion, and reducing static code size.; //; // NOTE: This code no longer performs load hoisting, it is subsumed by GVNHoist.; //; //===----------------------------------------------------------------------===//; //; //; // Example:; // Diamond shaped code before merge:; //; // header:; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // %lt = load %addr_l %le = load %addr_l; // <use %lt> <use %le>; // <...> <...>; // store %st, %addr_s store %se, %addr_s; // br label %if.end br label %if.end; // + +; // + +; // + +; // if.end (""footer""):; // <...>; //; // Diamond shaped code after merge:; //; // header:; // %l = load %addr_l; // br %cond, label %if.then, label %if.else; // + +; // + +; // + +; // if.then: if.else:; // <use %l> <use %l>; // <...> <...>; // br label %if.e",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp:56,load,load,56,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergedLoadStoreMotion.cpp,7,"['load', 'perform']","['load', 'loads', 'performs']"
Performance,"//===- MergedLoadStoreMotion.h - merge and hoist/sink load/stores ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; //! \file; //! This pass performs merges of loads and stores on both sides of a; // diamond (hammock). It hoists the loads and sinks the stores.; //; // The algorithm iteratively hoists two loads to the same address out of a; // diamond (hammock) and merges them into a single load in the header. Similar; // it sinks and merges two stores to the tail block (footer). The algorithm; // iterates over the instructions of one side of the diamond and attempts to; // find a matching load/store on the other side. It hoists / sinks when it; // thinks it safe to do so. This optimization helps with eg. hiding load; // latencies, triggering if-conversion, and reducing static code size.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h:54,load,load,54,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/MergedLoadStoreMotion.h,9,"['load', 'optimiz', 'perform']","['load', 'loads', 'optimization', 'performs']"
Performance,"//===- MipsConstantIslandPass.cpp - Emit Pc Relative loads ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is used to make Pc relative loads of constants.; // For now, only Mips16 will use this.; //; // Loading constants inline is expensive on Mips16 and it's in general better; // to place the constant nearby in code space and then it can be loaded with a; // simple 16 bit load instruction.; //; // The constants can be not just numbers but addresses of functions and labels.; // This can be particularly helpful in static relocation mode for embedded; // non-linux targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp:53,load,loads,53,interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsConstantIslandPass.cpp,5,"['Load', 'load']","['Loading', 'load', 'loaded', 'loads']"
Performance,"//===- MipsOptimizePICCall.cpp - Optimize PIC Calls -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass eliminates unnecessary instructions that set up $gp and replace; // instructions that load target function addresses with copy instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:33,Optimiz,Optimize,33,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,2,"['Optimiz', 'load']","['Optimize', 'load']"
Performance,"//===- Miscompilation.cpp - Debug program miscompilations -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements optimizer and code generation miscompilation debugging; // support.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:404,optimiz,optimizer,404,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['optimiz'],['optimizer']
Performance,"//===- ModuleFile.cpp - Module description --------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ModuleFile class, which describes a module that; // has been loaded from an AST file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleFile.cpp:469,load,loaded,469,interpreter/llvm-project/clang/lib/Serialization/ModuleFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleFile.cpp,1,['load'],['loaded']
Performance,"//===- ModuleFile.h - Module file description -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the Module class, which describes a module that has; // been loaded from an AST file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:462,load,loaded,462,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,1,['load'],['loaded']
Performance,"//===- ModuleLoader.h - Module Loader Interface -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ModuleLoader interface, which is responsible for; // loading named modules.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:31,Load,Loader,31,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,2,"['Load', 'load']","['Loader', 'loading']"
Performance,"//===- ModuleManager.cpp - Module Manager -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ModuleManager class, which manages a set of loaded; // modules for the ASTReader.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:449,load,loaded,449,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,"//===- ModuleManager.cpp - Module Manager ---------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ModuleManager class, which manages a set of loaded; // modules for the ASTReader.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:449,load,loaded,449,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,1,['load'],['loaded']
Performance,"//===- MultiOnDiskHashTable.h - Merged set of hash tables -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides a hash table data structure suitable for incremental and; // distributed storage across a set of files.; //; // Multiple hash tables from different files are implicitly merged to improve; // performance, and on reload the merged table will override those from other; // files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:593,perform,performance,593,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,1,['perform'],['performance']
Performance,"//===- ObjCARC.h - ObjC ARC Optimization --------------*- C++ -*-----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines common definitions/declarations used by the ObjC ARC; /// Optimizer. ARC stands for Automatic Reference Counting and is a system for; /// managing reference counts for objects in Objective C.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h:28,Optimiz,Optimization,28,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARC.h,2,['Optimiz'],"['Optimization', 'Optimizer']"
Performance,"//===- ObjCARCAPElim.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file implements optimizations which remove extraneous; /// autorelease pools.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp:36,Optimiz,Optimization,36,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCAPElim.cpp,3,"['Optimiz', 'optimiz']","['Optimization', 'optimizations']"
Performance,"//===- ObjCARCAliasAnalysis.cpp - ObjC ARC Optimization -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; /// TODO: Theoretically we could check for dependencies between objc_* calls; /// and FMRB_OnlyAccessesArgumentPointees calls or other well-behaved calls.; ///; /// TODO: The calls here to AAResultBase member functions are all effectively; /// no-ops that just return a conservative result. The original intent was to; /// chain to another analysis for a recursive query, but this was lost in a; /// refactor. These should instead be rephrased in terms of queries to AAQI.AAR.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp:43,Optimiz,Optimization,43,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCAliasAnalysis.cpp,2,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"//===- ObjCARCAliasAnalysis.h - ObjC ARC Alias Analysis ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h:504,optimiz,optimization,504,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h,1,['optimiz'],['optimization']
Performance,"//===- ObjCARCAnalysisUtils.h - ObjC ARC Analysis Utilities -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines common analysis utilities used by the ObjC ARC Optimizer.; /// ARC stands for Automatic Reference Counting and is a system for managing; /// reference counts for objects in Objective C.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:456,Optimiz,Optimizer,456,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,1,['Optimiz'],['Optimizer']
Performance,"//===- ObjCARCContract.cpp - ObjC ARC Optimization ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines late ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file mainly deals with ``contracting'' multiple lower level; /// operations into singular higher level operations through pattern matching.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//; // TODO: ObjCARCContract could insert PHI nodes when uses aren't; // dominated by single calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:38,Optimiz,Optimization,38,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,2,"['Optimiz', 'optimiz']","['Optimization', 'optimizations']"
Performance,"//===- ObjCARCExpand.cpp - ObjC ARC Optimization --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// This specific file deals with early optimizations which perform certain; /// cleanup operations.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp:36,Optimiz,Optimization,36,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCExpand.cpp,4,"['Optimiz', 'optimiz', 'perform']","['Optimization', 'optimizations', 'perform']"
Performance,"//===- ObjCARCOpts.cpp - ObjC ARC Optimization ----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file defines ObjC ARC optimizations. ARC stands for Automatic; /// Reference Counting and is a system for managing reference counts for objects; /// in Objective C.; ///; /// The optimizations performed include elimination of redundant, partially; /// redundant, and inconsequential reference count operations, elimination of; /// redundant weak pointer operations, and numerous minor simplifications.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:34,Optimiz,Optimization,34,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,4,"['Optimiz', 'optimiz', 'perform']","['Optimization', 'optimizations', 'performed']"
Performance,"//===- OperationKinds.h - Operation enums -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file enumerates the different kinds of operations that can be; // performed by various expressions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h:454,perform,performed,454,interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OperationKinds.h,1,['perform'],['performed']
Performance,"//===- OptimizationLevel.cpp ----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/OptimizationLevel.cpp:7,Optimiz,OptimizationLevel,7,interpreter/llvm-project/llvm/lib/Passes/OptimizationLevel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/OptimizationLevel.cpp,1,['Optimiz'],['OptimizationLevel']
Performance,"//===- OptimizationRemarkEmitter.cpp - Optimization Diagnostic --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp:7,Optimiz,OptimizationRemarkEmitter,7,interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/OptimizationRemarkEmitter.cpp,3,['Optimiz'],"['Optimization', 'OptimizationRemarkEmitter']"
Performance,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:7,Optimiz,OptimizationRemarkEmitter,7,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,3,['Optimiz'],"['Optimization', 'OptimizationRemarkEmitter']"
Performance,"//===- OptimizePHIs.cpp - Optimize machine instruction PHIs ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes machine instruction PHIs to take advantage of; // opportunities created during DAG legalization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:7,Optimiz,OptimizePHIs,7,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,3,"['Optimiz', 'optimiz']","['Optimize', 'OptimizePHIs', 'optimizes']"
Performance,"//===- OptimizerDriver.cpp - Allow BugPoint to run passes safely ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to run various passes; // without the threat of a buggy pass corrupting bugpoint (of course, bugpoint; // may have its own bugs, but that's another story...). It achieves this by; // forking a copy of itself and having the child process do the optimizations.; // If this client dies, we can always fork a new one. :); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp:7,Optimiz,OptimizerDriver,7,interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/OptimizerDriver.cpp,2,"['Optimiz', 'optimiz']","['OptimizerDriver', 'optimizations']"
Performance,"//===- PartialInlining.cpp - Inline parts of functions --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs partial inlining, typically by inlining an if statement; // that surrounds the body of the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:393,perform,performs,393,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,1,['perform'],['performs']
Performance,"//===- PartialInlining.h - Inline parts of functions ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs partial inlining, typically by inlining an if statement; // that surrounds the body of the function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/PartialInlining.h:393,perform,performs,393,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/PartialInlining.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/PartialInlining.h,1,['perform'],['performs']
Performance,"//===- PatternMatch.h - Match on the LLVM IR --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides a simple and efficient mechanism for performing general; // tree-based pattern matches on the LLVM IR. The power of these routines is; // that it allows you to write concise patterns that are expressive and easy to; // understand. The other major advantage of this is that it allows you to; // trivially capture/bind elements in the pattern to variables. For example,; // you can do something like this:; //; // Value *Exp = ...; // Value *X, *Y; ConstantInt *C1, *C2; // (X & C1) | (Y & C2); // if (match(Exp, m_Or(m_And(m_Value(X), m_ConstantInt(C1)),; // m_And(m_Value(Y), m_ConstantInt(C2))))) {; // ... Pattern is matched and variables are bound ...; // }; //; // This is primarily useful to things like the instruction combiner, but can; // also be useful for static analysis tools or code generators.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h:439,perform,performing,439,interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,1,['perform'],['performing']
Performance,"//===- PeepholeOptimizer.cpp - Peephole Optimizations ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Perform peephole optimizations on the machine code:; //; // - Optimize Extensions; //; // Optimization of sign / zero extension instructions. It may be extended to; // handle other instructions with similar properties.; //; // On some targets, some instructions, e.g. X86 sign / zero extension, may; // leave the source value in the lower part of the result. This optimization; // will replace some uses of the pre-extension value with uses of the; // sub-register of the results.; //; // - Optimize Comparisons; //; // Optimization of comparison instructions. For instance, in this code:; //; // sub r1, 1; // cmp r1, 0; // bz L1; //; // If the ""sub"" instruction all ready sets (or could be modified to set) the; // same flag that the ""cmp"" instruction sets and that ""bz"" uses, then we can; // eliminate the ""cmp"" instruction.; //; // Another instance, in this code:; //; // sub r1, r3 | sub r1, imm; // cmp r3, r1 or cmp r1, r3 | cmp r1, imm; // bge L1; //; // If the branch instruction can use flag from ""sub"", then we can replace; // ""sub"" with ""subs"" and eliminate the ""cmp"" instruction.; //; // - Optimize Loads:; //; // Loads that can be folded into a later instruction. A load is foldable; // if it loads to virtual registers and the virtual register defined has; // a single use.; //; // - Optimize Copies and Bitcast (more generally, target specific copies):; //; // Rewrite copies and bitcasts to avoid cross register bank copies; // when possible.; // E.g., Consider the following example, where capital and lower; // letters denote different register file:; // b = copy A <-- cross-bank copy; // C = copy ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:40,Optimiz,Optimizations,40,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,8,"['Optimiz', 'Perform', 'optimiz']","['Optimization', 'Optimizations', 'Optimize', 'Perform', 'optimization', 'optimizations']"
Performance,"//===- PhiValues.h - Phi Value Analysis -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PhiValues class, and associated passes, which can be; // used to find the underlying values of the phis in a function, i.e. the; // non-phi values that can be found by traversing the phi graph.; //; // This information is computed lazily and cached. If new phis are added to the; // function they are handled correctly, but if an existing phi has its operands; // modified PhiValues has to be notified by calling invalidateValue.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:647,cache,cached,647,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,1,['cache'],['cached']
Performance,"//===- PreISelIntrinsicLowering.cpp - Pre-ISel intrinsic lowering pass ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR lowering for the llvm.memcpy, llvm.memmove,; // llvm.memset, llvm.load.relative and llvm.objc.* intrinsics.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:473,load,load,473,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,1,['load'],['load']
Performance,"//===- PreISelIntrinsicLowering.h - Pre-ISel intrinsic lowering pass ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR lowering for the llvm.load.relative and llvm.objc.*; // intrinsics.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PreISelIntrinsicLowering.h:429,load,load,429,interpreter/llvm-project/llvm/include/llvm/CodeGen/PreISelIntrinsicLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PreISelIntrinsicLowering.h,1,['load'],['load']
Performance,"//===- PredIteratorCache.h - pred_iterator Cache ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PredIteratorCache class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h:43,Cache,Cache,43,interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h,1,['Cache'],['Cache']
Performance,"//===- Profile.cpp - XRay Profile Abstraction -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the XRay Profile class representing the latency profile generated by; // XRay's profiling mode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Profile.cpp:431,latency,latency,431,interpreter/llvm-project/llvm/lib/XRay/Profile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Profile.cpp,1,['latency'],['latency']
Performance,"//===- Profile.h - XRay Profile Abstraction -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the XRay Profile class representing the latency profile generated by; // XRay's profiling mode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h:431,latency,latency,431,interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Profile.h,1,['latency'],['latency']
Performance,"//===- PromoteMemoryToRegister.cpp - Convert allocas to registers ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file promotes memory references to be register references. It promotes; // alloca instructions which only have loads and stores as uses. An alloca is; // transformed by using iterated dominator frontiers to place PHI nodes, then; // traversing the function in depth-first order to rewrite loads and stores as; // appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:499,load,loads,499,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,2,['load'],['loads']
Performance,"//===- ProvenanceAnalysis.cpp - ObjC ARC Optimization ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; ///; /// This file defines a special form of Alias Analysis called ``Provenance; /// Analysis''. The word ``provenance'' refers to the history of the ownership; /// of an object. Thus ``Provenance Analysis'' is an analysis which attempts to; /// use various techniques to determine if locally; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp:41,Optimiz,Optimization,41,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.cpp,1,['Optimiz'],['Optimization']
Performance,"//===- ProvenanceAnalysis.h - ObjC ARC Optimization -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; ///; /// This file declares a special form of Alias Analysis called ``Provenance; /// Analysis''. The word ``provenance'' refers to the history of the ownership; /// of an object. Thus ``Provenance Analysis'' is an analysis which attempts to; /// use various techniques to determine if locally; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.h:39,Optimiz,Optimization,39,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysis.h,1,['Optimiz'],['Optimization']
Performance,"//===- ProvenanceAnalysisEvaluator.cpp - ObjC ARC Optimization ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysisEvaluator.cpp:50,Optimiz,Optimization,50,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysisEvaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ProvenanceAnalysisEvaluator.cpp,1,['Optimiz'],['Optimization']
Performance,"//===- PtrState.h - ARC State for a Ptr -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains declarations for the ARC state associated with a ptr. It; // is only used by the ARC Sequence Dataflow computation. By separating this; // from the actual dataflow, it is easier to consider the mechanics of the ARC; // optimization separate from the actual predicates being used.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:621,optimiz,optimization,621,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,1,['optimiz'],['optimization']
Performance,"//===- RDFLiveness.cpp ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Computation of the liveness information from the data-flow graph.; //; // The main functionality of this code is to compute block live-in; // information. With the live-in information in place, the placement; // of kill flags can also be recalculated.; //; // The block live-in calculation is based on the ideas from the following; // publication:; //; // Dibyendu Das, Ramakrishna Upadrasta, Benoit Dupont de Dinechin.; // ""Efficient Liveness Computation Using Merge Sets and DJ-Graphs.""; // ACM Transactions on Architecture and Code Optimization, Association for; // Computing Machinery, 2012, ACM TACO Special Issue on ""High-Performance; // and Embedded Architectures and Compilers"", 8 (4),; // <10.1145/2086696.2086706>. <hal-00647369>; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp:918,Optimiz,Optimization,918,interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFLiveness.cpp,2,"['Optimiz', 'Perform']","['Optimization', 'Performance']"
Performance,"//===- RISCVFoldMasks.cpp - MI Vector Pseudo Mask Peepholes ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs various peephole optimisations that fold masks into vector; // pseudo instructions after instruction selection.; //; // Currently it converts; // PseudoVMERGE_VVM %false, %false, %true, %allonesmask, %vl, %sew; // ->; // PseudoVMV_V_V %false, %true, %vl, %sew; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp:392,perform,performs,392,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFoldMasks.cpp,1,['perform'],['performs']
Performance,"//===- RISCVOptWInstrs.cpp - MI W instruction optimizations ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass does some optimizations for *W instructions at the MI level.; //; // First it removes unneeded sext.w instructions. Either because the sign; // extended bits aren't consumed or because the input was already sign extended; // by an earlier instruction.; //; // Then it removes the -w suffix from opw instructions whenever all users are; // dependent only on the lower word of the result of the instruction.; // The cases handled are:; // * addw because c.add has a larger register encoding than c.addw.; // * addiw because it helps reduce test differences between RV32 and RV64; // w/o being a pessimization.; // * mulw because c.mulw doesn't exist but c.mul does (w/ zcb); // * slliw because c.slliw doesn't exist and c.slli does; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:46,optimiz,optimizations,46,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,2,['optimiz'],['optimizations']
Performance,"//===- ReduceInstructionFlags.cpp - Specialized Delta Pass ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Try to remove optimization flags on instructions; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceInstructionFlags.cpp:397,optimiz,optimization,397,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceInstructionFlags.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceInstructionFlags.cpp,1,['optimiz'],['optimization']
Performance,"//===- Reg2Mem.cpp - Convert registers to allocas -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file demotes all registers to memory references. It is intended to be; // the inverse of PromoteMemoryToRegister. By converting to loads, the only; // values live across basic blocks are allocas and loads before phi nodes.; // It is intended that this should make CFG hacking much easier.; // To make later hacking easier, the entry block is split into two, such that; // all introduced allocas and nothing else are in the entry block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp:519,load,loads,519,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,2,['load'],['loads']
Performance,"//===- RegAllocBase.h - basic regalloc interface and driver -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegAllocBase class, which is the skeleton of a basic; // register allocation algorithm and interface for extending it. It provides the; // building blocks on which to construct other experimental allocators and test; // the validity of two principles:; //; // - If virtual and physical register liveness is modeled using intervals, then; // on-the-fly interference checking is cheap. Furthermore, interferences can be; // lazily cached and reused.; //; // - Register allocation complexity, and generated code performance is; // determined by the effectiveness of live range splitting rather than optimal; // coloring.; //; // Following the first principle, interfering checking revolves around the; // LiveIntervalUnion data structure.; //; // To fulfill the second principle, the basic allocator provides a driver for; // incremental splitting. It essentially punts on the problem of register; // coloring, instead driving the assignment of virtual to physical registers by; // the cost of splitting. The basic allocator allows for heuristic reassignment; // of registers, if a more sophisticated allocator chooses to do that.; //; // This framework provides a way to engineer the compile time vs. code; // quality trade-off without relying on a particular theoretical solver.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h:834,cache,cached,834,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBase.h,2,"['cache', 'perform']","['cached', 'performance']"
Performance,"//===- RegAllocGreedy.cpp - greedy register allocator ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RAGreedy function pass for register allocation in; // optimized builds.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:459,optimiz,optimized,459,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['optimiz'],['optimized']
Performance,"//===- RegAllocPBQP.cpp ---- PBQP Register Allocator ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a Partitioned Boolean Quadratic Programming (PBQP) based; // register allocator for LLVM. This allocator works by constructing a PBQP; // problem representing the register allocation problem under consideration,; // solving this using a PBQP solver, and mapping the solution back to a; // register assignment. If any variables are selected for spilling then spill; // code is inserted and the process repeated.; //; // The PBQP solver (pbqp.c) provided for this allocator uses a heuristic tuned; // for register allocation. For more information on PBQP for register; // allocation, see the following papers:; //; // (1) Hames, L. and Scholz, B. 2006. Nearly optimal register allocation with; // PBQP. In Proceedings of the 7th Joint Modular Languages Conference; // (JMLC'06). LNCS, vol. 4228. Springer, New York, NY, USA. 346-361.; //; // (2) Scholz, B., Eckstein, E. 2002. Register allocation for irregular; // architectures. In Proceedings of the Joint Conference on Languages,; // Compilers and Tools for Embedded Systems (LCTES'02), ACM Press, New York,; // NY, USA, 139-148.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:891,tune,tuned,891,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,1,['tune'],['tuned']
Performance,"//===- RegAllocScore.cpp - evaluate regalloc policy quality ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// Calculate a measure of the register allocation policy quality. This is used; /// to construct a reward for the training of the ML-driven allocation policy.; /// Currently, the score is the sum of the machine basic block frequency-weighed; /// number of loads, stores, copies, and remat instructions, each factored with; /// a relative weight.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.cpp:633,load,loads,633,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocScore.cpp,1,['load'],['loads']
Performance,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:1000,perform,performing,1000,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,2,"['optimiz', 'perform']","['optimization', 'performing']"
Performance,"//===- RegionPass.cpp - Region Pass and Region Pass Manager ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements RegionPass and RGPassManager. All region optimization; // and transformation passes are derived from RegionPass. RGPassManager is; // responsible for managing RegionPasses.; // Most of this code has been COPIED from LoopPass.cpp; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp:445,optimiz,optimization,445,interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPass.cpp,1,['optimiz'],['optimization']
Performance,"//===- RegionPass.h - RegionPass class --------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegionPass class. All region based analysis,; // optimization and transformation passes are derived from RegionPass.; // This class is implemented following the some ideas of the LoopPass.h class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:454,optimiz,optimization,454,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,1,['optimiz'],['optimization']
Performance,"//===- ReplayInlineAdvisor.cpp - Replay InlineAdvisor ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements ReplayInlineAdvisor that replays inline decisions based; // on previous inline remarks from optimization remark log. This is a best; // effort approach useful for testing compiler/source changes while holding; // inlining steady.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp:496,optimiz,optimization,496,interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ReplayInlineAdvisor.cpp,1,['optimiz'],['optimization']
Performance,"//===- ResourcePriorityQueue.cpp - A DFA-oriented priority queue -*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ResourcePriorityQueue class, which is a; // SchedulingPriorityQueue that prioritizes instructions using DFA state to; // reduce the length of the critical path through the basic block; // on VLIW platforms.; // The scheduler is basically a top-down adaptable list scheduler with DFA; // resource tracking added to the cost function.; // DFA is queried as a state machine to model ""packets/bundles"" during; // schedule. Currently packets/bundles are discarded at the end of; // scheduling, affecting only order of instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp:59,queue,queue,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ResourcePriorityQueue.cpp,1,['queue'],['queue']
Performance,"//===- RewriteStatepointsForGC.cpp - Make GC relocations explicit ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Rewrite call/invoke instructions so as to make potential relocations; // performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:456,perform,performed,456,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['perform'],['performed']
Performance,"//===- RewriteStatepointsForGC.h - ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides interface to ""Rewrite Statepoints for GC"" pass.; //; // This passe rewrites call/invoke instructions so as to make potential; // relocations performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h:543,perform,performed,543,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/RewriteStatepointsForGC.h,1,['perform'],['performed']
Performance,"//===- SIInsertHardClauses.cpp - Insert Hard Clauses ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Insert s_clause instructions to form hard clauses.; ///; /// Clausing load instructions can give cache coherency benefits. Before gfx10,; /// the hardware automatically detected ""soft clauses"", which were sequences of; /// memory instructions of the same type. In gfx10 this detection was removed,; /// and the s_clause instruction was introduced to explicitly mark ""hard; /// clauses"".; ///; /// It's the scheduler's job to form the clauses by putting similar memory; /// instructions next to each other. Our job is just to insert an s_clause; /// instruction to mark the start of each clause.; ///; /// Note that hard clauses are very similar to, but logically distinct from, the; /// groups of instructions that have to be restartable when XNACK is enabled.; /// The rules are slightly different in each case. For example an s_nop; /// instruction breaks a restartable group, but can appear in the middle of a; /// hard clause. (Before gfx10 there wasn't a distinction, and both were called; /// ""soft clauses"" or just ""clauses"".); ///; /// The SIFormMemoryClauses pass and GCNHazardRecognizer deal with restartable; /// groups, not hard clauses.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp:465,load,load,465,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp,2,"['cache', 'load']","['cache', 'load']"
Performance,"//===- SIPeepholeSDWA.cpp - Peephole optimization for SDWA instructions ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This pass tries to apply several peephole SDWA patterns.; ///; /// E.g. original:; /// V_LSHRREV_B32_e32 %0, 16, %1; /// V_ADD_CO_U32_e32 %2, %0, %3; /// V_LSHLREV_B32_e32 %4, 16, %2; ///; /// Replace:; /// V_ADD_CO_U32_sdwa %4, %1, %3; /// dst_sel:WORD_1 dst_unused:UNUSED_PAD src0_sel:WORD_1 src1_sel:DWORD; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp:37,optimiz,optimization,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp,1,['optimiz'],['optimization']
Performance,"//===- SLPVectorizer.cpp - A bottom up SLP Vectorizer ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the Bottom Up SLP vectorizer. It detects consecutive; // stores that can be put together into vector-stores. Next, it attempts to; // construct vectorizable tree using the use-def chains. If a profitable tree; // was found, the SLP vectorizer performs vectorization on the tree.; //; // The pass is inspired by the work described in the paper:; // ""Loop-Aware SLP in GCC"" by Ira Rosen, Dorit Nuzman, Ayal Zaks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:647,perform,performs,647,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['perform'],['performs']
Performance,"//===- SLPVectorizer.h ------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass implements the Bottom Up SLP vectorizer. It detects consecutive; // stores that can be put together into vector-stores. Next, it attempts to; // construct vectorizable tree using the use-def chains. If a profitable tree; // was found, the SLP vectorizer performs vectorization on the tree.; //; // The pass is inspired by the work described in the paper:; // ""Loop-Aware SLP in GCC"" by Ira Rosen, Dorit Nuzman, Ayal Zaks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h:643,perform,performs,643,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/SLPVectorizer.h,1,['perform'],['performs']
Performance,"//===- SPIRVModuleAnalysis.cpp - analysis of global instrs & regs - C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The analysis collects instructions that should be output at the module level; // and performs the global register numbering.; //; // The results of this analysis are used in AsmPrinter to rename registers; // globally and to output required instructions at the module level.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:468,perform,performs,468,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,1,['perform'],['performs']
Performance,"//===- SPIRVModuleAnalysis.h - analysis of global instrs & regs -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The analysis collects instructions that should be output at the module level; // and performs the global register numbering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h:468,perform,performs,468,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.h,1,['perform'],['performs']
Performance,"//===- SROA.cpp - Scalar Replacement Of Aggregates ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This transformation implements the well known scalar replacement of; /// aggregates transformation. It tries to identify promotable elements of an; /// aggregate alloca, and promote them to registers. It will also try to; /// convert uses of an element (or set of elements) of an alloca into a vector; /// or bitfield-style integer scalar if appropriate.; ///; /// It works to do this with minimal slicing of the alloca so that regions; /// which are merely transferred in and out of external memory remain unchanged; /// and are not decomposed to scalar code.; ///; /// Because this also performs alloca promotion, it can be thought of as also; /// serving the purpose of SSA formation. The algorithm iterates on the; /// function until all opportunities for promotion have been realized.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:980,perform,performs,980,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['perform'],['performs']
Performance,"//===- SampleProfile.h - SamplePGO pass ---------- --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides the interface for the sampled PGO loader pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h:448,load,loader,448,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SampleProfile.h,1,['load'],['loader']
Performance,"//===- SampleProfileLoaderBaseUtil.cpp - Profile loader Util func ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the SampleProfileLoader base utility functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp:49,load,loader,49,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,1,['load'],['loader']
Performance,"//===- Scalarizer.cpp - Scalarize vector operations -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass converts vector operations into scalar operations (or, optionally,; // operations on smaller vector widths), in order to expose optimization; // opportunities on the individual scalar operations.; // It is mainly intended for targets that do not have vector units, but it; // may also be useful for revectorizing code to different vector widths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:521,optimiz,optimization,521,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,1,['optimiz'],['optimization']
Performance,"//===- Scalarizer.h --- Scalarize vector operations -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass converts vector operations into scalar operations (or, optionally,; /// operations on smaller vector widths), in order to expose optimization; /// opportunities on the individual scalar operations.; /// It is mainly intended for targets that do not have vector units, but it; /// may also be useful for revectorizing code to different vector widths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Scalarizer.h:534,optimiz,optimization,534,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Scalarizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/Scalarizer.h,1,['optimiz'],['optimization']
Performance,"//===- ScheduleDAGRRList.cpp - Reg pressure reduction list scheduler ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements bottom-up and top-down register pressure reduction list; // schedulers, using standard algorithms. The basic approach uses a priority; // queue of available nodes to schedule. One at a time, nodes are taken from; // the priority queue (thus in priority order), checked for legality to; // schedule, and emitted if legal.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:537,queue,queue,537,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,['queue'],['queue']
Performance,"//===- ScheduleDAGVLIW.cpp - SelectionDAG list scheduler for VLIW -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:492,queue,queue,492,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,2,['queue'],['queue']
Performance,"//===- ScopedHashTable.h - A simple scoped hash table -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements an efficient scoped hash table, which is useful for; // things like dominator-based optimizations. This allows clients to do things; // like this:; //; // ScopedHashTable<int, int> HT;; // {; // ScopedHashTableScope<int, int> Scope1(HT);; // HT.insert(0, 0);; // HT.insert(1, 1);; // {; // ScopedHashTableScope<int, int> Scope2(HT);; // HT.insert(0, 42);; // }; // }; //; // Looking up the value for ""0"" in the Scope2 block will return 42. Looking; // up the value for 0 before 42 is inserted or after Scope2 is popped will; // return 0.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h:488,optimiz,optimizations,488,interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ScopedHashTable.h,1,['optimiz'],['optimizations']
Performance,"//===- ScopedNoAliasAA.cpp - Scoped No-Alias Alias Analysis ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the ScopedNoAlias alias-analysis pass, which implements; // metadata-based scoped no-alias support.; //; // Alias-analysis scopes are defined by an id (which can be a string or some; // other metadata node), a domain node, and an optional descriptive string.; // A domain is defined by an id (which can be a string or some other metadata; // node), and an optional descriptive string.; //; // !dom0 = metadata !{ metadata !""domain of foo()"" }; // !scope1 = metadata !{ metadata !scope1, metadata !dom0, metadata !""scope 1"" }; // !scope2 = metadata !{ metadata !scope2, metadata !dom0, metadata !""scope 2"" }; //; // Loads and stores can be tagged with an alias-analysis scope, and also, with; // a noalias tag for a specific scope:; //; // ... = load %ptr1, !alias.scope !{ !scope1 }; // ... = load %ptr2, !alias.scope !{ !scope1, !scope2 }, !noalias !{ !scope1 }; //; // When evaluating an aliasing query, if one of the instructions is associated; // has a set of noalias scopes in some domain that is a superset of the alias; // scopes in that domain of some other instruction, then the two memory; // accesses are assumed not to alias.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp:1016,Load,Loads,1016,interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScopedNoAliasAA.cpp,3,"['Load', 'load']","['Loads', 'load']"
Performance,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:708,load,load,708,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,4,['load'],['load']
Performance,"//===- SimplifyCFG.cpp - Code to perform CFG simplification ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Peephole optimize the CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:33,perform,perform,33,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"//===- SimplifyCFGOptions.h - Control structure for SimplifyCFG -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A set of parameters used to control the transforms in the SimplifyCFG pass.; // Options may change depending on the position in the optimization pipeline.; // For example, canonical form that includes switches and branches may later be; // replaced by lookup tables and selects.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h:515,optimiz,optimization,515,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyCFGOptions.h,1,['optimiz'],['optimization']
Performance,"//===- SimplifyCFGPass.cpp - CFG Simplification Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead code elimination and basic block merging, along; // with a collection of other peephole control flow optimizations. For example:; //; // * Removes basic blocks with no predecessors.; // * Merges a basic block into its predecessor if there is only one and the; // predecessor only has one successor.; // * Eliminates PHI nodes for basic blocks with a single predecessor.; // * Eliminates a basic block that only contains an unconditional branch.; // * Changes invoke instructions to nounwind functions to be calls.; // * Change things like ""if (x) if (y)"" into ""if (x&y)"".; // * etc..; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:510,optimiz,optimizations,510,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,1,['optimiz'],['optimizations']
Performance,"//===- SimplifyLibCalls.h - Library call simplifier -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes an interface to build some C language libcalls for; // optimization passes that need to call the various functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:456,optimiz,optimization,456,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,1,['optimiz'],['optimization']
Performance,"//===- SourceManager.cpp - Track and cache source files -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the SourceManager interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:37,cache,cache,37,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['cache'],['cache']
Performance,"//===- SourceManager.h - Track and cache source files -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Defines the SourceManager interface.; ///; /// There are three different types of locations in a %file: a spelling; /// location, an expansion location, and a presumed location.; ///; /// Given an example of:; /// \code; /// #define min(x, y) x < y ? x : y; /// \endcode; ///; /// and then later on a use of min:; /// \code; /// #line 17; /// return min(a, b);; /// \endcode; ///; /// The expansion location is the line in the source code where the macro; /// was expanded (the return statement), the spelling location is the; /// location in the source where the macro was originally defined,; /// and the presumed location is where the line directive states that; /// the line is 17, or any other line.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:35,cache,cache,35,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['cache'],['cache']
Performance,"//===- SpeculativeExecution.cpp ---------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDiverg",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:972,optimiz,optimized,972,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,2,['optimiz'],"['optimization', 'optimized']"
Performance,"//===- SpeculativeExecution.h -----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDiverg",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h:972,optimiz,optimized,972,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SpeculativeExecution.h,2,['optimiz'],"['optimization', 'optimized']"
Performance,"//===- SplitModule.cpp - Split a module into partitions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the function llvm::SplitModule, which splits a module; // into multiple linkable partitions. It can be used to implement parallel code; // generation for link-time optimization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp:565,optimiz,optimization,565,interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,1,['optimiz'],['optimization']
Performance,"//===- SplitModule.h - Split a module into partitions -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the function llvm::SplitModule, which splits a module; // into multiple linkable partitions. It can be used to implement parallel code; // generation for link-time optimization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SplitModule.h:565,optimiz,optimization,565,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SplitModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SplitModule.h,1,['optimiz'],['optimization']
Performance,"//===- StackColoring.cpp --------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements the stack-coloring optimization that looks for; // lifetime markers machine instructions (LIFETIME_START and LIFETIME_END),; // which represent the possible lifetime of stack slots. It attempts to; // merge disjoint stack slots and reduce the used stack space.; // NOTE: This pass is not StackSlotColoring, which optimizes spill slots.; //; // TODO: In the future we plan to improve stack coloring in the following ways:; // 1. Allow merging multiple small slots into a single larger slot at different; // offsets.; // 2. Merge this pass with StackSlotColoring and allow merging of allocas with; // spill slots.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:423,optimiz,optimization,423,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,2,['optimiz'],"['optimization', 'optimizes']"
Performance,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:775,optimiz,optimizations,775,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,2,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"//===- SwapByteOrder.h - Generic and optimized byte swaps -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares generic and optimized functions to swap the byte order of; // an integral type.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SwapByteOrder.h:37,optimiz,optimized,37,interpreter/llvm-project/llvm/include/llvm/Support/SwapByteOrder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SwapByteOrder.h,2,['optimiz'],['optimized']
Performance,"//===- SwitchLoweringUtils.cpp - Switch Lowering --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains switch inst lowering optimizations and utilities for; // codegen, so that it can be used for both SelectionDAG and GlobalISel.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:423,optimiz,optimizations,423,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,1,['optimiz'],['optimizations']
Performance,"//===- SymbolRewriter.h - Symbol Rewriting Pass -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the prototypes and definitions related to the Symbol; // Rewriter pass.; //; // The Symbol Rewriter pass takes a set of rewrite descriptors which define; // transformations for symbol names. These can be either single name to name; // trnsformation or more broad regular expression based transformations.; //; // All the functions are re-written at the IR level. The Symbol Rewriter itself; // is exposed as a module level pass. All symbols at the module level are; // iterated. For any matching symbol, the requested transformation is applied,; // updating references to it as well (a la RAUW). The resulting binary will; // only contain the rewritten symbols.; //; // By performing this operation in the compiler, we are able to catch symbols; // that would otherwise not be possible to catch (e.g. inlined symbols).; //; // This makes it possible to cleanly transform symbols without resorting to; // overly-complex macro tricks and the pre-processor. An example of where this; // is useful is the sanitizers where we would like to intercept a well-defined; // set of functions across the module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h:1075,perform,performing,1075,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SymbolRewriter.h,1,['perform'],['performing']
Performance,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:58,Load,Loads,58,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,2,['Load'],['Loads']
Performance,"//===- Target/X86/X86LowerAMXType.cpp - -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Pass to transform <256 x i32> load/store; /// <256 x i32> is bitcasted to x86_amx on X86, and AMX instruction set only; /// provides simple operation on x86_amx. The basic elementwise operation; /// is not supported by AMX. Since x86_amx is bitcasted from vector <256 x i32>; /// and only AMX intrinsics can operate on the type, we need transform; /// load/store <256 x i32> instruction to AMX load/store. If the bitcast can; /// not be combined with load/store, we transform the bitcast to amx load/store; /// and <256 x i32> store/load.; ///; /// If Front End not use O0 but the Mid/Back end use O0, (e.g. ""Clang -O2 -S; /// -emit-llvm t.c"" + ""llc t.ll"") we should make sure the amx data is volatile,; /// because that is necessary for AMX fast register allocation. (In Fast; /// registera allocation, register will be allocated before spill/reload, so; /// there is no additional register for amx to identify the step in spill.); /// The volatileTileData() will handle this case.; /// e.g.; /// ----------------------------------------------------------; /// | def %td = ... |; /// | ... |; /// | ""use %td"" |; /// ----------------------------------------------------------; /// will transfer to -->; /// ----------------------------------------------------------; /// | def %td = ... |; /// | call void @llvm.x86.tilestored64.internal(mem, %td) |; /// | ... |; /// | %td2 = call x86_amx @llvm.x86.tileloadd64.internal(mem)|; /// | ""use %td2"" |; /// ----------------------------------------------------------; //; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:420,load,load,420,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,6,['load'],['load']
Performance,"//===- TensorSpec.cpp - tensor type abstraction ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implementation file for the abstraction of a tensor type, and JSON loading; // utils.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp:450,load,loading,450,interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TensorSpec.cpp,1,['load'],['loading']
Performance,"//===- Trace.cpp - Implementation of Trace class --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class represents a single trace of LLVM basic blocks. A trace is a; // single entry, multiple exit, region of code that is often hot. Trace-based; // optimizations treat traces almost like they are a large, strange, basic; // block: because the trace path is assumed to be hot, optimizations for the; // fall-through path are made at the expense of the non-fall-through paths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp:538,optimiz,optimizations,538,interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Trace.cpp,2,['optimiz'],['optimizations']
Performance,"//===- Trace.cpp - XRay Trace Loading implementation. ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // XRay log reader implementation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp:30,Load,Loading,30,interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/XRay/Trace.cpp,1,['Load'],['Loading']
Performance,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:991,optimiz,optimizations,991,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,1,['optimiz'],['optimizations']
Performance,"//===- Transform/Utils/BasicBlockUtils.h - BasicBlock Utils -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform manipulations on basic blocks, and; // instructions contained within basic blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:408,perform,perform,408,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,1,['perform'],['perform']
Performance,"//===- TruncInstCombine.cpp -----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TruncInstCombine - looks for expression graphs post-dominated by TruncInst; // and for each eligible graph, it will create a reduced bit-width expression,; // replace the old expression with this new one and remove the old expression.; // Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width.; // 4. All instructions in the graph must not have users outside the graph.; // The only exception is for {ZExt, SExt}Inst with operand type equal to; // the new reduced type evaluated in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:1071,optimiz,optimization,1071,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,2,['optimiz'],['optimization']
Performance,"//===- TypeSize.h - Wrapper around type sizes -------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides a struct that can be used to query the size of IR types; // which may be scalable vectors. It provides convenience operators so that; // it can be used in much the same way as a single scalar value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h:475,scalab,scalable,475,interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,1,['scalab'],['scalable']
Performance,"//===- VNCoercion.h - Value Numbering Coercion Utilities --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file / This file provides routines used by LLVM's value numbering passes to; /// perform various forms of value extraction from memory when the types are not; /// identical. For example, given; ///; /// store i32 8, i32 *%foo; /// %a = bitcast i32 *%foo to i16; /// %val = load i16, i16 *%a; ///; /// It possible to extract the value of the load of %a from the store to %foo.; /// These routines know how to tell whether they can do that (the analyze*; /// routines), and can also insert the necessary IR to do it (the get*; /// routines).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:462,perform,perform,462,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,3,"['load', 'perform']","['load', 'perform']"
Performance,"//===- VPlan.cpp - Vectorizer Plan ----------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is the LLVM vectorization plan. It represents a candidate for; /// vectorization, allowing to plan and optimize how to vectorize a given loop; /// before generating LLVM-IR.; /// The vectorizer uses vectorization plans to estimate the costs of potential; /// candidates and if profitable to execute the desired plan, generating vector; /// LLVM-IR code.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp:504,optimiz,optimize,504,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.cpp,1,['optimiz'],['optimize']
Performance,"//===- WarnMissedTransforms.h -----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Emit warnings if forced code transformations have not been performed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/WarnMissedTransforms.h:442,perform,performed,442,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/WarnMissedTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/WarnMissedTransforms.h,1,['perform'],['performed']
Performance,"//===- WholeProgramDevirt.cpp - Whole program virtual call optimization ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements whole program optimization of virtual calls in cases; // where we know (via !type metadata) that the list of callees is fixed. This; // includes the following:; // - Single implementation devirtualization: if a virtual call has a single; // possible callee, replace all calls with a direct call to that callee.; // - Virtual constant propagation: if the virtual function's return type is an; // integer <=64 bits and all possible callees are readnone, for each class and; // each list of constant arguments: evaluate the function, store the return; // value alongside the virtual table, and rewrite each virtual call as a load; // from the virtual table.; // - Uniform return value optimization: if the conditions for virtual constant; // propagation hold and each function returns the same constant value, replace; // each virtual call with that constant.; // - Unique return value optimization for i1 return values: if the conditions; // for virtual constant propagation hold and a single vtable's function; // returns 0, or a single vtable's function returns 1, replace each virtual; // call with a comparison of the vptr against that vtable's address.; //; // This pass is intended to be used during the regular and thin LTO pipelines:; //; // During regular LTO, the pass determines the best optimization for each; // virtual call and applies the resolutions directly to virtual calls that are; // eligible for virtual call optimization (i.e. calls that use either of the; // llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics).; //; // During hybrid Regular/ThinLTO, the pass o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:59,optimiz,optimization,59,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,3,"['load', 'optimiz']","['load', 'optimization']"
Performance,"//===- X86AvoidStoreForwardingBlocks.cpp - Avoid HW Store Forward Block ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // If a load follows a store and reloads data that the store has written to; // memory, Intel microarchitectures can in many cases forward the data directly; // from the store to the load, This ""store forwarding"" saves cycles by enabling; // the load to directly obtain the data instead of accessing the data from; // cache or memory.; // A ""store forward block"" occurs in cases that a store cannot be forwarded to; // the load. The most typical case of store forward block on Intel Core; // microarchitecture that a small store cannot be forwarded to a large load.; // The estimated penalty for a store forward block is ~13 cycles.; //; // This pass tries to recognize and handle cases where ""store forward block""; // is created by the compiler when lowering memcpy calls to a sequence; // of a load and a store.; //; // The pass currently only handles cases where memcpy is lowered to; // XMM/YMM registers, it tries to break the memcpy into smaller copies.; // breaking the memcpy should be possible since there is no atomicity; // guarantee for loads and stores to XMM/YMM.; //; // It could be better for performance to solve the problem by loading; // to XMM/YMM then inserting the partial store before storing back from XMM/YMM; // to memory, but this will result in a more conservative optimization since it; // requires we prove that all memory accesses between the blocking store and the; // load must alias/don't alias before we can move the store, whereas the; // transformation done here is correct regardless to other memory accesses.; //===-------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:388,load,load,388,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,6,"['cache', 'load']","['cache', 'load']"
Performance,"//===- X86CompressEVEX.cpp ------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass compresses instructions from EVEX space to legacy/VEX/EVEX space; // when possible in order to reduce code size or facilitate HW decoding.; //; // Possible compression:; // a. AVX512 instruction (EVEX) -> AVX instruction (VEX); // b. Promoted instruction (EVEX) -> pre-promotion instruction (legacy/VEX); // c. NDD (EVEX) -> non-NDD (legacy); // d. NF_ND (EVEX) -> NF (EVEX); //; // Compression a, b and c can always reduce code size, with some exceptions; // such as promoted 16-bit CRC32 which is as long as the legacy version.; //; // legacy:; // crc32w %si, %eax ## encoding: [0x66,0xf2,0x0f,0x38,0xf1,0xc6]; // promoted:; // crc32w %si, %eax ## encoding: [0x62,0xf4,0x7d,0x08,0xf1,0xc6]; //; // From performance perspective, these should be same (same uops and same EXE; // ports). From a FMV perspective, an older legacy encoding is preferred b/c it; // can execute in more places (broader HW install base). So we will still do; // the compression.; //; // Compression d can help hardware decode (HW may skip reading the NDD; // register) although the instruction length remains unchanged.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp:1098,perform,performance,1098,interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CompressEVEX.cpp,1,['perform'],['performance']
Performance,"//===- X86DiscriminateMemOps.cpp - Unique IDs for Mem Ops -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This pass aids profile-driven cache prefetch insertion by ensuring all; /// instructions that have a memory operand are distinguishible from each other.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp:415,cache,cache,415,interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp,1,['cache'],['cache']
Performance,"//===- X86InterleavedAccess.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains the X86 implementation of the interleaved accesses; /// optimization generating X86-specific instructions/intrinsics for; /// interleaved access groups.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:470,optimiz,optimization,470,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,1,['optimiz'],['optimization']
Performance,"//===- X86OptimizeLEAs.cpp - optimize usage of LEA instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass that performs some optimizations with LEA; // instructions in order to improve performance and code size.; // Currently, it does two things:; // 1) If there are two LEA instructions calculating addresses which only differ; // by displacement inside a basic block, one of them is removed.; // 2) Address calculations in load and store instructions are replaced by; // existing LEA def registers where possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:29,optimiz,optimize,29,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,5,"['load', 'optimiz', 'perform']","['load', 'optimizations', 'optimize', 'performance', 'performs']"
Performance,"//===- X86VZeroUpper.cpp - AVX vzeroupper instruction inserter ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass which inserts x86 AVX vzeroupper instructions; // before calls to SSE encoded functions. This avoids transition latency; // penalty when transferring control between AVX encoded instructions and old; // SSE encoding mode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86VZeroUpper.cpp:522,latency,latency,522,interpreter/llvm-project/llvm/lib/Target/X86/X86VZeroUpper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86VZeroUpper.cpp,1,['latency'],['latency']
Performance,"//===- lib/CodeGen/GlobalISel/LegalizerPredicates.cpp - Predicates --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A library of predicate factories to use for LegalityPredicate.; //; //===----------------------------------------------------------------------===//; // Enable optimizations to work around MSVC debug mode bug in 32-bit:; // https://developercommunity.visualstudio.com/content/problem/1179643/msvc-copies-overaligned-non-trivially-copyable-par.html; // FIXME: Remove this when the issue is closed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp:543,optimiz,optimizations,543,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalityPredicates.cpp,1,['optimiz'],['optimizations']
Performance,"//===- lib/Passes/PassPluginLoader.cpp - Load Plugins for New PM Passes ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassPlugin.cpp:41,Load,Load,41,interpreter/llvm-project/llvm/lib/Passes/PassPlugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassPlugin.cpp,1,['Load'],['Load']
Performance,"//===- lib/Transforms/Utils/FunctionImportUtils.cpp - Importing utilities -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the FunctionImportGlobalProcessing class, used; // to perform the necessary global value handling for function importing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:458,perform,perform,458,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,1,['perform'],['perform']
Performance,"//===- llvm-lto: a simple command-line program to link modules with LTO ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program takes in a list of bitcode files, links them, performs link-time; // optimization, and outputs an object file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:442,perform,performs,442,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,2,"['optimiz', 'perform']","['optimization', 'performs']"
Performance,"//===- llvm/ADT/CachedHashString.h - Prehashed string/StringRef -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines CachedHashString and CachedHashStringRef. These are; /// owning and not-owning string types that store their hash in addition to; /// their string data.; ///; /// Unlike std::string, CachedHashString can be used in DenseSet/DenseMap; /// (because, unlike std::string, CachedHashString lets us have empty and; /// tombstone values).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:16,Cache,CachedHashString,16,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,5,['Cache'],"['CachedHashString', 'CachedHashStringRef']"
Performance,"//===- llvm/ADT/PriorityQueue.h - Priority queues ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the PriorityQueue class.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h:43,queue,queues,43,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityQueue.h,1,['queue'],['queues']
Performance,"//===- llvm/ADT/SetVector.h - Set with insert order iteration ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a set that has insertion order iteration; /// characteristics. This is useful for keeping a set of things that need to be; /// visited later but in a deterministic order (insertion order). The interface; /// is purposefully minimal.; ///; /// This file defines SetVector and SmallSetVector, which performs no; /// allocations if the SetVector has less than a certain number of elements.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:714,perform,performs,714,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,1,['perform'],['performs']
Performance,"//===- llvm/Analysis/AssumptionCache.h - Track @llvm.assume -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that keeps track of @llvm.assume intrinsics in; // the functions of a module (allowing assumptions within any function to be; // found cheaply by other parts of the optimizer).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:574,optimiz,optimizer,574,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['optimiz'],['optimizer']
Performance,"//===- llvm/Analysis/DomConditionCache.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Cache for branch conditions that affect a certain value for use by; // ValueTracking. Unlike AssumptionCache, this class does not perform any; // automatic analysis or invalidation. The caller is responsible for registering; // all relevant branches (and re-registering them if they change), and for; // removing invalidated values from the cache.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:383,Cache,Cache,383,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,3,"['Cache', 'cache', 'perform']","['Cache', 'cache', 'perform']"
Performance,"//===- llvm/Analysis/LoopCacheAnalysis.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interface for the loop cache analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:441,cache,cache,441,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['cache'],['cache']
Performance,"//===- llvm/Analysis/LoopUnrollAnalyzer.h - Loop Unroll Analyzer-*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements UnrolledInstAnalyzer class. It's used for predicting; // potential effects that loop unrolling might have, such as enabling constant; // propagation and other optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:563,optimiz,optimizations,563,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,1,['optimiz'],['optimizations']
Performance,"//===- llvm/Analysis/Trace.h - Represent one trace of LLVM code -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class represents a single trace of LLVM basic blocks. A trace is a; // single entry, multiple exit, region of code that is often hot. Trace-based; // optimizations treat traces almost like they are a large, strange, basic; // block: because the trace path is assumed to be hot, optimizations for the; // fall-through path are made at the expense of the non-fall-through paths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h:538,optimiz,optimizations,538,interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h,2,['optimiz'],['optimizations']
Performance,"//===- llvm/Analysis/WithCache.h - KnownBits cache for pointers -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Store a pointer to any type along with the KnownBits information for it; // that is computed lazily (if required).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/WithCache.h:45,cache,cache,45,interpreter/llvm-project/llvm/include/llvm/Analysis/WithCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/WithCache.h,1,['cache'],['cache']
Performance,"//===- llvm/CodeGen/SlotIndexes.h - Slot indexes representation -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements SlotIndex and related classes. The purpose of SlotIndex; // is to describe a position at which a register can become live, or cease to; // be live.; //; // SlotIndex is mostly a proxy for entries of the SlotIndexList, a class which; // is held is LiveIntervals and provides the real numbering. This allows; // LiveIntervals to perform largely transparent renumbering.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h:731,perform,perform,731,interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SlotIndexes.h,1,['perform'],['perform']
Performance,"//===- llvm/DataLayout.h - Data size & alignment info -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines layout properties related to datatype size/offset/alignment; // information. It uses lazy annotations to cache information about how; // structure types are laid out and used.; //; // This structure should be created once, filled in if the defaults are not; // correct and then passed around by const&. None of the members functions; // require modification to the object.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:506,cache,cache,506,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,1,['cache'],['cache']
Performance,"//===- llvm/IR/OptBisect.h - LLVM Bisect support ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file declares the interface for bisecting optimizations.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h:443,optimiz,optimizations,443,interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,1,['optimiz'],['optimizations']
Performance,"//===- llvm/IR/OptBisect/Bisect.cpp - LLVM Bisect support -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements support for a bisecting optimizations based on a; /// command line option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/OptBisect.cpp:440,optimiz,optimizations,440,interpreter/llvm-project/llvm/lib/IR/OptBisect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/OptBisect.cpp,1,['optimiz'],['optimizations']
Performance,"//===- llvm/Pass.h - Base class for Passes ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a base class that indicates that a specified class is a; // transformation pass implementation.; //; // Passes are designed this way so that it is possible to run passes in a cache; // and organizationally optimal order without having to specify it at the front; // end. This allows arbitrary passes to be strung together and have them; // executed as efficiently as possible.; //; // Passes should extend one of the classes below, depending on the guarantees; // that it can make about what will be modified as it is run. For example, most; // global optimizations should derive from FunctionPass, because they do not add; // or delete functions, they operate on the internals of the function.; //; // Note that this file #includes PassSupport.h and PassAnalysisSupport.h (at the; // bottom), so the APIs exposed by these files are also automatically available; // to all users of this file.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:576,cache,cache,576,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,2,"['cache', 'optimiz']","['cache', 'optimizations']"
Performance,"//===- llvm/Support/DivisionByConstantInfo.h ---------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This file implements support for optimizing divisions by a constant; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DivisionByConstantInfo.h:418,optimiz,optimizing,418,interpreter/llvm-project/llvm/include/llvm/Support/DivisionByConstantInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DivisionByConstantInfo.h,1,['optimiz'],['optimizing']
Performance,"//===- llvm/Transforms/Utils/BypassSlowDivision.h ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an optimization for div and rem on architectures that; // execute short instructions significantly faster than longer instructions.; // For example, on Intel Atom 32-bit divides are slow enough that during; // runtime it is profitable to check the value of the operands, and if they are; // positive and less than 256 use an unsigned 8-bit divide.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h:405,optimiz,optimization,405,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BypassSlowDivision.h,1,['optimiz'],['optimization']
Performance,"//===- llvm/Transforms/Utils/IntegerDivision.h ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an implementation of 32bit and 64bit scalar integer; // division for targets that don't have native support. It's largely derived; // from compiler-rt's implementations of __udivsi3 and __udivmoddi4,; // but hand-tuned for targets that prefer less control flow.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/IntegerDivision.h:615,tune,tuned,615,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/IntegerDivision.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/IntegerDivision.h,1,['tune'],['tuned']
Performance,"//===- llvm/Transforms/Utils/SizeOpts.h - size optimization -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared code size optimization related code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h:47,optimiz,optimization,47,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SizeOpts.h,2,['optimiz'],['optimization']
Performance,"//===- llvm/Transforms/Utils/UnrollLoop.h - Unrolling utilities -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines some loop unrolling utilities. It does not define any; // actual pass or policy, but provides a single function to perform loop; // unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h:516,perform,perform,516,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/UnrollLoop.h,1,['perform'],['perform']
Performance,"//===- opt.cpp - The LLVM Modular Optimizer -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimizations may be specified an arbitrary number of times on the command; // line, They are run in the order specified.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt/opt.cpp:34,Optimiz,Optimizer,34,interpreter/llvm-project/llvm/tools/opt/opt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/opt/opt.cpp,2,['Optimiz'],"['Optimizations', 'Optimizer']"
Performance,"//===- verify-uselistorder.cpp - The LLVM Modular Optimizer ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Verify that use-list order can be serialized correctly. After reading the; // provided IR, this tool shuffles the use-lists and then writes and reads to a; // separate Module whose use-list orders are compared to the original.; //; // The shuffles are deterministic, but guarantee that use-lists will change.; // The algorithm per iteration is as follows:; //; // 1. Seed the random number generator. The seed is different for each; // shuffle. Shuffle 0 uses default+0, shuffle 1 uses default+1, and so on.; //; // 2. Visit every Value in a deterministic order.; //; // 3. Assign a random number to each Use in the Value's use-list in order.; //; // 4. If the numbers are already in order, reassign numbers until they aren't.; //; // 5. Sort the use-list using Value::sortUseList(), which is a stable sort.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/verify-uselistorder/verify-uselistorder.cpp:50,Optimiz,Optimizer,50,interpreter/llvm-project/llvm/tools/verify-uselistorder/verify-uselistorder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/verify-uselistorder/verify-uselistorder.cpp,1,['Optimiz'],['Optimizer']
Performance,"//===- xray-account.h - XRay Function Call Accounting ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for performing some basic function call; // accounting from an XRay trace.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-account.h:419,perform,performing,419,interpreter/llvm-project/llvm/tools/llvm-xray/xray-account.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-account.h,1,['perform'],['performing']
Performance,"//===-- AArch64A53Fix835769.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This pass changes code to work around Cortex-A53 erratum 835769.; // It works around it by inserting a nop instruction in code sequences that; // in some circumstances may trigger the erratum.; // It inserts a nop instruction between a sequence of the following 2 classes; // of instructions:; // instr 1: mem-instr (including loads, stores and prefetches).; // instr 2: non-SIMD integer multiply-accumulate writing 64-bit X registers.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A53Fix835769.cpp:706,load,loads,706,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A53Fix835769.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A53Fix835769.cpp,1,['load'],['loads']
Performance,"//===-- AArch64A57FPLoadBalancing.cpp - Balance FP ops statically on A57---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // For best-case performance on Cortex-A57, we should try to use a balanced; // mix of odd and even D-registers when performing a critical sequence of; // independent, non-quadword FP/ASIMD floating-point multiply or; // multiply-accumulate operations.; //; // This pass attempts to detect situations where the register allocation may; // adversely affect this load balancing and to change the registers used so as; // to better utilize the CPU.; //; // Ideally we'd just take each multiply or multiply-accumulate in turn and; // allocate it alternating even or odd registers. However, multiply-accumulates; // are most efficiently performed in the same functional unit as their; // accumulation operand. Therefore this pass tries to find maximal sequences; // (""Chains"") of multiply-accumulates linked via their accumulation operand,; // and assign them all the same ""color"" (oddness/evenness).; //; // This optimization affects S-register and D-register floating point; // multiplies and FMADD/FMAs, as well as vector (floating point only) muls and; // FMADD/FMA. Q register instructions (and 128-bit vector instructions) are; // not affected.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:393,perform,performance,393,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,5,"['load', 'optimiz', 'perform']","['load', 'optimization', 'performance', 'performed', 'performing']"
Performance,"//===-- AArch64AdvSIMDScalar.cpp - Replace dead defs w/ zero reg --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // When profitable, replace GPR targeting i64 instructions with their; // AdvSIMD scalar equivalents. Generally speaking, ""profitable"" is defined; // as minimizing the number of cross-class register copies.; //===----------------------------------------------------------------------===//; //===----------------------------------------------------------------------===//; // TODO: Graph based predicate heuristics.; // Walking the instruction list linearly will get many, perhaps most, of; // the cases, but to do a truly thorough job of this, we need a more; // wholistic approach.; //; // This optimization is very similar in spirit to the register allocator's; // spill placement, only here we're determining where to place cross-class; // register copies rather than spills. As such, a similar approach is; // called for.; //; // We want to build up a set of graphs of all instructions which are candidates; // for transformation along with instructions which generate their inputs and; // consume their outputs. For each edge in the graph, we assign a weight; // based on whether there is a copy required there (weight zero if not) and; // the block frequency of the block containing the defining or using; // instruction, whichever is less. Our optimization is then a graph problem; // to minimize the total weight of all the graphs, then transform instructions; // and add or remove copy instructions as called for to implement the; // solution.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AdvSIMDScalarPass.cpp:964,optimiz,optimization,964,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AdvSIMDScalarPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AdvSIMDScalarPass.cpp,2,['optimiz'],['optimization']
Performance,"//===-- AArch64CleanupLocalDynamicTLSPass.cpp ---------------------*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Local-dynamic access to thread-local variables proceeds in three stages.; //; // 1. The offset of this Module's thread-local area from TPIDR_EL0 is calculated; // in much the same way as a general-dynamic TLS-descriptor access against; // the special symbol _TLS_MODULE_BASE.; // 2. The variable's offset from _TLS_MODULE_BASE_ is calculated using; // instructions with ""dtprel"" modifiers.; // 3. These two are added, together with TPIDR_EL0, to obtain the variable's; // true address.; //; // This is only better than general-dynamic access to the variable if two or; // more of the first stage TLS-descriptor calculations can be combined. This; // pass looks through a function and performs such combinations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CleanupLocalDynamicTLSPass.cpp:1067,perform,performs,1067,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CleanupLocalDynamicTLSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CleanupLocalDynamicTLSPass.cpp,1,['perform'],['performs']
Performance,"//===-- AArch64PBQPRegAlloc.cpp - AArch64 specific PBQP constraints -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file contains the AArch64 / Cortex-A57 specific register allocation; // constraints for use by the PBQP register allocator.; //; // It is essentially a transcription of what is contained in; // AArch64A57FPLoadBalancing, which tries to use a balanced; // mix of odd and even D-registers when performing a critical sequence of; // independent, non-quadword FP/ASIMD floating-point multiply-accumulates.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PBQPRegAlloc.cpp:676,perform,performing,676,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PBQPRegAlloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PBQPRegAlloc.cpp,1,['perform'],['performing']
Performance,"//===-- AMDGPUAtomicOptimizer.cpp -----------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass optimizes atomic operations by using a single lane of a wavefront; /// to perform the atomic operation, thus reducing contention on that memory; /// location.; /// Atomic optimizer uses following strategies to compute scan and reduced; /// values; /// 1. DPP -; /// This is the most efficient implementation for scan. DPP uses Whole Wave; /// Mode (WWM); /// 2. Iterative -; // An alternative implementation iterates over all active lanes; /// of Wavefront using llvm.cttz and performs scan using readlane & writelane; /// intrinsics; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp:405,optimiz,optimizes,405,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAtomicOptimizer.cpp,4,"['optimiz', 'perform']","['optimizer', 'optimizes', 'perform', 'performs']"
Performance,"//===-- AMDGPUCodeGenPrepare.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass does misc. AMDGPU optimizations on IR *just* before instruction; /// selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULateCodeGenPrepare.cpp:423,optimiz,optimizations,423,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULateCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULateCodeGenPrepare.cpp,1,['optimiz'],['optimizations']
Performance,"//===-- AMDGPUCodeGenPrepare.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass does misc. AMDGPU optimizations on IR before instruction; /// selection.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:423,optimiz,optimizations,423,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['optimiz'],['optimizations']
Performance,"//===-- AMDGPULowerKernelArguments.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This pass replaces accesses to kernel arguments with loads from; /// offsets from the kernarg base pointer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp:449,load,loads,449,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,1,['load'],['loads']
Performance,"//===-- AMDGPULowerKernelAttributes.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This pass does attempts to make use of reqd_work_group_size metadata; /// to eliminate loads from the dispatch packet and to constant fold OpenCL; /// get_local_size-like functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelAttributes.cpp:484,load,loads,484,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelAttributes.cpp,1,['load'],['loads']
Performance,"//===-- AMDGPULowerModuleLDSPass.cpp ------------------------------*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass eliminates local data store, LDS, uses from non-kernel functions.; // LDS is contiguous memory allocated per kernel execution.; //; // Background.; //; // The programming model is global variables, or equivalently function local; // static variables, accessible from kernels or other functions. For uses from; // kernels this is straightforward - assign an integer to the kernel for the; // memory required by all the variables combined, allocate them within that.; // For uses from functions there are performance tradeoffs to choose between.; //; // This model means the GPU runtime can specify the amount of memory allocated.; // If this is more than the kernel assumed, the excess can be made available; // using a language specific feature, which IR represents as a variable with; // no initializer. This feature is referred to here as ""Dynamic LDS"" and is; // lowered slightly differently to the normal case.; //; // Consequences of this GPU feature:; // - memory is limited and exceeding it halts compilation; // - a global accessed by one kernel exists independent of other kernels; // - a global exists independent of simultaneous execution of the same kernel; // - the address of the global may be different from different kernels as they; // do not alias, which permits only allocating variables they use; // - if the address is allowed to differ, functions need help to find it; //; // Uses from kernels are implemented here by grouping them in a per-kernel; // struct instance. This duplicates the variables, accurately modelling their; // aliasing properties relative to a single global represe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:896,perform,performance,896,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['perform'],['performance']
Performance,"//===-- AMDGPUMarkLastScratchLoad.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Mark scratch load/spill instructions which are guaranteed to be the last time; // this scratch slot is used so it can be evicted from caches.; //; // TODO: Handle general stack accesses not just spilling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMarkLastScratchLoad.cpp:396,load,load,396,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMarkLastScratchLoad.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMarkLastScratchLoad.cpp,2,"['cache', 'load']","['caches', 'load']"
Performance,"//===-- AMDGPUPromoteKernelArguments.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This pass recursively promotes generic pointer arguments of a kernel; /// into the global address space.; ///; /// The pass walks kernel's pointer arguments, then loads from them. If a loaded; /// value is a pointer and loaded pointer is unmodified in the kernel before the; /// load, then promote loaded pointer to global. Then recursively continue.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteKernelArguments.cpp:553,load,loads,553,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteKernelArguments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteKernelArguments.cpp,5,['load'],"['load', 'loaded', 'loads']"
Performance,"//===-- ARMExpandPseudoInsts.cpp - Expand pseudo instructions -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:533,optimiz,optimizations,533,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,1,['optimiz'],['optimizations']
Performance,"//===-- Analysis/CFG.h - BasicBlock Analyses --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions performs analyses on basic blocks, and instructions; // contained within basic blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:408,perform,performs,408,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,1,['perform'],['performs']
Performance,"//===-- BenchmarkRunner.h ---------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the abstract BenchmarkRunner class for measuring a certain execution; /// property of instructions (e.g. latency).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h:509,latency,latency,509,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.h,1,['latency'],['latency']
Performance,"//===-- Bitcode/Reader/MetadataLoader.h - Load Metadatas -------*- C++ -*-====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class handles loading Metadatas.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:42,Load,Load,42,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,2,"['Load', 'load']","['Load', 'loading']"
Performance,"//===-- BlockInCriticalSectionChecker.cpp -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines a checker for blocks in critical sections. This checker should find; // the calls to blocking functions (for example: sleep, getc, fgets, read,; // recv etc.) inside a critical section. When sleep(x) is called while a mutex; // is held, other threades cannot lock the same mutex. This might take some; // time, leading to bad performance or even deadlock.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp:717,perform,performance,717,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BlockInCriticalSectionChecker.cpp,1,['perform'],['performance']
Performance,"//===-- CFG.cpp - BasicBlock analysis --------------------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions performs analyses on basic blocks, and instructions; // contained within basic blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp:408,perform,performs,408,interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CFG.cpp,1,['perform'],['performs']
Performance,"//===-- CodeGenTBAA.cpp - TBAA information for LLVM CodeGen ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the code that manages TBAA information and defines the TBAA policy; // for the optimizer to use. Relevant standards text includes:; //; // C99 6.5p7; // C++ [basic.lval] (p10 in n3126, p15 in some earlier versions); //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp:470,optimiz,optimizer,470,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,1,['optimiz'],['optimizer']
Performance,"//===-- DereferenceChecker.cpp - Null dereference checker -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines NullDerefChecker, a builtin check in ExprEngine that performs; // checks for null pointers at loads and stores.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:449,perform,performs,449,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,2,"['load', 'perform']","['loads', 'performs']"
Performance,"//===-- DynamicLibrary.cpp - Runtime link/load libraries --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the operating system DynamicLibrary concept.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DynamicLibrary.cpp:42,load,load,42,interpreter/llvm-project/llvm/lib/Support/DynamicLibrary.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DynamicLibrary.cpp,1,['load'],['load']
Performance,"//===-- EmbedBitcodePass.h - Embeds bitcode into global ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides a pass which clones the current module and runs the; /// provided pass pipeline on the clone. The optimized module is stored into a; /// global variable in the `.llvm.lto` section. Primarily, this pass is used; /// to support the FatLTO pipeline, but could be used to generate a bitcode; /// section for any arbitrary pass pipeline without changing the current module.; ///; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/EmbedBitcodePass.h:513,optimiz,optimized,513,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/EmbedBitcodePass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/EmbedBitcodePass.h,1,['optimiz'],['optimized']
Performance,"//===-- ExecutionEngine.cpp - Common Implementation shared by EEs ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the common interface used by the various execution engine; // subclasses.; //; // FIXME: This file needs to be updated to support scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:531,scalab,scalable,531,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,1,['scalab'],['scalable']
Performance,"//===-- FindBugs.cpp - Run Many Different Optimizations -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an interface that allows bugpoint to choose different; // combinations of optimizations to run on the selected input. Bugpoint will; // run these optimizations and record the success/failure of each. This way; // we can hopefully spot bugs in the optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp:42,Optimiz,Optimizations,42,interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/FindBugs.cpp,4,"['Optimiz', 'optimiz']","['Optimizations', 'optimizations']"
Performance,"//===-- GuardUtils.cpp - Utils for work with guards -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Utils that are used to perform analyzes related to guards and their; // conditions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GuardUtils.cpp:402,perform,perform,402,interpreter/llvm-project/llvm/lib/Analysis/GuardUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GuardUtils.cpp,1,['perform'],['perform']
Performance,"//===-- GuardUtils.cpp - Utils for work with guards -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Utils that are used to perform transformations related to guards and their; // conditions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GuardUtils.cpp:402,perform,perform,402,interpreter/llvm-project/llvm/lib/Transforms/Utils/GuardUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GuardUtils.cpp,1,['perform'],['perform']
Performance,"//===-- GuardUtils.h - Utils for work with guards ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Utils that are used to perform analyzes related to guards and their; // conditions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GuardUtils.h:402,perform,perform,402,interpreter/llvm-project/llvm/include/llvm/Analysis/GuardUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GuardUtils.h,1,['perform'],['perform']
Performance,"//===-- GuardUtils.h - Utils for work with guards ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Utils that are used to perform transformations related to guards and their; // conditions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GuardUtils.h:402,perform,perform,402,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GuardUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GuardUtils.h,1,['perform'],['perform']
Performance,"//===-- HexagonPeephole.cpp - Hexagon Peephole Optimiztions ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; // This peephole pass optimizes in the following cases.; // 1. Optimizes redundant sign extends for the following case; // Transform the following pattern; // %170 = SXTW %166; // ...; // %176 = COPY %170:isub_lo; //; // Into; // %176 = COPY %166; //; // 2. Optimizes redundant negation of predicates.; // %15 = CMPGTrr %6, %2; // ...; // %16 = NOT_p killed %15; // ...; // JMP_c killed %16, <%bb.1>, implicit dead %pc; //; // Into; // %15 = CMPGTrr %6, %2;; // ...; // JMP_cNot killed %15, <%bb.1>, implicit dead %pc;; //; // Note: The peephole pass makes the instrucstions like; // %170 = SXTW %166 or %16 = NOT_p killed %15; // redundant and relies on some form of dead removal instructions, like; // DCE or DIE to actually eliminate them.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp:47,Optimiz,Optimiztions,47,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonPeephole.cpp,4,"['Optimiz', 'optimiz']","['Optimizes', 'Optimiztions', 'optimizes']"
Performance,"//===-- HexagonVectorCombine.cpp ------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // HexagonVectorCombine is a utility class implementing a variety of functions; // that assist in vector-based optimizations.; //; // AlignVectors: replace unaligned vector loads and stores with aligned ones.; // HvxIdioms: recognize various opportunities to generate HVX intrinsic code.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:487,optimiz,optimizations,487,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,2,"['load', 'optimiz']","['loads', 'optimizations']"
Performance,"//===-- IPO/OpenMPOpt.cpp - Collection of OpenMP specific optimizations ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // OpenMP specific optimizations:; //; // - Deduplication of runtime calls, e.g., omp_get_thread_num.; // - Replacing globalized device memory with stack memory.; // - Replacing globalized device memory with shared memory.; // - Parallel region merging.; // - Transforming generic-mode device kernels to SPMD mode.; // - Specializing the state machine for generic-mode device kernels.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:58,optimiz,optimizations,58,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,2,['optimiz'],['optimizations']
Performance,"//===-- InstructionPrecedenceTracking.cpp -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Implements a class that is able to define some instructions as ""special""; // (e.g. as having implicit control flow, or writing memory, or having another; // interesting property) and then efficiently answers queries of the types:; // 1. Are there any special instructions in the block of interest?; // 2. Return first of the special instructions in the given block;; // 3. Check if the given instruction is preceeded by the first special; // instruction in the same block.; // The class provides caching that allows to answer these queries quickly. The; // user must make sure that the cached data is invalidated properly whenever; // a content of some tracked block is changed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:965,cache,cached,965,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,1,['cache'],['cached']
Performance,"//===-- InstructionPrecedenceTracking.h -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Implements a class that is able to define some instructions as ""special""; // (e.g. as having implicit control flow, or writing memory, or having another; // interesting property) and then efficiently answers queries of the types:; // 1. Are there any special instructions in the block of interest?; // 2. Return first of the special instructions in the given block;; // 3. Check if the given instruction is preceeded by the first special; // instruction in the same block.; // The class provides caching that allows to answer these queries quickly. The; // user must make sure that the cached data is invalidated properly whenever; // a content of some tracked block is changed.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:965,cache,cached,965,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,1,['cache'],['cached']
Performance,"//===-- IntegerDivision.cpp - Expand integer division ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an implementation of 32bit and 64bit scalar integer; // division for targets that don't have native support. It's largely derived; // from compiler-rt's implementations of __udivsi3 and __udivmoddi4,; // but hand-tuned for targets that prefer less control flow.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:615,tune,tuned,615,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,1,['tune'],['tuned']
Performance,"//===-- LCSSA.cpp - Convert loops into loop-closed SSA form ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:966,optimiz,optimizations,966,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,1,['optimiz'],['optimizations']
Performance,"//===-- LICM.cpp - Loop Invariant Code Motion Pass ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs loop invariant code motion, attempting to remove as much; // code from the body of a loop as possible. It does this by either hoisting; // code into the preheader block, or by sinking code to the exit blocks if it is; // safe. This pass also promotes must-aliased memory locations in the loop to; // live in registers, thus hoisting and sinking ""invariant"" loads and stores.; //; // Hoisting operations out of loops is a canonicalization transform. It; // enables and simplifies subsequent optimizations in the middle-end.; // Rematerialization of hoisted instructions to reduce register pressure is the; // responsibility of the back-end, which has more accurate information about; // register pressure and also handles other optimizations than LICM that; // increase live-ranges.; //; // This pass uses alias analysis for two purposes:; //; // 1. Moving loop invariant loads and calls out of loops. If we can determine; // that a load or call inside of a loop never aliases anything stored to,; // we can hoist it or sink it like any other instruction.; // 2. Scalar Promotion of Memory - If there is a store instruction inside of; // the loop, we try to move the store to happen AFTER the loop instead of; // inside of the loop. This can only happen if a few conditions are true:; // A. The pointer stored through is loop invariant; // B. There are no stores or loads in the loop which _may_ alias the; // pointer. There are no calls in the loop which mod/ref the pointer.; // If these conditions are true, we can promote the loads and stores in the; // loop of the pointer to use a temporary all",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:393,perform,performs,393,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,3,"['load', 'optimiz', 'perform']","['loads', 'optimizations', 'performs']"
Performance,"//===-- LLJITWithOptimizingIRTransform.cpp -- LLJIT with IR optimization --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In this example we will use an IR transform to optimize a module as it; // passes through LLJIT's IRTransformLayer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp:60,optimiz,optimization,60,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithOptimizingIRTransform/LLJITWithOptimizingIRTransform.cpp,2,['optimiz'],"['optimization', 'optimize']"
Performance,"//===-- LTOModule.cpp - LLVM Link Time Optimizer --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Link Time Optimization library. This library is; // intended to be used by linker to optimize code at link time.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:39,Optimiz,Optimizer,39,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,3,"['Optimiz', 'optimiz']","['Optimization', 'Optimizer', 'optimize']"
Performance,"//===-- LanaiMemAluCombiner.cpp - Pass to combine memory & ALU operations -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Simple pass to combine memory and ALU operations; //; // The Lanai ISA supports instructions where a load/store modifies the base; // register used in the load/store operation. This pass finds suitable; // load/store and ALU instructions and combines them into one instruction.; //; // For example,; // ld [ %r6 -- ], %r12; // is a supported instruction that is not currently generated by the instruction; // selection pass of this backend. This pass generates these instructions by; // merging; // add %r6, -4, %r6; // followed by; // ld [ %r6 ], %r12; // in the same machine basic block into one machine instruction.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp:480,load,load,480,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiMemAluCombiner.cpp,3,['load'],['load']
Performance,"//===-- LatencyBenchmarkRunner.cpp ------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.cpp:8,Latency,LatencyBenchmarkRunner,8,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.cpp,1,['Latency'],['LatencyBenchmarkRunner']
Performance,"//===-- LatencyBenchmarkRunner.h --------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// A BenchmarkRunner implementation to measure instruction latencies.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.h:8,Latency,LatencyBenchmarkRunner,8,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/LatencyBenchmarkRunner.h,1,['Latency'],['LatencyBenchmarkRunner']
Performance,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:863,optimiz,optimization,863,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,1,['optimiz'],['optimization']
Performance,"//===-- Lint.cpp - Check for common errors in LLVM IR ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass statically checks for common and easily-identified constructs; // which produce undefined or likely unintended behavior in LLVM IR.; //; // It is not a guarantee of correctness, in two ways. First, it isn't; // comprehensive. There are checks which could be done statically which are; // not yet implemented. Some of these are indicated by TODO comments, but; // those aren't comprehensive either. Second, many conditions cannot be; // checked statically. This pass does no dynamic instrumentation, so it; // can't check for all possible problems.; //; // Another limitation is that it assumes all code will be executed. A store; // through a null pointer in a basic block which is never reached is harmless,; // but this pass will warn about it anyway. This is the main reason why most; // of these checks live here instead of in the Verifier pass.; //; // Optimization passes may make conditions that this pass checks for more or; // less obvious. If an optimization pass appears to be introducing a warning,; // it may be that the optimization pass is merely exposing an existing; // condition in the code.; //; // This code may be run before instcombine. In many cases, instcombine checks; // for the same kinds of things and turns instructions with undefined behavior; // into unreachable (or equivalent). Because of this, this pass makes some; // effort to look through bitcasts and so on.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp:1251,Optimiz,Optimization,1251,interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Lint.cpp,3,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"//===-- M68kExpandPseudo.cpp - Expand pseudo instructions -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a pass that expands pseudo instructions into target; /// instructions to allow proper scheduling, if-conversion, other late; /// optimizations, or simply the encoding of the instructions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp:544,optimiz,optimizations,544,interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kExpandPseudo.cpp,1,['optimiz'],['optimizations']
Performance,"//===-- MVETPAndVPTOptimisationsPass.cpp ----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This pass does a few optimisations related to Tail predicated loops; /// and MVE VPT blocks before register allocation is performed. For VPT blocks; /// the goal is to maximize the sizes of the blocks that will be created by the; /// MVE VPT Block Insertion pass (which runs after register allocation). For; /// tail predicated loops we transform the loop into something that will; /// hopefully make the backend ARMLowOverheadLoops pass's job easier.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp:512,perform,performed,512,interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETPAndVPTOptimisationsPass.cpp,1,['perform'],['performed']
Performance,"//===-- MipsExpandPseudoInsts.cpp - Expand pseudo instructions ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, and other late; // optimizations. This pass should be run after register allocation but before; // the post-regalloc scheduling pass.; //; // This is currently only used for expanding atomic pseudos after register; // allocation. We do this to avoid the fast register allocator introducing; // spills between ll and sc. These stores cause some MIPS implementations to; // abort the atomic RMW sequence.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp:533,optimiz,optimizations,533,interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsExpandPseudo.cpp,1,['optimiz'],['optimizations']
Performance,"//===-- ModuleUtils.cpp - Functions to manipulate Modules -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform manipulations on Modules.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:408,perform,perform,408,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,1,['perform'],['perform']
Performance,"//===-- ModuleUtils.h - Functions to manipulate Modules ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform manipulations on Modules.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:408,perform,perform,408,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,1,['perform'],['perform']
Performance,"//===-- NVPTXAtomicLower.cpp - Lower atomics of local memory ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Lower atomics of local memory to simple load/stores; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp:423,load,load,423,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.cpp,1,['load'],['load']
Performance,"//===-- NVPTXAtomicLower.h - Lower atomics of local memory ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Lower atomics of local memory to simple load/stores; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h:423,load,load,423,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAtomicLower.h,1,['load'],['load']
Performance,"//===-- NVPTXImageOptimizer.cpp - Image optimization pass -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass implements IR-level optimizations of image access code,; // including:; //; // 1. Eliminate istypep intrinsics when image access qualifier is known; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp:40,optimiz,optimization,40,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXImageOptimizer.cpp,2,['optimiz'],"['optimization', 'optimizations']"
Performance,"//===-- NVPTXPeephole.cpp - NVPTX Peephole Optimiztions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // In NVPTX, NVPTXFrameLowering will emit following instruction at the beginning; // of a MachineFunction.; //; // mov %SPL, %depot; // cvta.local %SP, %SPL; //; // Because Frame Index is a generic address and alloca can only return generic; // pointer, without this pass the instructions producing alloca'ed address will; // be based on %SP. NVPTXLowerAlloca tends to help replace store and load on; // this address with their .local versions, but this may introduce a lot of; // cvta.to.local instructions. Performance can be improved if we avoid casting; // address back and forth and directly calculate local address based on %SPL.; // This peephole pass optimizes these cases, for example; //; // It will transform the following pattern; // %0 = LEA_ADDRi64 %VRFrame64, 4; // %1 = cvta_to_local_yes_64 %0; //; // into; // %1 = LEA_ADDRi64 %VRFrameLocal64, 4; //; // %VRFrameLocal64 is the virtual register name of %SPL; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp:43,Optimiz,Optimiztions,43,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXPeephole.cpp,4,"['Optimiz', 'Perform', 'load', 'optimiz']","['Optimiztions', 'Performance', 'load', 'optimizes']"
Performance,"//===-- NVPTXReplaceImageHandles.cpp - Replace image handles for Fermi ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // On Fermi, image handles are not supported. To work around this, we traverse; // the machine code and replace image handles with concrete symbols. For this; // to work reliably, inlining of all function call must be performed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp:598,perform,performed,598,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXReplaceImageHandles.cpp,1,['perform'],['performed']
Performance,"//===-- OProfileWrapper.cpp - OProfile JIT API Wrapper implementation -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface in OProfileWrapper.h. It is responsible; // for loading the opagent dynamic library when the first call to an op_; // function occurs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp:466,load,loading,466,interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/OProfileJIT/OProfileWrapper.cpp,1,['load'],['loading']
Performance,"//===-- OProfileWrapper.h - OProfile JIT API Wrapper ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines a OProfileWrapper object that detects if the oprofile; // daemon is running, and provides wrappers for opagent functions used to; // communicate with the oprofile JIT interface. The dynamic library libopagent; // does not need to be linked directly as this object lazily loads the library; // when the first op_ function is called.; //; // See http://oprofile.sourceforge.net/doc/devel/jit-interface.html for the; // definition of the interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/OProfileWrapper.h:668,load,loads,668,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/OProfileWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/OProfileWrapper.h,1,['load'],['loads']
Performance,"//===-- OptimizedStructLayout.h - Struct layout algorithm ---------*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file provides an interface for laying out a sequence of fields; /// as a struct in a way that attempts to minimizes the total space; /// requirements of the struct while still satisfying the layout; /// requirements of the individual fields. The resulting layout may be; /// substantially more compact than simply laying out the fields in their; /// original order.; ///; /// Fields may be pre-assigned fixed offsets. They may also be given sizes; /// that are not multiples of their alignments. There is no currently no; /// way to describe that a field has interior padding that other fields may; /// be allocated into.; ///; /// This algorithm does not claim to be ""optimal"" for several reasons:; ///; /// - First, it does not guarantee that the result is minimal in size.; /// There is no known efficient algoorithm to achieve minimality for; /// unrestricted inputs. Nonetheless, this algorithm; ///; /// - Second, there are other ways that a struct layout could be optimized; /// besides space usage, such as locality. This layout may have a mixed; /// impact on locality: less overall memory may be used, but adjacent; /// fields in the original array may be moved further from one another.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OptimizedStructLayout.h:8,Optimiz,OptimizedStructLayout,8,interpreter/llvm-project/llvm/include/llvm/Support/OptimizedStructLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/OptimizedStructLayout.h,2,"['Optimiz', 'optimiz']","['OptimizedStructLayout', 'optimized']"
Performance,"//===-- PGOMemOPSizeOpt.cpp - Optimizations based on value profiling ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that optimizes memory intrinsics; // such as memcpy using the size value profile. When memory intrinsic size; // value profile metadata is available, a single memory intrinsic is expanded; // to a sequence of guarded specialized versions that are called with the; // hottest size(s), for later expansion into more optimal inline sequences.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:30,Optimiz,Optimizations,30,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,2,"['Optimiz', 'optimiz']","['Optimizations', 'optimizes']"
Performance,"//===-- PluginLoader.cpp - Implement -load command line option ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the -load <plugin> command line option handler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/PluginLoader.cpp:38,load,load,38,interpreter/llvm-project/llvm/lib/Support/PluginLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/PluginLoader.cpp,2,['load'],['load']
Performance,"//===-- RISCVInsertWriteVXRM.cpp - Insert Write of RISC-V VXRM CSR --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass inserts writes to the VXRM CSR as needed by vector instructions.; // Each instruction that uses VXRM carries an operand that contains its required; // VXRM value. This pass tries to optimize placement to avoid redundant writes; // to VXRM.; //; // This is done using 2 dataflow algorithms. The first is a forward data flow; // to calculate where a VXRM value is available. The second is a backwards; // dataflow to determine where a VXRM value is anticipated.; //; // Finally, we use the results of these two dataflows to insert VXRM writes; // where a value is anticipated, but not available.; //; // FIXME: This pass does not split critical edges, so there can still be some; // redundancy.; //; // FIXME: If we are willing to have writes that aren't always needed, we could; // reduce the number of VXRM writes in some cases.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:575,optimiz,optimize,575,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,1,['optimiz'],['optimize']
Performance,"//===-- RISCVMoveMerger.cpp - RISC-V move merge pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that performs move related peephole optimizations; // as Zcmp has specified. This pass should be run after register allocation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp:414,perform,performs,414,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMoveMerger.cpp,2,"['optimiz', 'perform']","['optimizations', 'performs']"
Performance,"//===-- SIFormMemoryClauses.cpp -------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file This pass extends the live ranges of registers used as pointers in; /// sequences of adjacent SMEM and VMEM instructions if XNACK is enabled. A; /// load that would overwrite a pointer would require breaking the soft clause.; /// Artificially extend the live ranges of the pointer operands by adding; /// implicit-def early-clobber operands throughout the soft clause.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp:539,load,load,539,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFormMemoryClauses.cpp,1,['load'],['load']
Performance,"//===-- SIOptimizeExecMaskingPreRA.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass performs exec mask handling peephole optimizations which needs; /// to be done before register allocation to reduce register pressure.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp:405,perform,performs,405,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp,2,"['optimiz', 'perform']","['optimizations', 'performs']"
Performance,"//===-- SIPostRABundler.cpp -----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass creates bundles of memory instructions to protect adjacent loads; /// and stores from being rescheduled apart from each other post-RA.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPostRABundler.cpp:464,load,loads,464,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPostRABundler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPostRABundler.cpp,1,['load'],['loads']
Performance,"//===-- SIPreEmitPeephole.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This pass performs the peephole optimizations before code emission.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp:396,perform,performs,396,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIPreEmitPeephole.cpp,2,"['optimiz', 'perform']","['optimizations', 'performs']"
Performance,"//===-- SizeOpts.cpp - code size optimization related code ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared code size optimization related code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp:33,optimiz,optimization,33,interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp,2,['optimiz'],['optimization']
Performance,"//===-- SnippetGenerator.h --------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Defines the abstract SnippetGenerator class for generating code that allows; /// measuring a certain property of instructions (e.g. latency).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:528,latency,latency,528,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,1,['latency'],['latency']
Performance,"//===-- Statistic.cpp - Easy way to expose stats information --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the 'Statistic' class, which is designed to be an easy; // way to expose various success metrics from passes. These statistics are; // printed at the end of a run, when the -stats command line option is enabled; // on the command line.; //; // This is useful for reporting information like the number of instructions; // simplified, optimized or removed by various transformations, like this:; //; // static Statistic NumInstEliminated(""GCSE"", ""Number of instructions killed"");; //; // Later, in the code: ++NumInstEliminated;; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Statistic.cpp:737,optimiz,optimized,737,interpreter/llvm-project/llvm/lib/Support/Statistic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Statistic.cpp,1,['optimiz'],['optimized']
Performance,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:691,Optimiz,Optimizations,691,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['Optimiz'],['Optimizations']
Performance,"//===-- UnreachableBlockElim.cpp - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp:560,perform,performs,560,interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/UnreachableBlockElim.cpp,1,['perform'],['performs']
Performance,"//===-- UnreachableBlockElim.h - Remove unreachable blocks for codegen --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is an extremely simple version of the SimplifyCFG pass. Its sole; // job is to delete LLVM basic blocks that are not reachable from the entry; // node. To do this, it performs a simple depth first traversal of the CFG,; // then deletes any unvisited nodes.; //; // Note that this pass is really a hack. In particular, the instruction; // selectors for various targets should just not generate code for unreachable; // blocks. Until LLVM has a more systematic way of defining instruction; // selectors, however, we cannot really expect them to handle additional; // complexity.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h:558,perform,performs,558,interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/UnreachableBlockElim.h,1,['perform'],['performs']
Performance,"//===-- UnrollLoop.cpp - Loop unrolling utilities -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements some loop unrolling utilities. It does not define any; // actual pass or policy, but provides a single function to perform loop; // unrolling.; //; // The process of unrolling can produce extraneous basic blocks linked with; // unconditional branches. This will be corrected in the future.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:519,perform,perform,519,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,1,['perform'],['perform']
Performance,"//===-- ValueLatticeUtils.cpp - Utils for solving lattices ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements common functions useful for performing data-flow; // analyses that propagate values across function boundaries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp:432,perform,performing,432,interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueLatticeUtils.cpp,1,['perform'],['performing']
Performance,"//===-- ValueLatticeUtils.h - Utils for solving lattices --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares common functions useful for performing data-flow analyses; // that propagate values across function boundaries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h:430,perform,performing,430,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,1,['perform'],['performing']
Performance,"//===-- Verifier.cpp - Implement the Module Verifier -----------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the function verifier interface, that can be used for some; // basic correctness checking of input to the system.; //; // Note that this does not provide full `Java style' security and verifications,; // instead it just tries to ensure that code is well-formed.; //; // * Both of a binary operator's parameters are of the same type; // * Verify that the indices of mem access instructions match other operands; // * Verify that arithmetic and other things are only performed on first-class; // types. Verify that shifts & logicals only happen on integrals f.e.; // * All of the constants in a switch statement are of the correct type; // * The code is in valid SSA form; // * It should be illegal to put a label into any other type (like a structure); // or to return one. [except constant arrays!]; // * Only phi nodes can be self referential: 'add i32 %0, %0 ; <int>:0' is bad; // * PHI nodes must have an entry for each predecessor, with no extras.; // * PHI nodes must be the first thing in a basic block, all grouped together; // * All basic blocks should only end with terminator insts, not contain them; // * The entry node to a function must not have predecessors; // * All Instructions must be embedded into a basic block; // * Functions cannot take a void-typed parameter; // * Verify that a function's argument list agrees with it's declared type.; // * It is illegal to specify a name for a void value.; // * It is illegal to have a internal global value with no initializer; // * It is illegal to have a ret instruction that returns a value that does not; // agree with the function retu",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:866,perform,performed,866,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['perform'],['performed']
Performance,"//===-- WebAssemblyFixFunctionBitcasts.cpp - Fix function bitcasts --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Fix bitcasted functions.; ///; /// WebAssembly requires caller and callee signatures to match, however in LLVM,; /// some amount of slop is vaguely permitted. Detect mismatch by looking for; /// bitcasts of functions and rewrite them to use wrapper functions instead.; ///; /// This doesn't catch all cases, such as when a function's address is taken in; /// one place and casted in another, but it works for many common cases.; ///; /// Note that LLVM already optimizes away function bitcasts in common cases by; /// dropping arguments as needed, so this pass only ends up getting used in less; /// common cases.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp:857,optimiz,optimizes,857,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixFunctionBitcasts.cpp,1,['optimiz'],['optimizes']
Performance,"//===-- WebAssemblyOptimizeReturned.cpp - Optimize ""returned"" attributes --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Optimize calls with ""returned"" attributes for WebAssembly.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeReturned.cpp:42,Optimiz,Optimize,42,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeReturned.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeReturned.cpp,2,['Optimiz'],['Optimize']
Performance,"//===-- WebAssemblyPeephole.cpp - WebAssembly Peephole Optimiztions -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Late peephole optimizations for WebAssembly.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp:55,Optimiz,Optimiztions,55,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyPeephole.cpp,2,"['Optimiz', 'optimiz']","['Optimiztions', 'optimizations']"
Performance,"//===-- WebAssemblyRegStackify.cpp - Register Stackification --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a register stacking pass.; ///; /// This pass reorders instructions to put register uses and defs in an order; /// such that they form single-use expression trees. Registers fitting this form; /// are then marked as ""stackified"", meaning references to them are replaced by; /// ""push"" and ""pop"" from the value stack.; ///; /// This is primarily a code size optimization, since temporary values on the; /// value stack don't need to be named.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:774,optimiz,optimization,774,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,1,['optimiz'],['optimization']
Performance,"//===-- WindowsResource.h ---------------------------------------*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This file declares the .res file class. .res files are intermediate; // products of the typical resource-compilation process on Windows. This; // process is as follows:; //; // .rc file(s) ---(rc.exe)---> .res file(s) ---(cvtres.exe)---> COFF file; //; // .rc files are human-readable scripts that list all resources a program uses.; //; // They are compiled into .res files, which are a list of the resources in; // binary form.; //; // Finally the data stored in the .res is compiled into a COFF file, where it; // is organized in a directory tree structure for optimized access by the; // program during runtime.; //; // Ref: msdn.microsoft.com/en-us/library/windows/desktop/ms648007(v=vs.85).aspx; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/WindowsResource.h:945,optimiz,optimized,945,interpreter/llvm-project/llvm/include/llvm/Object/WindowsResource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/WindowsResource.h,1,['optimiz'],['optimized']
Performance,"//===-- X86Counter.h --------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Perf counter that reads the LBRs for measuring the benchmarked block's; /// throughput.; ///; /// More info at: https://lwn.net/Articles/680985; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h:472,throughput,throughput,472,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/X86Counter.h,1,['throughput'],['throughput']
Performance,"//===-- X86EncodingOptimization.cpp - X86 Encoding optimization -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the implementation of the X86 encoding optimization; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86EncodingOptimization.cpp:51,optimiz,optimization,51,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86EncodingOptimization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86EncodingOptimization.cpp,2,['optimiz'],['optimization']
Performance,"//===-- X86EncodingOptimization.h - X86 Encoding optimization ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the declarations of the X86 encoding optimization; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86EncodingOptimization.h:49,optimiz,optimization,49,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86EncodingOptimization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86EncodingOptimization.h,2,['optimiz'],['optimization']
Performance,"//===-- X86FastTileConfig.cpp - Fast Tile Register Configure---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Pass to config the shape of AMX physical registers; /// AMX register need to be configured before use. Before FastRegAllocation pass; /// the ldtilecfg instruction is inserted, however at that time we don't; /// know the shape of each physical tile registers, because the register; /// allocation is not done yet. This pass runs after register allocation; /// pass. It collects the shape information of each physical tile register; /// and store the shape in the stack slot that is allocated for load config; /// to tile config register.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp:886,load,load,886,interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastTileConfig.cpp,1,['load'],['load']
Performance,"//===-- X86FixupVectorConstants.cpp - optimize constant generation -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file examines all full size vector constant pool loads and attempts to; // replace them with smaller constant pool entries, including:; // * Converting AVX512 memory-fold instructions to their broadcast-fold form; // * Broadcasting of full width loads.; // * TODO: Sign/Zero extension of full width loads.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp:38,optimiz,optimize,38,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupVectorConstants.cpp,4,"['load', 'optimiz']","['loads', 'optimize']"
Performance,"//===-- X86LowerTileCopy.cpp - Expand Tile Copy Instructions---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass which lower AMX tile copy instructions. Since; // there is no tile copy instruction, we need store tile register to stack; // and load from stack to another tile register. We need extra GR to hold; // the stride, and we need stack slot to hold the tile data register.; // We would run this pass after copy propagation, so that we don't miss copy; // optimization. And we would run this pass before prolog/epilog insertion,; // so that we can allocate stack slot.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp:540,load,load,540,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp,2,"['load', 'optimiz']","['load', 'optimization']"
Performance,"//===-- X86RegisterInfo.cpp - X86 Register Information --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the X86 implementation of the TargetRegisterInfo class.; // This file is responsible for the frame pointer elimination optimization; // on X86.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp:521,optimiz,optimization,521,interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,1,['optimiz'],['optimization']
Performance,"//===-- X86TileConfig.cpp - Tile Register Configure----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Pass to config the shape of AMX physical registers; /// AMX register need to be configured before use. In X86PreTileConfig pass; /// the pldtilecfg instruction is inserted, however at that time we don't; /// know the shape of each physical tile registers, because the register; /// allocation is not done yet. This pass runs after egister allocation; /// pass. It collects the shape information of each physical tile register; /// and store the shape in the stack slot that is allocated for load config; /// to tile config register.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TileConfig.cpp:879,load,load,879,interpreter/llvm-project/llvm/lib/Target/X86/X86TileConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TileConfig.cpp,1,['load'],['load']
Performance,"//===-- examples/ParallelJIT/ParallelJIT.cpp - Exercise threaded-safe JIT -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Parallel JIT; //; // This test program creates two LLVM functions then calls them from three; // separate threads. It requires the pthreads library.; // The three threads are created and then block waiting on a condition variable.; // Once all threads are blocked on the conditional variable, the main thread; // wakes them up. This complicated work is performed so that all three threads; // call into the JIT at the same time (or the best possible approximation of the; // same time). This test had assertion errors until I got the locking right.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp:736,perform,performed,736,interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ParallelJIT/ParallelJIT.cpp,1,['perform'],['performed']
Performance,"//===-- gold-plugin.cpp - Plugin to gold for Link Time Optimization ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a gold plugin for LLVM. It provides an LLVM implementation of the; // interface described in http://gcc.gnu.org/wiki/whopr/driver .; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:55,Optimiz,Optimization,55,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,1,['Optimiz'],['Optimization']
Performance,"//===-- llvm-lto2: test harness for the resolution-based LTO interface ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This program takes in a list of bitcode files, links them and performs; // link-time optimization according to the provided symbol resolutions using the; // resolution-based LTO interface, and outputs one or more object files.; //; // This program is intended to eventually replace llvm-lto which uses the legacy; // LTO interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp:445,perform,performs,445,interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto2/llvm-lto2.cpp,2,"['optimiz', 'perform']","['optimization', 'performs']"
Performance,"//===-- llvm-mca.cpp - Machine Code Analyzer -------------------*- C++ -* -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This utility is a simple driver that allows static performance analysis on; // machine code similarly to how IACA (Intel Architecture Code Analyzer) works.; //; // llvm-mca [options] <file-name>; // -march <type>; // -mcpu <cpu>; // -o <file>; //; // The target defaults to the host target.; // The cpu defaults to the 'native' host cpu.; // The output defaults to standard output.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:434,perform,performance,434,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,1,['perform'],['performance']
Performance,"//===-- llvm/ADT/Statistic.h - Easy way to expose stats ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the 'Statistic' class, which is designed to be an easy way; /// to expose various metrics from passes. These statistics are printed at the; /// end of a run (from llvm_shutdown), when the -stats command line option is; /// passed on the command line.; ///; /// This is useful for reporting information like the number of instructions; /// simplified, optimized or removed by various transformations, like this:; ///; /// static Statistic NumInstsKilled(""gcse"", ""Number of instructions killed"");; ///; /// Later, in the code: ++NumInstsKilled;; ///; /// NOTE: Statistics *must* be declared as global variables.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h:765,optimiz,optimized,765,interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Statistic.h,1,['optimiz'],['optimized']
Performance,"//===-- llvm/Support/PluginLoader.h - Plugin Loader for Tools ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A tool can #include this file to get a -load option that allows the user to; // load arbitrary shared objects into the tool's address space. Note that this; // header can only be included by a program ONCE, so it should never to used by; // library authors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PluginLoader.h:45,Load,Loader,45,interpreter/llvm-project/llvm/include/llvm/Support/PluginLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PluginLoader.h,3,"['Load', 'load']","['Loader', 'load']"
Performance,"//===-- llvm/Support/Threading.cpp- Control multithreading mode --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper functions for running LLVM in a multi-threaded; // environment.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Threading.cpp:440,multi-thread,multi-threaded,440,interpreter/llvm-project/llvm/lib/Support/Threading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Threading.cpp,1,['multi-thread'],['multi-threaded']
Performance,"//===-- llvm/Support/Threading.h - Control multithreading mode --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares helper functions for running LLVM in a multi-threaded; // environment.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:441,multi-thread,multi-threaded,441,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,1,['multi-thread'],['multi-threaded']
Performance,"//===--- AArch64StorePairSuppress.cpp --- Suppress store pair formation ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies floating point stores that should not be combined into; // store pairs. Later we may do the same for floating point loads.; // ===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp:520,load,loads,520,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp,1,['load'],['loads']
Performance,"//===--- AMDGPUIGroupLP.cpp - AMDGPU IGroupLP ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file This file defines a set of schedule DAG mutations that can be used to; // override default scheduler behavior to enforce specific scheduling patterns.; // They should be used in cases where runtime performance considerations such as; // inter-wavefront interactions, mean that compile-time heuristics cannot; // predict the optimal instruction ordering, or in kernels where optimum; // instruction scheduling is important enough to warrant manual intervention.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp:570,perform,performance,570,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUIGroupLP.cpp,1,['perform'],['performance']
Performance,"//===--- Assumptions.h - Assumption handling and organization ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // String assumptions that are known to optimization passes should be placed in; // the KnownAssumptionStrings set. This can be done in various ways, i.a.,; // via a static KnownAssumptionString object.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Assumptions.h:420,optimiz,optimization,420,interpreter/llvm-project/llvm/include/llvm/IR/Assumptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Assumptions.h,1,['optimiz'],['optimization']
Performance,"//===--- CHECK: pointer_with_type_tag attribute: datatypes should match ----//; /// Given a type tag expression find the type tag itself.; ///; /// \param TypeExpr Type tag expression, as it appears in user's code.; ///; /// \param VD Declaration of an identifier that appears in a type tag.; ///; /// \param MagicValue Type tag magic value.; ///; /// \param isConstantEvaluated whether the evalaution should be performed in; /// constant context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:412,perform,performed,412,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['perform'],['performed']
Performance,"//===--- ClangRefactor.cpp - Clang-based refactoring tool -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a clang-refactor tool that performs various; /// source transformations.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp:444,perform,performs,444,interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/ClangRefactor.cpp,1,['perform'],['performs']
Performance,"//===--- CodeGenPGO.cpp - PGO Instrumentation for LLVM CodeGen --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Instrumentation-based profile-guided optimization; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp:420,optimiz,optimization,420,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.cpp,1,['optimiz'],['optimization']
Performance,"//===--- CodeGenPGO.h - PGO Instrumentation for LLVM CodeGen ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Instrumentation-based profile-guided optimization; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.h:420,optimiz,optimization,420,interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenPGO.h,1,['optimiz'],['optimization']
Performance,"//===--- CodeGenTBAA.h - TBAA information for LLVM CodeGen ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is the code that manages TBAA information and defines the TBAA policy; // for the optimizer to use.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h:470,optimiz,optimizer,470,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.h,1,['optimiz'],['optimizer']
Performance,"//===--- Context.h - Context for the constexpr VM ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Defines the constexpr execution context.; //; // The execution context manages cached bytecode and the global context.; // It invokes the compiler and interpreter, propagating errors.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.h:462,cache,cached,462,interpreter/llvm-project/clang/lib/AST/Interp/Context.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Context.h,1,['cache'],['cached']
Performance,"//===--- CrossTranslationUnit.h - -------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides an interface to load binary AST dumps on demand. This; // feature can be utilized for tools that require cross translation unit; // support.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:418,load,load,418,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['load'],['load']
Performance,"//===--- DebugerSupportPlugin.h -- Utils for debugger support ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Generates debug objects and registers them using the jit-loader-gdb protocol.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.h:440,load,loader-gdb,440,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Debugging/DebuggerSupportPlugin.h,1,['load'],['loader-gdb']
Performance,"//===--- ExpandMemCmp.cpp - Expand memcmp() to load/stores ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass tries to expand memcmp() calls into optimally-sized loads and; // compares for the target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:47,load,load,47,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,2,['load'],"['load', 'loads']"
Performance,"//===--- ExpandMemCmp.h - Expand memcmp() to load/stores --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExpandMemCmp.h:45,load,load,45,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExpandMemCmp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExpandMemCmp.h,1,['load'],['load']
Performance,"//===--- GlobalModuleIndex.h - Global Module Index --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the GlobalModuleIndex class, which manages a global index; // containing all of the identifiers known to the various modules within a given; // subdirectory of the module cache. It is used to improve the performance of; // queries such as ""do any modules know about this identifier?""; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h:572,cache,cache,572,interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,2,"['cache', 'perform']","['cache', 'performance']"
Performance,"//===--- IncrementalExecutor.cpp - Incremental Execution --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.cpp:420,perform,performs,420,interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.cpp,1,['perform'],['performs']
Performance,"//===--- IncrementalExecutor.h - Incremental Execution ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.h:420,perform,performs,420,interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalExecutor.h,1,['perform'],['performs']
Performance,"//===--- IncrementalParser.h - Incremental Compilation ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code compilation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:420,perform,performs,420,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,1,['perform'],['performs']
Performance,"//===--- Interpreter.h - Incremental Compilation and Execution---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the component which performs incremental code; // compilation and execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h:421,perform,performs,421,interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h,1,['perform'],['performs']
Performance,"//===--- Lookup.cpp - Framework for clang refactoring tools ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper methods for clang tools performing name lookup.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:432,perform,performing,432,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,1,['perform'],['performing']
Performance,"//===--- Lookup.h - Framework for clang refactoring tools --*- C++ -*------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines helper methods for clang tools performing name lookup.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h:432,perform,performing,432,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h,1,['perform'],['performing']
Performance,"//===--- OptimizedStructLayout.cpp - Optimal data layout algorithm ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the performOptimizedStructLayout interface.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp:9,Optimiz,OptimizedStructLayout,9,interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,2,"['Optimiz', 'perform']","['OptimizedStructLayout', 'performOptimizedStructLayout']"
Performance,"//===--- RDFDeadCode.h ----------------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // RDF-based generic dead code elimination.; //; // The main interface of this class are functions ""collect"" and ""erase"".; // This allows custom processing of the function being optimized by a; // particular consumer. The simplest way to use this class would be to; // instantiate an object, and then simply call ""collect"" and ""erase"",; // passing the result of ""getDeadInstrs()"" to it.; // A more complex scenario would be to call ""collect"" first, then visit; // all post-increment instructions to see if the address update is dead; // or not, and if it is, convert the instruction to a non-updating form.; // After that ""erase"" can be called with the set of nodes including both,; // dead defs from the updating instructions and the nodes corresponding; // to the dead instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h:558,optimiz,optimized,558,interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/RDFDeadCode.h,1,['optimiz'],['optimized']
Performance,"//===--- Sema.cpp - AST Builder and Semantic Analysis Implementation ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the actions class which performs semantic analysis and; // builds an AST out of a parse stream.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:428,perform,performs,428,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['perform'],['performs']
Performance,"//===--- Sema.h - Semantic Analysis & AST Building --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the Sema class, which performs semantic analysis and; // builds ASTs.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:423,perform,performs,423,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performs']
Performance,"//===--- SourceLocationEncoding.h - Small serialized locations --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Source locations are stored pervasively in the AST, making up a third of; // the size of typical serialized files. Storing them efficiently is important.; //; // We use integers optimized by VBR-encoding, because:; // - when abbreviations cannot be used, VBR6 encoding is our only choice; // - in the worst case a SourceLocation can be ~any 32-bit number, but in; // practice they are highly predictable; //; // We encode the integer so that likely values encode as small numbers that; // turn into few VBR chunks:; // - the invalid sentinel location is a very common value: it encodes as 0; // - the ""macro or not"" bit is stored at the bottom of the integer; // (rather than at the top, as in memory), so macro locations can have; // small representations.; // - related locations (e.g. of a left and right paren pair) are usually; // similar, so when encoding a sequence of locations we store only; // differences between successive elements.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/SourceLocationEncoding.h:561,optimiz,optimized,561,interpreter/llvm-project/clang/include/clang/Serialization/SourceLocationEncoding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/SourceLocationEncoding.h,1,['optimiz'],['optimized']
Performance,"//===--- UndefinedArraySubscriptChecker.h ----------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This defines UndefinedArraySubscriptChecker, a builtin check in ExprEngine; // that performs checks for undefined array subscripts.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp:467,perform,performs,467,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefinedArraySubscriptChecker.cpp,1,['perform'],['performs']
Performance,"//===--- Value.h - Definition of interpreter value --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Value is a lightweight struct that is used for carrying execution results in; // clang-repl. It's a special runtime that acts like a messager between compiled; // code and interpreted code. This makes it possible to exchange interesting; // information between the compiled & interpreted world.; //; // A typical usage is like the below:; //; // Value V;; // Interp.ParseAndExecute(""int x = 42;"");; // Interp.ParseAndExecute(""x"", &V);; // V.getType(); // <-- Yields a clang::QualType.; // V.getInt(); // <-- Yields 42.; //; // The current design is still highly experimental and nobody should rely on the; // API being stable because we're hopefully going to make significant changes to; // it in the relatively near future. For example, Value also intends to be used; // as an exchange token for JIT support enabling remote execution on the embed; // devices where the JIT infrastructure cannot fit. To support that we will need; // to split the memory storage in a different place and perhaps add a resource; // header is similar to intrinsics headers which have stricter performance; // constraints.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Value.h:1457,perform,performance,1457,interpreter/llvm-project/clang/include/clang/Interpreter/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Value.h,1,['perform'],['performance']
Performance,"//===--- WebAssemblyOptimizeLiveIntervals.cpp - LiveInterval processing ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Optimize LiveIntervals for use in a post-RA context.; //; /// LiveIntervals normally runs before register allocation when the code is; /// only recently lowered out of SSA form, so it's uncommon for registers to; /// have multiple defs, and when they do, the defs are usually closely related.; /// Later, after coalescing, tail duplication, and other optimizations, it's; /// more common to see registers with multiple unrelated defs. This pass; /// updates LiveIntervals to distribute the value numbers across separate; /// LiveIntervals.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp:396,Optimiz,Optimize,396,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyOptimizeLiveIntervals.cpp,2,"['Optimiz', 'optimiz']","['Optimize', 'optimizations']"
Performance,"//===--- llvm-opt-fuzzer.cpp - Fuzzer for instruction selection ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Tool to fuzz optimization passes using libFuzzer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp:395,optimiz,optimization,395,interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-fuzzer/llvm-opt-fuzzer.cpp,1,['optimiz'],['optimization']
Performance,"//===--- llvm/CodeGen/SelectOptimize.h ---------------------------*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the declaration of the SelectOptimizePass class,; /// its corresponding pass name is `select-optimize`.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectOptimize.h:508,optimiz,optimize,508,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectOptimize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectOptimize.h,1,['optimiz'],['optimize']
Performance,"//===---- AlignmentFromAssumptions.h ----------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a ScalarEvolution-based transformation to set; // the alignments of load, stores and memory intrinsics based on the truth; // expressions of assume intrinsics. The primary motivation is to handle; // complex alignment assumptions that apply to vector loads and stores that; // appear after vectorization and unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/AlignmentFromAssumptions.h:472,load,load,472,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/AlignmentFromAssumptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/AlignmentFromAssumptions.h,2,['load'],"['load', 'loads']"
Performance,"//===---- LatencyPriorityQueue.cpp - A latency-oriented priority queue ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp:10,Latency,LatencyPriorityQueue,10,interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LatencyPriorityQueue.cpp,5,"['Latency', 'latency', 'queue']","['LatencyPriorityQueue', 'latency', 'latency-oriented', 'queue']"
Performance,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:10,Latency,LatencyPriorityQueue,10,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,5,"['Latency', 'latency', 'queue']","['LatencyPriorityQueue', 'latency', 'latency-oriented', 'queue']"
Performance,"//===---- MipsOs16.cpp for Mips Option -Os16 --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an optimization phase for the MIPS target.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp:382,optimiz,optimization,382,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOs16.cpp,1,['optimiz'],['optimization']
Performance,"//===---- PPCReduceCRLogicals.cpp - Reduce CR Bit Logical operations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass aims to reduce the number of logical operations on bits in the CR; // register. These instructions have a fairly high latency and only a single; // pipeline at their disposal in modern PPC cores. Furthermore, they have a; // tendency to occur in fairly small blocks where there's little opportunity; // to hide the latency between the CR logical operation and its user.; //; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp:510,latency,latency,510,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCReduceCRLogicals.cpp,2,['latency'],['latency']
Performance,"//===---- X86FixupSetCC.cpp - optimize usage of LEA instructions ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pass that fixes zero-extension of setcc patterns.; // X86 setcc instructions are modeled to have no input arguments, and a single; // GR8 output argument. This is consistent with other similar instructions; // (e.g. movb), but means it is impossible to directly generate a setcc into; // the lower GR8 of a specified GR32.; // This means that ISel must select (zext (setcc)) into something like; // seta %al; movzbl %al, %eax.; // Unfortunately, this can cause a stall due to the partial register write; // performed by the setcc. Instead, we can use:; // xor %eax, %eax; seta %al; // This both avoids the stall, and encodes shorter.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp:30,optimiz,optimize,30,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp,2,"['optimiz', 'perform']","['optimize', 'performed']"
Performance,"//===----- BPFMISimplifyPatchable.cpp - MI Simplify Patchable Insts -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass targets a subset of instructions like below; // ld_imm64 r1, @global; // ldd r2, r1, 0; // add r3, struct_base_reg, r2; //; // Here @global should represent an AMA (abstruct member access).; // Such an access is subject to bpf load time patching. After this pass, the; // code becomes; // ld_imm64 r1, @global; // add r3, struct_base_reg, r1; //; // Eventually, at BTF output stage, a relocation record will be generated; // for ld_imm64 which should be replaced later by bpf loader:; // r1 = <calculated field_info>; // add r3, struct_base_reg, r1; //; // This pass also removes the intermediate load generated in IR pass for; // __builtin_btf_type_id() intrinsic.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:620,load,load,620,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,3,['load'],"['load', 'loader']"
Performance,"//===----- COFFVCRuntimeSupport.h -- VC runtime support in ORC --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Utilities for loading and initializaing vc runtime in Orc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/COFFVCRuntimeSupport.h:397,load,loading,397,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/COFFVCRuntimeSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/COFFVCRuntimeSupport.h,1,['load'],['loading']
Performance,"//===----- CodeCompletion.h - Code Completion for ClangRepl ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the classes which performs code completion at the REPL.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/CodeCompletion.h:407,perform,performs,407,interpreter/llvm-project/clang/include/clang/Interpreter/CodeCompletion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/CodeCompletion.h,1,['perform'],['performs']
Performance,"//===----- DivisionByConstantInfo.cpp - division by constant -*- C++ -*----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// This file implements support for optimizing divisions by a constant; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DivisionByConstantInfo.cpp:418,optimiz,optimizing,418,interpreter/llvm-project/llvm/lib/Support/DivisionByConstantInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DivisionByConstantInfo.cpp,1,['optimiz'],['optimizing']
Performance,"//===----- MIRSampleProfile.h: SampleFDO Support in MIR ---*- c++ -*-------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the supoorting functions for machine level Sample FDO; // loader. This is used in Flow Sensitive SampelFDO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h:460,load,loader,460,interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MIRSampleProfile.h,1,['load'],['loader']
Performance,"//===----- ResourcePriorityQueue.h - A DFA-oriented priority queue -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the ResourcePriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using DFA state to; // reduce the length of the critical path through the basic block; // on VLIW platforms.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h:61,queue,queue,61,interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ResourcePriorityQueue.h,1,['queue'],['queue']
Performance,"//===----- SVEIntrinsicOpts - SVE ACLE Intrinsics Opts --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Performs general IR level optimizations on SVE intrinsics.; //; // This pass performs the following optimizations:; //; // - removes unnecessary ptrue intrinsics (llvm.aarch64.sve.ptrue), e.g:; // %1 = @llvm.aarch64.sve.ptrue.nxv4i1(i32 31); // %2 = @llvm.aarch64.sve.ptrue.nxv8i1(i32 31); // ; (%1 can be replaced with a reinterpret of %2); //; // - optimizes ptest intrinsics where the operands are being needlessly; // converted to and from svbool_t.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp:383,Perform,Performs,383,interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,5,"['Perform', 'optimiz', 'perform']","['Performs', 'optimizations', 'optimizes', 'performs']"
Performance,"//===----- SchedulePostRAList.cpp - list scheduler ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements a top-down list scheduler, using standard algorithms.; // The basic approach uses a priority queue of available nodes to schedule.; // One at a time, nodes are taken from the priority queue (thus in priority; // order), checked for legality to schedule, and emitted if legal.; //; // Nodes may not be legal to schedule either due to structural hazards (e.g.; // pipeline or resource constraints) or because an input to the instruction has; // not completed execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:492,queue,queue,492,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['queue'],['queue']
Performance,"//===----- X86CallFrameOptimization.cpp - Optimize x86 call sequences -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pass that optimizes call sequences on x86.; // Currently, it converts movs of function parameters onto the stack into; // pushes. This is beneficial for two main reasons:; // 1) The push instruction encoding is much smaller than a stack-ptr-based mov.; // 2) It is possible to push memory arguments directly. So, if the; // the transformation is performed pre-reg-alloc, it can help relieve; // register pressure.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:42,Optimiz,Optimize,42,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,3,"['Optimiz', 'optimiz', 'perform']","['Optimize', 'optimizes', 'performed']"
Performance,"//===----- X86DynAllocaExpander.cpp - Expand DynAlloca pseudo instruction -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a pass that expands DynAlloca pseudo-instructions.; //; // It performs a conservative analysis to determine whether each allocation; // falls within a region of the stack that is safe to use, or whether stack; // probes must be emitted.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp:463,perform,performs,463,interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp,1,['perform'],['performs']
Performance,"//===------ BPFAbstractMemberAccess.cpp - Abstracting Member Accesses -----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass abstracted struct/union member accesses in order to support; // compile-once run-everywhere (CO-RE). The CO-RE intends to compile the program; // which can run on different kernels. In particular, if bpf program tries to; // access a particular kernel data structure member, the details of the; // intermediate member access will be remembered so bpf loader can do; // necessary adjustment right before program loading.; //; // For example,; //; // struct s {; // int a;; // int b;; // };; // struct t {; // struct s c;; // int d;; // };; // struct t e;; //; // For the member access e.c.b, the compiler will generate code; // &e + 4; //; // The compile-once run-everywhere instead generates the following code; // r = 4; // &e + r; // The ""4"" in ""r = 4"" can be changed based on a particular kernel version.; // For example, on a particular kernel version, if struct s is changed to; //; // struct s {; // int new_field;; // int a;; // int b;; // }; //; // By repeating the member access on the host, the bpf loader can; // adjust ""r = 4"" as ""r = 8"".; //; // This feature relies on the following three intrinsic calls:; // addr = preserve_array_access_index(base, dimension, index); // addr = preserve_union_access_index(base, di_index); // !llvm.preserve.access.index <union_ditype>; // addr = preserve_struct_access_index(base, gep_index, di_index); // !llvm.preserve.access.index <struct_ditype>; //; // Bitfield member access needs special attention. User cannot take the; // address of a bitfield acceess. To facilitate kernel verifier; // for easy bitfield code optimization, a new clang intrinsic is i",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp:744,load,loader,744,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAbstractMemberAccess.cpp,2,['load'],"['loader', 'loading']"
Performance,"//===------ BPFPreserveStaticOffset.cpp -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // TLDR: replaces llvm.preserve.static.offset + GEP + load / store; // with llvm.bpf.getelementptr.and.load / store; //; // This file implements BPFPreserveStaticOffsetPass transformation.; // This transformation address two BPF verifier specific issues:; //; // (a) Access to the fields of some structural types is allowed only; // using load and store instructions with static immediate offsets.; //; // Examples of such types are `struct __sk_buff` and `struct; // bpf_sock_ops`. This is so because offsets of the fields of; // these structures do not match real offsets in the running; // kernel. During BPF program load LDX and STX instructions; // referring to the fields of these types are rewritten so that; // offsets match real offsets. For this rewrite to happen field; // offsets have to be encoded as immediate operands of the; // instructions.; //; // See kernel/bpf/verifier.c:convert_ctx_access function in the; // Linux kernel source tree for details.; //; // (b) Pointers to context parameters of BPF programs must not be; // modified before access.; //; // During BPF program verification a tag PTR_TO_CTX is tracked for; // register values. In case if register with such tag is modified; // BPF program is not allowed to read or write memory using this; // register. See kernel/bpf/verifier.c:check_mem_access function; // in the Linux kernel source tree for details.; //; // The following sequence of the IR instructions:; //; // %x = getelementptr %ptr, %constant_offset; // %y = load %x; //; // Is translated as a single machine instruction:; //; // LDW %ptr, %constant_offset; //; // In order for ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp:434,load,load,434,interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFPreserveStaticOffset.cpp,3,['load'],['load']
Performance,"//===------ CodeCompletion.cpp - Code Completion for ClangRepl -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the classes which performs code completion at the REPL.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:417,perform,performs,417,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,1,['perform'],['performs']
Performance,"//===------ Interpreter.cpp - Incremental Compilation and Execution -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the component which performs incremental code; // compilation and execution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:424,perform,performs,424,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,1,['perform'],['performs']
Performance,"//===------ PPCLoopInstrFormPrep.cpp - Loop Instr Form Prep Pass ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a pass to prepare loops for ppc preferred addressing; // modes, leveraging different instruction form. (eg: DS/DQ form, D/DS form with; // update); // Additional PHIs are created for loop induction variables used by load/store; // instructions so that preferred addressing modes can be used.; //; // 1: DS/DQ form preparation, prepare the load/store instructions so that they; // can satisfy the DS/DQ form displacement requirements.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(p + i + 5);; // unsigned long x2 = *(unsigned long *)(p + i + 9);; // }; //; // to look like this:; //; // unsigned NewP = p + 5;; // for (int i = 0; i < n; ++i) {; // unsigned long x1 = *(unsigned long *)(i + NewP);; // unsigned long x2 = *(unsigned long *)(i + NewP + 4);; // }; //; // 2: D/DS form with update preparation, prepare the load/store instructions so; // that we can use update form to do pre-increment.; // Generically, this means transforming loops like this:; // for (int i = 0; i < n; ++i); // array[i] = c;; //; // to look like this:; //; // T *p = array[-1];; // for (int i = 0; i < n; ++i); // *++p = c;; //; // 3: common multiple chains for the load/stores with same offsets in the loop,; // so that we can reuse the offsets and reduce the register pressure in the; // loop. This transformation can also increase the loop ILP as now each chain; // uses its own loop induction add/addi. But this will increase the number of; // add/addi in the loop.; //; // Generically, this means transforming loops like th",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp:620,load,load,620,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCLoopInstrFormPrep.cpp,2,['load'],['load']
Performance,"//===------- LegalizeVectorTypes.cpp - Legalization of vector types -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file performs vector type splitting and scalarization for LegalizeTypes.; // Scalarization is the act of changing a computation in an illegal one-element; // vector type to be a computation in its scalar element type. For example,; // implementing <1 x f32> arithmetic in a scalar f32 register. This is needed; // as a base case when scalarizing vector arithmetic like <4 x f32>, which; // eventually decomposes to scalars if the target doesn't support v4f32 or v2f32; // types.; // Splitting is the act of changing a computation in an invalid vector type to; // be a computation in two vectors of half the size. For example, implementing; // <128 x f32> operations in terms of two <64 x f32> operations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:393,perform,performs,393,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['perform'],['performs']
Performance,"//===------- VectorCombine.cpp - Optimize partial vector operations -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes scalar/vector interactions using target cost models. The; // transforms implemented here may not fit in traditional loop-based or SLP; // vectorization passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:33,Optimiz,Optimize,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,2,"['Optimiz', 'optimiz']","['Optimize', 'optimizes']"
Performance,"//===------- X86ExpandPseudo.cpp - Expand pseudo instructions -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that expands pseudo instructions into target; // instructions to allow proper scheduling, if-conversion, other late; // optimizations, or simply the encoding of the instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp:529,optimiz,optimizations,529,interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ExpandPseudo.cpp,1,['optimiz'],['optimizations']
Performance,"//===------- X86InsertPrefetch.cpp - Insert cache prefetch hints ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass applies cache prefetch instructions based on a profile. The pass; // assumes DiscriminateMemOps ran immediately before, to ensure debug info; // matches the one used at profile generation time. The profile is encoded in; // afdo format (text or binary). It contains prefetch hints recommendations.; // Each recommendation is made in terms of debug info locations, a type (i.e.; // nta, t{0|1|2}) and a delta. The debug info identifies an instruction with a; // memory operand (see X86DiscriminateMemOps). The prefetch will be made for; // a location at that memory operand + the delta specified in the; // recommendation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp:44,cache,cache,44,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp,2,['cache'],['cache']
Performance,"//===-------- LLVM-provided High-Level Optimization levels -*- C++ -*------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header enumerates the LLVM-provided high-level optimization levels.; /// Each level has a specific goal and rationale.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:39,Optimiz,Optimization,39,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,2,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"//===-------- LegalizeFloatTypes.cpp - Legalization of float types --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements float type expansion and softening for LegalizeTypes.; // Softening is the act of turning a computation in an illegal floating point; // type into a computation in an integer type of the same size; also known as; // ""soft float"". For example, turning f32 arithmetic into operations using i32.; // The resulting integer value is the same as what you would get by performing; // the floating point operation and bitcasting the result to the integer type.; // Expansion is the act of changing a computation in an illegal type to be a; // computation in two identical registers of a smaller type. For example,; // implementing ppcf128 arithmetic in two f64 registers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp:766,perform,performing,766,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeFloatTypes.cpp,1,['perform'],['performing']
Performance,"//===-------- LegalizeTypesGeneric.cpp - Generic type legalization --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements generic type expansion and splitting for LegalizeTypes.; // The routines here perform legalization when the details of the type (such as; // whether it is an integer or a float) do not matter.; // Expansion is the act of changing a computation in an illegal type to be a; // computation in two identical registers of a smaller type. The Lo/Hi part; // is required to be stored first in memory on little/big-endian machines.; // Splitting is the act of changing a computation in an illegal type to be a; // computation in two not necessarily identical registers of a smaller type.; // There are no requirements on how the type is represented in memory.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp:482,perform,perform,482,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypesGeneric.cpp,1,['perform'],['perform']
Performance,"//===-------- MIRSampleProfile.cpp: MIRSampleFDO (For FSAFDO) -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides the implementation of the MIRSampleProfile loader, mainly; // for flow sensitive SampleFDO.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp:445,load,loader,445,interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRSampleProfile.cpp,1,['load'],['loader']
Performance,"//===-------- VectorCombine.h - Optimize partial vector operations --------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass optimizes scalar/vector interactions using target cost models. The; // transforms implemented here may not fit in traditional loop-based or SLP; // vectorization passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h:32,Optimiz,Optimize,32,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,2,"['Optimiz', 'optimiz']","['Optimize', 'optimizes']"
Performance,"//===--------- IncrementalParser.cpp - Incremental Compilation -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the class which performs incremental code compilation.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp:419,perform,performs,419,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.cpp,1,['perform'],['performs']
Performance,"//===--------- LoopSimplifyCFG.cpp - Loop CFG Simplification Pass ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the Loop SimplifyCFG Pass. This pass is responsible for; // basic loop CFG cleanup, primarily to assist other loop passes. If you; // encounter a noncanonical CFG construct that causes another loop pass to; // perform suboptimally, this is the place to fix it up.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:614,perform,perform,614,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,1,['perform'],['perform']
Performance,"//===--------- PPCPreEmitPeephole.cpp - Late peephole optimizations -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A pre-emit peephole for catching opportunities introduced by late passes such; // as MachineBlockPlacement.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:54,optimiz,optimizations,54,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,1,['optimiz'],['optimizations']
Performance,"//===---------- AArch64CollectLOH.cpp - AArch64 collect LOH pass --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that collect the Linker Optimization Hint (LOH).; // This pass should be run at the very end of the compilation flow, just before; // assembly printer.; // To be useful for the linker, the LOH must be printed into the assembly file.; //; // A LOH describes a sequence of instructions that may be optimized by the; // linker.; // This same sequence cannot be optimized by the compiler because some of; // the information will be known at link time.; // For instance, consider the following sequence:; // L1: adrp xA, sym@PAGE; // L2: add xB, xA, sym@PAGEOFF; // L3: ldr xC, [xB, #imm]; // This sequence can be turned into:; // A literal load if sym@PAGE + sym@PAGEOFF + #imm - address(L3) is < 1MB:; // L3: ldr xC, sym+#imm; // It may also be turned into either the following more efficient; // code sequences:; // - If sym@PAGEOFF + #imm fits the encoding space of L3.; // L1: adrp xA, sym@PAGE; // L3: ldr xC, [xB, sym@PAGEOFF + #imm]; // - If sym@PAGE + sym@PAGEOFF - address(L1) < 1MB:; // L1: adr xA, sym; // L3: ldr xC, [xB, #imm]; //; // To be valid a LOH must meet all the requirements needed by all the related; // possible linker transformations.; // For instance, using the running example, the constraints to emit; // "".loh AdrpAddLdr"" are:; // - L1, L2, and L3 instructions are of the expected type, i.e.,; // respectively ADRP, ADD (immediate), and LD.; // - The result of L1 is used only by L2.; // - The register argument (xA) used in the ADD instruction is defined; // only by L1.; // - The result of L2 is used only by L3.; // - The base address (xB) in L3 is defined only L2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp:433,Optimiz,Optimization,433,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,3,"['Optimiz', 'optimiz']","['Optimization', 'optimized']"
Performance,"//===---------- PPCTLSDynamicCall.cpp - TLS Dynamic Call Fixup ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass expands ADDItls{ld,gd}LADDR[32] machine instructions into; // separate ADDItls[gd]L[32] and GETtlsADDR[32] instructions, both of; // which define GPR3. A copy is added from GPR3 to the target virtual; // register of the original instruction. The GETtlsADDR[32] is really; // a call instruction, so its target register is constrained to be GPR3.; // This is not true of ADDItls[gd]L[32], but there is a legacy linker; // optimization bug that requires the target register of the addi of; // a local- or general-dynamic TLS access sequence to be GPR3.; //; // This is done in a late pass so that TLS variable accesses can be; // fully commoned by MachineCSE.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:813,optimiz,optimization,813,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,1,['optimiz'],['optimization']
Performance,"//===----------- PPCVSXSwapRemoval.cpp - Remove VSX LE Swaps -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass analyzes vector computations and removes unnecessary; // doubleword swaps (xxswapd instructions). This pass is performed; // only for little-endian VSX code generation.; //; // For this specific case, loads and stores of v4i32, v4f32, v2i64,; // and v2f64 vectors are inefficient. These are implemented using; // the lxvd2x and stxvd2x instructions, which invert the order of; // doublewords in a vector register. Thus code generation inserts; // an xxswapd after each such load, and prior to each such store.; //; // The extra xxswapd instructions reduce performance. The purpose; // of this pass is to reduce the number of xxswapd instructions; // required for correctness.; //; // The primary insight is that much code that operates on vectors; // does not care about the relative order of elements in a register,; // so long as the correct memory order is preserved. If we have a; // computation where all input values are provided by lxvd2x/xxswapd,; // all outputs are stored using xxswapd/lxvd2x, and all intermediate; // computations are lane-insensitive (independent of element order),; // then all the xxswapd instructions associated with the loads and; // stores may be removed without changing observable semantics.; //; // This pass uses standard equivalence class infrastructure to create; // maximal webs of computations fitting the above description. Each; // such web is then optimized by removing its unnecessary xxswapd; // instructions.; //; // There are some lane-sensitive operations for which we can still; // permit the optimization, provided we modify those operations; // accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:502,perform,performed,502,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,4,"['load', 'perform']","['load', 'loads', 'performance', 'performed']"
Performance,"//===------------ BPFCheckAndAdjustIR.cpp - Check and Adjust IR -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Check IR and adjust IR for verifier friendly codes.; // The following are done for IR checking:; // - no relocation globals in PHI node.; // The following are done for IR adjustment:; // - remove __builtin_bpf_passthrough builtins. Target independent IR; // optimizations are done and those builtins can be removed.; // - remove llvm.bpf.getelementptr.and.load builtins.; // - remove llvm.bpf.getelementptr.and.store builtins.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp:641,optimiz,optimizations,641,interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFCheckAndAdjustIR.cpp,2,"['load', 'optimiz']","['load', 'optimizations']"
Performance,"//===------------ BPFIRPeephole.cpp - IR Peephole Transformation ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // IR level peephole optimization, specifically removing @llvm.stacksave() and; // @llvm.stackrestore().; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp:401,optimiz,optimization,401,interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp,1,['optimiz'],['optimization']
Performance,"//===------------ EPCDynamicLibrarySearchGenerator.h ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Support loading and searching of dynamic libraries in an executor process; // via the ExecutorProcessControl class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.h:391,load,loading,391,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.h,1,['load'],['loading']
Performance,"//===-------------- BPFMIChecking.cpp - MI Checking Legality -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs checking to signal errors for certain illegal usages at; // MachineInstruction layer. Specially, the result of XADD{32,64} insn should; // not be used. The pass is done at the PreEmit pass right before the; // machine code is emitted at which point the register liveness information; // is still available.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:392,perform,performs,392,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,1,['perform'],['performs']
Performance,"//===-------------- BPFMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to cleanup ugly code sequences at; // MachineInstruction layer.; //; // Currently, there are two optimizations implemented:; // - One pre-RA MachineSSA pass to eliminate type promotion sequences, those; // zero extend 32-bit subregisters to 64-bit registers, if the compiler; // could prove the subregisters is defined by 32-bit operations in which; // case the upper half of the underlying 64-bit registers were zeroed; // implicitly.; //; // - One post-RA PreEmit pass to do final cleanup on some redundant; // instructions generated due to bad RA on subregister.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp:392,perform,performs,392,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIPeephole.cpp,3,"['optimiz', 'perform']","['optimizations', 'performs']"
Performance,"//===-------------- PPCMIPeephole.cpp - MI Peephole Cleanups -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===---------------------------------------------------------------------===//; //; // This pass performs peephole optimizations to clean up ugly code; // sequences at the MachineInstruction layer. It runs at the end of; // the SSA phases, following VSX swap removal. A pass of dead code; // elimination follows this one for quick clean-up of any dead; // instructions introduced here. Although we could do this as callbacks; // from the generic peephole pass, this would have a couple of bad; // effects: it might remove optimization opportunities for VSX swap; // removal, and it would miss cleanups made possible following VSX; // swap removal.; //; // NOTE: We run the verifier after this pass in Asserts/Debug builds so it; // is important to keep the code valid after transformations.; // Common causes of errors stem from violating the contract specified; // by kill flags. Whenever a transformation changes the live range of; // a register, that register should be added to the work list using; // addRegToUpdate(RegsToUpdate, <Reg>). Furthermore, if a transformation; // is changing the definition of a register (i.e. removing the single; // definition of the original vreg), it needs to provide a dummy; // definition of that register using addDummyDef(<MBB>, <Reg>).; //===---------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:391,perform,performs,391,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,3,"['optimiz', 'perform']","['optimization', 'optimizations', 'performs']"
Performance,"//===--------------- SimpleExecutorDylibManager.h ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A simple dynamic library management class. Allows dynamic libraries to be; // loaded and searched.; //; // FIXME: The functionality in this file should be moved to the ORC runtime.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.h:461,load,loaded,461,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TargetProcess/SimpleExecutorDylibManager.h,1,['load'],['loaded']
Performance,"//===---------------- BPFAdjustOpt.cpp - Adjust Optimization --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Adjust optimization to make the code more kernel verifier friendly.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:48,Optimiz,Optimization,48,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,2,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"//===------------------ llvm-opt-report/OptReport.cpp ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file implements a tool that can parse the YAML optimization; /// records and generate an optimization summary annotated source listing; /// report.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-report/OptReport.cpp:448,optimiz,optimization,448,interpreter/llvm-project/llvm/tools/llvm-opt-report/OptReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-opt-report/OptReport.cpp,2,['optimiz'],['optimization']
Performance,"//===--------------------- BottleneckAnalysis.cpp ---------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the functionalities used by the BottleneckAnalysis; /// to report bottleneck info.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp:27,Bottleneck,BottleneckAnalysis,27,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.cpp,3,"['Bottleneck', 'bottleneck']","['BottleneckAnalysis', 'bottleneck']"
Performance,"//===--------------------- BottleneckAnalysis.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the bottleneck analysis view.; ///; /// This view internally observes backend pressure increase events in order to; /// identify problematic data dependencies and processor resource interferences.; ///; /// Example of bottleneck analysis report for a dot-product on X86 btver2:; ///; /// Cycles with backend pressure increase [ 40.76% ]; /// Throughput Bottlenecks: ; /// Resource Pressure [ 39.34% ]; /// - JFPA [ 39.34% ]; /// - JFPU0 [ 39.34% ]; /// Data Dependencies: [ 1.42% ]; /// - Register Dependencies [ 1.42% ]; /// - Memory Dependencies [ 0.00% ]; ///; /// According to the example, backend pressure increased during the 40.76% of; /// the simulated cycles. In particular, the major cause of backend pressure; /// increases was the contention on floating point adder JFPA accessible from; /// pipeline resource JFPU0.; ///; /// At the end of each cycle, if pressure on the simulated out-of-order buffers; /// has increased, a backend pressure event is reported.; /// In particular, this occurs when there is a delta between the number of uOps; /// dispatched and the number of uOps issued to the underlying pipelines.; ///; /// The bottleneck analysis view is also responsible for identifying and; /// printing the most ""critical"" sequence of dependent instructions according to; /// the simulated run.; ///; /// Below is the critical sequence computed for the dot-product example on; /// btver2:; ///; /// Instruction Dependency Information; /// +----< 2. vhaddps %xmm3, %xmm3, %xmm4; /// |; /// | < loop carried > ; /// |; /// | 0. vmulps	 %xmm0, %xmm0, %xmm2; /// +---->",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:27,Bottleneck,BottleneckAnalysis,27,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,5,"['Bottleneck', 'Throughput', 'bottleneck']","['BottleneckAnalysis', 'Bottlenecks', 'Throughput', 'bottleneck']"
Performance,"//===--------------------- DispatchStatistics.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements a view that prints a few statistics related to the; /// dispatch logic. It collects and analyzes instruction dispatch events as; /// well as static/dynamic dispatch stall events.; ///; /// Example:; /// ========; ///; /// Dynamic Dispatch Stall Cycles:; /// RAT - Register unavailable: 0; /// RCU - Retire tokens unavailable: 0; /// SCHEDQ - Scheduler full: 42; /// LQ - Load queue full: 0; /// SQ - Store queue full: 0; /// GROUP - Static restrictions on the dispatch group: 0; ///; ///; /// Dispatch Logic - number of cycles where we saw N micro opcodes dispatched:; /// [# dispatched], [# cycles]; /// 0, 15 (11.5%); /// 2, 4 (3.1%); ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h:788,Load,Load,788,interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/DispatchStatistics.h,3,"['Load', 'queue']","['Load', 'queue']"
Performance,"//===--------------------- InstructionInfoView.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the instruction info view.; ///; /// The goal fo the instruction info view is to print the latency and reciprocal; /// throughput information for every instruction in the input sequence.; /// This section also reports extra information related to the number of micro; /// opcodes, and opcode properties (i.e. 'MayLoad', 'MayStore', 'HasSideEffects); ///; /// Example:; ///; /// Instruction Info:; /// [1]: #uOps; /// [2]: Latency; /// [3]: RThroughput; /// [4]: MayLoad; /// [5]: MayStore; /// [6]: HasSideEffects; ///; /// [1] [2] [3] [4] [5] [6]	Instructions:; /// 1 2 1.00 	vmulps	%xmm0, %xmm1, %xmm2; /// 1 3 1.00 	vhaddps	%xmm2, %xmm2, %xmm3; /// 1 3 1.00 	vhaddps	%xmm3, %xmm3, %xmm4; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h:508,latency,latency,508,interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/InstructionInfoView.h,3,"['Latency', 'latency', 'throughput']","['Latency', 'latency', 'throughput']"
Performance,"//===--------------------- PipelinePrinter.h --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements class PipelinePrinter.; ///; /// PipelinePrinter allows the customization of the performance report.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h:498,perform,performance,498,interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/PipelinePrinter.h,1,['perform'],['performance']
Performance,"//===--------------------- RegisterFileStatistics.h -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This view collects and prints register file usage statistics.; ///; /// Example (-mcpu=btver2):; /// ========================; ///; /// Register File statistics:; /// Total number of mappings created: 6; /// Max number of mappings used: 3; ///; /// * Register File #1 -- FpuPRF:; /// Number of physical registers: 72; /// Total number of mappings created: 0; /// Max number of mappings used: 0; /// Number of optimizable moves: 200; /// Number of moves eliminated: 200 (100.0%); /// Number of zero moves: 200 (100.0%); /// Max moves eliminated per cycle: 2; ///; /// * Register File #2 -- IntegerPRF:; /// Number of physical registers: 64; /// Total number of mappings created: 6; /// Max number of mappings used: 3; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.h:805,optimiz,optimizable,805,interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/RegisterFileStatistics.h,1,['optimiz'],['optimizable']
Performance,"//===--------------------- SchedulerStatistics.h ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines class SchedulerStatistics. Class SchedulerStatistics is a; /// View that listens to instruction issue events in order to print general; /// statistics related to the hardware schedulers.; ///; /// Example:; /// ========; ///; /// Schedulers - number of cycles where we saw N instructions issued:; /// [# issued], [# cycles]; /// 0, 6 (2.9%); /// 1, 106 (50.7%); /// 2, 97 (46.4%); ///; /// Scheduler's queue usage:; /// [1] Resource name.; /// [2] Average number of used buffer entries.; /// [3] Maximum number of used buffer entries.; /// [4] Total number of buffer entries.; ///; /// [1] [2] [3] [4]; /// JALU01 0 0 20; /// JFPU01 15 18 18; /// JLSAGU 0 0 12; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h:816,queue,queue,816,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SchedulerStatistics.h,1,['queue'],['queue']
Performance,"//===--------------------- SummaryView.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file implements the summary view.; ///; /// The goal of the summary view is to give a very quick overview of the; /// performance throughput. Below is an example of summary view:; ///; ///; /// Iterations: 300; /// Instructions: 900; /// Total Cycles: 610; /// Dispatch Width: 2; /// IPC: 1.48; /// Block RThroughput: 2.0; ///; /// The summary view collects a few performance numbers. The two main; /// performance indicators are 'Total Cycles' and IPC (Instructions Per Cycle).; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h:519,perform,performance,519,interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/SummaryView.h,4,"['perform', 'throughput']","['performance', 'throughput']"
Performance,"//===---------------------- MicroOpQueueStage.h -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file defines a stage that implements a queue of micro opcodes.; /// It can be used to simulate a hardware micro-op queue that serves opcodes to; /// the out of order backend.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h:440,queue,queue,440,interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h,2,['queue'],['queue']
Performance,"//===----------------------- AlignmentFromAssumptions.cpp -----------------===//; // Set Load/Store Alignments From Assumptions; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a ScalarEvolution-based transformation to set; // the alignments of load, stores and memory intrinsics based on the truth; // expressions of assume intrinsics. The primary motivation is to handle; // complex alignment assumptions that apply to vector loads and stores that; // appear after vectorization and unrolling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp:89,Load,Load,89,interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/AlignmentFromAssumptions.cpp,3,"['Load', 'load']","['Load', 'load', 'loads']"
Performance,"//===----------------------- LSUnit.cpp --------------------------*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// A Load-Store Unit for the llvm-mca tool.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp:398,Load,Load-Store,398,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/LSUnit.cpp,1,['Load'],['Load-Store']
Performance,"//===------------------------- LSUnit.h --------------------------*- C++-*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// A Load/Store unit class that models load/store queues and that implements; /// a simple weak memory consistency model.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:398,Load,Load,398,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,3,"['Load', 'load', 'queue']","['Load', 'load', 'queues']"
Performance,"//===---------------------------------------------------------------------------; /// PassRegistrationListener class - This class is meant to be derived from by; /// clients that are interested in which passes get registered and unregistered; /// at runtime (which can be because of the RegisterPass constructors being run; /// as the program starts up, or may be because a shared object just got; /// loaded).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:402,load,loaded,402,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h,1,['load'],['loaded']
Performance,//===----------------------------------------------------------------------===//; // AArch64 Optimization Hooks; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:93,Optimiz,Optimization,93,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Optimiz'],['Optimization']
Performance,//===----------------------------------------------------------------------===//; // ARM Optimization Hooks; //===----------------------------------------------------------------------===//; // Helper function that checks if N is a null or all ones constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:89,Optimiz,Optimization,89,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Optimiz'],['Optimization']
Performance,"//===----------------------------------------------------------------------===//; // ASTReader Implementation; //===----------------------------------------------------------------------===//; /// Note that we have loaded the declaration with the given; /// Index.; ///; /// This routine notes that this declaration has already been loaded,; /// so that future GetDecl calls will return this declaration rather; /// than trying to load a new declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:215,load,loaded,215,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,3,['load'],"['load', 'loaded']"
Performance,"//===----------------------------------------------------------------------===//; // Addressing mode description hooks; //===----------------------------------------------------------------------===//; /// Return true if the addressing mode represented by AM is legal for this; /// target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp:296,load,load,296,interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,1,['load'],['load']
Performance,//===----------------------------------------------------------------------===//; // BaseMemOpClusterMutation - DAG post-processing to cluster loads or stores.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:143,load,loads,143,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['load'],['loads']
Performance,//===----------------------------------------------------------------------===//; // Branch Optimization; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:92,Optimiz,Optimization,92,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['Optimiz'],['Optimization']
Performance,//===----------------------------------------------------------------------===//; // CacheCost implementation; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp:85,Cache,CacheCost,85,interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopCacheAnalysis.cpp,1,['Cache'],['CacheCost']
Performance,"//===----------------------------------------------------------------------===//; // CastInfo; //===----------------------------------------------------------------------===//; /// This struct provides a method for customizing the way a cast is performed.; /// It inherits from CastIsPossible, to support the case of declaring many; /// CastIsPossible specializations without having to specialize the full; /// CastInfo.; ///; /// In order to specialize different behaviors, specify different functions in; /// your CastInfo specialization.; /// For isa<> customization, provide:; ///; /// `static bool isPossible(const From &f)`; ///; /// For cast<> customization, provide:; ///; /// `static To doCast(const From &f)`; ///; /// For dyn_cast<> and the *_if_present<> variants' customization, provide:; ///; /// `static To castFailed()` and `static To doCastIfPossible(const From &f)`; ///; /// Your specialization might look something like this:; ///; /// template<> struct CastInfo<foo, bar> : public CastIsPossible<foo, bar> {; /// static inline foo doCast(const bar &b) {; /// return foo(const_cast<bar &>(b));; /// }; /// static inline foo castFailed() { return foo(); }; /// static inline foo doCastIfPossible(const bar &b) {; /// if (!CastInfo<foo, bar>::isPossible(b)); /// return castFailed();; /// return doCast(b);; /// }; /// };; // The default implementations of CastInfo don't use cast traits for now because; // we need to specify types all over the place due to the current expected; // casting behavior and the way cast_retty works. New use cases can and should; // take advantage of the cast traits whenever possible!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:245,perform,performed,245,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,1,['perform'],['performed']
Performance,//===----------------------------------------------------------------------===//; // CastInst Class; //===----------------------------------------------------------------------===//; /// This is the base class for all instructions that perform data; /// casts. It is simply provided so that instruction category testing; /// can be performed with code like:; ///; /// if (isa<CastInst>(Instr)) { ... }; /// Base class of casting instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:236,perform,perform,236,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,2,['perform'],"['perform', 'performed']"
Performance,//===----------------------------------------------------------------------===//; // Custom DAG Optimizations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:96,Optimiz,Optimizations,96,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['Optimiz'],['Optimizations']
Performance,//===----------------------------------------------------------------------===//; // Custom DAG optimizations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:96,optimiz,optimizations,96,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['optimiz'],['optimizations']
Performance,"//===----------------------------------------------------------------------===//; // DiagnosticBuilder; //===----------------------------------------------------------------------===//; /// A little helper class used to produce diagnostics.; ///; /// This is constructed by the DiagnosticsEngine::Report method, and; /// allows insertion of extra information (arguments and source ranges) into; /// the currently ""in flight"" diagnostic. When the temporary for the builder; /// is destroyed, the diagnostic is issued.; ///; /// Note that many of these will be created as temporary objects (many call; /// sites), so we want them to be small and we never want their address taken.; /// This ensures that compilers with somewhat reasonable optimizers will promote; /// the common fields to registers, eliminating increments of the NumArgs field,; /// for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:737,optimiz,optimizers,737,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['optimiz'],['optimizers']
Performance,"//===----------------------------------------------------------------------===//; // Diagnostics forwarding code.; //===----------------------------------------------------------------------===//; /// GetMappedTokenLoc - If lexing out of a 'mapped buffer', where we pretend the; /// lexer buffer was all expanded at a single point, perform the mapping.; /// This is currently only used for _Pragma implementation, so it is the slow; /// path of the hot getSourceLocation method. Do not allow it to be inlined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:332,perform,perform,332,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['perform'],['perform']
Performance,"//===----------------------------------------------------------------------===//; // Fast Calling Convention (tail call) implementation; //===----------------------------------------------------------------------===//; // Like std call, callee cleans arguments, convention except that ECX is; // reserved for storing the tail called function address. Only 2 registers are; // free for argument passing (inreg). Tail call optimization is performed; // provided:; // * tailcallopt is enabled; // * caller/callee are fastcc; // On M68k_64 architecture with GOT-style position independent code only; // local (within module) calls are supported at the moment. To keep the stack; // aligned according to platform abi the function GetAlignedArgumentStackSize; // ensures that argument delta is always multiples of stack alignment. (Dynamic; // linkers need this - darwin's dyld for example) If a tail called function; // callee has more arguments than the caller the caller needs to make sure that; // there is room to move the RETADDR to. This is achieved by reserving an area; // the size of the argument delta right after the original RETADDR, but before; // the saved framepointer or the spilled registers e.g. caller(arg1, arg2); // calls callee(arg1, arg2,arg3,arg4) stack layout:; // arg1; // arg2; // RETADDR; // [ new RETADDR; // move area ]; // (possible EBP); // ESI; // EDI; // local1 ..; /// Make the stack size align e.g 16n + 12 aligned for a 16-byte align; /// requirement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:421,optimiz,optimization,421,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"//===----------------------------------------------------------------------===//; // Fast Calling Convention (tail call) implementation; //===----------------------------------------------------------------------===//; // Like std call, callee cleans arguments, convention except that ECX is; // reserved for storing the tail called function address. Only 2 registers are; // free for argument passing (inreg). Tail call optimization is performed; // provided:; // * tailcallopt is enabled; // * caller/callee are fastcc; // On X86_64 architecture with GOT-style position independent code only local; // (within module) calls are supported at the moment.; // To keep the stack aligned according to platform abi the function; // GetAlignedArgumentStackSize ensures that argument delta is always multiples; // of stack alignment. (Dynamic linkers need this - Darwin's dyld for example); // If a tail called function callee has more arguments than the caller the; // caller needs to make sure that there is room to move the RETADDR to. This is; // achieved by reserving an area the size of the argument delta right after the; // original RETADDR, but before the saved framepointer or the spilled registers; // e.g. caller(arg1, arg2) calls callee(arg1, arg2,arg3,arg4); // stack layout:; // arg1; // arg2; // RETADDR; // [ new RETADDR; // move area ]; // (possible EBP); // ESI; // EDI; // local1 ..; /// Make the stack size align e.g 16n + 12 aligned for a 16-byte align; /// requirement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:421,optimiz,optimization,421,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,2,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,//===----------------------------------------------------------------------===//; // Formal Arguments Calling Convention Implementation; //===----------------------------------------------------------------------===//; /// LowerFormalArguments - transform physical registers into virtual registers; /// and generate load operations for arguments places on the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:316,load,load,316,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['load'],['load']
Performance,//===----------------------------------------------------------------------===//; // Formatting and IO Library Call Optimizations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:116,Optimiz,Optimizations,116,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['Optimiz'],['Optimizations']
Performance,"//===----------------------------------------------------------------------===//; // Functions for running checkers for path-sensitive checking.; //===----------------------------------------------------------------------===//; /// Run checkers for pre-visiting Stmts.; ///; /// The notification is performed for every explored CFGElement, which does; /// not include the control flow statements such as IfStmt.; ///; /// \sa runCheckersForBranchCondition, runCheckersForPostStmt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h:299,perform,performed,299,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h,1,['perform'],['performed']
Performance,//===----------------------------------------------------------------------===//; // Helper functions; //===----------------------------------------------------------------------===//; /// A helper function that returns the pointer operand of a load or store; /// instruction. Returns nullptr if not load or store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:245,load,load,245,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['load'],['load']
Performance,//===----------------------------------------------------------------------===//; // Integer Library Call Optimizations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:106,Optimiz,Optimizations,106,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['Optimiz'],['Optimizations']
Performance,"//===----------------------------------------------------------------------===//; // Load, Store, Init; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:85,Load,Load,85,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,1,['Load'],['Load']
Performance,//===----------------------------------------------------------------------===//; // LoadAndStorePromoter Implementation; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:85,Load,LoadAndStorePromoter,85,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,1,['Load'],['LoadAndStorePromoter']
Performance,//===----------------------------------------------------------------------===//; // LoadInst Class; //===----------------------------------------------------------------------===//; /// An instruction for reading from memory. This uses the SubclassData field in; /// Value to store whether or not the load is volatile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:85,Load,LoadInst,85,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,"['Load', 'load']","['LoadInst', 'load']"
Performance,//===----------------------------------------------------------------------===//; // LoadInst Implementation; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:85,Load,LoadInst,85,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['Load'],['LoadInst']
Performance,//===----------------------------------------------------------------------===//; // Loading values from regions.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:85,Load,Loading,85,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['Load'],['Loading']
Performance,"//===----------------------------------------------------------------------===//; // Loop Strength Reduction hooks; //===----------------------------------------------------------------------===//; /// isLegalAddressingMode - Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:316,load,load,316,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['load'],['load']
Performance,//===----------------------------------------------------------------------===//; // MCJIT object cache class; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:98,cache,cache,98,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,2,['cache'],['cache']
Performance,//===----------------------------------------------------------------------===//; // MachineInstr latency interface.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:98,latency,latency,98,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['latency'],['latency']
Performance,//===----------------------------------------------------------------------===//; // Math Library Optimizations; //===----------------------------------------------------------------------===//; // Replace a libcall \p CI with a call to intrinsic \p IID,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:98,Optimiz,Optimizations,98,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['Optimiz'],['Optimizations']
Performance,//===----------------------------------------------------------------------===//; // Memory Optimization; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:92,Optimiz,Optimization,92,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Optimiz'],['Optimization']
Performance,"//===----------------------------------------------------------------------===//; // Object cache; //; // This object cache implementation writes cached objects to disk to the; // directory specified by CacheDir, using a filename provided in the module; // descriptor. The cache tries to load a saved object using that path if the; // file exists. CacheDir defaults to """", in which case objects are cached; // alongside their originating bitcodes.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:92,cache,cache,92,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,8,"['Cache', 'cache', 'load']","['CacheDir', 'cache', 'cached', 'load']"
Performance,"//===----------------------------------------------------------------------===//; // Optimization Methods; //===----------------------------------------------------------------------===//; /// If the specified instruction has a constant integer operand and there are; /// bits set in that constant that are not demanded, then clear those bits and; /// return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:85,Optimiz,Optimization,85,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['Optimiz'],['Optimization']
Performance,"//===----------------------------------------------------------------------===//; // Overview:; // The Pass Manager Infrastructure manages passes. It's responsibilities are:; //; // o Manage optimization pass execution order; // o Make required Analysis information available before pass P is run; // o Release memory occupied by dead passes; // o If Analysis information is dirtied by a pass then regenerate Analysis; // information before it is consumed by another pass.; //; // Pass Manager Infrastructure uses multiple pass managers. They are; // PassManager, FunctionPassManager, MPPassManager, FPPassManager, BBPassManager.; // This class hierarchy uses multiple inheritance but pass managers do not; // derive from another pass manager.; //; // PassManager and FunctionPassManager are two top-level pass manager that; // represents the external interface of this entire pass manager infrastucture.; //; // Important classes :; //; // [o] class PMTopLevelManager;; //; // Two top level managers, PassManager and FunctionPassManager, derive from; // PMTopLevelManager. PMTopLevelManager manages information used by top level; // managers such as last user info.; //; // [o] class PMDataManager;; //; // PMDataManager manages information, e.g. list of available analysis info,; // used by a pass manager to manage execution order of passes. It also provides; // a place to implement common pass manager APIs. All pass managers derive from; // PMDataManager.; //; // [o] class FunctionPassManager;; //; // This is a external interface used to manage FunctionPasses. This; // interface relies on FunctionPassManagerImpl to do all the tasks.; //; // [o] class FunctionPassManagerImpl : public ModulePass, PMDataManager,; // public PMTopLevelManager;; //; // FunctionPassManagerImpl is a top level manager. It manages FPPassManagers; //; // [o] class FPPassManager : public ModulePass, public PMDataManager;; //; // FPPassManager manages FunctionPasses and BBPassManagers; //; // [o] class MPPassManag",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:191,optimiz,optimization,191,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,1,['optimiz'],['optimization']
Performance,"//===----------------------------------------------------------------------===//; // Partial register updates; //===----------------------------------------------------------------------===//; //; // Swift renames NEON registers with 64-bit granularity. That means any; // instruction writing an S-reg implicitly reads the containing D-reg. The; // problem is mostly avoided by translating f32 operations to v2f32 operations; // on D-registers, but f32 loads are still a problem.; //; // These instructions can load an f32 into a NEON register:; //; // VLDRS - Only writes S, partial D update.; // VLD1LNd32 - Writes all D-regs, explicit partial D update, 2 uops.; // VLD1DUPd32 - Writes all D-regs, no partial reg update, 2 uops.; //; // FCONSTD can be used as a dependency-breaking instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:453,load,loads,453,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,2,['load'],"['load', 'loads']"
Performance,//===----------------------------------------------------------------------===//; // Perform initialization; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:85,Perform,Perform,85,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['Perform'],['Perform']
Performance,"//===----------------------------------------------------------------------===//; // PowerPC 970 Hazard Recognizer; //; // This models the dispatch group formation of the PPC970 processor. Dispatch; // groups are bundles of up to five instructions that can contain various mixes; // of instructions. The PPC970 can dispatch a peak of 4 non-branch and one; // branch instruction per-cycle.; //; // There are a number of restrictions to dispatch group formation: some; // instructions can only be issued in the first slot of a dispatch group, & some; // instructions fill an entire dispatch group. Additionally, only branches can; // issue in the 5th (last) slot.; //; // Finally, there are a number of ""structural"" hazards on the PPC970. These; // conditions cause large performance penalties due to misprediction, recovery,; // and replay logic that has to happen. These cases include setting a CTR and; // branching through it in the same dispatch group, and storing to an address,; // then loading from the same address within a dispatch group. To avoid these; // conditions, we insert no-op instructions when appropriate.; //; // FIXME: This is missing some significant cases:; // 1. Modeling of microcoded instructions.; // 2. Handling of serialized operations.; // 3. Handling of the esoteric cases in ""Resource-based Instruction Grouping"".; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:770,perform,performance,770,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,2,"['load', 'perform']","['loading', 'performance']"
Performance,"//===----------------------------------------------------------------------===//; // Properties of allocation functions; //; /// Return true if this is a call to an allocation function that does not have; /// side effects that we are required to preserve beyond the effect of; /// allocating a new object.; /// Ex: If our allocation routine has a counter for the number of objects; /// allocated, and the program prints it on exit, can the value change due; /// to optimization? Answer is highly language dependent.; /// Note: *Removable* really does mean removable; it does not mean observable.; /// A language (e.g. C++) can allow removing allocations without allowing; /// insertion or speculative execution of allocation routines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:465,optimiz,optimization,465,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,1,['optimiz'],['optimization']
Performance,"//===----------------------------------------------------------------------===//; // SCEV Utilities; //===----------------------------------------------------------------------===//; /// Compare the two values \p LV and \p RV in terms of their ""complexity"" where; /// ""complexity"" is a partial (and somewhat ad-hoc) relation used to order; /// operands in SCEV expressions. \p EqCache is a set of pairs of values that; /// have been previously deemed to be ""equally complex"" by this routine. It is; /// intended to avoid exponential time complexity in cases like:; ///; /// %a = f(%x, %y); /// %b = f(%a, %a); /// %c = f(%b, %b); ///; /// %d = f(%x, %y); /// %e = f(%d, %d); /// %f = f(%e, %e); ///; /// CompareValueComplexity(%f, %c); ///; /// Since we do not continue running this routine on expression trees once we; /// have seen unequal values, there is no need to track them in the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:888,cache,cache,888,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['cache'],['cache']
Performance,"//===----------------------------------------------------------------------===//; // SSACCmpConv; //===----------------------------------------------------------------------===//; //; // The SSACCmpConv class performs ccmp-conversion on SSA form machine code; // after determining if it is possible. The class contains no heuristics;; // external code should be used to determine when ccmp-conversion is a good; // idea.; //; // CCmp-formation works on a CFG representing chained conditions, typically; // from C's short-circuit || and && operators:; //; // From: Head To: Head; // / | CmpBB; // / | / |; // | CmpBB / |; // | / | Tail |; // | / | | |; // Tail | | |; // | | | |; // ... ... ... ...; //; // The Head block is terminated by a br.cond instruction, and the CmpBB block; // contains compare + br.cond. Tail must be a successor of both.; //; // The cmp-conversion turns the compare instruction in CmpBB into a conditional; // compare, and merges CmpBB into Head, speculatively executing its; // instructions. The AArch64 conditional compare instructions have an immediate; // operand that specifies the NZCV flag values when the condition is false and; // the compare isn't executed. This makes it possible to chain compares with; // different condition codes.; //; // Example:; //; // if (a == 5 || b == 17); // foo();; //; // Head:; // cmp w0, #5; // b.eq Tail; // CmpBB:; // cmp w1, #17; // b.eq Tail; // ...; // Tail:; // bl _foo; //; // Becomes:; //; // Head:; // cmp w0, #5; // ccmp w1, #17, 4, ne ; 4 = nZcv; // b.eq Tail; // ...; // Tail:; // bl _foo; //; // The ccmp condition code is the one that would cause the Head terminator to; // branch to CmpBB.; //; // FIXME: It should also be possible to speculate a block on the critical edge; // between Head and Tail, just like if-converting a diamond.; //; // FIXME: Handle PHIs in Tail by turning them into selects (if-conversion).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp:209,perform,performs,209,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,1,['perform'],['performs']
Performance,"//===----------------------------------------------------------------------===//; // SSAIfConv; //===----------------------------------------------------------------------===//; //; // The SSAIfConv class performs if-conversion on SSA form machine code after; // determining if it is possible. The class contains no heuristics; external; // code should be used to determine when if-conversion is a good idea.; //; // SSAIfConv can convert both triangles and diamonds:; //; // Triangle: Head Diamond: Head; // | \ / \_; // | \ / |; // | [TF]BB FBB TBB; // | / \ /; // | / \ /; // Tail Tail; //; // Instructions in the conditional blocks TBB and/or FBB are spliced into the; // Head block, and phis in the Tail block are converted to select instructions.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:205,perform,performs,205,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,1,['perform'],['performs']
Performance,//===----------------------------------------------------------------------===//; // ScalableVectorType Implementation; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:85,Scalab,ScalableVectorType,85,interpreter/llvm-project/llvm/lib/IR/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp,1,['Scalab'],['ScalableVectorType']
Performance,//===----------------------------------------------------------------------===//; // SelectionDAG Class; //===----------------------------------------------------------------------===//; /// doNotCSE - Return true if CSE should not be performed for this node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:235,perform,performed,235,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['perform'],['performed']
Performance,//===----------------------------------------------------------------------===//; // SelectionDAG latency interface.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:98,latency,latency,98,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['latency'],['latency']
Performance,"//===----------------------------------------------------------------------===//; // Snippets; //===----------------------------------------------------------------------===//; // When spilling a virtual register, we also spill any snippets it is connected; // to. The snippets are small live ranges that only have a single real use,; // leftovers from live range splitting. Spilling them enables memory operand; // folding or tightens the live range around the single use.; //; // This minimizes register pressure and maximizes the store-to-load distance for; // spill slots which can be important in tight loops.; /// isFullCopyOf - If MI is a COPY to or from Reg, return the other register,; /// otherwise return 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:542,load,load,542,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['load'],['load']
Performance,"//===----------------------------------------------------------------------===//; // SourceLocation manipulation methods.; //===----------------------------------------------------------------------===//; /// Return the FileID for a SourceLocation.; ///; /// This is the cache-miss path of getFileID. Not as hot as that function, but; /// still very important. It is responsible for finding the entry in the; /// SLocEntry tables that contains the specified location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:271,cache,cache-miss,271,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['cache'],['cache-miss']
Performance,"//===----------------------------------------------------------------------===//; // Spilling; //===----------------------------------------------------------------------===//; /// If MI is a load or store of StackSlot, it can be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:192,load,load,192,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['load'],['load']
Performance,//===----------------------------------------------------------------------===//; // String and Memory Library Call Optimizations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:116,Optimiz,Optimizations,116,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['Optimiz'],['Optimizations']
Performance,//===----------------------------------------------------------------------===//; // Target Optimization Hooks; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp:92,Optimiz,Optimization,92,interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,3,['Optimiz'],['Optimization']
Performance,"//===----------------------------------------------------------------------===//; // Trait classes that contain element comparison operators and type; // definitions used by ImutAVLTree, ImmutableSet, and ImmutableMap. These; // inherit from the profile traits (ImutProfileInfo) to include operations; // for element profiling.; //===----------------------------------------------------------------------===//; /// ImutContainerInfo - Generic definition of comparison operations for; /// elements of immutable containers that defaults to using; /// std::equal_to<> and std::less<> to perform comparison of elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:584,perform,perform,584,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,1,['perform'],['perform']
Performance,//===----------------------------------------------------------------------===//; // Transfer functions: Loads and stores.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:105,Load,Loads,105,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['Load'],['Loads']
Performance,"//===----------------------------------------------------------------------===//; // TruncInstCombine - looks for expression graphs dominated by trunc; // instructions and for each eligible graph, it will create a reduced bit-width; // expression and replace the old expression with this new one and remove the; // old one. Eligible expression graph is such that:; // 1. Contains only supported instructions.; // 2. Supported leaves: ZExtInst, SExtInst, TruncInst and Constant value.; // 3. Can be evaluated into type with reduced legal bit-width (or Trunc type).; // 4. All instructions in the graph must not have users outside the graph.; // Only exception is for {ZExt, SExt}Inst with operand type equal to the; // new reduced type chosen in (3).; //; // The motivation for this optimization is that evaluating and expression using; // smaller bit-width is preferable, especially for vectorization where we can; // fit more values in one vectorized instruction. In addition, this optimization; // may decrease the number of cast instructions, but will not increase it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:782,optimiz,optimization,782,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,2,['optimiz'],['optimization']
Performance,//===----------------------------------------------------------------------===//; // VE Target Optimization Support; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:95,Optimiz,Optimization,95,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['Optimiz'],['Optimization']
Performance,"//===----------------------------------------------------------------------===//; // Vector Widening Utilities; //===----------------------------------------------------------------------===//; // Utility function to find the type to chop up a widen vector for load/store; // TLI: Target lowering used to determine legal types.; // Width: Width left need to load/store.; // WidenVT: The widen vector type to load to/store from; // Align: If 0, don't allow use of a wider type; // WidenEx: If Align is not 0, the amount additional we can load/store from.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:261,load,load,261,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,4,['load'],['load']
Performance,"//===----------------------------------------------------------------------===//; // Vector shuffle lowering; //; // This is an experimental code path for lowering vector shuffles on x86. It is; // designed to handle arbitrary vector shuffles and blends, gracefully; // degrading performance as necessary. It works hard to recognize idiomatic; // shuffles and lower them to optimal instruction patterns without leaving; // a framework that allows reasonably efficient handling of all vector shuffle; // patterns.; //===----------------------------------------------------------------------===//; /// Tiny helper function to identify a no-op mask.; ///; /// This is a somewhat boring predicate function. It checks whether the mask; /// array input, which is assumed to be a single-input shuffle mask of the kind; /// used by the X86 shuffle instructions (not a fully general; /// ShuffleVectorSDNode mask) requires any shuffles to occur. Both undef and an; /// in-place shuffle are 'no-op's.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:280,perform,performance,280,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['performance']
Performance,"//===----------------------------------------------------------------------===//; // Verification and Construction; //===----------------------------------------------------------------------===//; /// HeaderMap::Create - This attempts to load the specified file as a header; /// map. If it doesn't look like a HeaderMap, it gives up and returns null.; /// If it looks like a HeaderMap but is obviously corrupted, it puts a reason; /// into the string error argument and returns null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp:239,load,load,239,interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderMap.cpp,1,['load'],['load']
Performance,//===----------------------------------------------------------------------===//; // X86 Optimization Hooks; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:89,Optimiz,Optimization,89,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Optimiz'],['Optimization']
Performance,"//===----------------------------------------------------------------------===//; // banerjeeMIVtest -; // Use Banerjee's Inequalities to test an MIV subscript pair.; // (Wolfe, in the race-car book, calls this the Extreme Value Test.); // Generally follows the discussion in Section 2.5.2 of; //; // Optimizing Supercompilers for Supercomputers; // Michael Wolfe; //; // The inequalities given on page 25 are simplified in that loops are; // normalized so that the lower bound is always 0 and the stride is always 1.; // For example, Wolfe gives; //; // LB^<_k = (A^-_k - B_k)^- (U_k - L_k - N_k) + (A_k - B_k)L_k - B_k N_k; //; // where A_k is the coefficient of the kth index in the source subscript,; // B_k is the coefficient of the kth index in the destination subscript,; // U_k is the upper bound of the kth index, L_k is the lower bound of the Kth; // index, and N_k is the stride of the kth index. Since all loops are normalized; // by the SCEV package, N_k = 1 and L_k = 0, allowing us to simplify the; // equation to; //; // LB^<_k = (A^-_k - B_k)^- (U_k - 0 - 1) + (A_k - B_k)0 - B_k 1; // = (A^-_k - B_k)^- (U_k - 1) - B_k; //; // Similar simplifications are possible for the other equations.; //; // When we can't determine the number of iterations for a loop,; // we use NULL as an indicator for the worst case, infinity.; // When computing the upper bound, NULL denotes +inf;; // for the lower bound, NULL denotes -inf.; //; // Return true if dependence disproved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:301,Optimiz,Optimizing,301,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['Optimiz'],['Optimizing']
Performance,"//===----------------------------------------------------------------------===//; // gcdMIVtest -; // Tests an MIV subscript pair for dependence.; // Returns true if any possible dependence is disproved.; // Marks the result as inconsistent.; // Can sometimes disprove the equal direction for 1 or more loops,; // as discussed in Michael Wolfe's book,; // High Performance Compilers for Parallel Computing, page 235.; //; // We spend some effort (code!) to handle cases like; // [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,; // but M and N are just loop-invariant variables.; // This should help us handle linearized subscripts;; // also makes this test a useful backup to the various SIV tests.; //; // It occurs to me that the presence of loop-invariant variables; // changes the nature of the test from ""greatest common divisor""; // to ""a common divisor"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:361,Perform,Performance,361,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['Perform'],['Performance']
Performance,"//===----------------------------------------------------------------------===//; // rewriteLoopExitValues - Optimize IV users outside the loop.; // As a side effect, reduces the amount of IV processing within the loop.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:109,Optimiz,Optimize,109,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['Optimiz'],['Optimize']
Performance,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeBase ---//; //===----------------------------------------------------------------------===//; //; // Both leaf and branch nodes store vectors of pairs.; // Leaves store ((KeyT, KeyT), ValT) pairs, branches use (NodeRef, KeyT).; //; // Keys and values are stored in separate arrays to avoid padding caused by; // different object alignments. This also helps improve locality of reference; // when searching the keys.; //; // The nodes don't know how many elements they contain - that information is; // stored elsewhere. Omitting the size field prevents padding and allows a node; // to fill the allocated cache lines completely.; //; // These are typical key and value sizes, the node branching factor (N), and; // wasted space when nodes are sized to fit in three cache lines (192 bytes):; //; // T1 T2 N Waste Used by; // 4 4 24 0 Branch<4> (32-bit pointers); // 8 4 16 0 Leaf<4,4>, Branch<4>; // 8 8 12 0 Leaf<4,8>, Branch<8>; // 16 4 9 12 Leaf<8,4>; // 16 8 8 0 Leaf<8,8>; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:714,cache,cache,714,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,2,['cache'],['cache']
Performance,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeRef ---//; //===----------------------------------------------------------------------===//; //; // B+-tree nodes can be leaves or branches, so we need a polymorphic node; // pointer that can point to both kinds.; //; // All nodes are cache line aligned and the low 6 bits of a node pointer are; // always 0. These bits are used to store the number of elements in the; // referenced node. Besides saving space, placing node sizes in the parents; // allow tree balancing algorithms to run without faulting cache lines for nodes; // that may not need to be modified.; //; // A NodeRef doesn't know whether it references a leaf node or a branch node.; // It is the responsibility of the caller to use the correct types.; //; // Nodes are never supposed to be empty, and it is invalid to store a node size; // of 0 in a NodeRef. The valid range of sizes is 1-64.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:344,cache,cache,344,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,2,['cache'],['cache']
Performance,"//===----------------------------------------------------------------------===//; //--- IntervalMapImpl::NodeSizer ---//; //===----------------------------------------------------------------------===//; //; // Compute node sizes from key and value types.; //; // The branching factors are chosen to make nodes fit in three cache lines.; // This may not be possible if keys or values are very large. Such large objects; // are handled correctly, but a std::map would probably give better performance.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:324,cache,cache,324,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,2,"['cache', 'perform']","['cache', 'performance']"
Performance,"//===----------------------------------------------------------------------===//; /// A description of a memory reference used in the backend.; /// Instead of holding a StoreInst or LoadInst, this class holds the address; /// Value of the reference along with a byte size and offset. This allows it; /// to describe lowered loads and stores. Also, the special PseudoSourceValue; /// objects can be used to represent loads and stores to memory locations; /// that aren't explicit in the regular LLVM IR.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h:182,Load,LoadInst,182,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineMemOperand.h,3,"['Load', 'load']","['LoadInst', 'loads']"
Performance,"//===----------------------------------------------------------------------===//; /// A single entry single exit Region.; ///; /// A Region is a connected subgraph of a control flow graph that has exactly; /// two connections to the remaining graph. It can be used to analyze or; /// optimize parts of the control flow graph.; ///; /// A <em> simple Region </em> is connected to the remaining graph by just two; /// edges. One edge entering the Region and another one leaving the Region.; ///; /// An <em> extended Region </em> (or just Region) is a subgraph that can be; /// transform into a simple Region. The transformation is done by adding; /// BasicBlocks that merge several entry or exit edges so that after the merge; /// just one entry and one exit edge exists.; ///; /// The \e Entry of a Region is the first BasicBlock that is passed after; /// entering the Region. It is an element of the Region. The entry BasicBlock; /// dominates all BasicBlocks in the Region.; ///; /// The \e Exit of a Region is the first BasicBlock that is passed after; /// leaving the Region. It is not an element of the Region. The exit BasicBlock,; /// postdominates all BasicBlocks in the Region.; ///; /// A <em> canonical Region </em> cannot be constructed by combining smaller; /// Regions.; ///; /// Region A is the \e parent of Region B, if B is completely contained in A.; ///; /// Two canonical Regions either do not intersect at all or one is; /// the parent of the other.; ///; /// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of; /// Regions in the control flow graph and E is the \e parent relation of these; /// Regions.; ///; /// Example:; ///; /// \verbatim; /// A simple control flow graph, that contains two regions.; ///; /// 1; /// / |; /// 2 |; /// / \ 3; /// 4 5 |; /// | | |; /// 6 7 8; /// \ | /; /// \ |/ Region A: 1 -> 9 {1,2,3,4,5,6,7,8}; /// 9 Region B: 2 -> 9 {2,4,5,6,7}; /// \endverbatim; ///; /// You can obtain more examples by either calling; ///; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:284,optimiz,optimize,284,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['optimiz'],['optimize']
Performance,"//===----------------------------------------------------------------------===//; /// FunctionPass class - This class is used to implement most global; /// optimizations. Optimizations should subclass this class if they meet the; /// following constraints:; ///; /// 1. Optimizations are organized globally, i.e., a function at a time; /// 2. Optimizing a function does not cause the addition or removal of any; /// functions in the module; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:156,optimiz,optimizations,156,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,4,"['Optimiz', 'optimiz']","['Optimizations', 'Optimizing', 'optimizations']"
Performance,//===----------------------------------------------------------------------===//; /// ModulePass class - This class is used to implement unstructured; /// interprocedural optimizations and analyses. ModulePasses may do anything; /// they want to the program.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:171,optimiz,optimizations,171,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,1,['optimiz'],['optimizations']
Performance,//===----------------------------------------------------------------------===//; /// Pass interface - Implemented by all 'passes'. Subclass this if you are an; /// interprocedural optimization or you do not fit into any of the more; /// constrained passes described below.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:181,optimiz,optimization,181,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,1,['optimiz'],['optimization']
Performance,"//===----------------------------------------------------------------------===//; /// This takes an arbitrary SelectionDAG as input and; /// hacks on it until the target machine can handle it. This involves; /// eliminating value sizes the machine cannot handle (promoting small sizes to; /// large sizes or splitting up large values into small values) as well as; /// eliminating operations the machine cannot handle.; ///; /// This code also does a small amount of optimization and recognition of idioms; /// as part of its processing. For example, if a target does not support a; /// 'setcc' instruction efficiently, but does support 'brcc' instruction, this; /// will attempt merge setcc and brc instructions into brcc's.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:467,optimiz,optimization,467,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['optimiz'],['optimization']
Performance,"//===----------------------------------------------------------------------===//; /// \class; /// Functions, function parameters, and return types can have attributes; /// to indicate how they should be treated by optimizations and code; /// generation. This class represents one of those attributes. It's light-weight; /// and should be passed around by-value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h:214,optimiz,optimizations,214,interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,1,['optimiz'],['optimizations']
Performance,//===----------------------------------------------------------------------===//; //; // EarlyCSE - This pass performs a simple and fast CSE pass over the dominator; // tree.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar.h:110,perform,performs,110,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar.h,1,['perform'],['performs']
Performance,//===----------------------------------------------------------------------===//; //; // LCSSA - This pass inserts phi nodes at loop boundaries to simplify other loop; // optimizations.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils.h:171,optimiz,optimizations,171,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils.h,1,['optimiz'],['optimizations']
Performance,"//===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load ba",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1299,load,load,1299,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,2,['load'],"['load', 'loads']"
Performance,//===----------------------------------------------------------------------===//; //; // LoopDataPrefetch - Perform data prefetching in loops.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar.h:108,Perform,Perform,108,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar.h,1,['Perform'],['Perform']
Performance,"//===----------------------------------------------------------------------===//; //; // PromoteMemoryToRegister - This pass is used to promote memory references to; // be register references. A simple example of the transformation performed by; // this pass is:; //; // FROM CODE TO CODE; // %X = alloca i32, i32 1 ret i32 42; // store i32 42, i32 *%X; // %Y = load i32* %X; // ret i32 %Y; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils.h:232,perform,performed,232,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils.h,2,"['load', 'perform']","['load', 'performed']"
Performance,"//===----------------------------------------------------------------------===//; //; // Stack Frame Processing methods; // +----------------------------+; //; // The stack is allocated decrementing the stack pointer on; // the first instruction of a function prologue. Once decremented,; // all stack references are done thought a positive offset; // from the stack/frame pointer, so the stack is considering; // to grow up! Otherwise terrible hacks would have to be made; // to get this stack ABI compliant :); //; // The stack frame required by the ABI (after call):; // Offset; //; // 0 ----------; // 4 Args to pass; // . saved $GP (used in PIC); // . Alloca allocations; // . Local Area; // . CPU ""Callee Saved"" Registers; // . saved FP; // . saved RA; // . FPU ""Callee Saved"" Registers; // StackSize -----------; //; // Offset - offset from sp after stack allocation on function prologue; //; // The sp is the stack pointer subtracted/added from the stack size; // at the Prologue/Epilogue; //; // References to the previous stack (to obtain arguments) are done; // with offsets that exceeds the stack size: (stacksize+(4*(num_arg-1)); //; // Examples:; // - reference to the actual stack frame; // for any local area var there is smt like : FI >= 0, StackOffset: 4; // sw REGX, 4(SP); //; // - reference to previous stack frame; // suppose there's a load to the 5th arguments : FI < 0, StackOffset: 16.; // The emitted instruction will be something like:; // lw REGX, 16+StackSize(SP); //; // Since the total stack size is unknown on LowerFormalArguments, all; // stack references (ObjectOffset) created to reference the function; // arguments, are negative numbers. This way, on eliminateFrameIndex it's; // possible to detect those references and the offsets are adjusted to; // their real location.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp:1358,load,load,1358,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFrameLowering.cpp,1,['load'],['load']
Performance,//===----------------------------------------------------------------------===//; //; // TBD:; // fastLowerArguments: Handle simple cases.; // PPCMaterializeGV: Handle TLS.; // SelectCall: Handle function pointers.; // SelectCall: Handle multi-register return values.; // SelectCall: Optimize away nops for local calls.; // processCallArgs: Handle bit-converted arguments.; // finishCall: Handle multi-register return values.; // PPCComputeAddress: Handle parameter references as FrameIndex's.; // PPCEmitCmp: Handle immediate as operand 1.; // SelectCall: Handle small byval arguments.; // SelectIntrinsicCall: Implement.; // SelectSelect: Implement.; // Consider factoring isTypeLegal into the base class.; // Implement switches and jump tables.; //; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:284,Optimiz,Optimize,284,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['Optimiz'],['Optimize']
Performance,"//===----------------------------------------------------------------------===//; //; // createScalarizeMaskedMemIntrinPass - Replace masked load, store, gather; // and scatter intrinsics with scalar code when target doesn't support them.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar.h:141,load,load,141,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar.h,1,['load'],['load']
Performance,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:220,optimiz,optimize,220,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['optimiz'],['optimize']
Performance,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//; /// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:294,optimiz,optimized,294,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,3,['optimiz'],['optimized']
