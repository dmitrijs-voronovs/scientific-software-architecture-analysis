quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"//!cached streamer info used in the last read.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClass.h:3,cache,cached,3,core/meta/inc/TClass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/inc/TClass.h,1,['cache'],['cached']
Performance,"//""Cache"" of ids.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/src/CocoaPrivate.h:3,Cache,Cache,3,graf2d/cocoa/src/CocoaPrivate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/cocoa/src/CocoaPrivate.h,1,['Cache'],['Cache']
Performance,"//#ifdef MINUIT2_THREAD_SAFE; // thread-safe version (do not use cache)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserTransformation.h:65,cache,cache,65,math/minuit2/inc/Minuit2/MnUserTransformation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserTransformation.h,1,['cache'],['cache']
Performance,//%tape.%d = load i8 *%head.%d,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp:13,load,load,13,interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.cpp,3,['load'],['load']
Performance,"//( GetNClasses() == 1 ? 0 : 1 ); ;; // Perform PCA and put it into PCAed events tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariablePCATransform.cxx:40,Perform,Perform,40,tmva/tmva/src/VariablePCATransform.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariablePCATransform.cxx,1,['Perform'],['Perform']
Performance,"//(const_cast<TChain*>(this))->LoadTree(fTreeOffset[treenum]);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx:31,Load,LoadTree,31,tree/tree/src/TChain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TChain.cxx,1,['Load'],['LoadTree']
Performance,//(load 48i8 and) deinterleave into 3 x 16i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:3,load,load,3,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['load'],['load']
Performance,//(load 96i8 and) deinterleave into 3 x 32i8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:3,load,load,3,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,2,['load'],['load']
Performance,//*****************************************************************************; //**** InsertNOPLoad pass; //*****************************************************************************; // This pass fixes the incorrectly working Load instructions that exists for; // some earlier versions of the LEON processor line. NOP instructions must; // be inserted after the load instruction to ensure that the Load instruction; // behaves as expected for these processors.; //; // This pass inserts a NOP after any LD or LDF instruction.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:232,Load,Load,232,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,3,"['Load', 'load']","['Load', 'load']"
Performance,"//*-*-*-*-*-*-*-*-*-*Perform a line search from position st along step *-*-*-*-*-*-*-*; //*-* =========================================; //*-* SLAMBG and ALPHA control the maximum individual steps allowed.; //*-* The first step is always =1. The max length of second step is SLAMBG.; //*-* The max size of subsequent steps is the maximum previous successful; //*-* step multiplied by ALPHA + the size of most recent successful step,; //*-* but cannot be smaller than SLAMBG.; //*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnLineSearch.cxx:21,Perform,Perform,21,math/minuit2/src/MnLineSearch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnLineSearch.cxx,1,['Perform'],['Perform']
Performance,"//- X86Insertwait.cpp - Strict-Fp:Insert wait instruction X87 instructions --//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the pass which insert x86 wait instructions after each; // X87 instructions when strict float is enabled.; //; // The logic to insert a wait instruction after an X87 instruction is as below:; // 1. If the X87 instruction don't raise float exception nor is a load/store; // instruction, or is a x87 control instruction, don't insert wait.; // 2. If the X87 instruction is an instruction which the following instruction; // is an X87 exception synchronizing X87 instruction, don't insert wait.; // 3. For other situations, insert wait instruction.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp:658,load,load,658,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertWait.cpp,1,['load'],['load']
Performance,"//- custom iterator for high performance std::vector iteration ---------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.h:29,perform,performance,29,bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CustomPyTypes.h,1,['perform'],['performance']
Performance,"//-- SystemZMachineScheduler.cpp - SystemZ Scheduler Interface -*- C++ -*---==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // -------------------------- Post RA scheduling ---------------------------- //; // SystemZPostRASchedStrategy is a scheduling strategy which is plugged into; // the MachineScheduler. It has a sorted Available set of SUs and a pickNode(); // implementation that looks to optimize decoder grouping and balance the; // usage of processor resources. Scheduler states are saved for the end; // region of each MBB, so that a successor block can learn from it.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:652,optimiz,optimize,652,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['optimiz'],['optimize']
Performance,"//-- cache and package management",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:5,cache,cache,5,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['cache'],['cache']
Performance,"//--- Load desired plugin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TFileStager.h:6,Load,Load,6,net/net/inc/TFileStager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/inc/TFileStager.h,1,['Load'],['Load']
Performance,"//---- Dynamic Loading --------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/inc/TUnixSystem.h:15,Load,Loading,15,core/unix/inc/TUnixSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/inc/TUnixSystem.h,1,['Load'],['Loading']
Performance,"//---- Dynamic Loading ---------------------------------------------------------; ////////////////////////////////////////////////////////////////////////////////; /// Add a new directory to the dynamic path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:15,Load,Loading,15,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['Load'],['Loading']
Performance,"//---- Macro to load a library into the interpreter --------------; // Call as R__LOAD_LIBRARY(libEvent); // This macro intentionally does not take string as argument, to; // prevent compilation errors with complex diagnostics due to; // TString BAD_DO_NOT_TRY = ""lib"";; // R__LOAD_LIBRARY(BAD_DO_NOT_TRY + ""BAD_DO_NOT_TRY.so"") // ERROR!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Rtypes.h:16,load,load,16,core/base/inc/Rtypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Rtypes.h,1,['load'],['load']
Performance,"//---- RQ_OBJECT macro -----------------------------------------------; //; // Macro is used to delegate TQObject methods to other classes; // Example:; //; // #include ""RQ_OBJECT.h""; //; // class A {; // RQ_OBJECT(""A""); // private:; // Int_t fValue;; // public:; // A() : fValue(0) { }; // ~A() { }; //; // void SetValue(Int_t value); // void PrintValue() const { printf(""value=%d\n"", fValue); }; // Int_t GetValue() const { return fValue; }; // };; //; // void A::SetValue(Int_t value); // {; // // Sets new value; //; // // to prevent infinite looping in the case; // // of cyclic connections; // if (value != fValue) {; // fValue = value;; // Emit(""SetValue(Int_t)"", fValue);; // }; // }; //; // Load this class into root session and try the following:; //; // a = new A();; // b = new A();; //; // Here is one way to connect two of these objects together:; //; // a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; //; // Calling a->SetValue(79) will make a emit a signal, which b; // will receive, i.e. b->SetValue(79) is invoked. b will in; // turn emit the same signal, which nobody receives, since no; // slot has been connected to it, so it disappears into hyperspace.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/RQ_OBJECT.h:700,Load,Load,700,core/base/inc/RQ_OBJECT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/RQ_OBJECT.h,1,['Load'],['Load']
Performance,"//----------------------------------------------------------------------------; // Cache this streamer info; /////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:83,Cache,Cache,83,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['Cache'],['Cache']
Performance,"//------------------------------------------------------------------------; // Load unloaded branch; //------------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx:79,Load,Load,79,tree/tree/src/TBranchSTL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchSTL.cxx,1,['Load'],['Load']
Performance,"//----------------------------------------------------------------------; // Information about each image on the HTML widget is held in an instance; // of the following class. All images are held on a list attached to the; // main widget object.; //; // This class is NOT an element. The <IMG> element is represented by an; // TGHtmlImageMarkup object below. There is one TGHtmlImageMarkup for each; // <IMG> in the source HTML. There is one of these objects for each unique; // image loaded. (If two <IMG> specify the same image, there are still two; // TGHtmlImageMarkup objects but only one TGHtmlImage object that is shared; // between them.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:485,load,loaded,485,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['load'],['loaded']
Performance,"//----------------------------------------------------------------------; // Various data types. This code is designed to run on a modern cached; // architecture where the CPU runs a lot faster than the memory bus. Hence; // we try to pack as much data into as small a space as possible so that it; // is more likely to fit in cache. The extra CPU instruction or two needed; // to unpack the data is not normally an issue since we expect the speed of; // the memory bus to be the limiting factor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:138,cache,cached,138,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,2,['cache'],"['cache', 'cached']"
Performance,"//------------------------------------------------------------------; /// Extract a uint16_t value from \a *offset_ptr.; ///; /// Extract a single uint16_t from the binary data at the offset; /// pointed to by \a offset_ptr, and update the offset on success.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted uint16_t value.; //------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:826,perform,performed,826,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['perform'],['performed']
Performance,"/// ""Eliminate"" a swifterror argument by reducing it to the alloca case; /// and then loading and storing in the prologue and epilog.; ///; /// The argument keeps the swifterror flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:86,load,loading,86,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['load'],['loading']
Performance,"/// ""Forget"" about the partially-substituted pack template argument,; /// when performing an instantiation that must preserve the parameter pack; /// use.; ///; /// This routine is meant to be overridden by the template instantiator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:79,perform,performing,79,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performing']
Performance,"/// ""Remember"" the partially-substituted pack template argument; /// after performing an instantiation that must preserve the parameter pack; /// use.; ///; /// This routine is meant to be overridden by the template instantiator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:75,perform,performing,75,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performing']
Performance,"/// #pragma optimize(""[optimization-list]"", on | off).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:12,optimiz,optimize,12,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['optimiz'],"['optimization-list', 'optimize']"
Performance,/// * Vector-of-non-pointer (isPointer == 0 && isVector == 1):; /// NumElements: 16;; /// SizeOfElement: 32;; /// Scalable: 1;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:114,Scalab,Scalable,114,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,1,['Scalab'],['Scalable']
Performance,/// * Vector-of-pointer (isPointer == 1 && isVector == 1):; /// NumElements: 16;; /// SizeOfElement: 16;; /// AddressSpace: 24;; /// Scalable: 1;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:133,Scalab,Scalable,133,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,1,['Scalab'],['Scalable']
Performance,"/// ------------------------------------------------------------------; /// The core of the Dwarf linking logic.; ///; /// The generation of the dwarf information from the object files will be; /// driven by the selection of 'root DIEs', which are DIEs that; /// describe variables or functions that resolves to the corresponding; /// code section(and thus have entries in the Addresses map). All the debug; /// information that will be generated(the DIEs, but also the line; /// tables, ranges, ...) is derived from that set of root DIEs.; ///; /// The root DIEs are identified because they contain relocations that; /// points to code section(the low_pc for a function, the location for; /// a variable). These relocations are gathered as a very first step; /// when we start processing a object file by AddressesMap.; ///; /// The overall linking process looks like this:; ///; /// parrallel_for_each(ObjectFile) {; /// for_each (Compile Unit) {; /// 1. Load Clang modules.; /// }; ///; /// parrallel_for_each(Compile Unit) {; /// 1. Load input DWARF for Compile Unit.; /// 2. Report warnings for Clang modules.; /// 3. Analyze live DIEs and type names(if ODR deduplication is requested).; /// 4. Clone DIEs(Generate output DIEs and resulting DWARF tables).; /// The result is in an OutDebugInfoBytes, which is an ELF file; /// containing DWARF tables corresponding to the current compile unit.; /// 5. Cleanup Input and Output DIEs.; /// }; ///; /// Deallocate loaded Object file.; /// }; ///; /// if (ODR deduplication is requested); /// Generate an artificial compilation unit (""Type Table"": used to partially; /// generate DIEs at the clone stage).; ///; /// for_each (ObjectFile) {; /// for_each (Compile Unit) {; /// 1. Set offsets to Compile Units DWARF tables.; /// 2. Sort offsets/attributes/patches to have a predictable result.; /// 3. Patch size/offsets fields.; /// 4. Generate index tables.; /// 5. Move DWARF tables of compile units into the resulting file.; /// }; /// }; ///; /// E",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h:957,Load,Load,957,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Parallel/DWARFLinker.h,1,['Load'],['Load']
Performance,"/// 1 for loads, 0 for stores. (see comment in SUList)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:10,load,loads,10,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['load'],['loads']
Performance,/// 1) Pops a pointer from the stack; /// 2) Load the value from the pointer; /// 3) Writes the value decreased by one back to the pointer,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:45,Load,Load,45,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,1,['Load'],['Load']
Performance,/// 1) Pops a pointer from the stack; /// 2) Load the value from the pointer; /// 3) Writes the value decreased by one back to the pointer; /// 4) Pushes the original (pre-dec) value on the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:45,Load,Load,45,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,1,['Load'],['Load']
Performance,/// 1) Pops a pointer from the stack; /// 2) Load the value from the pointer; /// 3) Writes the value increased by one back to the pointer,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:45,Load,Load,45,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,1,['Load'],['Load']
Performance,/// 1) Pops a pointer from the stack; /// 2) Load the value from the pointer; /// 3) Writes the value increased by one back to the pointer; /// 4) Pushes the original (pre-inc) value on the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:45,Load,Load,45,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,1,['Load'],['Load']
Performance,/// 32-bit load config (IMAGE_LOAD_CONFIG_DIRECTORY32),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h:11,load,load,11,interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,1,['load'],['load']
Performance,/// 64-bit load config (IMAGE_LOAD_CONFIG_DIRECTORY64),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h:11,load,load,11,interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/COFF.h,1,['load'],['load']
Performance,"/// < Invalid indicates there is no way to represent the cost as a; /// numeric value. This state exists to represent a possible issue,; /// e.g. if the cost-model knows the operation cannot be expanded; /// into a valid code-sequence by the code-generator. While some; /// passes may assert that the calculated cost must be valid, it is; /// up to individual passes how to interpret an Invalid cost. For; /// example, a transformation pass could choose not to perform a; /// transformation if the resulting cost would end up Invalid.; /// Because some passes may assert a cost is Valid, it is not; /// recommended to use Invalid costs to model 'Unknown'.; /// Note that Invalid is semantically different from a (very) high,; /// but valid cost, which intentionally indicates no issue, but; /// rather a strong preference not to select a certain operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/InstructionCost.h:461,perform,perform,461,interpreter/llvm-project/llvm/include/llvm/Support/InstructionCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/InstructionCost.h,1,['perform'],['perform']
Performance,/// <summary>; /// Returns the cached ResourceManager instance used by this class.; /// </summary>,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Resources.Designer.cs:31,cache,cached,31,interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Resources.Designer.cs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format-vs/ClangFormat/Resources.Designer.cs,1,['cache'],['cached']
Performance,"/// @brief Close the file object. This should be used instead of ::close for; /// portability. On error, the caller should assume the file is closed, as is; /// the case for Process::SafelyCloseFileDescriptor; ///; /// @param F On input, this is the file to close. On output, the file is; /// set to kInvalidFile.; ///; /// @returns An error code if closing the file failed. Typically, an error here; /// means that the filesystem may have failed to perform some buffered writes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:450,perform,perform,450,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['perform'],['perform']
Performance,"/// @brief Gets the result for the given node using the node name. This node also performs the necessary; /// code generation through recursive calls to 'translate'. A call to this function modifies the already; /// existing code body.; /// @param key The node to get the result string for.; /// @return String representing the result of this node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx:82,perform,performs,82,roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Detail/CodeSquashContext.cxx,1,['perform'],['performs']
Performance,"/// @brief Return the entry range in the sample that is being taken into consideration.; ///; /// Multiple multi-threading tasks might process different entry ranges of the same sample.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx:107,multi-thread,multi-threading,107,tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RSampleInfo.hxx,1,['multi-thread'],['multi-threading']
Performance,"/// @class RangeSet is a persistent set of non-overlapping ranges.; ///; /// New RangeSet objects can be ONLY produced by RangeSet::Factory object, which; /// also supports the most common operations performed on range sets.; ///; /// Empty set corresponds to an overly constrained symbol meaning that there; /// are no possible values for that symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h:200,perform,performed,200,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,1,['perform'],['performed']
Performance,/// @name Cache for Blocks Runtime Globals; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:10,Cache,Cache,10,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['Cache'],['Cache']
Performance,/// @name Cache for Objective-C runtime types; /// @{; /// Cached reference to the class for constant strings. This value has type; /// int * but is actually an Obj-C class pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:10,Cache,Cache,10,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,2,['Cache'],"['Cache', 'Cached']"
Performance,"/// @name Configuration; /// @{; /// Whether to perform case-sensitive comparisons.; ///; /// Currently, case-insensitive matching only works correctly with ASCII.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h:48,perform,perform,48,interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,1,['perform'],['perform']
Performance,/// @name FlushStmt Caches; /// @{; /// Set of parent Stmts for the currently serializing sub-stmt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h:20,Cache,Caches,20,interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,1,['Cache'],['Caches']
Performance,"/// @name Materialization; /// Materialization is used to construct functions only as they're needed.; /// This; /// is useful to reduce memory usage in LLVM or parsing work done by the; /// BitcodeReader to load the Module.; /// @{; /// If this function's Module is being lazily streamed in functions from disk; /// or some other source, this method can be used to check to see if the; /// function has been read in yet or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:208,load,load,208,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['load'],['load']
Performance,"/// @}; // Emits code that executes when the comparison result in the ll/sc; // expansion of a cmpxchg instruction is such that the store-conditional will; // not execute. This makes it possible to balance out the load-linked with; // a dedicated instruction, if desired.; // E.g., on ARM, if ldrex isn't followed by strex, the exclusive monitor would; // be unnecessarily held, except if clrex, inserted by this hook, is executed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:214,load,load-linked,214,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load-linked']
Performance,/// @}; /// Get the type from the cache or return null type if it doesn't; /// exist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:34,cache,cache,34,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['cache'],['cache']
Performance,"/// @}; /// Inserts in the IR a target-specific intrinsic specifying a fence.; /// It is called by AtomicExpandPass before expanding an; /// AtomicRMW/AtomicCmpXchg/AtomicStore/AtomicLoad; /// if shouldInsertFencesForAtomic returns true.; ///; /// Inst is the original atomic instruction, prior to other expansions that; /// may be performed.; ///; /// This function should either return a nullptr, or a pointer to an IR-level; /// Instruction*. Even complex fence sequences can be represented by a; /// single Instruction* through an intrinsic to be lowered later.; ///; /// The default implementation emits an IR fence before any release (or; /// stronger) operation that stores, and after any acquire (or stronger); /// operation. This is generally a correct implementation, but backends may; /// override if they wish to use alternative schemes (e.g. the PowerPC; /// standard ABI uses a fence before a seq_cst load instead of after a; /// seq_cst store).; /// @{",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:332,perform,performed,332,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,"['load', 'perform']","['load', 'performed']"
Performance,"/// @}; /// Retrieves a ToolChain for a particular device \p Target triple; ///; /// \param[in] HostTC is the host ToolChain paired with the device; ///; /// \param[in] TargetDeviceOffloadKind (e.g. OFK_Cuda/OFK_OpenMP/OFK_SYCL) is; /// an Offloading action that is optionally passed to a ToolChain (used by; /// CUDA, to specify if it's used in conjunction with OpenMP); ///; /// Will cache ToolChains for the life of the driver object, and create them; /// on-demand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:386,cache,cache,386,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['cache'],['cache']
Performance,"/// @}; /// Returns true if we should normalize; /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and; /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)) if it is likely; /// that it saves us from materializing N0 and N1 in an integer register.; /// Targets that are able to perform and/or on flags should return false here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:293,perform,perform,293,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['perform']
Performance,/// @}; /// \name Cache TTI Implementation; /// @{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.h:18,Cache,Cache,18,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.h,1,['Cache'],['Cache']
Performance,"/// @}; /// \name Scalar Target Information; /// @{; /// Flags indicating the kind of support for population count.; ///; /// Compared to the SW implementation, HW support is supposed to; /// significantly boost the performance when the population is dense, and it; /// may or may not degrade performance if the population is sparse. A HW; /// support is considered as ""Fast"" if it can outperform, or is on a par; /// with, SW implementation when the population is sparse; otherwise, it is; /// considered as ""Slow"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:216,perform,performance,216,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,2,['perform'],['performance']
Performance,"/// @}; ///; /// \defgroup ARCOpt ARC Optimization.; /// @{; // TODO: On code like this:; //; // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); // stuff_that_cannot_release(); // objc_retain(%x); // stuff_that_cannot_release(); // objc_autorelease(%x); //; // The second retain and autorelease can be deleted.; // TODO: It should be possible to delete; // objc_autoreleasePoolPush and objc_autoreleasePoolPop; // pairs if nothing is actually autoreleased between them. Also, autorelease; // calls followed by objc_autoreleasePoolPop calls (perhaps in ObjC++ code; // after inlining) can be turned into plain release calls.; // TODO: Critical-edge splitting. If the optimial insertion point is; // a critical edge, the current algorithm has to fail, because it doesn't; // know how to split edges. It should be possible to make the optimizer; // think in terms of edges, rather than blocks, and then split critical; // edges on demand.; // TODO: OptimizeSequences could generalized to be Interprocedural.; // TODO: Recognize that a bunch of other objc runtime calls have; // non-escaping arguments and non-releasing arguments, and may be; // non-autoreleasing.; // TODO: Sink autorelease calls as far as possible. Unfortunately we; // usually can't sink them past other calls, which would be the main; // case where it would be useful.; // TODO: The pointer returned from objc_loadWeakRetained is retained.; // TODO: Delete release+retain pairs (rare).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:38,Optimiz,Optimization,38,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,3,"['Optimiz', 'optimiz']","['Optimization', 'OptimizeSequences', 'optimizer']"
Performance,/// @}}; /// High level function that adds all passes necessary to go from llvm IR; /// representation to the MI representation.; /// Adds IR based lowering and target specific optimization passes and finally; /// the core instruction selection passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:177,optimiz,optimization,177,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,1,['optimiz'],['optimization']
Performance,"/// A ""string"" used to describe how code completion can; /// be performed for an entity.; ///; /// A code completion string typically shows how a particular entity can be; /// used. For example, the code completion string for a function would show; /// the syntax to call it, including the parentheses, placeholders for the; /// arguments, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:64,perform,performed,64,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['perform'],['performed']
Performance,"/// A C++ @c dynamic_cast expression (C++ [expr.dynamic.cast]).; ///; /// This expression node represents a dynamic cast, e.g.,; /// \c dynamic_cast<Derived*>(BasePtr). Such a cast may perform a run-time; /// check to determine how to perform the type conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:185,perform,perform,185,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,2,['perform'],['perform']
Performance,"/// A C++ @c reinterpret_cast expression (C++ [expr.reinterpret.cast]).; ///; /// This expression node represents a reinterpret cast, e.g.,; /// @c reinterpret_cast<int>(VoidPtr).; ///; /// A reinterpret_cast provides a differently-typed view of a value but; /// (in Clang, as in most C++ implementations) performs no actual work at; /// run time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:306,perform,performs,306,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['perform'],['performs']
Performance,"/// A CallbackVH to notify PhiValues when a value is deleted or replaced, so; /// that the cached information for that value can be cleared to avoid; /// dangling pointers to invalid values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:91,cache,cached,91,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,1,['cache'],['cached']
Performance,/// A Clang invocation that's based on the original TU invocation and that has; /// been partially transformed into one that can perform explicit build of; /// a discovered modular dependency. Note that this still needs to be adjusted; /// for each individual module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h:129,perform,perform,129,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/ModuleDepCollector.h,1,['perform'],['perform']
Performance,"/// A CompileUnit provides an anchor for all debugging; /// information generated during this instance of compilation.; /// \param Lang Source programming language, eg. dwarf::DW_LANG_C99; /// \param File File info.; /// \param Producer Identify the producer of debugging information; /// and code. Usually this is a compiler; /// version string.; /// \param isOptimized A boolean flag which indicates whether optimization; /// is enabled or not.; /// \param Flags This string lists command line options. This; /// string is directly embedded in debug info; /// output which may be used by a tool; /// analyzing generated debugging information.; /// \param RV This indicates runtime version for languages like; /// Objective-C.; /// \param SplitName The name of the file that we'll split debug info; /// out into.; /// \param Kind The kind of debug information to generate.; /// \param DWOId The DWOId if this is a split skeleton compile unit.; /// \param SplitDebugInlining Whether to emit inline debug info.; /// \param DebugInfoForProfiling Whether to emit extra debug info for; /// profile collection.; /// \param NameTableKind Whether to emit .debug_gnu_pubnames,; /// .debug_pubnames, or no pubnames at all.; /// \param SysRoot The clang system root (value of -isysroot).; /// \param SDK The SDK name. On Darwin, this is the last component; /// of the sysroot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h:410,optimiz,optimization,410,interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h,1,['optimiz'],['optimization']
Performance,"/// A DynamicLibrarySearchGenerator that uses ResourceTracker to remember; /// which symbols were resolved through dlsym during a transaction's reign.; /// Enables JITDyLib forgetting symbols upon unloading of a shared library.; /// While JITDylib::define() *is* invoked for these symbols, there is no RT; /// provided, and thus resource tracking doesn't work, no symbol removal; /// happens upon unloading the corresponding shared library.; ///; /// This might remove more symbols than strictly needed:; /// 1. libA is loaded; /// 2. libB is loaded; /// 3. symbol is resolved from libA; /// 4. libB is unloaded, removing the symbol, too; /// That's fine, it will trigger a subsequent dlsym to re-create the symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:520,load,loaded,520,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,2,['load'],['loaded']
Performance,/// A MapVector that performs no allocations if smaller than a certain; /// size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h:21,perform,performs,21,interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/MapVector.h,1,['perform'],['performs']
Performance,"/// A PC-relative REX load of a GOT entry, relaxable if GOT entry target; /// is in-range of the fixup.; ///; /// If the GOT entry target is in-range of the fixup then the load from the; /// GOT may be replaced with a direct memory address calculation.; ///; /// Fixup expression:; /// Fixup <- Target - (Fixup + 4) + Addend : int32; ///; /// Errors:; /// - The result of the fixup expression must fit into an int32, otherwise; /// an out-of-range error will be returned.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h:22,load,load,22,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h,2,['load'],['load']
Performance,"/// A PC-relative REX load of a Thread Local Variable Pointer (TLVP) entry,; /// relaxable if the TLVP entry target is in-range of the fixup.; ///; /// If the TLVP entry target is in-range of the fixup then the load from the; /// TLVP may be replaced with a direct memory address calculation.; ///; /// The target of this edge must be a thread local variable entry of the form; /// .quad <tlv getter thunk>; /// .quad <tlv key>; /// .quad <tlv initializer>; ///; /// Fixup expression:; /// Fixup <- Target - (Fixup + 4) + Addend : int32; ///; /// Errors:; /// - The result of the fixup expression must fit into an int32, otherwise; /// an out-of-range error will be returned.; /// - The target must be either external, or a TLV entry of the required; /// form, otherwise a malformed TLV entry error will be returned.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h:22,load,load,22,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h,2,['load'],['load']
Performance,"/// A PC-relative load of a GOT entry, relaxable if GOT entry target is; /// in-range of the fixup; ///; /// TODO: Explain the optimization; ///; /// Fixup expression; /// Fixup <- Target - (Fixup + 4) + Addend : int32; ///; /// Errors:; /// - The result of the fixup expression must fit into an int32, otherwise; /// an out-of-range error will be returned.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h:18,load,load,18,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h,2,"['load', 'optimiz']","['load', 'optimization']"
Performance,"/// A Recipe for widening load/store operations.; /// The recipe uses the following VPValues:; /// - For load: Address, optional mask; /// - For store: Address, stored value, optional mask; /// TODO: We currently execute only per-part unless a specific instance is; /// provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:26,load,load,26,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,2,['load'],['load']
Performance,"/// A RecursiveASTVisitor subclass that guarantees that AST traversal is; /// performed in a lexical order (i.e. the order in which declarations are; /// written in the source).; ///; /// RecursiveASTVisitor doesn't guarantee lexical ordering because there are; /// some declarations, like Objective-C @implementation declarations; /// that might be represented in the AST differently to how they were written; /// in the source.; /// In particular, Objective-C @implementation declarations may contain; /// non-Objective-C declarations, like functions:; ///; /// @implementation MyClass; ///; /// - (void) method { }; /// void normalFunction() { }; ///; /// @end; ///; /// Clang's AST stores these declarations outside of the @implementation; /// declaration, so the example above would be represented using the following; /// AST:; /// |-ObjCImplementationDecl ... MyClass; /// | `-ObjCMethodDecl ... method; /// | ...; /// `-FunctionDecl ... normalFunction; /// ...; ///; /// This class ensures that these declarations are traversed before the; /// corresponding TraverseDecl for the @implementation returns. This ensures; /// that the lexical parent relationship between these declarations and the; /// @implementation is preserved while traversing the AST. Note that the; /// current implementation doesn't mix these declarations with the declarations; /// contained in the @implementation, so the traversal of all of the; /// declarations in the @implementation still doesn't follow the lexical order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/LexicallyOrderedRecursiveASTVisitor.h:78,perform,performed,78,interpreter/llvm-project/clang/include/clang/AST/LexicallyOrderedRecursiveASTVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/LexicallyOrderedRecursiveASTVisitor.h,1,['perform'],['performed']
Performance,"/// A RooProdPdf with a fixed normalization set can be replaced by this class.; /// Its purpose is to provide the right client-server interface for the; /// evaluation of RooProdPdf cache elements that were created for a given; /// normalization set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:182,cache,cache,182,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['cache'],['cache']
Performance,/// A SetVector that performs no allocations if smaller than; /// a certain size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:21,perform,performs,21,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,1,['perform'],['performs']
Performance,"/// A ThreadPool for asynchronous parallel execution on a defined number of; /// threads.; ///; /// The pool keeps a vector of threads alive, waiting on a condition variable; /// for some work to become available.; ///; /// It is possible to reuse one thread pool for different groups of tasks; /// by grouping tasks using ThreadPoolTaskGroup. All tasks are processed using; /// the same queue, but it is possible to wait only for a specific group of; /// tasks to finish.; ///; /// It is also possible for worker threads to submit new tasks and wait for; /// them. Note that this may result in a deadlock in cases such as when a task; /// (directly or indirectly) tries to wait for its own completion, or when all; /// available threads are used up by tasks waiting for a task that has no thread; /// left to run on (this includes waiting on the returned future). It should be; /// generally safe to wait() for a group as long as groups do not form a cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h:388,queue,queue,388,interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,1,['queue'],['queue']
Performance,"/// A Trace object represents the records that have been loaded from XRay; /// log files generated by instrumented binaries. We encapsulate the logic of; /// reading the traces in factory functions that populate the Trace object; /// appropriately.; ///; /// Trace objects provide an accessor to an XRayFileHeader which says more about; /// details of the file from which the XRay trace was loaded from.; ///; /// Usage:; ///; /// if (auto TraceOrErr = loadTraceFile(""xray-log.something.xray"")) {; /// auto& T = *TraceOrErr;; /// // T.getFileHeader() will provide information from the trace header.; /// for (const XRayRecord &R : T) {; /// // ... do something with R here.; /// }; /// } else {; /// // Handle the error here.; /// }; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:57,load,loaded,57,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,3,['load'],"['loadTraceFile', 'loaded']"
Performance,/// A bitmap that indicates whether the entries of LoadedSLocEntryTable; /// have already been loaded from the external source.; ///; /// Same indexing as LoadedSLocEntryTable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:51,Load,LoadedSLocEntryTable,51,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,3,"['Load', 'load']","['LoadedSLocEntryTable', 'loaded']"
Performance,/// A bitmap that indicates whether the entries of LoadedSLocEntryTable; /// have already had their offset loaded from the external source.; ///; /// Superset of SLocEntryLoaded. Same indexing as SLocEntryLoaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:51,Load,LoadedSLocEntryTable,51,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,2,"['Load', 'load']","['LoadedSLocEntryTable', 'loaded']"
Performance,"/// A bitvector that, under the hood, relies on an IntervalMap to coalesce; /// elements into intervals. Good for representing sets which predominantly; /// contain contiguous ranges. Bad for representing sets with lots of gaps; /// between elements.; ///; /// Compared to SparseBitVector, CoalescingBitVector offers more predictable; /// performance for non-sequential find() operations.; ///; /// \tparam IndexT - The type of the index into the bitvector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:339,perform,performance,339,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,1,['perform'],['performance']
Performance,"/// A builder class that knows how to construct Instruction objects.; ///; /// Every llvm-mca Instruction is described by an object of class InstrDesc.; /// An InstrDesc describes which registers are read/written by the instruction,; /// as well as the instruction latency and hardware resources consumed.; ///; /// This class is used by the tool to construct Instructions and instruction; /// descriptors (i.e. InstrDesc objects).; /// Information from the machine scheduling model is used to identify processor; /// resources that are consumed by an instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/InstrBuilder.h:265,latency,latency,265,interpreter/llvm-project/llvm/include/llvm/MCA/InstrBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/InstrBuilder.h,1,['latency'],['latency']
Performance,"/// A builtin binary operation expression such as ""x + y"" or ""x <= y"".; ///; /// This expression node kind describes a builtin binary operation,; /// such as ""x + y"" for integer values ""x"" and ""y"". The operands will; /// already have been converted to appropriate types (e.g., by; /// performing promotions or conversions).; ///; /// In C++, where operators may be overloaded, a different kind of; /// expression node (CXXOperatorCallExpr) is used to express the; /// invocation of an overloaded operator with operator syntax. Within; /// a C++ template, whether BinaryOperator or CXXOperatorCallExpr is; /// used to store an expression ""x + y"" depends on the subexpressions; /// for x and y. If neither x or y is type-dependent, and the ""+""; /// operator resolves to a built-in operation, BinaryOperator will be; /// used to express the computation (x and y may still be; /// value-dependent). If either x or y is type-dependent, or if the; /// ""+"" resolves to an overloaded operator, CXXOperatorCallExpr will; /// be used to express the computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:285,perform,performing,285,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['perform'],['performing']
Performance,"/// A cache containing identifiers for which typo correction failed and; /// their locations, so that repeated attempts to correct an identifier in a; /// given location are ignored if typo correction already failed for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['cache'],['cache']
Performance,/// A cache for demangled symbols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:6,cache,cache,6,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,2,['cache'],['cache']
Performance,/// A cache for the CodeExtractor analysis. The operation \ref; /// CodeExtractor::extractCodeRegion is guaranteed not to invalidate this; /// object. This object should conservatively be considered invalid if any; /// other mutating operations on the IR occur.; ///; /// Constructing this object is O(n) in the size of the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:6,cache,cache,6,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,1,['cache'],['cache']
Performance,/// A cache from types to size and alignment information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['cache'],['cache']
Performance,"/// A cache from types to unadjusted alignment information. Only ARM and; /// AArch64 targets need this information, keeping it separate prevents; /// imposing overhead on TypeInfo size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['cache'],['cache']
Performance,/// A cache mapping a string value to a StringLiteral object with the same; /// value.; ///; /// This is lazily created. This is intentionally not serialized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['cache'],['cache']
Performance,/// A cache mapping from CXXRecordDecls to key functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['cache'],['cache']
Performance,/// A cache mapping from RecordDecls to ASTRecordLayouts.; ///; /// This is lazily created. This is intentionally not serialized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['cache'],['cache']
Performance,/// A cache of @llvm.assume intrinsics used by SimplifyInstruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:6,cache,cache,6,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['cache'],['cache']
Performance,"/// A cache of BitVector to reuse between Instructions.; /// The cache will only be exercised during Instruction initialization.; /// For X86, this is ~160 unique vectors for all of the ~15K Instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h:6,cache,cache,6,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/MCInstrDescView.h,2,['cache'],['cache']
Performance,/// A cache of MDKinds that can be passed into other functions to propagate; /// MDKind identifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:6,cache,cache,6,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['cache'],['cache']
Performance,/// A cache of MDKinds used by various ARC optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:6,cache,cache,6,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,2,"['cache', 'optimiz']","['cache', 'optimizations']"
Performance,/// A cache of \@llvm.assume calls used by SimplifyInstruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:6,cache,cache,6,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,1,['cache'],['cache']
Performance,/// A cache of \@llvm.assume calls within a function.; ///; /// This cache provides fast lookup of assumptions within a function by caching; /// them and amortizing the cost of scanning for them across all queries. Passes; /// that create new assumptions are required to call registerAssumption() to; /// register any new \@llvm.assume calls that they create. Deletions of; /// \@llvm.assume calls do not require special handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:6,cache,cache,6,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,2,['cache'],['cache']
Performance,"/// A cache of pointer bases and constant-folded offsets corresponding; /// to GEP (or derived from GEP) instructions.; ///; /// In order to find the base pointer one needs to perform non-trivial; /// traversal of the corresponding SCEV expression, so it's good to have the; /// results saved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:6,cache,cache,6,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,2,"['cache', 'perform']","['cache', 'perform']"
Performance,/// A cache of references to runtime entry point constants.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:6,cache,cache,6,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['cache'],['cache']
Performance,/// A cache of special member function overload resolution results; /// for C++ records.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['cache'],['cache']
Performance,"/// A cache of the first local declaration for ""interesting""; /// redeclaration chains.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,1,['cache'],['cache']
Performance,/// A cache of the flags available in enumerations with the flag_bits; /// attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['cache'],['cache']
Performance,"/// A cache of the value of this pointer, in the most recent generation in; /// which we queried it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,1,['cache'],['cache']
Performance,"/// A cache that maps paths to directory entries (either real or; /// virtual) we have looked up, or an error that occurred when we looked up; /// the directory.; ///; /// The actual Entries for real directories/files are; /// owned by UniqueRealDirs/UniqueRealFiles above, while the Entries; /// for virtual directories/files are owned by; /// VirtualDirectoryEntries/VirtualFileEntries above.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['cache'],['cache']
Performance,"/// A cache that maps paths to file entries (either real or; /// virtual) we have looked up, or an error that occurred when we looked up; /// the file.; ///; /// \see SeenDirEntries",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:6,cache,cache,6,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['cache'],['cache']
Performance,"/// A cached code-completion result, which may be introduced in one of; /// many different contexts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:6,cache,cached,6,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['cache'],['cached']
Performance,/// A cached value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:6,cache,cached,6,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['cache'],['cached']
Performance,/// A call of a function or method that performs unchecked buffer operations; /// over one of its pointer parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:40,perform,performs,40,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['perform'],['performs']
Performance,"/// A callback value handle applied to function objects, which we use to; /// delete our cache of intrinsics for a function when it is deleted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:89,cache,cache,89,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['cache'],['cache']
Performance,/// A callback value handle updates the cache when values are erased.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:40,cache,cache,40,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['cache'],['cache']
Performance,/// A clang tool that runs the preprocessor in a mode that's optimized for; /// dependency scanning for the given compiler invocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp:61,optimiz,optimized,61,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningWorker.cpp,1,['optimiz'],['optimized']
Performance,/// A class for performing structural comparisons of LLVM assembly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h:16,perform,performing,16,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.h,1,['perform'],['performing']
Performance,/// A class that represents two vectorization factors (initialized with 0 by; /// default). One for fixed-width vectorization and one for scalable; /// vectorization. This can be used by the vectorizer to choose from a range of; /// fixed and/or scalable VFs in order to find the most cost-effective VF to; /// vectorize with.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:138,scalab,scalable,138,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,2,['scalab'],['scalable']
Performance,/// A class to track the execution mode when codegening directives within; /// a target region. The appropriate mode (SPMD|NON-SPMD) is set on entry; /// to the target region and used by containing directives such as 'parallel'; /// to emit optimized code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:241,optimiz,optimized,241,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['optimiz'],['optimized']
Performance,/// A cleanup to perform a release of an object at the end of a; /// function. This is used to balance out the incoming +1 of a; /// ns_consumed argument when we can't reasonably do that just by; /// not doing the initial retain for a __block argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:17,perform,perform,17,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['perform'],['perform']
Performance,"/// A closure is a set of virtual register representing all of the edges in; /// the closure, as well as all of the instructions connected by those edges.; ///; /// A closure may encompass virtual registers in the same register bank that; /// have different widths. For example, it may contain 32-bit GPRs as well as; /// 64-bit GPRs.; ///; /// A closure that computes an address (i.e. defines a virtual register that is; /// used in a memory operand) excludes the instructions that contain memory; /// operands using the address. Such an instruction will be included in a; /// different closure that manipulates the loaded or stored value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp:617,load,loaded,617,interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,1,['load'],['loaded']
Performance,"/// A cluster group is loaded in two stages. Stage one loads only the summary information.; /// Stage two loads the list of cluster IDs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:23,load,loaded,23,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,3,['load'],"['loaded', 'loads']"
Performance,"/// A collection of on-disk hash tables, merged when relevant for performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:66,perform,performance,66,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,1,['perform'],['performance']
Performance,/// A common refactoring action rule interface that defines the 'invoke'; /// function that performs the refactoring operation (either fully or; /// partially).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:92,perform,performs,92,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,1,['perform'],['performs']
Performance,/// A container for analyses that lazily runs them and caches their; /// results.; ///; /// This class can manage analyses for any IR unit where the address of the IR; /// unit sufficies as its identity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:55,cache,caches,55,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['caches']
Performance,/// A flag indicating whether the optimization that removes or moves; /// retain/release pairs should be performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:34,optimiz,optimization,34,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,2,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,/// A function analysis which provides an \c AssumptionCache.; ///; /// This analysis is intended for use with the new pass manager and will vend; /// assumption caches for a given function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:162,cache,caches,162,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['cache'],['caches']
Performance,/// A function of this type is used to load modules referenced by the index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h:39,load,load,39,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h,1,['load'],['load']
Performance,"/// A function pass for tsan instrumentation.; ///; /// Instruments functions to detect race conditions reads. This function pass; /// inserts calls to runtime library functions. If the functions aren't declared; /// yet, the pass inserts the declarations. Otherwise the existing globals are",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/ThreadSanitizer.h:88,race condition,race conditions,88,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/ThreadSanitizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/ThreadSanitizer.h,1,['race condition'],['race conditions']
Performance,/// A function that will be called with the name of dll file that must be; /// loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/COFFPlatform.h:79,load,loaded,79,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/COFFPlatform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/COFFPlatform.h,1,['load'],['loaded']
Performance,"/// A global index for a set of module files, providing information about; /// the identifiers within those module files.; ///; /// The global index is an aid for name lookup into modules, offering a central; /// place where one can look for identifiers determine which; /// module files contain any information about that identifier. This; /// allows the client to restrict the search to only those module files known; /// to have a information about that identifier, improving performance. Moreover,; /// the global module index may know about module files that have not been; /// imported, and can be queried to determine which modules the current; /// translation could or should load to fix a problem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h:479,perform,performance,479,interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,2,"['load', 'perform']","['load', 'performance']"
Performance,/// A handle used to represent a loaded dylib in the target process.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/TargetProcessControlTypes.h:33,load,loaded,33,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/TargetProcessControlTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/TargetProcessControlTypes.h,1,['load'],['loaded']
Performance,/// A handler for state updates occurring while an HTTPRequest is performed.; /// Can trigger the client to abort the request by returning an Error from any; /// of its methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h:66,perform,performed,66,interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,1,['perform'],['performed']
Performance,/// A handy option to enable/disable all ARC Optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:45,Optimiz,Optimizations,45,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,2,['Optimiz'],['Optimizations']
Performance,/// A helper class for performing the null-initialization of a return; /// value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:23,perform,performing,23,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['perform'],['performing']
Performance,"/// A helper class for separating a constant offset from a GEP index.; ///; /// In real programs, a GEP index may be more complicated than a simple addition; /// of something and a constant integer which can be trivially splitted. For; /// example, to split ((a << 3) | 5) + b, we need to search deeper for the; /// constant offset, so that we can separate the index to (a << 3) + b and 5.; ///; /// Therefore, this class looks into the expression that computes a given GEP; /// index, and tries to find a constant integer that can be hoisted to the; /// outermost level of the expression as an addition. Not every constant in an; /// expression can jump out. e.g., we cannot transform (b * (a + 5)) to (b * a +; /// 5); nor can we transform (3 * (a + 5)) to (3 * a + 5), however in this case,; /// -instcombine probably already optimized (3 * (a + 5)) to (3 * a + 15).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:829,optimiz,optimized,829,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['optimiz'],['optimized']
Performance,"/// A helper class keeping track of loaded libraries. It implements a fast; /// search O(1) while keeping deterministic iterability in a memory efficient; /// way. The underlying set uses a custom hasher for better efficiency given the; /// specific problem where the library names (m_LibName) are relatively short; /// strings and the base paths (m_Path) are repetitive long strings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:36,load,loaded,36,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['load'],['loaded']
Performance,/// A helper function that returns the address space of the pointer operand of; /// load or store instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:84,load,load,84,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['load'],['load']
Performance,/// A helper function that returns the alignment of load or store instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:52,load,load,52,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['load'],['load']
Performance,"/// A helper function that returns the pointer operand of a load, store; /// or GEP instruction. Returns nullptr if not load, store, or GEP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:60,load,load,60,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,2,['load'],['load']
Performance,/// A helper function that returns the type of a load or store instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:49,load,load,49,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['load'],['load']
Performance,"/// A helper that repeats an SCC pass each time an indirect call is refined to; /// a direct call by that pass.; ///; /// While the CGSCC pass manager works to re-visit SCCs and RefSCCs as they; /// change shape, we may also want to repeat an SCC pass if it simply refines; /// an indirect call to a direct call, even if doing so does not alter the; /// shape of the graph. Note that this only pertains to direct calls to; /// functions where IPO across the SCC may be able to compute more precise; /// results. For intrinsics, we assume scalar optimizations already can fully; /// reason about them.; ///; /// This repetition has the potential to be very large however, as each one; /// might refine a single call site. As a consequence, in practice we use an; /// upper bound on the number of repetitions to limit things.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:545,optimiz,optimizations,545,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['optimiz'],['optimizations']
Performance,"/// A lazily constructed view of the call graph of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unk",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:190,optimiz,optimization,190,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,5,['optimiz'],"['optimization', 'optimizations', 'optimizing']"
Performance,"/// A list of SUnits, used in Value2SUsMap, during DAG construction.; /// Note: to gain speed it might be worth investigating an optimized; /// implementation of this data structure, such as a singly linked list; /// with a memory pool (SmallVector was tried but slow and SparseSet is not; /// applicable).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:129,optimiz,optimized,129,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['optimiz'],['optimized']
Performance,/// A list of cached binaries in LRU order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h:14,cache,cached,14,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,1,['cache'],['cached']
Performance,/// A list of matchers that all need to succeed for the current rule to match.; /// FIXME: This currently supports a single match position but could be; /// extended to support multiple positions to support div/rem fusion or; /// load-multiple instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:230,load,load-multiple,230,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,1,['load'],['load-multiple']
Performance,/// A load candidate for masked gather.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:6,load,load,6,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['load']
Performance,/// A loaded pass plugin.; ///; /// An instance of this class wraps a loaded pass plugin and gives access to; /// its interface defined by the \c PassPluginLibraryInfo it exposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h:6,load,loaded,6,interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,2,['load'],['loaded']
Performance,/// A magic value for use with the Threshold parameter to indicate; /// that the loop unroll should be performed regardless of how much; /// code expansion would result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:103,perform,performed,103,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['perform'],['performed']
Performance,/// A map from the ComparisonCategoryType (represented as 'char') to the; /// cached information for the specified category.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h:78,cache,cached,78,interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h,1,['cache'],['cached']
Performance,"/// A measurement, once fully configured, can be saved into a ROOT; /// file. This will persitify the Measurement object, along with any; /// channels and samples that have been added to it. It can then be; /// loaded, potentially modified, and used to create new models.; ///; /// Write every histogram to the file.; /// Edit the measurement to point to this file; /// and to point to each histogram in this file; /// Then write the measurement itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Measurement.cxx:211,load,loaded,211,roofit/histfactory/src/Measurement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/Measurement.cxx,1,['load'],['loaded']
Performance,"/// A memcmp expansion that compares equality with 0 and only has one block of; /// load and compare can bypass the compare, branch, and phi IR that is required; /// in the general case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:84,load,load,84,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['load'],['load']
Performance,"/// A memcmp expansion that only has one block of load and compare can bypass; /// the compare, branch, and phi IR that is required in the general case.; /// This function also analyses users of memcmp, and if there is only one user; /// from which we can conclude that only 2 out of 3 memcmp outcomes really; /// matter, then it generates more efficient code with only one comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:50,load,load,50,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['load'],['load']
Performance,"/// A memory efficient llvm::VectorSet. The class provides O(1) search; /// complexity. It is tuned to compare BasePaths first by checking the; /// address and then the representation which models the base path reuse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:94,tune,tuned,94,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['tune'],['tuned']
Performance,/// A module loader that doesn't know how to create or load modules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:13,load,loader,13,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,2,['load'],"['load', 'loader']"
Performance,"/// A mostly-opaque identifier, where 0 is ""invalid"", >0 is; /// this module, and <-1 is something loaded from another module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h:99,load,loaded,99,interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h,1,['load'],['loaded']
Performance,"/// A node in the call graph.; ///; /// This represents a single node. Its primary roles are to cache the list of; /// callees, de-duplicate and provide fast testing of whether a function is a; /// callee, and facilitate iteration of child nodes in the graph.; ///; /// The node works much like an optional in order to lazily populate the; /// edges of each node. Until populated, there are no edges. Once populated,; /// you can access the edges by dereferencing the node or using the `->`; /// operator as if the node was an `std::optional<EdgeSequence>`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:96,cache,cache,96,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['cache'],['cache']
Performance,"/// A one-entry cache to speed up getFileID.; ///; /// LastFileIDLookup records the last FileID looked up or created, because it; /// is very common to look up many tokens from the same file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:16,cache,cache,16,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['cache'],['cache']
Performance,/// A pair of memory protections and allocation policies.; ///; /// Optimized for use as a small map key.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h:68,Optimiz,Optimized,68,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/MemoryFlags.h,1,['Optimiz'],['Optimized']
Performance,"/// A parser for options common to all command-line Clang tools.; ///; /// Parses a common subset of command-line arguments, locates and loads a; /// compilation commands database and runs a tool with user-specified action. It; /// also contains a help message for the common command-line options.; ///; /// An example of usage:; /// \code; /// #include ""clang/Frontend/FrontendActions.h""; /// #include ""clang/Tooling/CommonOptionsParser.h""; /// #include ""clang/Tooling/Tooling.h""; /// #include ""llvm/Support/CommandLine.h""; ///; /// using namespace clang::tooling;; /// using namespace llvm;; ///; /// static cl::OptionCategory MyToolCategory(""My tool options"");; /// static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage);; /// static cl::extrahelp MoreHelp(""\nMore help text...\n"");; /// static cl::opt<bool> YourOwnOption(...);; /// ...; ///; /// int main(int argc, const char **argv) {; /// CommonOptionsParser OptionsParser(argc, argv, MyToolCategory);; /// ClangTool Tool(OptionsParser.getCompilations(),; /// OptionsParser.getSourcePathList());; /// return Tool.run(newFrontendActionFactory<SyntaxOnlyAction>().get());; /// }; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h:137,load,loads,137,interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,1,['load'],['loads']
Performance,"/// A pass manager to run a set of extra function simplification passes after; /// vectorization, if requested. LoopVectorize caches the; /// ShouldRunExtraVectorPasses analysis to request extra simplifications, if; /// they could be beneficial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:126,cache,caches,126,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,1,['cache'],['caches']
Performance,/// A pass that does profile-guided sinking of instructions into loops.; ///; /// This is a function pass as it shouldn't be composed into any kind of; /// unified loop pass pipeline. The goal of it is to sink code into loops that; /// is loop invariant but only required within the loop body when doing so; /// reduces the global expected dynamic frequency with which it executes.; /// A classic example is an extremely cold branch within a loop body.; ///; /// We do this as a separate pass so that during normal optimization all; /// invariant operations can be held outside the loop body to simplify; /// fundamental analyses and transforms of the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h:515,optimiz,optimization,515,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSink.h,1,['optimiz'],['optimization']
Performance,"/// A pass to do RPO deduction and propagation of function attributes.; ///; /// This pass provides a general RPO or ""top down"" propagation of; /// function attributes. For a few (rare) cases, we can deduce significantly; /// more about function attributes by working in RPO, so this pass; /// provides the complement to the post-order pass above where the majority of; /// deduction is performed.; // FIXME: Currently there is no RPO CGSCC pass structure to slide into and so; // this is a boring module pass, but eventually it should be an RPO CGSCC pass; // when such infrastructure is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionAttrs.h:387,perform,performed,387,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionAttrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionAttrs.h,1,['perform'],['performed']
Performance,"/// A pass to instrument code and perform run-time bounds checking on loads,; /// stores, and other memory intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/BoundsChecking.h:34,perform,perform,34,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/BoundsChecking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/BoundsChecking.h,2,"['load', 'perform']","['loads', 'perform']"
Performance,"/// A pass to simplify and canonicalize the CFG of a function.; ///; /// This pass iteratively simplifies the entire CFG of a function. It may change; /// or remove control flow to put the CFG into a canonical form expected by; /// other passes of the mid-level optimizer. Depending on the specified options,; /// it may further optimize control-flow to create non-canonical forms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:262,optimiz,optimizer,262,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,2,['optimiz'],"['optimize', 'optimizer']"
Performance,"/// A post-order depth-first RefSCC iterator over the call graph.; ///; /// This iterator walks the cached post-order sequence of RefSCCs. However,; /// it trades stability for flexibility. It is restricted to a forward; /// iterator but will survive mutations which insert new RefSCCs and continue; /// to point to the same RefSCC even if it moves in the post-order sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:100,cache,cached,100,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['cache'],['cached']
Performance,/// A potentially stricter node kind.; ///; /// It allows to perform implicit and dynamic cast of matchers without; /// needing to change \c Implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h:61,perform,perform,61,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h,1,['perform'],['perform']
Performance,"/// A priority queue, implemented as a heap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:15,queue,queue,15,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,1,['queue'],['queue']
Performance,/// A queue of (optional) vtables that may be emitted opportunistically.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:6,queue,queue,6,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['queue'],['queue']
Performance,/// A queue of (optional) vtables to consider emitting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:6,queue,queue,6,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['queue'],['queue']
Performance,/// A queue of unified blocks to process.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:6,queue,queue,6,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,1,['queue'],['queue']
Performance,"/// A queue used for performing data recursion over statements.; /// Parameters involving this type are used to implement data; /// recursion over Stmts and Exprs within this class, and should; /// typically not be explicitly specified by derived classes.; /// The bool bit indicates whether the statement has been traversed or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h:6,queue,queue,6,interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/RecursiveASTVisitor.h,2,"['perform', 'queue']","['performing', 'queue']"
Performance,/// A range covering the PCH and preamble module files loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:55,load,loaded,55,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,"/// A recipe to represent inloop reduction operations, performing a reduction on; /// a vector operand into a scalar value, and adding the result to a chain.; /// The Operands are {ChainOp, VecOp, [Condition]}.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:55,perform,performing,55,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['perform'],['performing']
Performance,"/// A record that stores the set of declarations that are; /// visible from a given DeclContext.; ///; /// The record itself stores a set of mappings, each of which; /// associates a declaration name with one or more declaration; /// IDs. This data is used when performing qualified name lookup; /// into a DeclContext via DeclContext::lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:262,perform,performing,262,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['perform'],['performing']
Performance,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:526,cache,cache,526,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,2,['cache'],['cache']
Performance,/// A representative guaranteed-executed load or store instruction for use by; /// metadata transfer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:41,load,load,41,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['load'],['load']
Performance,/// A reusable client that can perform HTTPRequests through a network socket.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h:31,perform,perform,31,interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,1,['perform'],['perform']
Performance,"/// A rewritten comparison expression that was originally written using; /// operator syntax.; ///; /// In C++20, the following rewrites are performed:; /// - <tt>a == b</tt> -> <tt>b == a</tt>; /// - <tt>a != b</tt> -> <tt>!(a == b)</tt>; /// - <tt>a != b</tt> -> <tt>!(b == a)</tt>; /// - For \c \@ in \c <, \c <=, \c >, \c >=, \c <=>:; /// - <tt>a @ b</tt> -> <tt>(a <=> b) @ 0</tt>; /// - <tt>a @ b</tt> -> <tt>0 @ (b <=> a)</tt>; ///; /// This expression provides access to both the original syntax and the; /// rewritten expression.; ///; /// Note that the rewritten calls to \c ==, \c <=>, and \c \@ are typically; /// \c CXXOperatorCallExprs, but could theoretically be \c BinaryOperators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:141,perform,performed,141,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['perform'],['performed']
Performance,/// A scope in which we're performing pack deduction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:27,perform,performing,27,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['perform'],['performing']
Performance,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:158,load,loads,158,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,6,['load'],"['load', 'loads']"
Performance,/// A scoped hash table of the current values of read-only call; /// values.; ///; /// It uses the same generation count as loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:124,load,loads,124,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['load'],['loads']
Performance,"/// A self-contained host- and target-independent arbitrary-precision; /// floating-point software implementation.; ///; /// APFloat uses bignum integer arithmetic as provided by static functions in; /// the APInt class. The library will work with bignum integers whose parts are; /// any unsigned type at least 16 bits wide, but 64 bits is recommended.; ///; /// Written for clarity rather than speed, in particular with a view to use in; /// the front-end of a cross compiler so that target arithmetic can be correctly; /// performed on the host. Performance should nonetheless be reasonable,; /// particularly for its intended use. It may be useful as a base; /// implementation for a run-time library during development of a faster; /// target-specific one.; ///; /// All 5 rounding modes in the IEEE-754R draft are handled correctly for all; /// implemented operations. Currently implemented operations are add, subtract,; /// multiply, divide, fused-multiply-add, conversion-to-float,; /// conversion-to-integer and conversion-from-integer. New rounding modes; /// (e.g. away from zero) can be added with three or four lines of code.; ///; /// Four formats are built-in: IEEE single precision, double precision,; /// quadruple precision, and x87 80-bit extended double (when operating with; /// full extended precision). Adding a new format that obeys IEEE semantics; /// only requires adding two lines of code: a declaration and definition of the; /// format.; ///; /// All operations return the status of that operation as an exception bit-mask,; /// so multiple operations can be done consecutively with their results or-ed; /// together. The returned status can be useful for compiler diagnostics; e.g.,; /// inexact, underflow and overflow can be easily diagnosed on constant folding,; /// and compiler optimizers can determine what exceptions would be raised by; /// folding operations and optimize, or perhaps not optimize, accordingly.; ///; /// At present, underflow tininess is detecte",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h:526,perform,performed,526,interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFloat.h,2,"['Perform', 'perform']","['Performance', 'performed']"
Performance,"/// A semantic tree transformation that allows one to transform one; /// abstract syntax tree into another.; ///; /// A new tree transformation is defined by creating a new subclass \c X of; /// \c TreeTransform<X> and then overriding certain operations to provide; /// behavior specific to that transformation. For example, template; /// instantiation is implemented as a tree transformation where the; /// transformation of TemplateTypeParmType nodes involves substituting the; /// template arguments for their corresponding template parameters; a similar; /// transformation is performed for non-type template parameters and; /// template template parameters.; ///; /// This tree-transformation template uses static polymorphism to allow; /// subclasses to customize any of its operations. Thus, a subclass can; /// override any of the transformation or rebuild operators by providing an; /// operation with the same signature as the default implementation. The; /// overriding function should not be virtual.; ///; /// Semantic tree transformations are split into two stages, either of which; /// can be replaced by a subclass. The ""transform"" step transforms an AST node; /// or the parts of an AST node using the various transformation functions,; /// then passes the pieces on to the ""rebuild"" step, which constructs a new AST; /// node of the appropriate kind from the pieces. The default transformation; /// routines recursively transform the operands to composite AST nodes (e.g.,; /// the pointee type of a PointerType node) and, if any of those operand nodes; /// were changed by the transformation, invokes the rebuild operation to create; /// a new AST node.; ///; /// Subclasses can customize the transformation at various levels. The; /// most coarse-grained transformations involve replacing TransformType(),; /// TransformExpr(), TransformDecl(), TransformNestedNameSpecifierLoc(),; /// TransformTemplateName(), or TransformTemplateArgument() with entirely; /// new implementations.;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:581,perform,performed,581,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performed']
Performance,/// A set of #undef directives that we have loaded; used to; /// deduplicate the same #undef information coming from multiple module; /// files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:44,load,loaded,44,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// A set of deallocations that should be performed when the; /// ASTContext is destroyed.; // FIXME: We really should have a better mechanism in the ASTContext to; // manage running destructors for types which do variable sized allocation; // within the AST. In some places we thread the AST bump pointer allocator; // into the datastructures which avoids this mess during deallocation but is; // wasteful of memory, and here we require a lot of error prone book keeping; // in order to track and run destructors while we're tearing things down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:42,perform,performed,42,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['perform'],['performed']
Performance,/// A set of load/store MachineInstrs with same base register sorted by; /// offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:13,load,load,13,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['load'],['load']
Performance,"/// A set of parameters to control various transforms performed by IPSCCP pass.; /// Each of the boolean parameters can be set to:; /// true - enabling the transformation.; /// false - disabling the transformation.; /// Intended use is to create a default object, modify parameters with; /// additional setters and then pass it to IPSCCP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h:54,perform,performed,54,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h,1,['perform'],['performed']
Performance,"/// A set of parameters used to control various transforms performed by the; /// LoopUnroll pass. Each of the boolean parameters can be set to:; /// true - enabling the transformation.; /// false - disabling the transformation.; /// None - relying on a global default.; ///; /// There is also OptLevel parameter, which is used for additional loop unroll; /// tuning.; ///; /// Intended use is to create a default object, modify parameters with; /// additional setters and then pass it to LoopUnrollPass.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h:59,perform,performed,59,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopUnrollPass.h,1,['perform'],['performed']
Performance,"/// A set of symbols to look up, each associated with a SymbolLookupFlags; /// value.; ///; /// This class is backed by a vector and optimized for fast insertion,; /// deletion and iteration. It does not guarantee a stable order between; /// operations, and will not automatically detect duplicate elements (they; /// can be manually checked by calling the validate method).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:133,optimiz,optimized,133,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['optimiz'],['optimized']
Performance,/// A simple handler which streams the returned data to a cache file. The cache; /// file is only created if a 200 OK status is observed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp:58,cache,cache,58,interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Debuginfod/Debuginfod.cpp,2,['cache'],['cache']
Performance,"/// A simplistic name lookup mechanism that performs name lookup; /// into this declaration context without consulting the external source.; ///; /// This function should almost never be used, because it subverts the; /// usual relationship between a DeclContext and the external source.; /// See the ASTImporter for the (few, but important) use cases.; ///; /// FIXME: This is very inefficient; replace uses of it with uses of; /// noload_lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:44,perform,performs,44,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['perform'],['performs']
Performance,"/// A single branch of a function summary.; ///; /// A branch is defined by a series of constraints - ""assumptions"" -; /// that together form a single possible outcome of invoking the function.; /// When static analyzer considers a branch, it tries to introduce; /// a child node in the Exploded Graph. The child node has to include; /// constraints that define the branch. If the constraints contradict; /// existing constraints in the state, the node is not created and the branch; /// is dropped; otherwise it's queued for future exploration.; /// The branch is accompanied by a note text that may be displayed; /// to the user when a bug is found on a path that takes this branch.; ///; /// For example, consider the branches in `isalpha(x)`:; /// Branch 1); /// x is in range ['A', 'Z'] or in ['a', 'z']; /// then the return value is not 0. (I.e. out-of-range [0, 0]); /// and the note may say ""Assuming the character is alphabetical""; /// Branch 2); /// x is out-of-range ['A', 'Z'] and out-of-range ['a', 'z']; /// then the return value is 0; /// and the note may say ""Assuming the character is non-alphabetical"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:515,queue,queued,515,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['queue'],['queued']
Performance,/// A single-element cache based on the file ID.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:21,cache,cache,21,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['cache'],['cache']
Performance,/// A snapshot of the pending instantiations in the chain.; ///; /// This record tracks the instantiations that Sema has to perform at the; /// end of the TU. It consists of a pair of values for every pending; /// instantiation where the first value is the ID of the decl and the second; /// is the instantiation location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:124,perform,perform,124,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['perform'],['perform']
Performance,/// A specialized derived class of inner loop vectorizer that performs; /// vectorization of *main* loops in the process of vectorizing loops and their; /// epilogues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:62,perform,performs,62,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['perform'],['performs']
Performance,/// A specialized priority queue for WeigthedLeaves. It automatically folds; /// constants and allows removal of non-top elements while maintaining the; /// priority order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:27,queue,queue,27,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['queue'],['queue']
Performance,/// A specialized result for the \c LoopAnalysisManagerFunctionProxy which; /// retains a \c LoopInfo reference.; ///; /// This allows it to collect loop objects for which analysis results may be; /// cached in the \c LoopAnalysisManager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:201,cache,cached,201,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,1,['cache'],['cached']
Performance,/// A specification for a virtual function call with all constant integer; /// arguments. This is used to perform virtual constant propagation on the; /// summary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:106,perform,perform,106,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['perform'],['perform']
Performance,"/// A stack object to be created when performing template; /// instantiation.; ///; /// Construction of an object of type \c InstantiatingTemplate; /// pushes the current instantiation onto the stack of active; /// instantiations. If the size of this stack exceeds the maximum; /// number of recursive template instantiations, construction; /// produces an error and evaluates true.; ///; /// Destruction of this object will pop the named instantiation off; /// the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:38,perform,performing,38,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,/// A stack of exception code slots. Entering an __except block pushes a slot; /// on the stack and leaving pops one. The __exception_code() intrinsic loads; /// a value from the top of the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:151,load,loads,151,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['load'],['loads']
Performance,/// A stage that simulates a queue of instruction opcodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h:29,queue,queue,29,interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Stages/MicroOpQueueStage.h,1,['queue'],['queue']
Performance,"/// A stat ""cache"" that can be used by FileManager to keep; /// track of the results of stat() calls that occur throughout the; /// execution of the front end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h:12,cache,cache,12,interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h,1,['cache'],['cache']
Performance,/// A state machine that detects the \#ifndef-wrapping a file; /// idiom for the multiple-include optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorLexer.h:98,optimiz,optimization,98,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorLexer.h,1,['optimiz'],['optimization']
Performance,/// A string hash of the top-level declaration and macro definition; /// names processed the last time that we reparsed the file.; ///; /// This hash value is used to determine when we need to refresh the; /// global code-completion cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:233,cache,cache,233,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['cache'],['cache']
Performance,/// A string hash of the top-level declaration and macro definition; /// names processed the last time that we reparsed the precompiled preamble.; ///; /// This hash value is used to determine when we need to refresh the; /// global code-completion cache after a rebuild of the precompiled preamble.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:249,cache,cache,249,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['cache'],['cache']
Performance,"/// A thread-safe stack of N indexes (0 to size - 1).; /// RSlotStack can be used to safely assign a ""processing slot"" number to; /// each thread in multi-thread applications.; /// In release builds, pop and push operations are unchecked, potentially; /// resulting in undefined behavior if more slot numbers than available are; /// requested.; /// An important design assumption is that a slot will almost always be available; /// when a thread asks for it, and if it is not available it will be very soon,; /// therefore a spinlock is used for synchronization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/RSlotStack.hxx:149,multi-thread,multi-thread,149,core/imt/inc/ROOT/RSlotStack.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/RSlotStack.hxx,1,['multi-thread'],['multi-thread']
Performance,/// A trace represents a plausible sequence of executed basic blocks that; /// passes through the current basic block one. The Trace class serves as a; /// handle to internal cached data structures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:175,cache,cached,175,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,1,['cache'],['cached']
Performance,/// A type which sorts a priority queue by the number of unprocessed; /// predecessor blocks it has remaining.; ///; /// This is actually really expensive to calculate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:34,queue,queue,34,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,1,['queue'],['queue']
Performance,"/// A type-checked pair of {Register Location (or 0), Index}, used to index; /// into a \ref VarLocMap. This can be efficiently converted to a 64-bit int; /// for insertion into a \ref VarLocSet, and efficiently converted back. The; /// type-checker helps ensure that the conversions aren't lossy.; ///; /// Why encode a location /into/ the VarLocMap index? This makes it possible; /// to find the open VarLocs killed by a register def very quickly. This is a; /// performance-critical operation for LiveDebugValues.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:465,perform,performance-critical,465,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['perform'],['performance-critical']
Performance,"/// A uniform memory op is a load or store which accesses the same memory; /// location on all \p VF lanes, if \p VF is provided and otherwise if the; /// memory location is invariant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:29,load,load,29,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['load'],['load']
Performance,/// A utility class used to compute instruction encodings for a code region.; ///; /// It provides a simple API to compute and return instruction encodings as; /// strings. Encodings are cached internally for later usage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CodeEmitter.h:187,cache,cached,187,interpreter/llvm-project/llvm/include/llvm/MCA/CodeEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CodeEmitter.h,1,['cache'],['cached']
Performance,/// A utility function for looking up initializer symbols. Performs a blocking; /// lookup for the given symbols in each of the given JITDylibs.; ///; /// Note: This function is deprecated and will be removed in the near future.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:59,Perform,Performs,59,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['Perform'],['Performs']
Performance,"/// A vector containing identifiers that have already been; /// loaded.; ///; /// If the pointer at index I is non-NULL, then it refers to the; /// IdentifierInfo for the identifier with ID=I+1 that has already; /// been loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:64,load,loaded,64,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,2,['load'],['loaded']
Performance,"/// A vector containing macros that have already been; /// loaded.; ///; /// If the pointer at index I is non-NULL, then it refers to the; /// MacroInfo for the identifier with ID=I+1 that has already; /// been loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:59,load,loaded,59,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,2,['load'],['loaded']
Performance,/// A vector containing selectors that have already been loaded.; ///; /// This vector is indexed by the Selector ID (-1). NULL selector; /// entries indicate that the particular selector ID has not yet; /// been loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:57,load,loaded,57,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,2,['load'],['loaded']
Performance,/// A vector containing submodules that have already been loaded.; ///; /// This vector is indexed by the Submodule ID (-1). NULL submodule entries; /// indicate that the particular submodule ID has not yet been loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:58,load,loaded,58,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,2,['load'],['loaded']
Performance,/// A vector select of 2 constant vectors can be simplified to math/logic to; /// avoid a variable select instruction and possibly avoid constant loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:146,load,loads,146,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loads']
Performance,"/// A vector select: ""(select vL, vR, (setcc LHS, RHS))"" is best performed with; /// the compare-mask instructions rather than going via NZCV, even if LHS and; /// RHS are really scalar. This replaces any scalar setcc in the above pattern; /// with a vector one followed by a DUP shuffle on the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:65,perform,performed,65,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['perform'],['performed']
Performance,"/// A vector that has set insertion semantics.; ///; /// This adapter class provides a way to keep a set of things that also has the; /// property of a deterministic iteration order. The order of iteration is the; /// order of insertion.; ///; /// The key and value types are derived from the Set and Vector types; /// respectively. This allows the vector-type operations and set-type operations; /// to have different types. In particular, this is useful when storing pointers; /// as ""Foo *"" values but looking them up as ""const Foo *"" keys.; ///; /// No constraint is placed on the key and value types, although it is assumed; /// that value_type can be converted into key_type for insertion. Users must be; /// aware of any loss of information in this conversion. For example, setting; /// value_type to float and key_type to int can produce very surprising results,; /// but it is not explicitly disallowed.; ///; /// The parameter N specifies the ""small"" size of the container, which is the; /// number of elements upto which a linear scan over the Vector will be used; /// when searching for elements instead of checking Set, due to it being better; /// for performance. A value of 0 means that this mode of operation is not used,; /// and is the default value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h:1165,perform,performance,1165,interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SetVector.h,1,['perform'],['performance']
Performance,/// A version of \c PriorityWorklist that selects small size optimized data; /// structures for the vector and map.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h:61,optimiz,optimized,61,interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PriorityWorklist.h,1,['optimiz'],['optimized']
Performance,"/// A very simple error handler that is usually replaced by the TROOT default error handler.; /// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; /// can get scrambled; /// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TError.cxx:176,multi-thread,multi-threaded,176,core/foundation/src/TError.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TError.cxx,1,['multi-thread'],['multi-threaded']
Performance,"/// A very specialized mode that will optimize for code size at any and all; /// costs.; ///; /// This is useful primarily when there are absolute size limitations and; /// any effort taken to reduce the size is worth it regardless of the; /// execution time impact. You should expect this level to produce rather; /// slow, but very small, code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:38,optimiz,optimize,38,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,1,['optimiz'],['optimize']
Performance,/// A view that collects and prints a few performance numbers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h:42,perform,performance,42,interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/Views/BottleneckAnalysis.h,2,['perform'],['performance']
Performance,/// A virtual file system optimized for the dependency discovery.; ///; /// It is primarily designed to work with source files whose contents was; /// preprocessed to remove any tokens that are unlikely to affect the dependency; /// computation.; ///; /// This is not a thread safe VFS. A single instance is meant to be used only in; /// one thread. Multiple instances are allowed to service multiple threads; /// running in parallel.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:26,optimiz,optimized,26,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['optimiz'],['optimized']
Performance,/// A work queue of functions that may have been modified and should be; /// analyzed again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:11,queue,queue,11,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['queue'],['queue']
Performance,/// A worklist of PHIs to speculate prior to promoting allocas.; ///; /// All of these PHIs have been checked for the safety of speculation and by; /// being speculated will allow promoting allocas currently in the promotable; /// queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:231,queue,queue,231,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['queue'],['queue']
Performance,/// A wrapper interface to populate the PGO symtab with functions; /// decls from module \c M. This interface is used by transformation; /// passes such as indirect function call promotion. Variable \c InLTO; /// indicates if this is called from LTO optimization passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:250,optimiz,optimization,250,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,1,['optimiz'],['optimization']
Performance,"/// ABS - Determine the unsigned absolute value of a signed integer value of; /// the same bitwidth.; /// Note: A value of INT_MIN will return INT_MIN, no saturation or overflow; /// is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:186,perform,performed,186,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['perform'],['performed']
Performance,"/// ANNOTATION_LABEL - Represents a mid basic block label used by; /// annotations. This should remain within the basic block and be ordered; /// with respect to other call instructions, but loads and stores may float; /// past it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:191,load,loads,191,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['load'],['loads']
Performance,/// ATOMIC_CMP_SWAP - the exact same as the target-independent nodes; /// except they ensure that the compare input is zero-extended for; /// sub-word versions because the atomic loads zero-extend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:179,load,loads,179,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['load'],['loads']
Performance,/// Abstract base class for actions which can be performed by the frontend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:49,perform,performed,49,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['perform'],['performed']
Performance,/// Abstract base class used to perform a contextual implicit; /// conversion from an expression to any type passing a filter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:32,perform,perform,32,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['perform']
Performance,/// Abstract base interface for LS (load/store) units in llvm-mca.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:36,load,load,36,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['load'],['load']
Performance,"/// Abstract interface for a module loader.; ///; /// This abstract interface describes a module loader, which is responsible; /// for resolving a module name (e.g., ""std"") to an actual module file, and; /// then loading that module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:36,load,loader,36,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,3,['load'],"['loader', 'loading']"
Performance,"/// Abstract interface for introducing a FileManager cache for 'stat'; /// system calls, which is used by precompiled and pretokenized headers to; /// improve performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h:53,cache,cache,53,interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h,2,"['cache', 'perform']","['cache', 'performance']"
Performance,"/// Access a particular processing slot.; ///; /// This method is thread-safe as long as concurrent calls request different slots (i.e. pass a different; /// argument) and no thread accesses slot `i` via the arrow operator, so mixing usage of GetAtSlot; /// with usage of the arrow operator can be dangerous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:89,concurren,concurrent,89,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['concurren'],['concurrent']
Performance,/// Access the object which can disable optional passes and individual; /// optimizations at compile time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:76,optimiz,optimizations,76,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,2,['optimiz'],['optimizations']
Performance,/// Accessor to the directive tokens that's atomic to avoid data races.; /// \p CachedFileContents has ownership of the pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:80,Cache,CachedFileContents,80,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['Cache'],['CachedFileContents']
Performance,"/// According to the property that indexed load/store instructions zero-extend; /// their indices, try to narrow the type of index operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:43,load,load,43,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['load'],['load']
Performance,/// Account for slicing gain in the current cost.; /// Slicing provide a few gains like removing a shift or a; /// truncate. This method allows to grow the cost of the original; /// load with the gain from this slice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,load,load,182,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,/// ActOnPropertyImplDecl - This routine performs semantic checks and; /// builds the AST node for a property implementation declaration; declared; /// as \@synthesize or \@dynamic.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:41,perform,performs,41,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['perform'],['performs']
Performance,/// ActOnStartCategoryImplementation - Perform semantic checks on the; /// category implementation declaration and build an ObjCCategoryImplDecl; /// object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:39,Perform,Perform,39,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['Perform'],['Perform']
Performance,"/// ActOnStartDelayedCXXMethodDeclaration - We have completed; /// parsing a top-level (non-nested) C++ class, and we are now; /// parsing those parts of the given Method declaration that could; /// not be parsed earlier (C++ [class.mem]p2), such as default; /// arguments. This action should enter the scope of the given; /// Method declaration as if we had just parsed the qualified method; /// name. However, it should not bring the parameters into scope;; /// that will be performed by ActOnDelayedCXXMethodParameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:477,perform,performed,477,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['perform'],['performed']
Performance,"/// ActOnTypedefNameDecl - Perform semantic checking for a declaration which; /// declares a typedef-name, either using the 'typedef' type specifier or via; /// a C++0x [dcl.typedef]p2 alias-declaration: 'using T = A;'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,Perform,Perform,27,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Perform'],['Perform']
Performance,"/// Action - Represent an abstract compilation step to perform.; ///; /// An action represents an edge in the compilation graph; typically; /// it is a job to transform an input using some tool.; ///; /// The current driver is hard wired to expect actions which produce a; /// single primary output, at least in terms of controlling the; /// compilation. Actions can produce auxiliary files, but can only; /// produce a single output to feed into subsequent actions.; ///; /// Actions are usually owned by a Compilation, which creates new; /// actions via MakeAction().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h:55,perform,perform,55,interpreter/llvm-project/clang/include/clang/Driver/Action.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Action.h,1,['perform'],['perform']
Performance,/// Add a branch condition to the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:34,cache,cache,34,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,1,['cache'],['cache']
Performance,"/// Add a chain edge between a load and store if the store can be an; /// alias of the load on a subsequent iteration, i.e., a loop carried; /// dependence. This code is very similar to the code in ScheduleDAGInstrs; /// but that code doesn't create loop carried dependences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:31,load,load,31,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['load'],['load']
Performance,/// Add a definition for the given function to the queue of statements; /// to emit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h:51,queue,queue,51,interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h,1,['queue'],['queue']
Performance,"/// Add a new step in the initialization that performs a derived-to-; /// base cast.; ///; /// \param BaseType the base type to which we will be casting.; ///; /// \param Category Indicates whether the result will be treated as an; /// rvalue, an xvalue, or an lvalue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:46,perform,performs,46,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['perform'],['performs']
Performance,/// Add a new step that performs a function reference conversion to the; /// given type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:24,perform,performs,24,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['perform'],['performs']
Performance,/// Add a new step that performs a qualification conversion to the; /// given type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:24,perform,performs,24,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['perform'],['performs']
Performance,/// Add a new step that performs conversion from non-atomic to atomic; /// type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:24,perform,performs,24,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['perform'],['performs']
Performance,/// Add a pass to perform basic verification of the machine function if; /// verification is enabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:18,perform,perform,18,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['perform'],['perform']
Performance,"/// Add a pass to the queue of passes to run. This passes ownership of; /// the Pass to the PassManager. When the PassManager is destroyed, the pass; /// will be destroyed as well, so there is no need to delete the pass. This; /// may even destroy the pass right away if it is found to be redundant. This; /// implies that all passes MUST be allocated with 'new'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h:22,queue,queue,22,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h,1,['queue'],['queue']
Performance,"/// Add a segment to LR and coalesce when possible, just like; /// LR.addSegment(). Segments should be added in increasing start order for; /// best performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:149,perform,performance,149,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,1,['perform'],['performance']
Performance,"/// Add a stack map intrinsic call's live variable operands to a stackmap; /// or patchpoint target node's operand list.; ///; /// Constants are converted to TargetConstants purely as an optimization to; /// avoid constant materialization and register allocation.; ///; /// FrameIndex operands are converted to TargetFrameIndex so that ISEL does not; /// generate addess computation nodes, and so FinalizeISel can convert the; /// TargetFrameIndex into a DirectMemRefOp StackMap location. This avoids; /// address materialization and register allocation, but may also be required; /// for correctness. If a StackMap (or PatchPoint) intrinsic directly uses an; /// alloca in the entry block, then the runtime may assume that the alloca's; /// StackMap location can be read immediately after compilation and that the; /// location is valid at any point during execution (this is similar to the; /// assumption made by the llvm.gcroot intrinsic). If the alloca's location were; /// only available in a register, then the runtime would need to trap when; /// execution reaches the StackMap in order to read the alloca's location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:187,optimiz,optimization,187,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['optimiz'],['optimization']
Performance,"/// Add all of the Objective-C methods in the given Objective-C; /// container to the set of results.; ///; /// The container will be a class, protocol, category, or implementation of; /// any of the above. This mether will recurse to include methods from; /// the superclasses of classes along with their categories, protocols, and; /// implementations.; ///; /// \param Container the container in which we'll look to find methods.; ///; /// \param WantInstanceMethods Whether to add instance methods (only); if; /// false, this routine will add factory methods (only).; ///; /// \param CurContext the context in which we're performing the lookup that; /// finds methods.; ///; /// \param AllowSameLength Whether we allow a method to be added to the list; /// when it has the same number of parameters as we have selector identifiers.; ///; /// \param Results the structure into which we'll add results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:626,perform,performing,626,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['perform'],['performing']
Performance,/// Add an \@llvm.assume intrinsic to this function's cache.; ///; /// The call passed in must be an instruction within this function and must; /// not already be in the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:54,cache,cache,54,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,2,['cache'],['cache']
Performance,/// Add an object file to be linked. Pre-load compile unit die. Call; /// \p OnCUDieLoaded for each compile unit die. If \p File has reference to; /// a Clang module and UpdateIndexTablesOnly == false then the module is be; /// pre-loaded by \p Loader.; ///; /// \pre a call to setNoODR(true) and/or setUpdateIndexTablesOnly(bool Update); /// must be made when required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerBase.h:41,load,load,41,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/DWARFLinkerBase.h,3,"['Load', 'load']","['Loader', 'load', 'loaded']"
Performance,/// Add common passes that perform LLVM IR to IR transforms in preparation for; /// instruction selection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:27,perform,perform,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,4,['perform'],['perform']
Performance,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:47,perform,perform,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,4,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,/// Add common target configurable passes that perform LLVM IR to IR; /// transforms following machine independent optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:47,perform,perform,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,4,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,/// Add function candidates found via argument-dependent lookup; /// to the set of overloading candidates.; ///; /// This routine performs argument-dependent name lookup based on the; /// given function name (which may also be an operator name) and adds; /// all of the overload candidates found by ADL to the overload; /// candidate set (C++ [basic.lookup.argdep]).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:130,perform,performs,130,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['perform'],['performs']
Performance,"/// Add object file to be linked. Pre-load compile unit die. Call; /// \p OnCUDieLoaded for each compile unit die. If specified \p File; /// has reference to the Clang module then such module would be; /// pre-loaded by \p Loader for !Update case.; ///; /// \pre NoODR, Update options should be set before call to addObjectFile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h:38,load,load,38,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,6,"['Load', 'load']","['Loader', 'load', 'loaded']"
Performance,"/// Add other KahanSum into accumulator. Does not vectorise.; ///; /// Based on KahanIncrement from:; /// Y. Tian, S. Tatikonda and B. Reinwald, ""Scalable and Numerically Stable Descriptive Statistics in SystemML,"" 2012 IEEE 28th International Conference on Data Engineering, 2012, pp. 1351-1359, doi: 10.1109/ICDE.2012.12.; /// Note that while Tian et al. add the carry in the first step, we subtract; /// the carry, in accordance with the Add(Indexed) implementation(s) above.; /// This is purely an implementation choice that has no impact on performance.; ///; /// \note Take care when using += (and -=) to add other KahanSums into a zero-initialized; /// KahanSum. The operator behaves correctly in this case, but the result may be slightly; /// off if you expect 0 + x to yield exactly x (where 0 is the zero-initialized KahanSum; /// and x another KahanSum). In particular, x's carry term may get lost. This doesn't; /// just happen with zero-initialized KahanSums; see the SubtractWithABitTooSmallCarry; /// test case in the testKahan unittest for other examples. This behavior is internally; /// consistent: the carry also gets lost if you switch the operands and it also happens with; /// other KahanSum operators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h:146,Scalab,Scalable,146,math/mathcore/inc/Math/Util.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h,2,"['Scalab', 'perform']","['Scalable', 'performance']"
Performance,"/// Add passes that optimize instruction level parallelism for out-of-order; /// targets. These passes are run while the machine code is still in SSA; /// form, so they can use MachineTraceMetrics to control their heuristics.; ///; /// All passes added here should preserve the MachineDominatorTree,; /// MachineLoopInfo, and MachineTraceMetrics analyses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:20,optimiz,optimize,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['optimiz'],['optimize']
Performance,/// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:20,optimiz,optimize,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,4,['optimiz'],['optimize']
Performance,/// Add passes that optimize machine instructions in SSA form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:20,optimiz,optimize,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['optimiz'],['optimize']
Performance,"/// Add standard target-independent passes that are tightly coupled with; /// optimized register allocation, including coalescing, machine instruction; /// scheduling, and register allocation itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:78,optimiz,optimized,78,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['optimiz'],['optimized']
Performance,/// Add the encoded TypeString to the cache only if it is NonRecursive or; /// Recursive (viz: all sub-members were expanded as fully as possible).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:38,cache,cache,38,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,1,['cache'],['cache']
Performance,/// Add the following state to the analysis queue \c Queue.; ///; /// Assume the current state is \p PreviousNode and has been reached with a; /// penalty of \p Penalty. Insert a line break if \p NewLine is \c true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:44,queue,queue,44,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,2,"['Queue', 'queue']","['Queue', 'queue']"
Performance,"/// Add the given statement or expression to the queue of; /// statements to emit.; ///; /// This routine should be used when emitting types and declarations; /// that have expressions as part of their formulation. Once the; /// type or declaration has been written, Emit() will write; /// the corresponding statements just after the record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h:49,queue,queue,49,interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h,1,['queue'],['queue']
Performance,/// Add the referenced object file to the list of objects to be loaded and; /// relocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:64,load,loaded,64,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['load'],['loaded']
Performance,"/// Add the specified path to the specified group list, without performing any; /// sysroot remapping.; /// Returns true if the path exists, false if it was ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp:64,perform,performing,64,interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/InitHeaderSearch.cpp,1,['perform'],['performing']
Performance,/// Add the table \p Data loaded from file \p File.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h:26,load,loaded,26,interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/MultiOnDiskHashTable.h,1,['load'],['loaded']
Performance,/// Add to the record the first declaration from each module file that; /// provides a declaration of D. The intent is to provide a sufficient; /// set such that reloading this set will load all current redeclarations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:186,load,load,186,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['load'],['load']
Performance,/// Add to the record the first template specialization from each module; /// file that provides a declaration of D. We store the DeclId and an; /// ODRHash of the template arguments of D which should provide enough; /// information to load D only if the template instantiator needs it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:236,load,load,236,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['load'],['load']
Performance,"/// AddOverloadCandidate - Adds the given function to the set of; /// candidate functions, using the given function call arguments. If; /// @p SuppressUserConversions, then don't allow user-defined; /// conversions via constructors or conversion operators.; ///; /// \param PartialOverloading true if we are performing ""partial"" overloading; /// based on an incomplete set of function arguments. This feature is used by; /// code completion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:308,perform,performing,308,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['perform'],['performing']
Performance,/// AddPredQueued - Queues and update to add a predecessor edge to SUnit SU.; /// This returns true if this is a new predecessor.; /// Does *NOT* update the topological ordering! It just queues an update.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:20,Queue,Queues,20,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,"['Queue', 'queue']","['Queues', 'queues']"
Performance,/// Address-mode matching performs shift-of-and to and-of-shift; /// reassociation in order to expose more scaled addressing; /// opportunities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:26,perform,performs,26,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['perform'],['performs']
Performance,"/// AddressRangesMap class maps values to the address ranges.; /// It keeps normalized address ranges and corresponding values.; /// This class keeps a sorted vector of AddressRangeValuePair objects; /// and can perform insertions and searches efficiently.; /// Intersecting([100,200), [150,300)) ranges splitted into non-conflicting; /// parts([100,200), [200,300)). Adjacent([100,200), [200,300)) address; /// ranges are not combined during insertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h:212,perform,perform,212,interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AddressRanges.h,1,['perform'],['perform']
Performance,"/// Adds a barrier edge to SU by calling addPred(), with latency 0; /// generally or latency 1 for a store followed by a load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:57,latency,latency,57,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,3,"['latency', 'load']","['latency', 'load']"
Performance,/// Adds a node to the translation cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:35,cache,cache,35,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['cache'],['cache']
Performance,"/// Adds a requirement that another module flag be present and have a; /// specified value after linking is performed. The value must be a metadata; /// pair, where the first element of the pair is the ID of the module flag; /// to be restricted, and the second element of the pair is the value the; /// module flag should be restricted to. This behavior can be used to; /// restrict the allowable results (via triggering of an error) of linking; /// IDs with the **Override** behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:108,perform,performed,108,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['perform'],['performed']
Performance,"/// Adds barrier chain edges from all SUs in map, and then clear the map.; /// This is equivalent to insertBarrierChain(), but optimized for the common; /// case where the new BarrierChain (a global memory object) has a higher; /// NodeNum than all SUs in map. It is assumed BarrierChain has been set; /// before calling this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:127,optimiz,optimized,127,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['optimiz'],['optimized']
Performance,/// Adds dependencies from instructions in the current list of; /// instructions being scheduled to scheduling barrier. We want to make sure; /// instructions which define registers that are either used by the; /// terminator or are live-out are properly scheduled. This is especially; /// important when the definition latency of the return value(s) are too; /// high to be hidden by the branch or when the liveout registers used by; /// instructions in the fallthrough block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:320,latency,latency,320,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['latency'],['latency']
Performance,/// Adjust the \p GlobalLSCost according to the target; /// paring capabilities and the layout of the slices.; /// \pre \p GlobalLSCost should account for at least as many loads as; /// there is in the slices in \p LoadedSlices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:172,load,loads,172,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['Load', 'load']","['LoadedSlices', 'loads']"
Performance,"/// Advance the iterator to the first set bit AT, OR AFTER, \p Index. If; /// no such set bit exists, advance to end(). This is like std::lower_bound.; /// This is useful if \p Index is close to the current iterator position.; /// However, unlike \ref find(), this has worst-case O(n) performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:285,perform,performance,285,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,1,['perform'],['performance']
Performance,"/// AdvanceCycle - This callback is invoked whenever the next top-down; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts. This should increment the; /// internal state of the hazard recognizer so that previously ""Hazard""; /// instructions will now not be hazards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:162,latency,latency,162,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['latency'],['latency']
Performance,/// Advances \p OriginAddr to point to the next 32-bit origin and then loads; /// from it. Returns the origin's loaded value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:71,load,loads,71,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,2,['load'],"['loaded', 'loads']"
Performance,/// Algorithm parameters; default values are tuned on real-world binaries,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h:45,tune,tuned,45,interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,1,['tune'],['tuned']
Performance,/// Algorithm-specific params for Cache-Directed Sort. The values are tuned for; /// the best performance of large-scale front-end bound binaries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:34,Cache,Cache-Directed,34,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,3,"['Cache', 'perform', 'tune']","['Cache-Directed', 'performance', 'tuned']"
Performance,"/// All loaded modules, indexed by name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:8,load,loaded,8,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,"/// All specializations that that have already been loaded, ie avoiding; /// deserialization of lazily registered specializations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h:52,load,loaded,52,interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,3,['load'],['loaded']
Performance,"/// Allocate a memory block of (at least) the given size suitable for data.; /// The SectionID is a unique identifier assigned by the JIT engine, and; /// optionally recorded by the memory manager to access a loaded section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:209,load,loaded,209,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['load'],['loaded']
Performance,"/// Allocate a memory block of (at least) the given size suitable for; /// executable code. The SectionID is a unique identifier assigned by the; /// RuntimeDyld instance, and optionally recorded by the memory manager to; /// access a loaded section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:235,load,loaded,235,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['load'],['loaded']
Performance,"/// Allocate a number of loaded SLocEntries, which will be actually; /// loaded on demand from the external source.; ///; /// NumSLocEntries will be allocated, which occupy a total of TotalSize space; /// in the global source view. The lowest ID and the base offset of the; /// entries will be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:25,load,loaded,25,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,2,['load'],['loaded']
Performance,"/// Allocate space for a new set of loaded preprocessed entities.; ///; /// \returns The index into the set of loaded preprocessed entities, which; /// corresponds to the first newly-allocated entity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:36,load,loaded,36,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,2,['load'],['loaded']
Performance,"/// Allocate space for a new set of loaded preprocessed skipped; /// ranges.; ///; /// \returns The index into the set of loaded preprocessed ranges, which; /// corresponds to the first newly-allocated range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:36,load,loaded,36,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,2,['load'],['loaded']
Performance,"/// Allocates LS resources for instruction IR.; ///; /// This method assumes that a previous call to `isAvailable(IR)` succeeded; /// returning LSU_AVAILABLE.; ///; /// Rules are:; /// By default, rules are:; /// 1. A store may not pass a previous store.; /// 2. A load may not pass a previous store unless flag 'NoAlias' is set.; /// 3. A load may pass a previous load.; /// 4. A store may not pass a previous load (regardless of flag 'NoAlias').; /// 5. A load has to wait until an older load barrier is fully executed.; /// 6. A store has to wait until an older store barrier is fully executed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:265,load,load,265,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,6,['load'],['load']
Performance,"/// Allocates a register for VirtReg definition. Typically the register is; /// already assigned from a use of the virtreg, however we still need to; /// perform an allocation if:; /// - It is a dead definition without any uses.; /// - The value is live out and all uses are in different basic blocks.; ///; /// \return true if MI's MachineOperands were re-arranged/invalidated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:154,perform,perform,154,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['perform'],['perform']
Performance,"/// Allocates and fills a page that contains the index-th element. The default implementation searches; /// the page and calls LoadPageImpl(). Returns a default-constructed RPage for suppressed columns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:127,Load,LoadPageImpl,127,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['Load'],['LoadPageImpl']
Performance,/// Allocator for a cached set of global code completions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:20,cache,cached,20,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['cache'],['cached']
Performance,/// Allocator used to store cached code completions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:28,cache,cached,28,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['cache'],['cached']
Performance,/// Allocator used to store globally cached code-completion results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:37,cache,cached,37,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,1,['cache'],['cached']
Performance,"/// Allow non-dependent types to differ, e.g., when performing; /// template argument deduction from a function call where conversions; /// may apply.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:52,perform,performing,52,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['perform'],['performing']
Performance,/// Allow targets to perform final scheduling actions at the level of the; /// whole MachineFunction. By default does nothing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:21,perform,perform,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['perform'],['perform']
Performance,"/// Allow the insertion operator to return the actual remark type rather than a; /// common base class. This allows returning the result of the insertion; /// directly by value, e.g. return OptimizationRemarkAnalysis(...) << ""blah"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:190,Optimiz,OptimizationRemarkAnalysis,190,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['Optimiz'],['OptimizationRemarkAnalysis']
Performance,"/// Allow the target to reverse allocation order of local live ranges. This; /// will generally allocate shorter local live ranges first. For targets with; /// many registers, this could reduce regalloc compile time by a large; /// factor. It is disabled by default for three reasons:; /// (1) Top-down allocation is simpler and easier to debug for targets that; /// don't benefit from reversing the order.; /// (2) Bottom-up allocation could result in poor evicition decisions on some; /// targets affecting the performance of compiled code.; /// (3) Bottom-up allocation is no longer guaranteed to optimally color.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:513,perform,performance,513,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['perform'],['performance']
Performance,"/// AllowFPOpFusion - This flag is set by the -fp-contract=xxx option.; /// This controls the creation of fused FP ops that store intermediate; /// results in higher precision than IEEE allows (E.g. FMAs).; ///; /// Fast mode - allows formation of fused FP ops whenever they're; /// profitable.; /// Standard mode - allow fusion only for 'blessed' FP ops. At present the; /// only blessed op is the fmuladd intrinsic. In the future more blessed ops; /// may be added.; /// Strict mode - allow fusion only if/when it can be proven that the excess; /// precision won't effect the result.; ///; /// Note: This option only controls formation of fused ops by the; /// optimizers. Fused operations that are explicitly specified (e.g. FMA; /// via the llvm.fma.* intrinsic) will always be honored, regardless of; /// the value of this option.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:663,optimiz,optimizers,663,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['optimiz'],['optimizers']
Performance,/// Allows non-imported definitions to get the potentially more constraining; /// visibility from the prevailing definition. FromPrevailing is the default; /// because it works for many binary formats. ELF can use the more optimized; /// 'ELF' scheme.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:223,optimiz,optimized,223,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['optimiz'],['optimized']
Performance,"/// Allows us to assert that ASTUnit is not being used concurrently,; /// which is not supported.; ///; /// Clients should create instances of the ConcurrencyCheck class whenever; /// using the ASTUnit in a way that isn't intended to be concurrent, which is; /// just about any usage.; /// Becomes a noop in release mode; only useful for debug mode checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:55,concurren,concurrently,55,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,3,"['Concurren', 'concurren']","['ConcurrencyCheck', 'concurrent', 'concurrently']"
Performance,/// Also search for prebuilt implicit modules in the prebuilt module cache; /// path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h:69,cache,cache,69,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,1,['cache'],['cache']
Performance,/// Also try moving call address load from outside callseq_start to just; /// before the call to allow it to be folded.; ///; /// [Load chain]; /// ^; /// |; /// [Load]; /// ^ ^; /// | |; /// / \--; /// / |; ///[CALLSEQ_START] |; /// ^ |; /// | |; /// [LOAD/C2Reg] |; /// | |; /// \ /; /// \ /; /// [CALL],MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:33,load,load,33,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,4,"['LOAD', 'Load', 'load']","['LOAD', 'Load', 'load']"
Performance,"/// Always perform the requested mapping action on the element, even; /// if it was already mapped before.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h:11,perform,perform,11,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPConstants.h,1,['perform'],['perform']
Performance,"/// An Iterator adapter using an InnerInvGraphT::iterator as a base iterator,; /// and storing the VertexIdentifier the iterator range comes from. The; /// dereference operator is then performed using a pointer to the graph's edge; /// set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h:185,perform,performed,185,interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Graph.h,1,['perform'],['performed']
Performance,/// An LLVMContext together with an associated mutex that can be used to lock; /// the context to prevent concurrent access by other threads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h:106,concurren,concurrent,106,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ThreadSafeModule.h,1,['concurren'],['concurrent']
Performance,/// An LValue is a candidate for having its loads and stores be made atomic if; /// we are operating under /volatile:ms *and* the LValue itself is volatile and; /// performing such an operation can be performed without a libcall.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:44,load,loads,44,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,3,"['load', 'perform']","['loads', 'performed', 'performing']"
Performance,"/// An RAII class that tracks when the Preprocessor starts and stops lexing; /// the definition of a (ISO C/C++) variadic macro. As an example, this is; /// useful for unpoisoning and repoisoning certain identifiers (such as; /// __VA_ARGS__) that are only allowed in this context. Also, being a friend; /// of the Preprocessor class allows it to access PP's cached identifiers; /// directly (as opposed to performing a lookup each time).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/VariadicMacroSupport.h:359,cache,cached,359,interpreter/llvm-project/clang/include/clang/Lex/VariadicMacroSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/VariadicMacroSupport.h,2,"['cache', 'perform']","['cached', 'performing']"
Performance,/// An SDNode for swaps that are not associated with any loads/stores; /// and thereby have no chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:57,load,loads,57,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['load'],['loads']
Performance,/// An UnresolvedSet-like class that might not have been loaded from the; /// external AST source yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTUnresolvedSet.h:57,load,loaded,57,interpreter/llvm-project/clang/include/clang/AST/ASTUnresolvedSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTUnresolvedSet.h,1,['load'],['loaded']
Performance,"/// An abstract interface for privatizability.; ///; /// A pointer is privatizable if it can be replaced by a new, private one.; /// Privatizing pointer reduces the use count, interaction between unrelated; /// code parts.; ///; /// In order for a pointer to be privatizable its value cannot be observed; /// (=nocapture), it is (for now) not written (=readonly & noalias), we know; /// what values are necessary to make the private copy look like the original; /// one, and the values we need can be loaded (=dereferenceable).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:501,load,loaded,501,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['load'],['loaded']
Performance,/// An abstract superclass that describes a custom extension to the; /// module/precompiled header file format.; ///; /// A module file extension can introduce additional information into; /// compiled module files (.pcm) and precompiled headers (.pch) via a; /// custom writer that can then be accessed via a custom reader when; /// the module file or precompiled header is loaded.; ///; /// Subclasses must use LLVM RTTI for open class hierarchies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h:375,load,loaded,375,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFileExtension.h,1,['load'],['loaded']
Performance,"/// An allocator for DiagnosticStorage objects, which uses a small cache to; /// objects, used to reduce malloc()/free() traffic for partial diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:67,cache,cache,67,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['cache'],['cache']
Performance,/// An analysis for type-inference for VPValues.; /// It infers the scalar type for a given VPValue by bottom-up traversing; /// through defining recipes until root nodes with known types are reached (e.g.; /// live-ins or load recipes). The types are then propagated top down through; /// operations.; /// Note that the analysis caches the inferred types. A new analysis object must; /// be constructed once a VPlan has been modified in a way that invalidates any; /// of the previously inferred types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h:223,load,load,223,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanAnalysis.h,2,"['cache', 'load']","['caches', 'load']"
Performance,"/// An analysis over an ""inner"" IR unit that provides access to an; /// analysis manager over a ""outer"" IR unit. The inner unit must be contained; /// in the outer unit.; ///; /// For example OuterAnalysisManagerProxy<ModuleAnalysisManager, Function> is an; /// analysis over Functions (the ""inner"" unit) which provides access to a Module; /// analysis manager. The ModuleAnalysisManager is the ""outer"" manager being; /// proxied, and Modules are the ""outer"" IR unit. The inner/outer relationship; /// is valid because each Function is contained in one Module.; ///; /// This proxy only exposes the const interface of the outer analysis manager,; /// to indicate that you cannot cause an outer analysis to run from within an; /// inner pass. Instead, you must rely on the \c getCachedResult API. This is; /// due to keeping potential future concurrency in mind. To give an example,; /// running a module analysis before any function passes may give a different; /// result than running it in a function pass. Both may be valid, but it would; /// produce non-deterministic results. GlobalsAA is a good analysis example,; /// because the cached information has the mod/ref info for all memory for each; /// function at the time the analysis was computed. The information is still; /// valid after a function transformation, but it may be *different* if; /// recomputed after that transform. GlobalsAA is never invalidated.; ///; /// This proxy doesn't manage invalidation in any way -- that is handled by the; /// recursive return path of each layer of the pass manager. A consequence of; /// this is the outer analyses may be stale. We invalidate the outer analyses; /// only when we're done running passes over the inner IR units.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:841,concurren,concurrency,841,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,2,"['cache', 'concurren']","['cached', 'concurrency']"
Performance,/// An analysis pass to compute the \c CallGraph for a \c Module.; ///; /// This class implements the concept of an analysis pass used by the \c; /// ModuleAnalysisManager to run an analysis over a module and cache the; /// resulting data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h:209,cache,cache,209,interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CallGraph.h,1,['cache'],['cache']
Performance,/// An analysis pass which caches information about the Function.; /// Records the function level information used by GCRoots.; /// This pass depends on `CollectorMetadataAnalysis`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:27,cache,caches,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,1,['cache'],['caches']
Performance,/// An analysis pass which caches information about the entire Module.; /// Records a cache of the 'active' gc strategy objects for the current Module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:27,cache,caches,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,2,['cache'],"['cache', 'caches']"
Performance,/// An analysis pass which caches information about the entire Module.; /// Records both the function level information used by GCRoots and a; /// cache of the 'active' gc strategy objects for the current Module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:27,cache,caches,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,2,['cache'],"['cache', 'caches']"
Performance,/// An array of decls optimized for the common case of only containing; /// one entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclContextInternals.h:22,optimiz,optimized,22,interpreter/llvm-project/clang/include/clang/AST/DeclContextInternals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclContextInternals.h,1,['optimiz'],['optimized']
Performance,"/// An attacker may speculatively store over a value that is then speculatively; /// loaded and used as the target of an indirect call or jump instruction. This; /// is called Spectre v1.2 or Bounds Check Bypass Store (BCBS) and is described; /// in this paper:; /// https://people.csail.mit.edu/vlk/spectre11.pdf; ///; /// When this happens, the speculative execution of the call or jump will end up; /// being steered to this attacker controlled address. While most such loads; /// will be adequately hardened already, we want to ensure that they are; /// definitively treated as needing post-load hardening. While address hardening; /// is sufficient to prevent secret data from leaking to the attacker, it may; /// not be sufficient to prevent an attacker from steering speculative; /// execution. We forcibly unfolded all relevant loads above and so will always; /// have an opportunity to post-load harden here, we just need to scan for cases; /// not already flagged and add them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:85,load,loaded,85,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,5,['load'],"['load', 'loaded', 'loads']"
Performance,"/// An entry in the shadow map, which is optimized to store a; /// single declaration (the common case) but can also store a list; /// of declarations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:41,optimiz,optimized,41,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['optimiz'],['optimized']
Performance,"/// An entry in the shadow map, which is optimized to store; /// a single (declaration, index) mapping (the common case) but; /// can also store a list of (declaration, index) mappings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:41,optimiz,optimized,41,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['optimiz'],['optimized']
Performance,/// An ephemeral helper class for building MS RTTI types. It caches some; /// calls to the module and information about the most derived class in a; /// hierarchy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:61,cache,caches,61,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['cache'],['caches']
Performance,/// An immutable pass that tracks lazily created \c AssumptionCache; /// objects.; ///; /// This is essentially a workaround for the legacy pass manager's weaknesses; /// which associates each assumption cache with Function and clears it if the; /// function is deleted. The nature of the AssumptionCache is that it is not; /// invalidated by any changes to the function body and so this is sufficient; /// to be conservatively correct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:204,cache,cache,204,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['cache'],['cache']
Performance,/// An indicator of whether the current node is in a queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:53,queue,queue,53,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,1,['queue'],['queue']
Performance,/// An inferface for inquiring the load address of a loaded object file; /// to be used by the DIContext implementations when applying relocations; /// on the fly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h:35,load,load,35,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h,2,['load'],"['load', 'loaded']"
Performance,"/// An interface for accessing data in a stream-like format, but which; /// discourages copying. Instead of specifying a buffer in which to copy; /// data on a read, the API returns an ArrayRef to data owned by the stream's; /// implementation. Since implementations may not necessarily store data in a; /// single contiguous buffer (or even in memory at all), in such cases a it may; /// be necessary for an implementation to cache such a buffer so that it can; /// return it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h:427,cache,cache,427,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStream.h,1,['cache'],['cache']
Performance,/// An item in the prioritized BFS search queue. The \c StateNode's; /// \c State has the given \c OrderedPenalty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:42,queue,queue,42,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['queue'],['queue']
Performance,/// An object which temporarily prevents a value from being; /// destroyed by aggressive peephole optimizations that assume that; /// all uses of a value have been realized in the IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:98,optimiz,optimizations,98,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['optimiz'],['optimizations']
Performance,"/// An operation on a type.; ///; /// \tparam ImplClass Class implementing the operation. Must be inherited from; /// TypeVisitor.; /// \tparam RetTy %Type of result produced by the operation.; ///; /// The class implements polymorphic operation on an object of type derived; /// from Type. The operation is performed by calling method Visit. It then; /// dispatches the call to function \c VisitFooType, if actual argument type; /// is \c FooType.; ///; /// The class implements static polymorphism using Curiously Recurring; /// Template Pattern. It is designed to be a base class for some concrete; /// class:; ///; /// \code; /// class SomeVisitor : public TypeVisitor<SomeVisitor,sometype> { ... };; /// ...; /// Type *atype = ...; /// ...; /// SomeVisitor avisitor;; /// sometype result = avisitor.Visit(atype);; /// \endcode; ///; /// Actual treatment is made by methods of the derived class, TypeVisitor only; /// dispatches call to the appropriate method. If the implementation class; /// \c ImplClass provides specific action for some type, say; /// \c ConstantArrayType, it should define method; /// <tt>VisitConstantArrayType(const ConstantArrayType*)</tt>. Otherwise; /// \c TypeVisitor dispatches call to the method that handles parent type. In; /// this example handlers are tried in the sequence:; ///; /// \li <tt>ImplClass::VisitConstantArrayType(const ConstantArrayType*)</tt>; /// \li <tt>ImplClass::VisitArrayType(const ArrayType*)</tt>; /// \li <tt>ImplClass::VisitType(const Type*)</tt>; /// \li <tt>TypeVisitor::VisitType(const Type*)</tt>; ///; /// The first function of this sequence that is defined will handle object of; /// type \c ConstantArrayType.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeVisitor.h:308,perform,performed,308,interpreter/llvm-project/clang/include/clang/AST/TypeVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeVisitor.h,1,['perform'],['performed']
Performance,/// An optimization pass inserting data prefetches in loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDataPrefetch.h:7,optimiz,optimization,7,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDataPrefetch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopDataPrefetch.h,1,['optimiz'],['optimization']
Performance,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:7,optimiz,optimization,7,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['optimiz'],['optimization']
Performance,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:7,optimiz,optimization,7,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['optimiz'],['optimization']
Performance,/// An optimization pass to turn multiple LDR / STR ops of the same base and; /// incrementing offset into LDM / STM ops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:7,optimiz,optimization,7,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['optimiz'],['optimization']
Performance,"/// An ordered map of auto-generated variables to their unique names.; /// It stores variables with the following names: 1) "".gomp_critical_user_"" +; /// <critical_section_name> + "".var"" for ""omp critical"" directives; 2); /// <mangled_name_for_global_var> + "".cache."" for cache for threadprivate; /// variables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:260,cache,cache,260,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,4,['cache'],['cache']
Performance,/// An owning collection for any auxiliary matchers created while optimizing; /// nested matchers contained.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:66,optimiz,optimizing,66,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,2,['optimiz'],['optimizing']
Performance,/// Analyze - Get an instruction sequence to load immediate Imm. The last; /// instruction in the sequence must be an ADDiu if LastInstrIsADDiu is; /// true;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:45,load,load,45,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,1,['load'],['load']
Performance,/// Analyze and optimize control flow related to the specified block. This; /// is never called on the entry block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h:16,optimiz,optimize,16,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,1,['optimiz'],['optimize']
Performance,"/// Analyze data dependencies that exist between memory loads or stores,; /// in the graph nodes and create edges between them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:56,load,loads,56,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,1,['load'],['loads']
Performance,/// Analyze profitability of direct move; /// prefer float load to int load plus direct move; /// when there is no integer use of int load,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:59,load,load,59,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,3,['load'],['load']
Performance,"/// Analyze the given select instruction, returning true if; /// it cannot be understood. It is assumed that MI->isSelect() is true.; ///; /// When successful, return the controlling condition and the operands that; /// determine the true and false result values.; ///; /// Result = SELECT Cond, TrueOp, FalseOp; ///; /// Some targets can optimize select instructions, for example by predicating; /// the instruction defining one of the operands. Such targets should set; /// Optimizable.; ///; /// @param MI Select instruction to analyze.; /// @param Cond Condition controlling the select.; /// @param TrueOp Operand number of the value selected when Cond is true.; /// @param FalseOp Operand number of the value selected when Cond is false.; /// @param Optimizable Returned as true if MI is optimizable.; /// @returns False on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:339,optimiz,optimize,339,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,4,"['Optimiz', 'optimiz']","['Optimizable', 'optimizable', 'optimize']"
Performance,/// Analyze the interleaved accesses and collect them in interleave; /// groups. Substitute symbolic strides using \p Strides.; /// Consider also predicated loads/stores in the analysis if; /// \p EnableMaskedInterleavedGroup is true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:157,load,loads,157,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['load'],['loads']
Performance,"/// Analyze the name and prototype of the given function and set any; /// applicable attributes. Note that this merely helps optimizations on an; /// already existing function but does not consider mandatory attributes.; ///; /// If the library function is unavailable, this doesn't modify it.; ///; /// Returns true if any attributes were set and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h:125,optimiz,optimizations,125,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BuildLibCalls.h,1,['optimiz'],['optimizations']
Performance,"/// Analyze the return values of a function, returning true if the return can; /// be performed without sret-demotion and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp:86,perform,performed,86,interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallingConvLower.cpp,1,['perform'],['performed']
Performance,"/// Analyze the specified global variable and optimize it if possible. If we; /// make a change, return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:46,optimiz,optimize,46,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['optimiz'],['optimize']
Performance,"/// Analyze the specified global variable and optimize; /// it if possible. If we make a change, return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:46,optimiz,optimize,46,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['optimiz'],['optimize']
Performance,"/// AnalyzeIndirectGlobalMemory - We found an non-address-taken global variable; /// which holds a pointer type. See if the global always points to non-aliased; /// heap memory: that is, all initializers of the globals store a value known; /// to be obtained via a noalias return function call which have no other use.; /// Further, all loads out of GV must directly use the memory, not store the; /// pointer somewhere. If this is true, we consider the memory pointed to by; /// GV to be owned by GV and can disambiguate other pointers from it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:337,load,loads,337,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['load'],['loads']
Performance,"/// Another version of `LoadPage` that allows to specify cluster-relative indexes.; /// Returns a default-constructed RPage for suppressed columns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:24,Load,LoadPage,24,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['Load'],['LoadPage']
Performance,"/// Append all `events` to the internal RooDataSet or increment the bins of a RooDataHist at the given locations.; ///; /// \param events Events to fill into `data`. The layout is assumed to be `(x, y, z, ...) (x, y, z, ...), (...)`.; /// \note The order of the variables inside `events` must be consistent with the order given in the constructor.; /// No matching by name is performed.; /// \param eventSize Size of a single event.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsDataHelper.cxx:376,perform,performed,376,roofit/roofitcore/src/RooAbsDataHelper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsDataHelper.cxx,1,['perform'],['performed']
Performance,/// Appends enum types to Enc and adds the encoding to the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:59,cache,cache,59,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,1,['cache'],['cache']
Performance,/// Appends structure and union types to Enc and adds encoding to cache.; /// Recursively calls appendType (via extractFieldType) for each field.; /// Union types have their fields ordered according to the ABI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:66,cache,cache,66,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,1,['cache'],['cache']
Performance,"/// Applies the first rule whose pattern matches; other rules are ignored. If; /// the matchers are independent then order doesn't matter. In that case,; /// `applyFirst` is simply joining the set of rules into one.; //; // `applyFirst` is like an `anyOf` matcher with an edit action attached to each; // of its cases. Anywhere you'd use `anyOf(m1.bind(""id1""), m2.bind(""id2""))` and; // then dispatch on those ids in your code for control flow, `applyFirst` lifts; // that behavior to the rule level. So, you can write `applyFirst({makeRule(m1,; // action1), makeRule(m2, action2), ...});`; //; // For example, consider a type `T` with a deterministic serialization function,; // `serialize()`. For performance reasons, we would like to make it; // non-deterministic. Therefore, we want to drop the expectation that; // `a.serialize() = b.serialize() iff a = b` (although we'll maintain; // `deserialize(a.serialize()) = a`).; //; // We have three cases to consider (for some equality function, `eq`):; // ```; // eq(a.serialize(), b.serialize()) --> eq(a,b); // eq(a, b.serialize()) --> eq(deserialize(a), b); // eq(a.serialize(), b) --> eq(a, deserialize(b)); // ```; //; // `applyFirst` allows us to specify each independently:; // ```; // auto eq_fun = functionDecl(...);; // auto method_call = cxxMemberCallExpr(...);; //; // auto two_calls = callExpr(callee(eq_fun), hasArgument(0, method_call),; // hasArgument(1, method_call));; // auto left_call =; // callExpr(callee(eq_fun), callExpr(hasArgument(0, method_call)));; // auto right_call =; // callExpr(callee(eq_fun), callExpr(hasArgument(1, method_call)));; //; // RewriteRule R = applyFirst({makeRule(two_calls, two_calls_action),; // makeRule(left_call, left_call_action),; // makeRule(right_call, right_call_action)});; // ```; /// @{",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:698,perform,performance,698,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,1,['perform'],['performance']
Performance,/// Applies the given attribute to the Decl without performing any; /// additional semantic checking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:52,perform,performing,52,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['perform'],['performing']
Performance,"/// Applies the transformations described by \p Config to \p In and writes; /// the result into \p Out. This function does the dispatch based on the; /// format of the input binary (COFF, ELF, MachO or wasm).; /// \returns any Error encountered whilst performing the operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/ObjCopy.h:252,perform,performing,252,interpreter/llvm-project/llvm/include/llvm/ObjCopy/ObjCopy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/ObjCopy.h,1,['perform'],['performing']
Performance,/// Applies the transformations described by \p Config to; /// each member in archive \p Ar.; /// Writes a result in a file specified by \p Config.OutputFilename.; /// \returns any Error encountered whilst performing the operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/ObjCopy.h:206,perform,performing,206,interpreter/llvm-project/llvm/include/llvm/ObjCopy/ObjCopy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/ObjCopy.h,1,['perform'],['performing']
Performance,"/// Apply VPlan-to-VPlan optimizations to \p Plan, including induction recipe; /// optimizations, dead recipe removal, replicate region optimizations and; /// block merging.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:25,optimiz,optimizations,25,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,3,['optimiz'],['optimizations']
Performance,/// Apply a Cache-Directed Sort for functions represented by a call graph.; /// The placement is done by optimizing the call locality by co-locating; /// frequently executed functions.; /// \p FuncSizes: The sizes of the nodes (in bytes).; /// \p FuncCounts: The execution counts of the nodes in the profile.; /// \p CallCounts: The execution counts of every edge (jump) in the profile. The; /// map also defines the edges in CFG and should include 0-count edges.; /// \p CallOffsets: The offsets of the calls from their source nodes.; /// \returns The best function order found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:12,Cache,Cache-Directed,12,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,2,"['Cache', 'optimiz']","['Cache-Directed', 'optimizing']"
Performance,/// Apply a Cache-Directed Sort with a custom config.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:12,Cache,Cache-Directed,12,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,1,['Cache'],['Cache-Directed']
Performance,/// Apply a post-processing step optimizing block placement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:33,optimiz,optimizing,33,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['optimiz'],['optimizing']
Performance,"/// Apply a set of heuristics to a new candidate. Heuristics are currently; /// hierarchical. This may be more efficient than a graduated cost model because; /// we don't need to evaluate all aspects of the model for each node in the; /// queue. But it's really done to make the heuristics easier to debug and; /// statistically analyze.; ///; /// \param Cand provides the policy and current best candidate.; /// \param TryCand refers to the next SUnit candidate, otherwise uninitialized.; /// \param Zone describes the scheduled zone that we are extending, or nullptr; /// if Cand is from a different zone than TryCand.; /// \return \c true if TryCand is better than Cand (Reason is NOT NoCand)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:239,queue,queue,239,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['queue'],['queue']
Performance,/// Apply the transformations described by \p Config and \p COFFConfig; /// to \p In and writes the result into \p Out.; /// \returns any Error encountered whilst performing the operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/COFF/COFFObjcopy.h:163,perform,performing,163,interpreter/llvm-project/llvm/include/llvm/ObjCopy/COFF/COFFObjcopy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/COFF/COFFObjcopy.h,1,['perform'],['performing']
Performance,/// Apply the transformations described by \p Config and \p ELFConfig to; /// \p In and writes the result into \p Out.; /// \returns any Error encountered whilst performing the operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/ELF/ELFObjcopy.h:162,perform,performing,162,interpreter/llvm-project/llvm/include/llvm/ObjCopy/ELF/ELFObjcopy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/ELF/ELFObjcopy.h,1,['perform'],['performing']
Performance,"/// Apply the transformations described by \p Config and \p ELFConfig to; /// \p In, which is treated as a raw binary input, and writes the result; /// into \p Out.; /// \returns any Error encountered whilst performing the operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/ELF/ELFObjcopy.h:208,perform,performing,208,interpreter/llvm-project/llvm/include/llvm/ObjCopy/ELF/ELFObjcopy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/ELF/ELFObjcopy.h,1,['perform'],['performing']
Performance,"/// Apply the transformations described by \p Config and \p ELFConfig to; /// \p In, which must represent an IHex file, and writes the result; /// into \p Out.; /// \returns any Error encountered whilst performing the operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/ELF/ELFObjcopy.h:203,perform,performing,203,interpreter/llvm-project/llvm/include/llvm/ObjCopy/ELF/ELFObjcopy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/ELF/ELFObjcopy.h,1,['perform'],['performing']
Performance,/// Apply the transformations described by \p Config and \p MachOConfig to; /// \p In and writes the result into \p Out.; /// \returns any Error encountered whilst performing the operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/MachO/MachOObjcopy.h:164,perform,performing,164,interpreter/llvm-project/llvm/include/llvm/ObjCopy/MachO/MachOObjcopy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/MachO/MachOObjcopy.h,2,['perform'],['performing']
Performance,/// Apply the transformations described by \p Config and \p WasmConfig; /// to \p In and writes the result into \p Out.; /// \returns any Error encountered whilst performing the operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/wasm/WasmObjcopy.h:163,perform,performing,163,interpreter/llvm-project/llvm/include/llvm/ObjCopy/wasm/WasmObjcopy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/wasm/WasmObjcopy.h,1,['perform'],['performing']
Performance,/// Apply the transformations described by \p Config and \p XCOFFConfig; /// to \p In and writes the result into \p Out.; /// \returns any Error encountered whilst performing the operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/XCOFF/XCOFFObjcopy.h:164,perform,performing,164,interpreter/llvm-project/llvm/include/llvm/ObjCopy/XCOFF/XCOFFObjcopy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ObjCopy/XCOFF/XCOFFObjcopy.h,1,['perform'],['performing']
Performance,"/// ApplyOneQAOverride - Apply a list of edits to the input argument lists.; ///; /// The input string is a space separated list of edits to perform,; /// they are applied in order to the input argument lists. Edits; /// should be one of the following forms:; ///; /// '#': Silence information about the changes to the command line arguments.; ///; /// '^': Add FOO as a new argument at the beginning of the command line.; ///; /// '+': Add FOO as a new argument at the end of the command line.; ///; /// 's/XXX/YYY/': Substitute the regular expression XXX with YYY in the command; /// line.; ///; /// 'xOPTION': Removes all instances of the literal argument OPTION.; ///; /// 'XOPTION': Removes all instances of the literal argument OPTION,; /// and the following argument.; ///; /// 'Ox': Removes all flags matching 'O' or 'O[sz0-9]' and adds 'Ox'; /// at the end of the command line.; ///; /// \param OS - The stream to write edit information to.; /// \param Args - The vector of command line arguments.; /// \param Edit - The override command to perform.; /// \param SavedStrings - Set to use for storing string representations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:141,perform,perform,141,interpreter/llvm-project/clang/tools/driver/driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp,2,['perform'],['perform']
Performance,/// ApproxFuncFPMath - This flag is enabled when the; /// -enable-approx-func-fp-math is specified on the command line. This; /// specifies that optimizations are allowed to substitute math functions; /// with approximate calculations,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:145,optimiz,optimizations,145,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['optimiz'],['optimizations']
Performance,/// Are the two types RVV-bitcast-compatible types? I.e. is bitcasting from the; /// first RVV type (e.g. an RVV scalable type) to the second type (e.g. an RVV; /// VLS type) allowed?; ///; /// This will also return false if the two given types do not make sense from; /// the perspective of RVV bitcasts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:113,scalab,scalable,113,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['scalab'],['scalable']
Performance,/// Are we optimizing for code size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:11,optimiz,optimizing,11,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['optimiz'],['optimizing']
Performance,"/// Arrange the argument and result information for the function type; /// through which to perform a send to the given Objective-C method,; /// using the given receiver type. The receiver type is not always; /// the 'self' type of the method or even an Objective-C pointer type.; /// This is *not* the right method for actually performing such a; /// message send, due to the possibility of optional arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:92,perform,perform,92,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,2,['perform'],"['perform', 'performing']"
Performance,"/// As an optimization, there is no need to emit an entry in the directory; /// table for the same directory as DW_AT_comp_dir.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:10,optimiz,optimization,10,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,1,['optimiz'],['optimization']
Performance,"/// As part of recovering from missing or changed content, produce a; /// fake content cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:87,cache,cache,87,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['cache'],['cache']
Performance,"/// As we scan instructions optimizing them, this is the next instruction; /// to optimize. Transforms that can invalidate this should update it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:28,optimiz,optimizing,28,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,2,['optimiz'],"['optimize', 'optimizing']"
Performance,/// Asserts that the cached info for \p BB is up-to-date. This helps to catch; /// the usage error of accessing a block without properly invalidating after a; /// previous transform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:21,cache,cached,21,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,1,['cache'],['cached']
Performance,"/// Assign DWARF discriminators.; ///; /// To assign discriminators, we examine the boundaries of every; /// basic block and its successors. Suppose there is a basic block B1; /// with successor B2. The last instruction I1 in B1 and the first; /// instruction I2 in B2 are located at the same file and line number.; /// This situation is illustrated in the following code snippet:; ///; /// if (i < 10) x = i;; ///; /// entry:; /// br i1 %cmp, label %if.then, label %if.end, !dbg !10; /// if.then:; /// %1 = load i32* %i.addr, align 4, !dbg !10; /// store i32 %1, i32* %x, align 4, !dbg !10; /// br label %if.end, !dbg !10; /// if.end:; /// ret void, !dbg !12; ///; /// Notice how the branch instruction in block 'entry' and all the; /// instructions in block 'if.then' have the exact same debug location; /// information (!dbg !10).; ///; /// To distinguish instructions in block 'entry' from instructions in; /// block 'if.then', we generate a new lexical block for all the; /// instruction in block 'if.then' that share the same file and line; /// location with the last instruction of block 'entry'.; ///; /// This new lexical block will have the same location information as; /// the previous one, but with a new DWARF discriminator value.; ///; /// One of the main uses of this discriminator value is in runtime; /// sample profilers. It allows the profiler to distinguish instructions; /// at location !dbg !10 that execute on different basic blocks. This is; /// important because while the predicate 'if (x < 10)' may have been; /// executed millions of times, the assignment 'x = i' may have only; /// executed a handful of times (meaning that the entry->if.then edge is; /// seldom taken).; ///; /// If we did not have discriminator information, the profiler would; /// assign the same weight to both blocks 'entry' and 'if.then', which; /// in turn will make it conclude that the entry->if.then edge is very; /// hot.; ///; /// To decide where to create new discriminator values, this func",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:508,load,load,508,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,1,['load'],['load']
Performance,"/// Associates a FileID with its ""included/expanded in"" decomposed; /// location.; ///; /// Used to cache results from and speed-up \c getDecomposedIncludedLoc; /// function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:100,cache,cache,100,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['cache'],['cache']
Performance,/// Associates the given entry with the filename in the local cache and; /// returns it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:62,cache,cache,62,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cache']
Performance,"/// Assume that a legal-sized 'or'-reduction of shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:63,load,loaded,63,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,6,"['Load', 'load', 'optimiz']","['Load', 'load', 'loaded', 'optimizer']"
Performance,"/// Assume that a vector of stores of bitwise-or/shifted/zexted loaded values; /// can be load combined in the backend. Load combining may not be allowed in; /// the IR optimizer, so we do not want to alter the pattern. For example,; /// partially transforming a scalar bswap() pattern into vector code is; /// effectively impossible for the backend to undo.; /// TODO: If load combining is allowed in the IR optimizer, this analysis; /// may not be necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:64,load,loaded,64,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,6,"['Load', 'load', 'optimiz']","['Load', 'load', 'loaded', 'optimizer']"
Performance,/// Assumption Cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:15,Cache,Cache,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['Cache'],['Cache']
Performance,/// Assumption cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:15,cache,cache,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['cache'],['cache']
Performance,"/// At this point, we have learned that the only two values ever stored into GV; /// are its initializer and OtherVal. See if we can shrink the global into a; /// boolean and select between the two values whenever it is used. This exposes; /// the values to other scalar optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:271,optimiz,optimizations,271,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['optimiz'],['optimizations']
Performance,"/// Atomic pointer that's lock-free, but that can coordinate concurrent writes; /// from a lazy generator. Should be reserved for cases where concurrent uses of; /// a generator for the same storage is unlikely.; ///; /// The laziness comes in with \a loadOrGenerate(), which lazily calls the; /// provided generator ONLY when the value is currently \c nullptr. With; /// concurrent calls, only one generator is called and the rest see that value.; ///; /// Most other APIs treat an in-flight \a loadOrGenerate() as if \c nullptr; /// were stored. APIs that are required to write a value will spin.; ///; /// The underlying storage is \a std::atomic<uintptr_t>.; ///; /// TODO: In C++20, use std::atomic<T>::wait() instead of spinning and call; /// std::atomic<T>::notify_all() in \a loadOrGenerate().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:61,concurren,concurrent,61,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,6,"['concurren', 'load']","['concurrent', 'loadOrGenerate']"
Performance,/// AtomicExpandID -- Lowers atomic operations in terms of either cmpxchg; /// load-linked/store-conditional loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:79,load,load-linked,79,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['load'],['load-linked']
Performance,"/// Atomically add a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AADD instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] + __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,perform,performance,234,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h,1,['perform'],['performance']
Performance,"/// Atomically add a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AADD instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] + __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,perform,performance,234,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h,1,['perform'],['performance']
Performance,"/// Atomically and a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AAND instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] AND __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,perform,performance,234,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h,1,['perform'],['performance']
Performance,"/// Atomically and a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AAND instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] AND __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,perform,performance,234,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h,1,['perform'],['performance']
Performance,"/// Atomically or a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AOR instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] OR __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:233,perform,performance,233,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h,1,['perform'],['performance']
Performance,"/// Atomically or a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AOR instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] OR __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:233,perform,performance,233,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h,1,['perform'],['performance']
Performance,"/// Atomically xor a 32-bit value at memory operand \a __A and a 32-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AXOR instruction.; ///; /// \param __A; /// A pointer to a 32-bit memory location.; /// \param __B; /// A 32-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+31:__A] := MEM[__A+31:__A] XOR __B[31:0]; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,perform,performance,234,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h,1,['perform'],['performance']
Performance,"/// Atomically xor a 64-bit value at memory operand \a __A and a 64-bit \a __B,; /// and store the result to the same memory location.; ///; /// This intrinsic should be used for contention or weak ordering. It may; /// result in bad performance for hot data used by single thread only.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c AXOR instruction.; ///; /// \param __A; /// A pointer to a 64-bit memory location.; /// \param __B; /// A 64-bit integer value.; ///; /// \code{.operation}; /// MEM[__A+63:__A] := MEM[__A+63:__A] XOR __B[63:0]; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h:234,perform,performance,234,interpreter/llvm-project/clang/lib/Headers/raointintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/raointintrin.h,1,['perform'],['performance']
Performance,"/// Attach an external AST source to the AST context.; ///; /// The external AST source provides the ability to load parts of; /// the abstract syntax tree as needed from some external storage,; /// e.g., a precompiled header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:112,load,load,112,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['load'],['load']
Performance,"/// Attach body to a C++0x range-based for statement.; ///; /// By default, performs semantic analysis to finish the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:76,perform,performs,76,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Attach the body to a new case statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Attach the body to the switch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,/// Attemps to make calls as fast as possible while guaranteeing that tail; /// call optimization can always be performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h:85,optimiz,optimization,85,interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,2,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"/// Attempt a user-defined conversion between two types (C++ [dcl.init]),; /// which enumerates all conversion functions and performs overload resolution; /// to select the best.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:125,perform,performs,125,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performs']
Performance,"/// Attempt initialization by constructor (C++ [dcl.init]), which; /// enumerates the constructors of the initialized entity and performs overload; /// resolution to select the best.; /// \param DestType The destination class type.; /// \param DestArrayType The destination type, which is either DestType or; /// a (possibly multidimensional) array of DestType.; /// \param IsListInit Is this list-initialization?; /// \param IsInitListCopy Is this non-list-initialization resulting from a; /// list-initialization from {x} where x is the same; /// type as the entity?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:129,perform,performs,129,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['performs']
Performance,"/// Attempt to classify the name at the current token position. This may; /// form a type, scope or primary expression annotation, or replace the token; /// with a typo-corrected keyword. This is only appropriate when the current; /// name must refer to an entity which has already been declared.; ///; /// \param CCC Indicates how to perform typo-correction for this name. If NULL,; /// no typo correction will be performed.; /// \param AllowImplicitTypename Whether we are in a context where a dependent; /// nested-name-specifier without typename is treated as a type (e.g.; /// T::type).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:335,perform,perform,335,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,2,['perform'],"['perform', 'performed']"
Performance,"/// Attempt to constant fold an instruction with the; /// specified opcode and operands. If successful, the constant result is; /// returned, if not, null is returned. Note that this function can fail when; /// attempting to fold instructions like loads and stores, which have no; /// constant expression form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:248,load,loads,248,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['load'],['loads']
Performance,"/// Attempt to create the given module from the specified source buffer.; /// Does not load the module or make any submodule visible; for that, use; /// loadModule and makeModuleVisible.; ///; /// \param Loc The location at which to create the module.; /// \param ModuleName The name of the module to create.; /// \param Source The source of the module: a (preprocessed) module map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:87,load,load,87,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,2,['load'],"['load', 'loadModule']"
Performance,/// Attempt to eliminate a load whose dependencies are; /// non-local by performing PHI construction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,load,load,27,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,"['load', 'perform']","['load', 'performing']"
Performance,"/// Attempt to eliminate a load, first by eliminating it; /// locally, and then attempting non-local elimination if that fails.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,load,load,27,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['load'],['load']
Performance,"/// Attempt to extract the fields of \p LCV and bind them to the struct region; /// \p R.; ///; /// This path is used when it seems advantageous to ""force"" loading the values; /// within a LazyCompoundVal to bind memberwise to the struct region, rather; /// than using a Default binding at the base of the entire region. This is a; /// heuristic attempting to avoid building long chains of LazyCompoundVals.; ///; /// \returns The updated store bindings, or \c std::nullopt if binding; /// non-lazily would be too expensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:156,load,loading,156,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['load'],['loading']
Performance,"/// Attempt to fix the degenerate cases when the instruction serialization; /// causes the register lifetimes to overlap. For example,; /// p' = store_pi(p, b); /// = load p, offset; /// In this case p and p' overlap, which means that two registers are needed.; /// Instead, this function changes the load to use p' and updates the offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:167,load,load,167,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,2,['load'],['load']
Performance,"/// Attempt to fold a load or store of the specified stack; /// slot into the specified machine instruction for the specified operand(s).; /// If this is possible, a new instruction is returned with the specified; /// operand folded, otherwise NULL is returned.; /// The new instruction is inserted before MI, and the client is responsible; /// for removing the old instruction.; /// If VRM is passed, the assigned physregs can be inspected by target to; /// decide on using an opcode (note that those assignments can still change).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:22,load,load,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['load'],['load']
Performance,"/// Attempt to fold an SSE floating point to integer conversion of a constant; /// floating point. If roundTowardZero is false, the default IEEE rounding is; /// used (toward nearest, ties to even). This matches the behavior of the; /// non-truncating SSE instructions in the default rounding mode. The desired; /// integer type Ty is used to select how many bits are available for the; /// result. Returns null if the conversion cannot be performed, otherwise; /// returns the Constant value resulting from the conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:440,perform,performed,440,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['perform'],['performed']
Performance,"/// Attempt to load API notes for the given framework. A framework will have; /// the API notes file under either {FrameworkPath}/APINotes,; /// {FrameworkPath}/Headers or {FrameworkPath}/PrivateHeaders, while a; /// library will have the API notes simply in its directory.; ///; /// \param FrameworkPath The path to the framework.; /// \param Public Whether to load the public API notes. Otherwise, attempt; /// to load the private API notes.; ///; /// \returns the header directory entry (e.g., for Headers or PrivateHeaders); /// for which the API notes were successfully loaded, or NULL if API notes; /// could not be loaded for any reason.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h:15,load,load,15,interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,5,['load'],"['load', 'loaded']"
Performance,/// Attempt to load a debug object from disk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h:15,load,load,15,interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/DwarfLinkerForBinary.h,1,['load'],['load']
Performance,"/// Attempt to load the given module.; ///; /// This routine attempts to load the module described by the given; /// parameters. If there is a module cache, this may implicitly compile the; /// module before loading it.; ///; /// \param ImportLoc The location of the 'import' keyword.; ///; /// \param Path The identifiers (and their locations) of the module; /// ""path"", e.g., ""std.vector"" would be split into ""std"" and ""vector"".; ///; /// \param Visibility The visibility provided for the names in the loaded; /// module.; ///; /// \param IsInclusionDirective Indicates that this module is being loaded; /// implicitly, due to the presence of an inclusion directive. Otherwise,; /// it is being loaded due to an import declaration.; ///; /// \returns If successful, returns the loaded module. Otherwise, returns; /// NULL to indicate that the module could not be loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:15,load,load,15,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,9,"['cache', 'load']","['cache', 'load', 'loaded', 'loading']"
Performance,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:51,load,load,51,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,7,"['Load', 'load', 'optimiz', 'perform']","['Load', 'load', 'optimization', 'perform']"
Performance,"/// Attempt to negate \p Root. Retuns nullptr if negation can't be performed,; /// otherwise returns negated value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:67,perform,performed,67,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,1,['perform'],['performed']
Performance,"/// Attempt to perform the SMS algorithm on the specified loop. This function is; /// the main entry point for the algorithm. The function identifies candidate; /// loops, calculates the minimum initiation interval, and attempts to schedule; /// the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:15,perform,perform,15,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['perform'],['perform']
Performance,/// Attempt to propagate a given AND node back to load leaves so that they; /// can be combined into narrow loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:50,load,load,50,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],"['load', 'loads']"
Performance,"/// Attempt to use the vbroadcast instruction to generate a splat value; /// from a splat BUILD_VECTOR which uses:; /// a. A single scalar load, or a constant.; /// b. Repeated pattern of constants (e.g. <0,1,0,1> or <0,1,2,3,0,1,2,3>).; ///; /// The VBROADCAST node is returned when a pattern is found,; /// or SDValue() otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:139,load,load,139,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,"/// Attempt to write a symbol table to the bitcode file. This must be called; /// at most once after all modules have been written.; ///; /// A reader does not require a symbol table to interpret a bitcode file;; /// the symbol table is needed only to improve link-time performance. So; /// this function may decide not to write a symbol table. It may so decide; /// if, for example, the target is unregistered or the IR is malformed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:270,perform,performance,270,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,1,['perform'],['performance']
Performance,"/// Attempts to create a new module and add it to the list of known; /// modules.; ///; /// \param FileName The file name of the module to be loaded.; ///; /// \param Type The kind of module being loaded.; ///; /// \param ImportLoc The location at which the module is imported.; ///; /// \param ImportedBy The module that is importing this module, or NULL if; /// this module is imported directly by the user.; ///; /// \param Generation The generation in which this module was loaded.; ///; /// \param ExpectedSize The expected size of the module file, used for; /// validation. This will be zero if unknown.; ///; /// \param ExpectedModTime The expected modification time of the module; /// file, used for validation. This will be zero if unknown.; ///; /// \param ExpectedSignature The expected signature of the module file, used; /// for validation. This will be zero if unknown.; ///; /// \param ReadSignature Reads the signature from an AST file without actually; /// loading it.; ///; /// \param Module A pointer to the module file if the module was successfully; /// loaded.; ///; /// \param ErrorStr Will be set to a non-empty string if any errors occurred; /// while trying to load the module.; ///; /// \return A pointer to the module that corresponds to this file name,; /// and a value indicating whether the module was loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:142,load,loaded,142,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,7,['load'],"['load', 'loaded', 'loading']"
Performance,"/// Attempts to load a pass plugin from a given file.; ///; /// \returns Returns an error if either the library cannot be found or loaded,; /// there is no public entry point, or the plugin implements the wrong API; /// version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h:16,load,load,16,interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,2,['load'],"['load', 'loaded']"
Performance,/// Attempts to load the global index.; ///; /// \returns true if loading the global index has failed for any reason.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:16,load,load,16,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,2,['load'],"['load', 'loading']"
Performance,"/// Attempts to reduce a cleanup's entry block to a fallthrough. This; /// is basically llvm::MergeBlockIntoPredecessor, except; /// simplified/optimized for the tighter constraints on cleanup blocks.; ///; /// Returns the new block, whatever it is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:144,optimiz,optimized,144,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,1,['optimiz'],['optimized']
Performance,"/// Attempts to rewrite the location operand of debug intrinsics in terms of; /// the coroutine frame pointer, folding pointer offsets into the DIExpression; /// of the intrinsic.; /// If the frame pointer is an Argument, store it into an alloca if; /// OptimizeFrame is false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:254,Optimiz,OptimizeFrame,254,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,1,['Optimiz'],['OptimizeFrame']
Performance,/// AvailableQueue - The priority queue to use for the available SUnits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:34,queue,queue,34,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,2,['queue'],['queue']
Performance,/// AvailableQueue - The priority queue to use for the available SUnits.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:34,queue,queue,34,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['queue'],['queue']
Performance,/// BBInfo - Per-basic block information used internally by SSAUpdaterImpl.; /// The predecessors of each block are cached here since pred_iterator is; /// slow and we need to iterate over the blocks at least a few times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h:116,cache,cached,116,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterImpl.h,1,['cache'],['cached']
Performance,"/// BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions; /// and truncation for bfloat16. These nodes form a semi-softened interface; /// for dealing with bf16 (as an i16), which is often a storage-only type but; /// has native conversions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:57,perform,perform,57,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['perform'],['perform']
Performance,/// BFI and PSI are used to check for profile guided size optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:58,optimiz,optimizations,58,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,2,['optimiz'],['optimizations']
Performance,"/// BITCAST - This operator converts between integer, vector and FP; /// values, as if the value was stored to memory with one type and loaded; /// from the same address with the other type (or equivalently for vector; /// format conversions, etc). The source and result are required to have; /// the same bit size (e.g. f32 <-> i32). This can also be used for; /// int-to-int or fp-to-fp conversions, but that is a noop, deleted by; /// getNode().; ///; /// This operator is subtly different from the bitcast instruction from; /// LLVM-IR since this node may change the bits in the register. For; /// example, this occurs on big-endian NEON and big-endian MSA where the; /// layout of the bits in the register depends on the vector type and this; /// operator acts as a shuffle operation for some vector type combinations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:136,load,loaded,136,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['load'],['loaded']
Performance,"/// BRCOND - Conditional branch. The first operand is the chain, the; /// second is the condition, the third is the block to branch to if the; /// condition is true. If the type of the condition is not i1, then the; /// high bits must conform to getBooleanContents. If the condition is undef,; /// it nondeterministically jumps to the block.; /// TODO: Its semantics w.r.t undef requires further discussion; we need to; /// make it sure that it is consistent with optimizations in MIR & the; /// meaning of IMPLICIT_DEF. See https://reviews.llvm.org/D92015",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:464,optimiz,optimizations,464,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['optimiz'],['optimizations']
Performance,/// Base class for LoadSDNode and StoreSDNode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:19,Load,LoadSDNode,19,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['Load'],['LoadSDNode']
Performance,"/// Base class for a JIT linker.; ///; /// A JITLinkerBase instance links one object file into an ongoing JIT; /// session. Symbol resolution and finalization operations are pluggable,; /// and called using continuation passing (passing a continuation for the; /// remaining linker work) to allow them to be performed asynchronously.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h:308,perform,performed,308,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/JITLinkGeneric.h,1,['perform'],['performed']
Performance,/// Base class for inspecting loads and stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:30,load,loads,30,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,1,['load'],['loads']
Performance,"/// Base class for instruction visitors; ///; /// Instruction visitors are used when you want to perform different actions; /// for different kinds of instructions without having to use lots of casts; /// and a big switch statement (in your code, that is).; ///; /// To define your own visitor, inherit from this class, specifying your; /// new type for the 'SubClass' template parameter, and ""override"" visitXXX; /// functions in your class. I say ""override"" because this class is defined; /// in terms of statically resolved overloading, not virtual functions.; ///; /// For example, here is a visitor that counts the number of malloc; /// instructions processed:; ///; /// /// Declare the class. Note that we derive from InstVisitor instantiated; /// /// with _our new subclasses_ type.; /// ///; /// struct CountAllocaVisitor : public InstVisitor<CountAllocaVisitor> {; /// unsigned Count;; /// CountAllocaVisitor() : Count(0) {}; ///; /// void visitAllocaInst(AllocaInst &AI) { ++Count; }; /// };; ///; /// And this class would be used like this:; /// CountAllocaVisitor CAV;; /// CAV.visit(function);; /// NumAllocas = CAV.Count;; ///; /// The defined has 'visit' methods for Instruction, and also for BasicBlock,; /// Function, and Module, which recursively process all contained instructions.; ///; /// Note that if you don't implement visitXXX for some instruction type,; /// the visitXXX method for instruction superclass will be invoked. So; /// if instructions are added in the future, they will be automatically; /// supported, if you handle one of their superclasses.; ///; /// The optional second template argument specifies the type that instruction; /// visitation functions should return. If you specify this, you *MUST* provide; /// an implementation of visitInstruction though!.; ///; /// Note that this class is specifically designed as a template to avoid; /// virtual function call overhead. Defining and using an InstVisitor is just; /// as efficient as having your own switch ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstVisitor.h:97,perform,perform,97,interpreter/llvm-project/llvm/include/llvm/IR/InstVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstVisitor.h,1,['perform'],['perform']
Performance,"/// Base class shared by cached entries, representing objects and archives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:25,cache,cached,25,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,1,['cache'],['cached']
Performance,"/// Base class to perform data transformations from TTree branches to RNTuple fields if necessary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx:18,perform,perform,18,tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/inc/ROOT/RNTupleImporter.hxx,1,['perform'],['perform']
Performance,"/// Base memory addresses of load/store instructions, grouped by block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:29,load,load,29,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,1,['load'],['load']
Performance,/// Base type for MachOBuilder load command wrappers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h:31,load,load,31,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h,1,['load'],['load']
Performance,"/// Based only on latency of instructions, determine if it is cost efficient; /// to replace the instruction InstDesc by the instructions stored in the; /// array InstDescRepl.; /// Return true if replacement is expected to be faster.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:18,latency,latency,18,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,2,['latency'],['latency']
Performance,/// Basic-block the load instructions are within,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:20,load,load,20,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['load'],['load']
Performance,"/// Because 4 contiguous bytes share one 4-byte origin, the most accurate load; /// is __dfsan_load_label_and_origin. This function returns the union of all; /// labels and the origin of the first taint label. However this is an; /// additional call with many instructions. To ensure common cases are fast,; /// checks if it is possible to load labels and origins without using the; /// callback function.; ///; /// When enabling tracking load instructions, we always use; /// __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:74,load,load,74,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,3,['load'],['load']
Performance,"/// Begin iterator for local, non-loaded, preprocessed entities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:34,load,loaded,34,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['load'],['loaded']
Performance,/// Bits from load opcodes used to compute HW prefetcher instruction tags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp:14,load,load,14,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp,1,['load'],['load']
Performance,/// Bitwise AND assignment operator.; ///; /// Performs a bitwise AND operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:47,Perform,Performs,47,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['Perform'],['Performs']
Performance,/// Bitwise AND assignment operator.; ///; /// Performs a bitwise AND operation on this APInt and RHS. The result is; /// assigned to *this.; ///; /// \returns *this after ANDing with RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:47,Perform,Performs,47,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['Perform'],['Performs']
Performance,/// Bitwise OR assignment operator.; ///; /// Performs a bitwise OR operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:46,Perform,Performs,46,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['Perform'],['Performs']
Performance,/// Bitwise OR assignment operator.; ///; /// Performs a bitwise OR operation on this APInt and RHS. The result is; /// assigned *this;; ///; /// \returns *this after ORing with RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:46,Perform,Performs,46,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['Perform'],['Performs']
Performance,/// Bitwise XOR assignment operator.; ///; /// Performs a bitwise XOR operation on this APInt and RHS. RHS is; /// logically zero-extended or truncated to match the bit-width of; /// the LHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:47,Perform,Performs,47,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['Perform'],['Performs']
Performance,/// Bitwise XOR assignment operator.; ///; /// Performs a bitwise XOR operation on this APInt and RHS. The result is; /// assigned to *this.; ///; /// \returns *this after XORing with RHS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:47,Perform,Performs,47,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['Perform'],['Performs']
Performance,/// Blocking wait for all the threads to complete and the queue to be empty.; /// It is an error to try to add new tasks while blocking on this call.; /// Calling wait() from a task would deadlock waiting for itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h:58,queue,queue,58,interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,1,['queue'],['queue']
Performance,"/// Bloom filter is a stochastic data structure which can tell us if a symbol; /// name does not exist in a library with 100% certainty. If it tells us it; /// exists this may not be true:; /// https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2; ///; /// ELF has this optimization in the new linkers by default, It is stored in the; /// gnu.hash section of the object file.; ///; ///\returns true if the symbol may be in the library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:275,optimiz,optimization,275,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['optimiz'],['optimization']
Performance,"/// BranchFolding - This pass performs machine code CFG based; /// optimizations to delete branches to branches, eliminate branches to; /// successor blocks (creating fall throughs), and eliminating branches over; /// branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:30,perform,performs,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,2,"['optimiz', 'perform']","['optimizations', 'performs']"
Performance,/// Break after each annotation on a field in Java files.; /// \code{.java}; /// true: false:; /// @Partial vs. @Partial @Mock DataLoad loader;; /// @Mock; /// DataLoad loader;; /// \endcode; /// \version 3.8,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:136,load,loader,136,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,2,['load'],['loader']
Performance,/// Break the memcpy's load and store into smaller copies; /// such that each memory load that was blocked by a smaller store; /// would now be copied separately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:23,load,load,23,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,2,['load'],['load']
Performance,"/// Buffer size to use for writing to files, must be a multiple of 4096 bytes. Testing suggests that 4MiB gives best; /// performance (with Direct I/O) at a reasonable memory consumption.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:122,perform,performance,122,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,1,['perform'],['performance']
Performance,/// Build 'order' clause with argument \p A ('concurrent').; ///; /// \param A Argument of the clause ('concurrent').; /// \param ALoc Starting location of the argument.; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param EndLoc Ending location of the clause.; /// \param Modifier The modifier applied to 'order' clause.; /// \param MLoc Location of the modifier,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:46,concurren,concurrent,46,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,2,['concurren'],['concurrent']
Performance,"/// Build a fat object default optimization pipeline.; ///; /// This builds a pipeline that runs the LTO/ThinLTO pre-link pipeline, and; /// emits a section containing the pre-link bitcode along side the object code; /// generated in non-LTO compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:31,optimiz,optimization,31,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['optimiz'],['optimization']
Performance,"/// Build a new ""if"" statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:54,perform,performs,54,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new (previously unresolved) declaration reference; /// expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:101,perform,performs,101,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ ""delete"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,perform,performs,63,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ ""new"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,perform,performs,60,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ ""this"" expression.; ///; /// By default, builds a new ""this"" expression without performing any; /// semantic analysis. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:100,perform,performing,100,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performing']
Performance,"/// Build a new C++ __builtin_bit_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:73,perform,performs,73,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ __uuidof(expr) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,perform,performs,69,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ __uuidof(type) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,perform,performs,69,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ catch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,perform,performs,59,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ const_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ dynamic_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ exception declaration.; ///; /// By default, performs semantic analysis to build the new decaration.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ functional-style cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:76,perform,performs,76,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ reinterpret_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,perform,performs,71,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ static_cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,perform,performs,66,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ throw expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,perform,performs,60,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ try statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,perform,performs,57,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ typeid(expr) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ typeid(type) expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++ zero-initialization expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:74,perform,performs,74,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++0x range-based for statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,perform,performs,71,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['perform'],['performs']
Performance,"/// Build a new C++11 decltype type.; ///; /// By default, performs semantic analysis when building the decltype type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,perform,performs,59,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C++1z fold-expression.; ///; /// By default, performs semantic analysis in order to build a new fold; /// expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,perform,performs,61,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new C-style cast expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,perform,performs,63,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new DependentAddressSpaceType or return the pointee; /// type variable with the correct address space (retrieved from; /// AddrSpaceExpr) applied to it. The former will be returned in cases; /// where the address space remains dependent.; ///; /// By default, performs semantic analysis when building the type with address; /// space applied. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:272,perform,performs,272,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new GNU statement expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,perform,performs,64,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new MS style inline asm statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,perform,performs,69,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C ""isa"" expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,perform,performs,68,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C \@autoreleasepool statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:79,perform,performs,79,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C \@catch statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,perform,performs,69,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C \@encode expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,perform,performs,71,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C \@finally statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,perform,performs,71,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C \@synchronized statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:76,perform,performs,76,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C \@throw statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,perform,performs,69,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C \@try statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C array literal.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C boxed expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,perform,performs,68,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C dictionary literal.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,perform,performs,70,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C fast enumeration statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:78,perform,performs,78,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C ivar reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:77,perform,performs,77,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new Objective-C property reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:81,perform,performs,81,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['perform'],['performs']
Performance,"/// Build a new OpenMP 'affinity' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,perform,performs,64,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'align' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,perform,performs,61,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'aligned' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,perform,performs,63,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'allocate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,perform,performs,64,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'allocator' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'at' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,perform,performs,58,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'bind' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,perform,performs,60,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'collapse' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,perform,performs,64,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'copyin' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,perform,performs,62,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'copyprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'default' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,perform,performs,63,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'defaultmap' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,perform,performs,66,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'depend' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,perform,performs,69,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'depobj' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,perform,performs,69,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'destroy' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,perform,performs,63,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'detach' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,perform,performs,62,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'device' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,perform,performs,62,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'dist_schedule' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,perform,performs,69,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'doacross' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,perform,performs,64,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'exclusive' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'filter' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,perform,performs,62,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'final' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,perform,performs,61,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'firstprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,perform,performs,68,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'flush' pseudo clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,perform,performs,68,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'from' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,perform,performs,60,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'grainsize' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'has_device_addr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,perform,performs,71,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'hint' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,perform,performs,60,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'if' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,perform,performs,58,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'in_reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,perform,performs,68,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'inclusive' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'init' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,perform,performs,60,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'is_device_ptr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,perform,performs,69,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'lastprivate' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'linear' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,perform,performs,62,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'map' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,perform,performs,59,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'message' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,perform,performs,63,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'nocontext' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'nontemporal' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'novariants' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,perform,performs,66,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'num_tasks' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'num_teams' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'num_threads' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'ompx_attribute' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,perform,performs,70,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'ompx_bare' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'ompx_dyn_cgroup_mem' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:75,perform,performs,75,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'order' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,perform,performs,61,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'ordered' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,perform,performs,63,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'priority' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,perform,performs,64,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'private' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,perform,performs,63,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'proc_bind' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'safelen' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,perform,performs,63,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'schedule' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,perform,performs,64,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'severity' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,perform,performs,64,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'shared' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,perform,performs,62,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'simdlen' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,perform,performs,63,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'task_reduction' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,perform,performs,70,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'thread_limit' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,perform,performs,68,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'to' clause.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,perform,performs,58,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'use' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,perform,performs,59,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'use_device_addr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,perform,performs,71,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'use_device_ptr' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,perform,performs,70,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP 'uses_allocators' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,perform,performs,71,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new OpenMP executable directive.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new \c va_arg expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,perform,performs,60,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new __builtin_choose_expr expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:72,perform,performs,72,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new address-of-label expression.; ///; /// By default, performs semantic analysis, using the name of the label; /// rather than attempting to map the label statement itself.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new array section expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,perform,performs,64,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new array shaping expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,perform,performs,64,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new array subscript expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,perform,performs,66,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new array type given the element type, size; /// modifier, size of the array (if known), size expression, and index type; /// qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.; /// Also by default, all of the other Rebuild*Array",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:172,perform,performs,172,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new array type trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new atomic operation expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new atomic type given its value type.; ///; /// By default, performs semantic analysis when building the atomic type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:72,perform,performs,72,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new attributed statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,perform,performs,60,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new binary operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:66,perform,performs,66,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new block pointer type given its pointee type.; ///; /// By default, performs semantic analysis when building the block pointer; /// type. Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:81,perform,performs,81,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new builtin offsetof expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new call expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:55,perform,performs,55,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new case statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:54,perform,performs,54,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new co_await expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,perform,performs,59,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['perform'],['performs']
Performance,"/// Build a new co_return statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,perform,performs,59,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new co_yield expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,perform,performs,59,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new compound literal expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new compound statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,perform,performs,58,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new conditional operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:71,perform,performs,71,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new constant array type given the element type, size; /// modifier, (known) size of the array, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:156,perform,performs,156,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new declaration statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,perform,performs,61,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new default statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,perform,performs,57,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new dependent-sized array type given the element type,; /// size modifier, size expression, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,perform,performs,153,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new designated initializer expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:73,perform,performs,73,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new do-while statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:58,perform,performs,58,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new expression in parentheses.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new expression list in parentheses.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,perform,performs,70,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new expression pack expansion.; ///; /// By default, performs semantic analysis to build a new pack expansion; /// for an expression. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new expression representing a call to a source location; /// builtin.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:104,perform,performs,104,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new expression that references a declaration.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:80,perform,performs,80,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['perform'],['performs']
Performance,"/// Build a new expression trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new extended vector element access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:81,perform,performs,81,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new extended vector type given the element type and; /// number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:111,perform,performs,111,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new for statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,perform,performs,53,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new function type.; ///; /// By default, performs semantic analysis when building the function type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:53,perform,performs,53,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new generic selection expression with a type predicate.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:90,perform,performs,90,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new generic selection expression with an expression predicate.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:97,perform,performs,97,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new goto statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:54,perform,performs,54,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new incomplete array type given the element type, size; /// modifier, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:131,perform,performs,131,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new indirect goto statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:63,perform,performs,63,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new initializer list expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new inline asm statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,perform,performs,60,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new iterator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,perform,performs,59,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new label statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:55,perform,performs,55,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new matrix subscript expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new member access expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:64,perform,performs,64,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new member pointer type given the pointee type and the; /// class type it refers into.; ///; /// By default, performs semantic analysis when building the member pointer; /// type. Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:121,perform,performs,121,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new member reference expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:67,perform,performs,67,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['perform'],['performs']
Performance,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:730,perform,performed,730,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['perform'],['performed']
Performance,"/// Build a new noexcept expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:59,perform,performs,59,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new object-construction expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:70,perform,performs,70,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,3,['perform'],['performs']
Performance,"/// Build a new overloaded operator call expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// The semantic analysis provides the behavior of template instantiation,; /// copying with transformations that turn what looks like an overloaded; /// operator call into a use of a builtin operator, performing; /// argument-dependent lookup, etc. Subclasses may override this routine to; /// provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:75,perform,performs,75,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['perform'],"['performing', 'performs']"
Performance,"/// Build a new pointer type given its pointee type.; ///; /// By default, performs semantic analysis when building the pointer type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:75,perform,performs,75,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new potentially dependently-sized extended vector type; /// given the element type and number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:141,perform,performs,141,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,['perform'],['performs']
Performance,"/// Build a new predefined expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,perform,performs,61,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new pseudo-destructor expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,perform,performs,68,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new reference type given the type it references.; ///; /// By default, performs semantic analysis when building the; /// reference type. Subclasses may override this routine to provide; /// different behavior.; ///; /// \param LValue whether the type was written with an lvalue sigil; /// or an rvalue sigil.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:83,perform,performs,83,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new return statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:56,perform,performs,56,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new rewritten operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:69,perform,performs,69,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new shuffle vector expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new sizeof, alignof or vec step expression with an; /// expression argument.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:111,perform,performs,111,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new sizeof, alignof or vec_step expression with a; /// type argument.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:104,perform,performs,104,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new template argument pack expansion.; ///; /// By default, performs semantic analysis to build a new pack expansion; /// for a template argument. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:72,perform,performs,72,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new template name given a nested name specifier and the; /// name that is referred to as a template.; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:135,perform,performs,135,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new template name given a nested name specifier and the; /// overloaded operator name that is referred to as a template.; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:155,perform,performs,155,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new template name given a template template parameter pack; /// and the; ///; /// By default, performs semantic analysis to determine whether the name can; /// be resolved to a specific template, then builds the appropriate kind of; /// template name. Subclasses may override this routine to provide different; /// behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:106,perform,performs,106,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new template specialization type.; ///; /// By default, performs semantic analysis when building the template; /// specialization type. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:68,perform,performs,68,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new template-id expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:62,perform,performs,62,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new type trait expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:61,perform,performs,61,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new typename type that refers to an identifier.; ///; /// By default, performs semantic analysis when building the typename type; /// (or elaborated type). Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:82,perform,performs,82,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new typeof(expr) type.; ///; /// By default, performs semantic analysis when building the typeof type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:57,perform,performs,57,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new unary operator expression.; ///; /// By default, performs semantic analysis to build the new expression.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:65,perform,performs,65,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new value-initialized expression.; ///; /// By default, builds the implicit value initialization without performing; /// any semantic analysis. Subclasses may override this routine to provide; /// different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:117,perform,performing,117,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performing']
Performance,"/// Build a new variable-length array type given the element type,; /// size modifier, size expression, and index type qualifiers.; ///; /// By default, performs semantic analysis when building the array type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:153,perform,performs,153,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new vector type given the element type and; /// number of elements.; ///; /// By default, performs semantic analysis when building the vector type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:102,perform,performs,102,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a new while statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:55,perform,performs,55,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build a per-module default optimization pipeline.; ///; /// This provides a good default optimization pipeline for per-module; /// optimization and code generation without any link-time optimization. It; /// typically correspond to frontend ""-O[123]"" options for optimization; /// levels \c O1, \c O2 and \c O3 resp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:31,optimiz,optimization,31,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,5,['optimiz'],['optimization']
Performance,"/// Build a pre-link, LTO-targeting default optimization pipeline to a pass; /// manager.; ///; /// This adds the pre-link optimizations tuned to work well with a later LTO; /// run. It works to minimize the IR which needs to be analyzed without; /// making irreversible decisions which could be made better during the LTO; /// run.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:44,optimiz,optimization,44,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,3,"['optimiz', 'tune']","['optimization', 'optimizations', 'tuned']"
Performance,"/// Build a pre-link, ThinLTO-targeting default optimization pipeline to; /// a pass manager.; ///; /// This adds the pre-link optimizations tuned to prepare a module for; /// a ThinLTO run. It works to minimize the IR which needs to be analyzed; /// without making irreversible decisions which could be made better during; /// the LTO run.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:48,optimiz,optimization,48,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,3,"['optimiz', 'tune']","['optimization', 'optimizations', 'tuned']"
Performance,"/// Build an LTO default optimization pipeline to a pass manager.; ///; /// This provides a good default optimization pipeline for link-time; /// optimization and code generation. It is particularly tuned to fit well; /// when IR coming into the LTO phase was first run through \c; /// addPreLinkLTODefaultPipeline, and the two coordinate closely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:25,optimiz,optimization,25,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,4,"['optimiz', 'tune']","['optimization', 'tuned']"
Performance,"/// Build an Objective-C object type.; ///; /// By default, performs semantic analysis when building the object type.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:60,perform,performs,60,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Build an ThinLTO default optimization pipeline to a pass manager.; ///; /// This provides a good default optimization pipeline for link-time; /// optimization and code generation. It is particularly tuned to fit well; /// when IR coming into the LTO phase was first run through \c; /// addPreLinkLTODefaultPipeline, and the two coordinate closely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:29,optimiz,optimization,29,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,4,"['optimiz', 'tune']","['optimization', 'tuned']"
Performance,"/// Build and attach the minimal necessary MIB metadata. If the alloc has a; /// single allocation type, add a function attribute instead. The reason for; /// adding an attribute in this case is that it matches how the behavior for; /// allocation calls will be communicated to lib call simplification after; /// cloning or another optimization to distinguish the allocation types,; /// which is lower overhead and more direct than maintaining this metadata.; /// Returns true if memprof metadata attached, false if not (attribute added).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:332,optimiz,optimization,332,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,1,['optimiz'],['optimization']
Performance,"/// Build and insert G_PREFETCH \p Addr, \p RW, \p Locality, \p CacheType",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:64,Cache,CacheType,64,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,1,['Cache'],['CacheType']
Performance,"/// Build and insert `Res = <opcode> Addr, MMO`.; ///; /// Loads the value stored at \p Addr. Puts the result in \p Res.; ///; /// \pre setBasicBlock or setMI must have been called.; /// \pre \p Res must be a generic virtual register.; /// \pre \p Addr must be a generic virtual register with pointer type.; ///; /// \return a MachineInstrBuilder for the newly created instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:59,Load,Loads,59,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,1,['Load'],['Loads']
Performance,"/// Build and insert `Res = G_LOAD Addr, MMO`.; ///; /// Loads the value stored at \p Addr. Puts the result in \p Res.; ///; /// \pre setBasicBlock or setMI must have been called.; /// \pre \p Res must be a generic virtual register.; /// \pre \p Addr must be a generic virtual register with pointer type.; ///; /// \return a MachineInstrBuilder for the newly created instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:57,Load,Loads,57,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,1,['Load'],['Loads']
Performance,/// Build instruction(s) for an indirect register read.; ///; /// \returns The instruction that performs the indirect register read,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h:96,perform,performs,96,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,1,['perform'],['performs']
Performance,/// Build instruction(s) for an indirect register write.; ///; /// \returns The instruction that performs the indirect register write,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h:97,perform,performs,97,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,1,['perform'],['performs']
Performance,/// Build the copy and dispose helpers for the given __block variable; /// emission. Places the helpers in the global cache. Returns null; /// if no helpers are required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:118,cache,cache,118,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['cache'],['cache']
Performance,"/// Build the coroutine body statements that require a non-dependent; /// promise type in order to construct.; ///; /// For example different new/delete overloads are selected depending on; /// if the promise type provides `unhandled_exception()`, and therefore they; /// cannot be built until the promise type is complete so that we can perform; /// name lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h:338,perform,perform,338,interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/CoroutineStmtBuilder.h,1,['perform'],['perform']
Performance,/// Build the metaclass object for a class.; ///; /// struct _class_t {; /// struct _class_t *isa;; /// struct _class_t * const superclass;; /// void *cache;; /// IMP *vtable;; /// struct class_ro_t *ro;; /// }; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:151,cache,cache,151,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['cache'],['cache']
Performance,"/// Build up the general order of nodes, by performing a topological sort of the; /// parent region's nodes, while ensuring that there is no outer cycle node; /// between any two inner cycle nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:44,perform,performing,44,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,1,['perform'],['performing']
Performance,"/// BuildActions - Construct the list of actions to perform for the; /// given arguments, which are only done for a single architecture.; ///; /// \param C - The compilation that is being built.; /// \param Args - The input arguments.; /// \param Actions - The list to store the resulting actions onto.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:52,perform,perform,52,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['perform'],['perform']
Performance,"/// BuildCallToObjectOfClassType - Build a call to an object of class; /// type (C++ [over.call.object]), which can end up invoking an; /// overloaded function call operator (@c operator()) or performing a; /// user-defined conversion on the object argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:193,perform,performing,193,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['perform'],['performing']
Performance,"/// BuildConvertedConstantExpression - Check that the expression From is a; /// converted constant expression of type T, perform the conversion but; /// does not evaluate the expression",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:121,perform,perform,121,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['perform'],['perform']
Performance,"/// BuildDeclaratorGroup - convert a list of declarations into a declaration; /// group, performing any necessary semantic checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:89,perform,performing,89,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['perform'],['performing']
Performance,/// BuildIDFetcher searches local cache directories for debug info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/BuildID.h:34,cache,cache,34,interpreter/llvm-project/llvm/include/llvm/Object/BuildID.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/BuildID.h,1,['cache'],['cache']
Performance,"/// BuildJobsForAction - Construct the jobs to perform for the action \p A and; /// return an InputInfo for the result of running \p A. Will only construct; /// jobs for a given (Action, ToolChain, BoundArch, DeviceKind) tuple once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:47,perform,perform,47,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['perform'],['perform']
Performance,/// BuildOffloadingActions - Construct the list of actions to perform for the; /// offloading toolchain that will be embedded in the host.; ///; /// \param C - The compilation that is being built.; /// \param Args - The input arguments.; /// \param Input - The input type and arguments; /// \param HostAction - The host action used in the offloading toolchain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:62,perform,perform,62,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['perform'],['perform']
Performance,"/// BuildUniversalActions - Construct the list of actions to perform; /// for the given arguments, which may require a universal build.; ///; /// \param C - The compilation that is being built.; /// \param TC - The default host tool chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:61,perform,perform,61,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['perform'],['perform']
Performance,/// Builder for the alloca slices.; ///; /// This class builds a set of alloca slices by recursively visiting the uses; /// of an alloca and making a slice for each load and store at each offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:165,load,load,165,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['load'],['load']
Performance,"/// Builds a bloom filter lookup optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:33,optimiz,optimization,33,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['optimiz'],['optimization']
Performance,/// Builds a cache to make future calls to expandedToken(SourceRange) faster.; /// Creates an index only once. Further calls to it will be no-op.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:13,cache,cache,13,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,1,['cache'],['cache']
Performance,"/// Builds a dependency file when attached to a Preprocessor (for includes) and; /// ASTReader (for module imports), and writes it out at the end of processing; /// a source file. Users should attach to the ast reader whenever a module is; /// loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h:244,load,loaded,244,interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,1,['load'],['loaded']
Performance,/// Builds an AST for 'Code' with additional flags.; ///; /// \param Code C++ code.; /// \param Args Additional flags to pass on.; /// \param FileName The file name which 'Code' will be mapped as.; /// \param ToolName The name of the binary running the tool. Standard library; /// header paths will be resolved relative to this.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; ///; /// \param Adjuster A function to filter the command line arguments as specified.; ///; /// \return The resulting AST or null if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:388,load,loading,388,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,1,['load'],['loading']
Performance,/// Builds an AST for 'Code'.; ///; /// \param Code C++ code.; /// \param FileName The file name which 'Code' will be mapped as.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; ///; /// \return The resulting AST or null if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:188,load,loading,188,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,1,['load'],['loading']
Performance,"/// By default, only sections that are ""required for execution"" are passed to; /// the RTDyldMemoryManager, and other sections are discarded. Passing 'true'; /// to this method will cause RuntimeDyld to pass all sections to its; /// memory manager regardless of whether they are ""required to execute"" in the; /// usual sense. This is useful for inspecting metadata sections that may not; /// contain relocations, E.g. Debug info, stackmaps.; ///; /// Must be called before the first object file is loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:498,load,loaded,498,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['load'],['loaded']
Performance,"/// By default, optimization remark is missing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:16,optimiz,optimization,16,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,1,['optimiz'],['optimization']
Performance,"/// By default, uses are *not* optimized during MemorySSA construction.; /// Calling this method will attempt to optimize all MemoryUses, if this has; /// not happened yet for this MemorySSA instance. This should be done if you; /// plan to query the clobbering access for most uses, or if you walk the; /// def-use chain of uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:31,optimiz,optimized,31,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,2,['optimiz'],"['optimize', 'optimized']"
Performance,"/// By the time a cluster has been loaded, this cluster might not be necessary anymore. This can happen if; /// there are jumps in the access pattern (i.e. the access pattern deviates from linear access).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:35,load,loaded,35,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,1,['load'],['loaded']
Performance,/// Bypass the overridden contents of a file. This creates a new FileEntry; /// and initializes the content cache for it. Returns std::nullopt if there; /// is no such file in the filesystem.; ///; /// This should be called before parsing has begun.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:108,cache,cache,108,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['cache'],['cache']
Performance,"/// Byte offset (possibly negative) from start of amd_kernel_code_t; /// object to kernel's entry point instruction. The actual code for; /// the kernel is required to be 256 byte aligned to match hardware; /// requirements (SQ cache line is 16). The code must be position; /// independent code (PIC) for AMD devices to give runtime the; /// option of copying code to discrete GPU memory or APU L2; /// cache. The Finalizer should endeavour to allocate all kernel; /// machine code in contiguous memory pages so that a device; /// pre-fetcher will tend to only pre-fetch Kernel Code objects,; /// improving cache performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:228,cache,cache,228,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,4,"['cache', 'perform']","['cache', 'performance']"
Performance,/// ByteArray: the bit mask to apply to bytes loaded from the byte array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:46,load,loaded,46,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['load'],['loaded']
Performance,"/// Bytecode function.; ///; /// Contains links to the bytecode of the function, as well as metadata; /// describing all arguments and stack-local variables.; ///; /// # Calling Convention; ///; /// When calling a function, all argument values must be on the stack.; ///; /// If the function has a This pointer (i.e. hasThisPointer() returns true,; /// the argument values need to be preceeded by a Pointer for the This object.; ///; /// If the function uses Return Value Optimization, the arguments (and; /// potentially the This pointer) need to be preceeded by a Pointer pointing; /// to the location to construct the returned value.; ///; /// After the function has been called, it will remove all arguments,; /// including RVO and This pointer, from the stack.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h:472,Optimiz,Optimization,472,interpreter/llvm-project/clang/lib/AST/Interp/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Function.h,1,['Optimiz'],['Optimization']
Performance,"/// C++ type version cached from the descriptor after a call to `ConnectPageSource()`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:21,cache,cached,21,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['cache'],['cached']
Performance,"/// CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end; /// of a call sequence, and carry arbitrary information that target might; /// want to know. The first operand is a chain, the rest are specified by; /// the target and not touched by the DAG optimizers.; /// Targets that may use stack to pass call arguments define additional; /// operands:; /// - size of the call frame part that must be set up within the; /// CALLSEQ_START..CALLSEQ_END pair,; /// - part of the call frame prepared prior to CALLSEQ_START.; /// Both these parameters must be constants, their sum is the total call; /// frame size.; /// CALLSEQ_START..CALLSEQ_END pairs may not be nested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:268,optimiz,optimizers,268,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['optimiz'],['optimizers']
Performance,"/// CFI-specific: a vector containing the list of function summaries that use; /// the llvm.type.checked.load intrinsic and therefore will require; /// resolutions for llvm.type.test in order to implement CFI checks if; /// devirtualization was unsuccessful. If devirtualization was successful, the; /// pass will clear this vector by calling markDevirt(). If at the end of the; /// pass the vector is non-empty, we will need to add a use of llvm.type.test; /// to each of the function summaries in the vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:105,load,load,105,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['load'],['load']
Performance,"/// CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of; /// vector type with the same length and element type, this produces a; /// concatenated vector result value, with length equal to the sum of the; /// lengths of the input vectors. If VECTOR0 is a fixed-width vector, then; /// VECTOR1..VECTORN must all be fixed-width vectors. Similarly, if VECTOR0; /// is a scalable vector, then VECTOR1..VECTORN must all be scalable vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:382,scalab,scalable,382,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,['scalab'],['scalable']
Performance,"/// CPU time spent preparing the multi-thread workload.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx:33,multi-thread,multi-thread,33,tree/readspeed/inc/ReadSpeed.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx,1,['multi-thread'],['multi-thread']
Performance,/// CRTP base class for visiting operations performed by a special member; /// function (or inherited constructor).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:44,perform,performed,44,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['perform'],['performed']
Performance,"/// CRTP base class which implements the entire standard iterator facade; /// in terms of a minimal subset of the interface.; ///; /// Use this when it is reasonable to implement most of the iterator; /// functionality in terms of a core subset. If you need special behavior or; /// there are performance implications for this, you may want to override the; /// relevant members instead.; ///; /// Note, one abstraction that this does *not* provide is implementing; /// subtraction in terms of addition by negating the difference. Negation isn't; /// always information preserving, and I can see very reasonable iterator; /// designs where this doesn't work well. It doesn't really force much added; /// boilerplate anyways.; ///; /// Another abstraction that this doesn't provide is implementing increment in; /// terms of addition of one. These aren't equivalent for all iterator; /// categories, and respecting that adds a lot of complexity for little gain.; ///; /// Iterators are expected to have const rules analogous to pointers, with a; /// single, const-qualified operator*() that returns ReferenceT. This matches; /// the second and third pointers in the following example:; /// \code; /// int Value;; /// { int *I = &Value; } // ReferenceT 'int&'; /// { int *const I = &Value; } // ReferenceT 'int&'; const; /// { const int *I = &Value; } // ReferenceT 'const int&'; /// { const int *const I = &Value; } // ReferenceT 'const int&'; const; /// \endcode; /// If an iterator facade returns a handle to its own state, then T (and; /// PointerT and ReferenceT) should usually be const-qualified. Otherwise, if; /// clients are expected to modify the handle itself, the field can be declared; /// mutable or use const_cast.; ///; /// Classes wishing to use `iterator_facade_base` should implement the following; /// methods:; ///; /// Forward Iterators:; /// (All of the following methods); /// - DerivedT &operator=(const DerivedT &R);; /// - bool operator==(const DerivedT &R) const;; /// - T &",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h:293,perform,performance,293,interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/iterator.h,1,['perform'],['performance']
Performance,"/// CRTP base for graphs built from either IR or ThinLTO summary index.; ///; /// The graph represents the call contexts in all memprof metadata on allocation; /// calls, with nodes for the allocations themselves, as well as for the calls; /// in each context. The graph is initially built from the allocation memprof; /// metadata (or summary) MIBs. It is then updated to match calls with callsite; /// metadata onto the nodes, updating it to reflect any inlining performed on; /// those calls.; ///; /// Each MIB (representing an allocation's call context with allocation; /// behavior) is assigned a unique context id during the graph build. The edges; /// and nodes in the graph are decorated with the context ids they carry. This; /// is used to correctly update the graph when cloning is performed so that we; /// can uniquify the context for a single (possibly cloned) allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:465,perform,performed,465,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,2,['perform'],['performed']
Performance,"/// CUDA toolchain. Our assembler is ptxas, and our ""linker"" is fatbinary,; /// which isn't properly a linker but nonetheless performs the step of stitching; /// together object files from the assembler into a single blob.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:126,perform,performs,126,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,1,['perform'],['performs']
Performance,/// Cache Control.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['Cache'],['Cache']
Performance,"/// Cache \p Matrix as result of \p Inst and update the uses of \p Inst. For; /// users with shape information, there's nothing to do: they will use the; /// cached value when they are lowered. For other users, \p Matrix is; /// flattened and the uses are updated to use it. Also marks \p Inst for; /// deletion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,2,"['Cache', 'cache']","['Cache', 'cached']"
Performance,/// Cache a module load. M might be nullptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,2,"['Cache', 'load']","['Cache', 'load']"
Performance,"/// Cache any ""global"" code-completion results, so that we can avoid; /// recomputing them with each completion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['Cache'],['Cache']
Performance,/// Cache costs for the loops in the loop nest associated with this object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['Cache'],['Cache']
Performance,/// Cache declarations relevant to DW_TAG_imported_declarations (C++; /// using declarations and global alias variables) that aren't covered; /// by other more specific caches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Cache,Cache,4,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,2,"['Cache', 'cache']","['Cache', 'caches']"
Performance,/// Cache for TLI::getLibFunc() result without prototype validation.; /// UnknownLibFunc if uninitialized. NotLibFunc if definitely not lib func.; /// Otherwise may be libfunc if prototype validation passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['Cache'],['Cache']
Performance,/// Cache for \c getLoopProperties.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['Cache'],['Cache']
Performance,/// Cache for alias results.; /// TODO: consider moving this to the AliasAnalysis itself.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['Cache'],['Cache']
Performance,/// Cache for block sets to allow reuse.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['Cache'],['Cache']
Performance,/// Cache for existing real directories.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['Cache'],['Cache']
Performance,/// Cache for existing real files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['Cache'],['Cache']
Performance,/// Cache for file names for this unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h,1,['Cache'],['Cache']
Performance,/// Cache for getAllocatableAndAlignedRegClassMask method:; /// AlignNumBits -> Class bitmask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,1,['Cache'],['Cache']
Performance,"/// Cache for getSubReg method: {Offset, Size} -> SubReg index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,1,['Cache'],['Cache']
Performance,"/// Cache for getSuperRegClassMask method: { RC, SubRegIdx } -> Class bitmask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,1,['Cache'],['Cache']
Performance,/// Cache for module units which is usable for current module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Cache'],['Cache']
Performance,/// Cache for the deleted virtual member call function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.h:4,Cache,Cache,4,interpreter/llvm-project/clang/lib/CodeGen/CGVTables.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.h,1,['Cache'],['Cache']
Performance,/// Cache for the pure virtual member call function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.h:4,Cache,Cache,4,interpreter/llvm-project/clang/lib/CodeGen/CGVTables.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.h,1,['Cache'],['Cache']
Performance,"/// Cache key for BasicAA results. It only includes the pointer and size from; /// MemoryLocation, as BasicAA is AATags independent. Additionally, it includes; /// the value of MayBeCrossIteration, which may affect BasicAA results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['Cache'],['Cache']
Performance,/// Cache macro expanded tokens for TokenLexers.; //; /// Works like a stack; a TokenLexer adds the macro expanded tokens that is; /// going to lex in the cache and when it finishes the tokens are removed; /// from the end of the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,3,"['Cache', 'cache']","['Cache', 'cache']"
Performance,/// Cache maintained during a computeKnownBits request.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelKnownBits.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelKnownBits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GISelKnownBits.h,1,['Cache'],['Cache']
Performance,/// Cache of BB->getTerminator().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['Cache'],['Cache']
Performance,/// Cache of PCM files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['Cache'],['Cache']
Performance,"/// Cache of TBAA base nodes that have already been visited. This cachce maps; /// a node that has been visited to a pair (IsInvalid, BitWidth) where; ///; /// \c IsInvalid is true iff the node is invalid.; /// \c BitWidth, if non-zero, is the bitwidth of the integer used to denoting; /// the offset of the access. If zero, only a zero offset is allowed.; ///; /// \c BitWidth has no meaning if \c IsInvalid is true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,1,['Cache'],['Cache']
Performance,/// Cache of additional modules that should be used for name lookup; /// within the current template instantiation. Computed lazily; use; /// getLookupModules() to get a complete set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Cache'],['Cache']
Performance,"/// Cache of all stable symbols, indexed by SymIndexId. Just because a; /// symbol has been parsed does not imply that it will be stable and have; /// an Id. Id allocation is an implementation, with the only guarantee; /// being that once an Id is allocated, the symbol can be assumed to be; /// cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,2,"['Cache', 'cache']","['Cache', 'cached']"
Performance,"/// Cache of all the ToolChains in use by the driver.; ///; /// This maps from the string representation of a triple to a ToolChain; /// created targeting that triple. The driver owns all the ToolChain objects; /// stored in it, and will clean them up when torn down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['Cache'],['Cache']
Performance,/// Cache of attribute lists verified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['Cache'],['Cache']
Performance,/// Cache of buffers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h,1,['Cache'],['Cache']
Performance,/// Cache of constants visited in search of ConstantExprs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['Cache'],['Cache']
Performance,/// Cache of declarations of the llvm.experimental.deoptimize.<ty> intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['Cache'],['Cache']
Performance,/// Cache of failed test results. Successful test results are never cached; /// since we always reduce following a success.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,2,"['Cache', 'cache']","['Cache', 'cached']"
Performance,/// Cache of failed test results. Successful test results are never cached; /// since we always reduce following a success. We maintain an independent; /// cache from that used by the individual delta passes because we may get; /// hits across multiple individual delta invocations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DAGDeltaAlgorithm.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/Support/DAGDeltaAlgorithm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DAGDeltaAlgorithm.cpp,3,"['Cache', 'cache']","['Cache', 'cache', 'cached']"
Performance,"/// Cache of forward declarations for methods belonging to the interface.; /// The extra bit on the DISubprogram specifies whether a method is; /// ""objc_direct"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Cache,Cache,4,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['Cache'],['Cache']
Performance,/// Cache of forward declared types to RAUW at the end of compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Cache,Cache,4,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['Cache'],['Cache']
Performance,/// Cache of indices of anonymous declarations within their lexical; /// contexts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,1,['Cache'],['Cache']
Performance,/// Cache of known offloading architectures for the ToolChain already derived.; /// This should only be modified when we first initialize the offloading; /// toolchains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['Cache'],['Cache']
Performance,/// Cache of lazily loaded module for import.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,2,"['Cache', 'load']","['Cache', 'loaded']"
Performance,/// Cache of modules visible to lookup in this module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Basic/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h,1,['Cache'],['Cache']
Performance,/// Cache of parts of the loop used throughout loop fusion. These should not; /// need to change throughout the analysis and transformation.; /// These parts are cached to avoid repeatedly looking up in the Loop class.; /// Preheader of the loop this candidate represents,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,2,"['Cache', 'cache']","['Cache', 'cached']"
Performance,/// Cache of previously constructed Types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Cache,Cache,4,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['Cache'],['Cache']
Performance,/// Cache of previously constructed interfaces which may change.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Cache,Cache,4,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['Cache'],['Cache']
Performance,/// Cache of references to clang modules and precompiled headers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Cache,Cache,4,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['Cache'],['Cache']
Performance,/// Cache of replaceable forward declarations (functions and; /// variables) to RAUW at the end of compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Cache,Cache,4,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['Cache'],['Cache']
Performance,"/// Cache of static archives. Objects that are part of a static archive are; /// stored under this object, rather than in the map below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,1,['Cache'],['Cache']
Performance,"/// Cache of the tree/chain branch names. Never access directy, always use GetBranchNames().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx:4,Cache,Cache,4,tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,1,['Cache'],['Cache']
Performance,"/// Cache of translated arguments for a particular tool chain, bound; /// architecture, and device offload kind.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,1,['Cache'],['Cache']
Performance,"/// Cache pairs ""filename - source location""; ///; /// Cache contains only source locations from preamble so it is; /// guaranteed that they stay valid when the SourceManager is recreated.; /// This cache is used when loading preamble to increase performance; /// of that loading. It must be cleared when preamble is recreated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,6,"['Cache', 'cache', 'load', 'perform']","['Cache', 'cache', 'loading', 'performance']"
Performance,/// Cache policy: expiration (in seconds) for an entry.; /// A value of 0 will be ignored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['Cache'],['Cache']
Performance,/// Cache policy: interval (seconds) between two prunes of the cache. Set to a; /// negative value to disable pruning. A value of 0 will force pruning to; /// occur.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,/// Cache policy: the maximum number of files in the cache directory. A value; /// of 0 will be ignored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,/// Cache policy: the maximum size for the cache directory in bytes. A value; /// over the amount of available space on the disk will be reduced to the; /// amount of available space. A value of 0 will be ignored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,/// Cache results for the isBeforeInTranslationUnit method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['Cache'],['Cache']
Performance,/// Cache storing single nonlocal def for the instruction.; /// It is set when nonlocal def would be found in function returning only; /// local dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['Cache'],['Cache']
Performance,"/// Cache tentative mappings from UnknownSCEVs in a Loop, to a SCEV expression; /// they can be rewritten into under certain predicates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['Cache'],['Cache']
Performance,"/// Cache that maps VLA types to size expressions for that type,; /// represented by instantiated Metadata nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:4,Cache,Cache,4,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['Cache'],['Cache']
Performance,/// Cache the backedge-taken count of the loops for this function as they; /// are computed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['Cache'],['Cache']
Performance,/// Cache the current connection level of each subtree.; /// This mutable array is updated during scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,1,['Cache'],['Cache']
Performance,/// Cache the max count for a single resource.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['Cache'],['Cache']
Performance,/// Cache the module flag for whether we should use debug-info assignment; /// tracking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,1,['Cache'],['Cache']
Performance,/// Cache the predicated backedge-taken count of the loops for this; /// function as they are computed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['Cache'],['Cache']
Performance,/// Cache the result of a successful lookup at the given include location; /// using the search path at \c HitIt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:4,Cache,Cache,4,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['Cache'],['Cache']
Performance,/// Cache the result of analyzeLoop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['Cache'],['Cache']
Performance,/// Cache the target analysis information about the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePipeliner.h,1,['Cache'],['Cache']
Performance,/// Cache to save the location where it can be used as the starting; /// position as input for calling MachineBasicBlock::SkipPHIsLabelsAndDebug.; /// This is to prevent MachineBasicBlock::SkipPHIsLabelsAndDebug from; /// repeatedly searching the same set of PHIs/Labels/Debug instructions; /// if it is called many times for the same block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['Cache'],['Cache']
Performance,/// Cache type for the splitBlock function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:4,Cache,Cache,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['Cache'],['Cache']
Performance,"/// Cache which blocks are in which funclet, if an EH funclet personality is; /// in use. Otherwise empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:4,Cache,Cache,4,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['Cache'],['Cache']
Performance,/// CachePtrTy - LLVM type for struct objc_cache *.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:4,Cache,CachePtrTy,4,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Cache'],['CachePtrTy']
Performance,/// CacheTy - LLVM type for struct objc_cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:4,Cache,CacheTy,4,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Cache'],['CacheTy']
Performance,"/// Cached ""raise"" selector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/DomainSpecific/ObjCNoReturn.h:4,Cache,Cached,4,interpreter/llvm-project/clang/include/clang/Analysis/DomainSpecific/ObjCNoReturn.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/DomainSpecific/ObjCNoReturn.h,1,['Cache'],['Cached']
Performance,/// Cached BB's register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:4,Cache,Cached,4,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['Cache'],['Cached']
Performance,/// Cached MCSymbol for this block (used if IsEHCatchRetTarget).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Cache,Cached,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['Cache'],['Cached']
Performance,"/// Cached deleter of fField",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:4,Cache,Cached,4,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['Cache'],['Cached']
Performance,/// Cached entry holding one or more (in case of a fat binary) object files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Cache,Cached,4,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,1,['Cache'],['Cached']
Performance,/// Cached entry holding one or more (in the of a fat binary) archive files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Cache,Cached,4,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,1,['Cache'],['Cached']
Performance,/// Cached global indices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:4,Cache,Cached,4,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h,1,['Cache'],['Cached']
Performance,"/// Cached identifier for ""NSException"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/DomainSpecific/ObjCNoReturn.h:4,Cache,Cached,4,interpreter/llvm-project/clang/include/clang/Analysis/DomainSpecific/ObjCNoReturn.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/DomainSpecific/ObjCNoReturn.h,1,['Cache'],['Cached']
Performance,"/// Cached information about one file (either on disk; /// or in the virtual file system).; ///; /// If the 'File' member is valid, then this FileEntry has an open file; /// descriptor for the file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileEntry.h:4,Cache,Cached,4,interpreter/llvm-project/clang/include/clang/Basic/FileEntry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileEntry.h,1,['Cache'],['Cached']
Performance,/// Cached information per basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:4,Cache,Cached,4,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['Cache'],['Cached']
Performance,/// Cached legal types (in default mode).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:4,Cache,Cached,4,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['Cache'],['Cached']
Performance,/// Cached local copy of the number of registers the target has.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Cache,Cached,4,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['Cache'],['Cached']
Performance,"/// Cached location ops may be erased during LSR, in which case a poison is; /// required when restoring from the cache. The type of that location is no; /// longer available, so just use int8. The poison will be replaced by one or; /// more locations later when a SCEVDbgValueBuilder selects alternative; /// locations to use for the salvage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:4,Cache,Cached,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,2,"['Cache', 'cache']","['Cached', 'cache']"
Performance,/// Cached native pointer indices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:4,Cache,Cached,4,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h,1,['Cache'],['Cached']
Performance,/// Cached per-block interference maps,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:4,Cache,Cached,4,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,1,['Cache'],['Cached']
Performance,/// Cached reference to the class for constant strings. This value has type; /// int * but is actually an Obj-C class pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:4,Cache,Cached,4,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Cache'],['Cached']
Performance,/// Cached reference to the module which we will insert declarations into.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h:4,Cache,Cached,4,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,1,['Cache'],['Cached']
Performance,"/// Cached resolved paths from the line table.; /// The key is <UniqueUnitID, FileIdx>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h:4,Cache,Cached,4,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h,2,['Cache'],['Cached']
Performance,/// Cached result of the last \see getPreprocessedEntitiesInRange; /// query.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:4,Cache,Cached,4,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['Cache'],['Cached']
Performance,/// Cached results from previous queries,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:4,Cache,Cached,4,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['Cache'],['Cached']
Performance,/// Cached set of selectors in NSException that are 'noreturn'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/DomainSpecific/ObjCNoReturn.h:4,Cache,Cached,4,interpreter/llvm-project/clang/include/clang/Analysis/DomainSpecific/ObjCNoReturn.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/DomainSpecific/ObjCNoReturn.h,1,['Cache'],['Cached']
Performance,/// Cached superclass type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:4,Cache,Cached,4,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['Cache'],['Cached']
Performance,"/// Cached tokens are stored here when we do backtracking or; /// lookahead. They are ""lexed"" by the CachingLex() method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:4,Cache,Cached,4,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['Cache'],['Cached']
Performance,/// Cached tokens state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:4,Cache,Cached,4,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['Cache'],['Cached']
Performance,/// Cached transition table. This is a table of NfaStatePairs that contains; /// zero-terminated sequences pointed to by DFA transitions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h:4,Cache,Cached,4,interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h,1,['Cache'],['Cached']
Performance,"/// CachedTokens - The sequence of tokens that comprises the initializer,; /// including any leading '='.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:4,Cache,CachedTokens,4,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['Cache'],['CachedTokens']
Performance,/// Caches identifiers/selectors for NSFoundation APIs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Cache,Caches,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Cache'],['Caches']
Performance,/// Caches pairs of template-like decls whose associated constraints were; /// checked for subsumption and whether or not the first's constraints did in; /// fact subsume the second's.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Cache,Caches,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Cache'],['Caches']
Performance,/// Caches the IsKnownBase flag for a value and asserts that it wasn't present; /// in the cache before.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:4,Cache,Caches,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,2,"['Cache', 'cache']","['Caches', 'cache']"
Performance,"/// Caches the normalized associated constraints of declarations (concepts or; /// constrained declarations). If an error occurred while normalizing the; /// associated constraints of the template or concept, nullptr will be cached; /// here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Cache,Caches,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['Cache', 'cache']","['Caches', 'cached']"
Performance,"/// Calculate and dump ThinLTO specific inliner stats.; /// The main statistics are:; /// (1) Number of inlined imported functions,; /// (2) Number of imported functions inlined into importing module (indirect),; /// (3) Number of non imported functions inlined into importing module; /// (indirect).; /// The difference between first and the second is that first stat counts; /// all performed inlines on imported functions, but the second one only the; /// functions that have been eventually inlined to a function in the importing; /// module (by a chain of inlines). Because llvm uses bottom-up inliner, it is; /// possible to e.g. import function `A`, `B` and then inline `B` to `A`,; /// and after this `A` might be too big to be inlined into some other function; /// that calls it. It calculates this statistic by building graph, where; /// the nodes are functions, and edges are performed inlines and then by marking; /// the edges starting from not imported function.; ///; /// If `Verbose` is set to true, then it also dumps statistics; /// per each inlined function, sorted by the greatest inlines count like; /// - number of performed inlines; /// - number of performed inlines to importing module",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h:385,perform,performed,385,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h,4,['perform'],['performed']
Performance,"/// Calculate iterated dominance frontiers; ///; /// This uses the linear-time phi algorithm based on DJ-graphs mentioned in; /// the file-level comment. It performs DF->IDF pruning using the live-in; /// set, to avoid computing the IDF for blocks where an inserted PHI node; /// would be dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericIteratedDominanceFrontier.h:157,perform,performs,157,interpreter/llvm-project/llvm/include/llvm/Support/GenericIteratedDominanceFrontier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericIteratedDominanceFrontier.h,1,['perform'],['performs']
Performance,"/// Calculate the ""Indirect Address"" for the given \p RegIndex and; /// \p Channel; ///; /// We model indirect addressing using a virtual address space that can be; /// accessed with loads and stores. The ""Indirect Address"" is the memory; /// address in this virtual address space that maps to the given \p RegIndex; /// and \p Channel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h:183,load,loads,183,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,1,['load'],['loads']
Performance,/// Calculate the cache footprint of each loop in the nest (when it is; /// considered to be in the innermost position).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:18,cache,cache,18,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['cache'],['cache']
Performance,"/// Calculate the cost of vector reduction intrinsics.; ///; /// This is the cost of reducing the vector value of type \p Ty to a scalar; /// value using the operation denoted by \p Opcode. The FastMathFlags; /// parameter \p FMF indicates what type of reduction we are performing:; /// 1. Tree-wise. This is the typical 'fast' reduction performed that; /// involves successively splitting a vector into half and doing the; /// operation on the pair of halves until you have a scalar value. For; /// example:; /// (v0, v1, v2, v3); /// ((v0+v2), (v1+v3), undef, undef); /// ((v0+v2+v1+v3), undef, undef, undef); /// This is the default behaviour for integer operations, whereas for; /// floating point we only do this if \p FMF indicates that; /// reassociation is allowed.; /// 2. Ordered. For a vector with N elements this involves performing N; /// operations in lane order, starting with an initial scalar value, i.e.; /// result = InitVal + v0; /// result = result + v1; /// result = result + v2; /// result = result + v3; /// This is only the case for FP operations and when reassociation is not; /// allowed.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:270,perform,performing,270,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,3,['perform'],"['performed', 'performing']"
Performance,/// Calculates latency statistics for each edge and stores the data in the; /// Graph,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h:15,latency,latency,15,interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h,1,['latency'],['latency']
Performance,/// Calculates latency statistics for each vertex and stores the data in the; /// Graph,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h:15,latency,latency,15,interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h,1,['latency'],['latency']
Performance,"/// Calculates the complexity of the given StmtSequence.; /// \param Limit The limit of complexity we probe for. After reaching; /// this limit during calculation, this method is exiting; /// early to improve performance and returns this limit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CloneDetection.h:209,perform,performance,209,interpreter/llvm-project/clang/include/clang/Analysis/CloneDetection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CloneDetection.h,1,['perform'],['performance']
Performance,"/// Call \p CB on all accesses that might interfere with \p I and; /// return true if all such accesses were known and the callback returned true; /// for all of them, false otherwise. In contrast to forallInterferingAccesses; /// this function will perform reasoning to exclude write accesses that cannot; /// affect the load even if they on the surface look as if they would. The; /// flag \p HasBeenWrittenTo will be set to true if we know that \p I does not; /// read the initial value of the underlying memory. If \p SkipCB is given and; /// returns false for a potentially interfering access, that access is not; /// checked for actual interference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:250,perform,perform,250,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,2,"['load', 'perform']","['load', 'perform']"
Performance,"/// Call this before applying any other heuristics to the Available queue.; /// Updates the Available/Pending Q's if necessary and returns the single; /// available instruction, or NULL if there are multiple candidates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:68,queue,queue,68,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['queue'],['queue']
Performance,/// CallExprUnaryConversions - a special case of an unary conversion; /// performed on a function designator of a call expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:74,perform,performed,74,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['perform'],['performed']
Performance,/// Callback from DAG postProcessing to create cluster edges for loads/stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:65,load,loads,65,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['load'],['loads']
Performance,/// Callback functions - These functions are invoked whenever a pass is loaded; /// or removed from the current executable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h:72,load,loaded,72,interpreter/llvm-project/llvm/include/llvm/PassSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassSupport.h,1,['load'],['loaded']
Performance,/// Callback handler that receives notifications when performing code; /// completion within the preprocessor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h:54,perform,performing,54,interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,1,['perform'],['performing']
Performance,"/// Callback invoked when performing code completion for a preprocessor; /// directive.; ///; /// This callback will be invoked when the preprocessor processes a '#' at the; /// start of a line, followed by the code-completion token.; ///; /// \param InConditional Whether we're inside a preprocessor conditional; /// already.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h:26,perform,performing,26,interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,1,['perform'],['performing']
Performance,"/// Callback invoked when performing code completion in a context; /// where the name of a macro is expected.; ///; /// \param IsDefinition Whether this is the definition of a macro, e.g.,; /// in a \#define.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h:26,perform,performing,26,interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,1,['perform'],['performing']
Performance,"/// Callback invoked when performing code completion in a part of the; /// file where we expect natural language, e.g., a comment, string, or; /// \#error directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h:26,perform,performing,26,interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,1,['perform'],['performing']
Performance,"/// Callback invoked when performing code completion in a preprocessor; /// expression, such as the condition of an \#if or \#elif directive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h:26,perform,performing,26,interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,1,['perform'],['performing']
Performance,"/// Callback invoked when performing code completion inside a; /// function-like macro argument.; ///; /// There will be another callback invocation after the macro arguments are; /// parsed, so this callback should generally be used to note that the next; /// callback is invoked inside a macro argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h:26,perform,performing,26,interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,1,['perform'],['performing']
Performance,"/// Callback invoked when performing code completion inside the filename; /// part of an #include directive. (Also #import, #include_next, etc).; /// \p Dir is the directory relative to the include path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h:26,perform,performing,26,interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,1,['perform'],['performing']
Performance,/// Callback invoked when performing code completion within a block of; /// code that was excluded due to preprocessor conditionals.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h:26,perform,performing,26,interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/CodeCompletionHandler.h,1,['perform'],['performing']
Performance,"/// Callback invoked whenever a source file is skipped as the result; /// of header guard optimization.; ///; /// \param SkippedFile The file that is skipped instead of entering \#include; ///; /// \param FilenameTok The file name token in \#include ""FileName"" directive; /// or macro expanded file name token from \#include MACRO(PARAMS) directive.; /// Note that FilenameTok contains corresponding quotes/angles symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h:90,optimiz,optimization,90,interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PPCallbacks.h,1,['optimiz'],['optimization']
Performance,/// Callback to get an OptimizationRemarkEmitter from a Function *,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:23,Optimiz,OptimizationRemarkEmitter,23,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['Optimiz'],['OptimizationRemarkEmitter']
Performance,/// Called by JITLink to modify the pass pipeline prior to linking.; /// The default version performs no modification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:93,perform,performs,93,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['perform'],['performs']
Performance,/// Called if some element of this constant is no longer valid.; /// At this point only other constants may be on the use_list for this; /// constant. Any constants on our Use list must also be destroy'd. The; /// implementation must be sure to remove the constant from the list of; /// available cached constants. Implementations should implement; /// destroyConstantImpl to remove constants from any pools/maps they are; /// contained it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constant.h:297,cache,cached,297,interpreter/llvm-project/llvm/include/llvm/IR/Constant.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constant.h,1,['cache'],['cached']
Performance,/// Called on a load from and a store to a location.; ///; /// The method will be called each time a location (pointer) value is; /// accessed.; /// \param Loc The value of the location (pointer).; /// \param IsLoad The flag specifying if the location is a store or a load.; /// \param S The load is performed while processing the statement.; ///; /// check::Location,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:16,load,load,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,4,"['load', 'perform']","['load', 'performed']"
Performance,/// Called on binding of a value to a location.; ///; /// \param Loc The value of the location (pointer).; /// \param Val The value which will be stored at the location Loc.; /// \param S The bind is performed while processing the statement S.; ///; /// check::Bind,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:200,perform,performed,200,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,1,['perform'],['performed']
Performance,/// Called on well formed \#pragma clang optimize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:41,optimiz,optimize,41,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['optimiz'],['optimize']
Performance,/// Called the analysis engine determines load elimination won't happen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:42,load,load,42,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['load'],['load']
Performance,/// Called to account for a load or store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:28,load,load,28,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['load'],['load']
Performance,/// Called to account for a load relative intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:28,load,load,28,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['load'],['load']
Performance,/// Called to account for the expectation the inlining would result in a load; /// elimination.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:73,load,load,73,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['load'],['load']
Performance,/// Called within X86InstrPostProcess to specify certain instructions; /// as load and store barriers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCA/X86CustomBehaviour.h:78,load,load,78,interpreter/llvm-project/llvm/lib/Target/X86/MCA/X86CustomBehaviour.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCA/X86CustomBehaviour.h,1,['load'],['load']
Performance,/// Calls BuildAssumeFromInst and if the resulting llvm.assume is valid insert; /// if before I. This is usually what need to be done to salvage the knowledge; /// contained in the instruction I.; /// The AssumptionCache must be provided if it is available or the cache may; /// become silently be invalid.; /// The DominatorTree can optionally be provided to enable cross-block; /// reasoning.; /// This returns if a change was made.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h:264,cache,cache,264,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,1,['cache'],['cache']
Performance,/// Calls a C++ function to perform an action when a match is complete.; /// The MatcherState is passed to the function to allow it to modify; /// instructions.; /// This is less constrained than a custom renderer and can update; /// instructions; /// in the state.; /// - FnID(2) - The function to call.; /// TODO: Remove this at some point when combiners aren't reliant on it. It's; /// a bit of a hack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h:28,perform,perform,28,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,1,['perform'],['perform']
Performance,"/// Calls remove on all trackers currently associated with this JITDylib.; /// Does not run static deinits.; ///; /// Note that removal happens outside the session lock, so new code may be; /// added concurrently while the clear is underway, and the newly added; /// code will *not* be cleared. Adding new code concurrently with a clear; /// is usually a bug and should be avoided.; ///; /// It is illegal to call this method on a defunct JITDylib and the client; /// is responsible for ensuring that they do not do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:200,concurren,concurrently,200,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,2,['concurren'],['concurrently']
Performance,"/// Can load/store 1 register/cycle, but needs an extra cycle for address; /// computation and potentially also for register writeback.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:8,load,load,8,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,1,['load'],['load']
Performance,/// Can load/store 1 register/cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:8,load,load,8,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,1,['load'],['load']
Performance,"/// Can load/store 2 registers/cycle, but needs an extra cycle if the access; /// is not 64-bit aligned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:8,load,load,8,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,1,['load'],['load']
Performance,/// Can load/store 2 registers/cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h:8,load,load,8,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSubtarget.h,1,['load'],['load']
Performance,"/// Can the stack be realigned. This can be false if the target does not; /// support stack realignment, or if the user asks us not to realign the; /// stack. In this situation, overaligned allocas are all treated as dynamic; /// allocations and the target must handle them as part of DYNAMIC_STACKALLOC; /// lowering. All non-alloca stack objects have their alignment clamped to the; /// base ABI stack alignment.; /// FIXME: There is room for improvement in this case, in terms of; /// grouping overaligned allocas into a ""secondary stack frame"" and; /// then only use a single alloca to allocate this frame and only a; /// single virtual register to access it. Currently, without such an; /// optimization, each such alloca gets its own dynamic realignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:696,optimiz,optimization,696,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['optimiz'],['optimization']
Performance,"/// Can we constant-emit a load of a reference to a variable of the; /// given type? This is different from predicates like; /// Decl::mightBeUsableInConstantExpressions because we do want it to apply; /// in situations that don't necessarily satisfy the language's rules; /// for this (e.g. C++'s ODR-use rules). For example, we want to able; /// to do this with const float variables even if those variables; /// aren't marked 'constexpr'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:27,load,load,27,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['load'],['load']
Performance,/// Cannot be used concurrently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h:19,concurren,concurrently,19,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DIEAttributeCloner.h,1,['concurren'],['concurrently']
Performance,"/// Canonicalize path by removing ""."", "".."", ""./"", components. This is; /// a VFS request, do not bother about symlinks in the path components; /// but canonicalize in order to perform the correct entry search.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h:177,perform,perform,177,interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,1,['perform'],['perform']
Performance,"/// Capture Mach-O header from binary, primarily load commands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/DylibReader.h:49,load,load,49,interpreter/llvm-project/llvm/include/llvm/TextAPI/DylibReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/DylibReader.h,1,['load'],['load']
Performance,"/// Captures loop safety information.; /// It keep information for loop blocks may throw exception or otherwise; /// exit abnormally on any iteration of the loop which might actually execute; /// at runtime. The primary way to consume this information is via; /// isGuaranteedToExecute below, but some callers bailout or fallback to; /// alternate reasoning if a loop contains any implicit control flow.; /// NOTE: LoopSafetyInfo contains cached information regarding loops and their; /// particular blocks. This information is only dropped on invocation of; /// computeLoopSafetyInfo. If the loop or any of its block is deleted, or if; /// any thrower instructions have been added or removed from them, or if the; /// control flow has changed, or in case of other meaningful modifications, the; /// LoopSafetyInfo needs to be recomputed. If a meaningful modifications to the; /// loop were made and the info wasn't recomputed properly, the behavior of all; /// methods except for computeLoopSafetyInfo is undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:439,cache,cached,439,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['cache'],['cached']
Performance,"/// Cast a call or invoke instruction to the given type.; ///; /// When promoting a call site, the return type of the call site might not match; /// that of the callee. If this is the case, we have to cast the returned value; /// to the correct type. The location of the cast depends on if we have a call; /// or invoke instruction.; ///; /// For example, if the call instruction below requires a bitcast after; /// promotion:; ///; /// orig_bb:; /// %t0 = call i32 @func(); /// ...; ///; /// The bitcast is placed after the call instruction:; ///; /// orig_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t0 = call i32 @func(); /// %t1 = bitcast i32 %t0 to ...; /// ...; ///; /// A similar transformation is performed for invoke instructions. However,; /// since invokes are terminating, a new block is created for the bitcast. For; /// example, if the invoke instruction below requires a bitcast after promotion:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %normal_dst unwind label %unwind_dst; ///; /// The edge between the original block and the invoke's normal destination is; /// split, and the bitcast is placed there:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %split_bb unwind label %unwind_dst; ///; /// split_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t1 = bitcast i32 %t0 to ...; /// br label %normal_dst; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:749,perform,performed,749,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,1,['perform'],['performed']
Performance,/// Certain SIMD instructions with vector element operand are not efficient.; /// Rewrite them into SIMD instructions with vector operands. This rewrite; /// is driven by the latency of the instructions.; /// Return true if the SIMD instruction is modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:175,latency,latency,175,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,1,['latency'],['latency']
Performance,"/// Certain SIMD instructions with vector element operand are not efficient.; /// Rewrite them into SIMD instructions with vector operands. This rewrite; /// is driven by the latency of the instructions.; /// The instruction of concerns are for the time being FMLA, FMLS, FMUL,; /// and FMULX and hence they are hardcoded.; ///; /// For example:; /// fmla v0.4s, v1.4s, v2.s[1]; ///; /// Is rewritten into; /// dup v3.4s, v2.s[1] // DUP not necessary if redundant; /// fmla v0.4s, v1.4s, v3.4s; ///; /// Return true if the SIMD instruction is modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:175,latency,latency,175,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,1,['latency'],['latency']
Performance,/// Certain metadata on instructions are invalid after running RS4GC.; /// Optimizations that run after RS4GC can incorrectly use this metadata to; /// optimize functions. We drop such metadata on the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:75,Optimiz,Optimizations,75,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,2,"['Optimiz', 'optimiz']","['Optimizations', 'optimize']"
Performance,/// Chain of offsetted loads necessary to load the value if it lives in; /// memory. Every load except for the last is pointer-sized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:23,load,loads,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,3,['load'],"['load', 'loads']"
Performance,"/// Change the MachineInstr \p MI into the equivalent extending load to 32 bit; /// register if it is safe to do so. Return the replacement instruction if; /// OK, otherwise return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:64,load,load,64,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['load'],['load']
Performance,"/// Change the callee of Edge to existing callee clone NewCallee, performing; /// the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:66,perform,performing,66,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['perform'],['performing']
Performance,/// Change the latency between the two SUnits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:15,latency,latency,15,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['latency'],['latency']
Performance,/// CharLiteralParser - Perform interpretation and semantic analysis of a; /// character literal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h:24,Perform,Perform,24,interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h,1,['Perform'],['Perform']
Performance,/// Check \p Pred on all Read/Write instructions.; ///; /// This method will evaluate \p Pred on all instructions that read or write; /// to memory present in the information cache and return true if \p Pred; /// holds on all of them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:175,cache,cache,175,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['cache'],['cache']
Performance,/// Check all MachineMemOperands for a hint that the load/store is strided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:53,load,load,53,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['load'],['load']
Performance,/// Check and lazily calculate whether the state is modified in the stack; /// frame to which \p CallExitBeginN belongs.; /// The calculation is cached in FramesModifying.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h:145,cache,cached,145,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,1,['cache'],['cached']
Performance,"/// Check assignment constraints for an assignment of RHS to LHSType.; ///; /// \param LHSType The destination type for the assignment.; /// \param RHS The source expression for the assignment.; /// \param Diagnose If \c true, diagnostics may be produced when checking; /// for assignability. If a diagnostic is produced, \p RHS will be; /// set to ExprError(). Note that this function may still return; /// without producing a diagnostic, even for an invalid assignment.; /// \param DiagnoseCFAudited If \c true, the target is a function parameter; /// in an audited Core Foundation API and does not need to be checked; /// for ARC retain issues.; /// \param ConvertRHS If \c true, \p RHS will be updated to model the; /// conversions necessary to perform the assignment. If \c false,; /// \p Diagnose must also be \c false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:749,perform,perform,749,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['perform']
Performance,/// Check for equivalence ignoring load/store alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:35,load,load,35,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['load'],['load']
Performance,/// Check global module index for missing imports.; /// \param Name The symbol name to look for.; /// \param TriggerLoc The location for what triggered the load.; /// \returns Returns true if any modules with that symbol found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:156,load,load,156,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,1,['load'],['load']
Performance,"/// Check if N satisfies:; /// N is used once.; /// N is a Load.; /// The load is compatible with ExtOpcode. It means; /// If load has explicit zero/sign extension, ExpOpcode must have the same; /// extension.; /// Otherwise returns true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,Load,Load,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,"['Load', 'load']","['Load', 'load']"
Performance,"/// Check if Op is a load operation that could be folded into a vector splat; /// instruction as a memory operand. Example: vbroadcastss 16(%rdi), %xmm2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:21,load,load,21,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['load'],['load']
Performance,"/// Check if Op is a load operation that could be folded into some other x86; /// instruction as a memory operand. Example: vpaddd (%rdi), %xmm0, %xmm0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:21,load,load,21,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['load'],['load']
Performance,/// Check if \p I has an opcode that can be widened and return a VPWidenRecipe; /// if it can. The function should only be called if the cost-model indicates; /// that widening should be performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:187,perform,performed,187,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,1,['perform'],['performed']
Performance,"/// Check if \p LoadMI is a partial register load that we can't fold into \p MI; /// because the latter uses contents that wouldn't be defined in the folded; /// version. For instance, this transformation isn't legal:; /// movss (%rdi), %xmm0; /// addps %xmm0, %xmm0; /// ->; /// addps (%rdi), %xmm0; ///; /// But this one is:; /// movss (%rdi), %xmm0; /// addss %xmm0, %xmm0; /// ->; /// addss (%rdi), %xmm0; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:16,Load,LoadMI,16,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,2,"['Load', 'load']","['LoadMI', 'load']"
Performance,/// Check if a bitwise-& is performed on an Objective-C pointer. This; /// is usually indicative of introspection within the Objective-C pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:28,perform,performed,28,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['perform'],['performed']
Performance,/// Check if a pass is enabled given \p Opt option. The option always; /// overrides defaults if explicitly used. Otherwise its default will; /// be used given that a pass shall work at an optimization \p Level; /// minimum.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.h:189,optimiz,optimization,189,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.h,1,['optimiz'],['optimization']
Performance,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:25,load,load,25,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,5,"['load', 'perform']","['load', 'performs']"
Performance,"/// Check if it's possible and beneficial to fold the addressing computation; /// `AddrI` into the addressing mode of the load/store instruction `MemI`. The; /// memory instruction is a user of the virtual register `Reg`, which in turn; /// is the ultimate destination of zero or more COPY instructions from the; /// output register of `AddrI`.; /// Return the adddressing mode after folding in `AM`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:122,load,load,122,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['load'],['load']
Performance,/// Check if the ConstantExpr \p CE requires the queue pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp:49,queue,queue,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,1,['queue'],['queue']
Performance,/// Check if the default location must be constant.; /// Constant for NVPTX for better optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h:87,optimiz,optimization,87,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h,1,['optimiz'],['optimization']
Performance,"/// Check if the given Cst should be converted into; /// a load of a global variable initialized with Cst.; /// A constant should be converted if it is likely that the materialization of; /// the constant will be tricky. Thus, we give up on zero or undef values.; ///; /// \todo Currently, accept only vector related types.; /// Also we give up on all simple vector type to keep the existing; /// behavior. Otherwise, we should push here all the check of the lowering of; /// BUILD_VECTOR. By giving up, we lose the potential benefit of merging; /// constant via global merge and the fact that the same constant is stored; /// only once with this method (versus, as many function that uses the constant; /// for the regular approach, even for float).; /// Again, the simplest solution would be to promote every; /// constant and rematerialize them when they are actually cheap to create.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp:59,load,load,59,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp,1,['load'],['load']
Performance,"/// Check if the given use (Instruction + OpIdx) of Cst should be converted into; /// a load of a global variable initialized with Cst.; /// A use should be converted if it is legal to do so.; /// For instance, it is not legal to turn the mask operand of a shuffle vector; /// into a load of a global variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp:88,load,load,88,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp,2,['load'],['load']
Performance,/// Check if the instruction or the bundle of instructions has; /// load from stack slots. Return the frameindex and machine memory operand; /// if true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:68,load,load,68,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,1,['load'],['load']
Performance,/// Check if the library is an OS library that is not shared cache eligible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h:61,cache,cache,61,interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,1,['cache'],['cache']
Performance,/// Check if the load or store instruction \p I should widened for \p; /// Range.Start and potentially masked. Such instructions are handled by a; /// recipe that takes an additional VPInstruction for the mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:17,load,load,17,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,1,['load'],['load']
Performance,"/// Check if the loop header has a conditional branch that is not; /// loop-invariant, because it involves load instructions. If all paths from; /// either the true or false successor to the header or loop exists do not; /// modify the memory feeding the condition, perform 'partial unswitching'. That; /// is, duplicate the instructions feeding the condition in the pre-header. Then; /// unswitch on the duplicated condition. The condition is now known in the; /// unswitched version for the 'invariant' path through the original loop.; ///; /// If the branch condition of the header is partially invariant, return a pair; /// containing the instructions to duplicate and a boolean Constant to update; /// the condition in the loops created for the true or false successors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:107,load,load,107,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,2,"['load', 'perform']","['load', 'perform']"
Performance,"/// Check if the loop is a candidate for converting to a hardware; /// loop. If so, then perform the transformation.; ///; /// This function works on innermost loops first. A loop can be converted; /// if it is a counting loop; either a register value or an immediate.; ///; /// The code makes several assumptions about the representation of the loop; /// in llvm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:89,perform,perform,89,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['perform'],['perform']
Performance,"/// Check if the mask is a DE-interleave mask for an interleaved load.; ///; /// E.g. DE-interleave masks (Factor = 2) could be:; /// <0, 2, 4, 6> (mask of index 0 to extract even elements); /// <1, 3, 5, 7> (mask of index 1 to extract odd elements)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:65,load,load,65,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,1,['load'],['load']
Performance,"/// Check if the operands on the edges \p Edges of the \p UserTE allows; /// reordering (i.e. the operands can be reordered because they have only one; /// user and reordarable).; /// \param ReorderableGathers List of all gather nodes that require reordering; /// (e.g., gather of extractlements or partially vectorizable loads).; /// \param GatherOps List of gather operand nodes for \p UserTE that require; /// reordering, subset of \p NonVectorized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:322,load,loads,322,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['loads']
Performance,/// Check if the specified global variable must be captured by outer capture; /// regions.; /// \param Level Relative level of nested OpenMP construct for that; /// the check is performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:178,perform,performed,178,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performed']
Performance,/// Check if the specified variable is captured by 'target' directive.; /// \param Level Relative level of nested OpenMP construct for that the check; /// is performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:158,perform,performed,158,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performed']
Performance,/// Check if the specified variable is used in 'private' clause.; /// \param Level Relative level of nested OpenMP construct for that the check; /// is performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:152,perform,performed,152,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performed']
Performance,"/// Check if the value of \p Offset represents a valid immediate for the SVE; /// gather load/prefetch and scatter store instructiona with vector base and; /// immediate offset addressing mode:; ///; /// [<Zn>.[S|D]{, #<imm>}]; ///; /// where <imm> = sizeof(<T>) * k, for k = 0, 1, ..., 31.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:89,load,load,89,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['load']
Performance,"/// Check if the value of \p OffsetInBytes can be used as an immediate for; /// the gather load/prefetch and scatter store instructions with vector base and; /// immediate offset addressing mode:; ///; /// [<Zn>.[S|D]{, #<imm>}]; ///; /// where <imm> = sizeof(<T>) * k, for k = 0, 1, ..., 31.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:91,load,load,91,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['load'],['load']
Performance,/// Check if this mbb is guaranteed to execute. If not then a load from this mbb; /// may not be safe to hoist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:62,load,load,62,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['load'],['load']
Performance,"/// Check if this pointer is consecutive when vectorizing. This happens; /// when the last index of the GEP is the induction variable, or that the; /// pointer itself is an induction variable.; /// This check allows us to vectorize A[idx] into a wide load/store.; /// Returns:; /// 0 - Stride is unknown or non-consecutive.; /// 1 - Address is consecutive.; /// -1 - Address is consecutive, and decreasing.; /// NOTE: This method must only be used before modifying the original scalar; /// loop. Do not use after invoking 'createVectorizedLoopSkeleton' (PR34965).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:251,load,load,251,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['load'],['load']
Performance,"/// Check if this slice can be merged with an expensive cross register; /// bank copy. E.g.,; /// i = load i32; /// f = bitcast i32 i to float",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:102,load,load,102,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,"/// Check if two axis have the same bin borders; ///; /// Default implementation should work for any RAxis type, but is quite; /// inefficient as it does virtual GetBinFrom calls in a loop. RAxis; /// implementations are encouraged to provide optimized overrides for common; /// axis binning comparison scenarios.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx:243,optimiz,optimized,243,hist/histv7/inc/ROOT/RAxis.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histv7/inc/ROOT/RAxis.hxx,1,['optimiz'],['optimized']
Performance,"/// Check if we can change the instruction to use an offset value from the; /// previous iteration. If so, return true and set the base and offset values; /// so that we can rewrite the load, if necessary.; /// v1 = Phi(v0, v3); /// v2 = load v1, 0; /// v3 = post_store v1, 4, x; /// This function enables the load to be rewritten as v2 = load v3, 4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:186,load,load,186,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,4,['load'],['load']
Performance,/// Check is a \p Load is clobbered in its function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.h:18,Load,Load,18,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.h,1,['Load'],['Load']
Performance,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:151,load,load,151,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['load'],['load']
Performance,"/// Check specified statement that it is suitable for 'atomic update'; /// constructs and extract 'x', 'expr' and Operation from the original; /// expression. If DiagId and NoteId == 0, then only check is performed; /// without error notification.; /// \param DiagId Diagnostic which should be emitted if error is found.; /// \param NoteId Diagnostic note for the main error message.; /// \return true if statement is not an update expression, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:205,perform,performed,205,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['perform'],['performed']
Performance,"/// Check that the lifetime of the initializer (and its subobjects) is; /// sufficient for initializing the entity, and perform lifetime extension; /// (when permitted) if not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:120,perform,perform,120,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['perform']
Performance,/// Check that the usual arithmetic conversions can be performed on this pair of; /// expressions that might be of enumeration type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:55,perform,performed,55,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['perform'],['performed']
Performance,/// Check that this evaluated value is fully-initialized and can be loaded by; /// an lvalue-to-rvalue conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:68,load,loaded,68,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['load'],['loaded']
Performance,"/// Check the profitability of all involved LoadedSlice.; /// Currently, it is considered profitable if there is exactly two; /// involved slices (1) which are (2) next to each other in memory, and; /// whose cost (\see LoadedSlice::Cost) is smaller than the original load (3).; ///; /// Note: The order of the elements in \p LoadedSlices may be modified, but not; /// the elements themselves.; ///; /// FIXME: When the cost model will be mature enough, we can relax; /// constraints (1) and (2).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,Load,LoadedSlice,44,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,"['Load', 'load']","['LoadedSlice', 'LoadedSlices', 'load']"
Performance,"/// Check to see if V is (and load (ptr), imm), where the load is having; /// specific bytes cleared out. If so, return the byte size being masked out; /// and the shift amount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,load,load,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],['load']
Performance,"/// Check to see if any of the pending instructions are ready to issue. If; /// so, add them to the available queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:110,queue,queue,110,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['queue'],['queue']
Performance,/// Check whether MI is a candidate for folding into a later instruction.; /// We only fold loads to virtual registers and the virtual register defined; /// has a single user.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:92,load,loads,92,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['load'],['loads']
Performance,"/// Check whether \p BB contains an instruction thought to load from, store; /// to, or otherwise clobber the alloca \p Addr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:59,load,load,59,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,1,['load'],['load']
Performance,"/// Check whether a specialization is well-formed in the current; /// context.; ///; /// This routine determines whether a template specialization can be declared; /// in the current context (C++ [temp.expl.spec]p2).; ///; /// \param S the semantic analysis object for which this check is being; /// performed.; ///; /// \param Specialized the entity being specialized or instantiated, which; /// may be a kind of template (class template, function template, etc.) or; /// a member of a class template (member function, static data member,; /// member class).; ///; /// \param PrevDecl the previous declaration of this entity, if any.; ///; /// \param Loc the location of the explicit specialization or instantiation of; /// this entity.; ///; /// \param IsPartialSpecialization whether this is a partial specialization of; /// a class template.; ///; /// \returns true if there was an error that we cannot recover from, false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:300,perform,performed,300,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['perform'],['performed']
Performance,"/// Check whether it is poison-safe to represent the expression S using the; /// instruction I. If such a replacement is performed, the poison flags of; /// instructions in DropPoisonGeneratingInsts must be dropped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:121,perform,performed,121,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['perform'],['performed']
Performance,/// Check whether or not \p First and \p Second are next to each other; /// in memory. This means that there is no hole between the bits loaded; /// by \p First and the bits loaded by \p Second.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:137,load,loaded,137,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],['loaded']
Performance,/// Check whether or not the chain ending in StoreNode is suitable for doing; /// the {load; op; store} to modify transformation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:87,load,load,87,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['load'],['load']
Performance,/// Check whether specified \p CUDie is a Clang module reference.; /// if \p Quiet is false then display error messages.; /// \return first == true if CUDie is a Clang module reference.; /// second == true if module is already loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h:227,load,loaded,227,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,2,['load'],['loaded']
Performance,/// Check whether the call is eligible for tail call optimization. Targets; /// that want to do tail call optimization should implement this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:53,optimiz,optimization,53,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,6,['optimiz'],['optimization']
Performance,/// Check whether the data dependence could prevent store-load; /// forwarding.; ///; /// \return false if we shouldn't vectorize at all or avoid larger; /// vectorization factors by limiting MinDepDistBytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:58,load,load,58,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['load'],['load']
Performance,/// Check whether the given instruction can be the end of a LOH chain; /// involving a load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp:87,load,load,87,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,1,['load'],['load']
Performance,/// Check whether the given instruction can load a litteral.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp:44,load,load,44,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CollectLOH.cpp,1,['load'],['load']
Performance,/// Check whether the target can fold a load that feeds a subreg operand; /// (or a subreg operand that feeds a store).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:40,load,load,40,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,1,['load'],['load']
Performance,"/// Check whether the target can fold a load that feeds a subreg operand; /// (or a subreg operand that feeds a store).; /// For example, X86 may want to return true if it can fold; /// movl (%esp), %eax; /// subb, %al, ...; /// Into:; /// subb (%esp), ...; ///; /// Ideally, we'd like the target implementation of foldMemoryOperand() to; /// reject subregs - but since this behavior used to be enforced in the; /// target-independent code, moving this responsibility to the targets; /// has the potential of causing nasty silent breakage in out-of-tree targets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:40,load,load,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['load'],['load']
Performance,"/// CheckAssignmentConstraints - Perform type checking for assignment,; /// argument passing, variable initialization, and function return values.; /// C99 6.5.16.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:33,Perform,Perform,33,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Perform'],['Perform']
Performance,"/// CheckBooleanCondition - Diagnose problems involving the use of; /// the given expression as a boolean condition (e.g. in an if; /// statement). Also performs the standard function and array; /// decays, possibly changing the input variable.; ///; /// \param Loc - A location associated with the condition, e.g. the; /// 'if' keyword.; /// \return true iff there were any errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:153,perform,performs,153,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performs']
Performance,"/// CheckConvertedConstantExpression - Check that the expression From is a; /// converted constant expression of type T, perform the conversion and produce; /// the converted expression, per C++11 [expr.const]p3.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:121,perform,perform,121,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['perform'],['perform']
Performance,"/// CheckDerivedToBaseConversion - Check whether the Derived-to-Base; /// conversion (where Derived and Base are class types) is; /// well-formed, meaning that the conversion is unambiguous (and; /// that all of the base classes are accessible). Returns true; /// and emits a diagnostic if the code is ill-formed, returns false; /// otherwise. Loc is the location where this routine should point to; /// if there is an error, and Range is the source range to highlight; /// if there is an error.; ///; /// If either InaccessibleBaseID or AmbiguousBaseConvID are 0, then the; /// diagnostic for the respective type of error will be suppressed, but the; /// check for ill-formed code will still be performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:696,perform,performed,696,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['perform'],['performed']
Performance,"/// CheckParmsForFunctionDef - Check that the parameters of the given; /// function are appropriate for the definition of a function. This; /// takes care of any checks that cannot be performed on the; /// declaration itself, e.g., that the types of each of the function; /// parameters are complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:184,perform,performed,184,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['perform'],['performed']
Performance,"/// CheckReturn - Analyze the return values of a function, returning; /// true if the return can be performed without sret-demotion, and; /// false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:100,perform,performed,100,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,1,['perform'],['performed']
Performance,/// Checking the operand of a load. Must be suitably sized and aligned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:30,load,load,30,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['load'],['load']
Performance,/// Checks access for a hierarchy conversion.; ///; /// \param ForceCheck true if this check should be performed even if access; /// control is disabled; some things rely on this for semantics; /// \param ForceUnprivileged true if this check should proceed as if the; /// context had no special privileges,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:103,perform,performed,103,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['perform'],['performed']
Performance,/// Checks if a value can be loaded from a block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h:29,load,loaded,29,interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Interp.h,1,['load'],['loaded']
Performance,"/// Checks if the given array of loads can be represented as a vectorized,; /// scatter or just simple gather.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:33,load,loads,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['loads']
Performance,/// Checks if the optimization of original scalar identity operations on; /// matched horizontal reductions is enabled and allowed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:18,optimiz,optimization,18,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['optimiz'],['optimization']
Performance,"/// Checks if the specified call is known to never read or write memory.; ///; /// Note that if the call only reads from known-constant memory, it is also; /// legal to return true. Also, calls that unwind the stack are legal for; /// this predicate.; ///; /// Many optimizations (such as CSE and LICM) can be performed on such calls; /// without worrying about aliasing properties, and many calls have this; /// property (e.g. calls to 'sin' and 'cos').; ///; /// This property corresponds to the GCC 'const' attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:266,optimiz,optimizations,266,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,"['optimiz', 'perform']","['optimizations', 'performed']"
Performance,"/// Checks if the specified call is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Calls that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:227,optimiz,optimizations,227,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,"['optimiz', 'perform']","['optimizations', 'performed']"
Performance,"/// Checks if the specified function is known to never read or write memory.; ///; /// Note that if the function only reads from known-constant memory, it is; /// also legal to return true. Also, function that unwind the stack are legal; /// for this predicate.; ///; /// Many optimizations (such as CSE and LICM) can be performed on such calls; /// to such functions without worrying about aliasing properties, and many; /// functions have this property (e.g. 'sin' and 'cos').; ///; /// This property corresponds to the GCC 'const' attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:277,optimiz,optimizations,277,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,"['optimiz', 'perform']","['optimizations', 'performed']"
Performance,"/// Checks if the specified function is known to only read from non-volatile; /// memory (or not access memory at all).; ///; /// Functions that unwind the stack are legal for this predicate.; ///; /// This property allows many common optimizations to be performed in the; /// absence of interfering store instructions, such as CSE of strlen calls.; ///; /// This property corresponds to the GCC 'pure' attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:235,optimiz,optimizations,235,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,"['optimiz', 'perform']","['optimizations', 'performed']"
Performance,"/// Checks if the specified gather tree entry \p TE can be represented as a; /// shuffled vector entry + (possibly) permutation with other gathers. It; /// implements the checks only for possibly ordered scalars (Loads,; /// ExtractElement, ExtractValue), which can be part of the graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:213,Load,Loads,213,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['Load'],['Loads']
Performance,/// Checks whether a declaration is in this context.; /// This also loads the Decls from the external source before the check.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:68,load,loads,68,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['load'],['loads']
Performance,"/// Checks whether the given constructor is a valid subject for the; /// complete-to-base constructor delegation optimization, i.e.; /// emitting the complete constructor as a simple call to the base; /// constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:113,optimiz,optimization,113,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['optimiz'],['optimization']
Performance,/// Choose a method of checking LR before performing a tail call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h:42,perform,performing,42,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,1,['perform'],['performing']
Performance,/// Choose the best candidate to use for the lane after \p Last. The set of; /// candidates to choose from are values with an opcode matching \p Last's; /// or loads consecutive to \p Last.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:160,load,loads,160,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['load'],['loads']
Performance,"/// Class objc_loadClassref (void *); ///; /// Loads from a classref. For Objective-C stub classes, this invokes the; /// initialization callback stored inside the stub. For all other classes; /// this simply dereferences the pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:47,Load,Loads,47,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Load'],['Loads']
Performance,"/// Class recording the (high level) _value_ of a variable. Identifies the value; /// of the variable as a list of ValueIDNums and constant MachineOperands, or as; /// an empty list for undef debug values or VPHI values which we have not found; /// valid locations for.; /// This class also stores meta-information about how the value is qualified.; /// Used to reason about variable values when performing the second; /// (DebugVariable specific) dataflow analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:396,perform,performing,396,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['perform'],['performing']
Performance,/// Class representing a substitution to perform in the RegExStr string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:41,perform,perform,41,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['perform'],['perform']
Performance,"/// Class representing coefficient of floating-point addend.; /// This class needs to be highly efficient, which is especially true for; /// the constructor. As of I write this comment, the cost of the default; /// constructor is merely 4-byte-store-zero (Assuming compiler is able to; /// perform write-merging).; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:290,perform,perform,290,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['perform'],['perform']
Performance,"/// Class responsible for emitting a DWARF v5 Accelerator Table. The only; /// public function is emit(), which performs the actual emission.; ///; /// A callback abstracts the logic to provide a CU index for a given entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:112,perform,performs,112,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,1,['perform'],['performs']
Performance,/// Class that performs lookup for a selector's entries in the global; /// method pool stored in an AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:15,perform,performs,15,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,1,['perform'],['performs']
Performance,/// Class that performs lookup for an identifier stored in an AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:15,perform,performs,15,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,1,['perform'],['performs']
Performance,/// Class that performs name lookup into a DeclContext stored; /// in an AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h:15,perform,performs,15,interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderInternals.h,1,['perform'],['performs']
Performance,"/// Class to acquire and release the Python GIL where it applies, i.e.; /// if libPython is loaded and the interpreter is initialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/src/TMPClient.cxx:92,load,loaded,92,core/multiproc/src/TMPClient.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/multiproc/src/TMPClient.cxx,1,['load'],['loaded']
Performance,/// Class to represent scalable SIMD vectors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:23,scalab,scalable,23,interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,1,['scalab'],['scalable']
Performance,"/// Class to represent target extensions types, which are generally; /// unintrospectable from target-independent optimizations.; ///; /// Target extension types have a string name, and optionally have type and/or; /// integer parameters. The exact meaning of any parameters is dependent on the; /// target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:114,optimiz,optimizations,114,interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,1,['optimiz'],['optimizations']
Performance,"/// Classify whether a cast is worth optimizing.; ///; /// This is a helper to decide whether the simplification of; /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.; ///; /// \param CI The cast we are interested in.; ///; /// \return true if this cast actually results in any code being generated and; /// if it cannot already be eliminated by some other transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:37,optimiz,optimizing,37,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,2,"['optimiz', 'perform']","['optimizing', 'performed']"
Performance,"/// Clean-up operations to be performed at the end of a task.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx:30,perform,performed,30,tree/dataframe/inc/ROOT/RDF/RAction.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx,10,['perform'],['performed']
Performance,"/// Clear all analysis results cached by this AnalysisManager.; ///; /// Like \c clear(IRUnitT&), this doesn't invalidate the results; it simply; /// deletes them. This lets you clean up the AnalysisManager when the set of; /// IR units itself has potentially changed, and thus we can't even look up a; /// a result and invalidate/clear it directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:31,cache,cached,31,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['cached']
Performance,/// Clear all the per-function data used to load samples and propagate weights.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:44,load,load,44,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,1,['load'],['load']
Performance,/// Clear and free the cached objc methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:23,cache,cached,23,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['cache'],['cached']
Performance,"/// Clear any cached analysis results for a single unit of IR.; ///; /// This doesn't invalidate, but instead simply deletes, the relevant results.; /// It is useful when the IR is being removed and we want to clear out all the; /// memory pinned for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:14,cache,cached,14,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['cached']
Performance,/// Clear cache that is used to connect a pass to the analysis (PassInfo).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h:10,cache,cache,10,interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassAnalysisSupport.h,1,['cache'],['cache']
Performance,/// Clear the Node Cache for all Regions.; ///; /// @see Region::clearNodeCache(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:19,Cache,Cache,19,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['Cache'],['Cache']
Performance,"/// Clear the cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:14,cache,cache,14,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['cache'],['cache']
Performance,/// Clear the cache for BB RegionNodes.; ///; /// After calling this function the BasicBlock RegionNodes will be stored at; /// different memory locations. RegionNodes obtained before this function is; /// called are therefore not comparable to RegionNodes abtained afterwords.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:14,cache,cache,14,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,1,['cache'],['cache']
Performance,/// Clear the cache of \@llvm.assume intrinsics for a function.; ///; /// It will be re-scanned the next time it is requested.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:14,cache,cache,14,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['cache'],['cache']
Performance,"/// Clear the cache payload but retain slot mapping w.r.t to; /// normalization and integration sets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:14,cache,cache,14,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['cache'],['cache']
Performance,/// Clear the location definitions currently cached for insertion after /p; /// After.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:45,cache,cached,45,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['cache'],['cached']
Performance,/// Clear this MachineInstr's memory reference descriptor list. This resets; /// the memrefs to their most conservative state. This should be used only; /// as a last resort since it greatly pessimizes our knowledge of the memory; /// access performed by the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:242,perform,performed,242,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['perform'],['performed']
Performance,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:135,cache,cached,135,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,1,['cache'],['cached']
Performance,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:446,load,loads,446,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,1,['load'],['loads']
Performance,/// Clients can choose to implement this to get notified right before; /// a load is RAUW'd another value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:77,load,load,77,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,1,['load'],['load']
Performance,/// Clones instruction or the whole instruction bundle \p Orig and insert; /// into \p MBB before \p InsertBefore.; ///; /// Note: Does not perform target specific adjustments; consider using; /// TargetInstrInfo::duplicate() intead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:140,perform,perform,140,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['perform'],['perform']
Performance,"/// ClusterNeighboringLoads - Cluster loads from ""near"" addresses into; /// combined SUnits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h:38,load,loads,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,1,['load'],['loads']
Performance,"/// ClusterNeighboringLoads - Force nearby loads together by ""gluing"" them.; /// This function finds loads of the same base and different offsets. If the; /// offsets are not far apart (target specific), it add MVT::Glue inputs and; /// outputs to ensure they are scheduled together and in order. This; /// optimization may benefit some targets by improving cache locality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:43,load,loads,43,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,4,"['cache', 'load', 'optimiz']","['cache', 'loads', 'optimization']"
Performance,"/// Code completion consumer that combines the cached code-completion; /// results from an ASTUnit with the code-completion results provided to it,; /// then passes the result on to",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:47,cache,cached,47,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['cache'],['cached']
Performance,/// Code generation optimization level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CodeGen.h:20,optimiz,optimization,20,interpreter/llvm-project/llvm/include/llvm/Support/CodeGen.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CodeGen.h,1,['optimiz'],['optimization']
Performance,/// CodeGen optimization level,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:12,optimiz,optimization,12,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['optimiz'],['optimization']
Performance,/// CodeGenOptions - Track various options which control how the code; /// is optimized and passed to the backend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:78,optimiz,optimized,78,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,1,['optimiz'],['optimized']
Performance,"/// Collect Uniform and Scalar values for the given \p VF.; /// The sets depend on CM decision for Load/Store instructions; /// that may be vectorized as interleave, gather-scatter or scalarized.; /// Also make a decision on what to do about call instructions in the loop; /// at that VF -- scalarize, call a known vector routine, or call a; /// vector intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:99,Load,Load,99,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['Load'],['Load']
Performance,/// Collect all of the loop invariant input values transitively used by the; /// homogeneous instruction graph from a given root.; ///; /// This essentially walks from a root recursively through loop variant operands; /// which have perform the same logical operation (AND or OR) and finds all; /// inputs which are loop invariant. For some operations these can be; /// re-associated and unswitched out of the loop entirely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:233,perform,perform,233,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['perform'],['perform']
Performance,"/// Collect functions with definitions in Module M. For reader which; /// support loading function profiles on demand, return true when the; /// reader has been given a module. Always return false for reader; /// which doesn't support loading function profiles on demand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h:82,load,loading,82,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProfReader.h,2,['load'],['loading']
Performance,"/// Collect poison-generating recipes that may generate a poison value that is; /// used after vectorization, even when their operands are not poison. Those; /// recipes meet the following conditions:; /// * Contribute to the address computation of a recipe generating a widen; /// memory load/store (VPWidenMemoryInstructionRecipe or; /// VPInterleaveRecipe).; /// * Such a widen memory load/store has at least one underlying Instruction; /// that is in a basic block that needs predication and after vectorization; /// the generated instruction won't be predicated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:289,load,load,289,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['load'],['load']
Performance,"/// Collect the instructions that are scalar after vectorization. An; /// instruction is scalar if it is known to be uniform or will be scalarized; /// during vectorization. collectLoopScalars should only add non-uniform nodes; /// to the list if they are used by a load/store instruction that is marked as; /// CM_Scalarize. Non-uniform scalarized instructions will be represented by; /// VF values in the vectorized loop, each corresponding to an iteration of; /// the original scalar loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:266,load,load,266,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['load'],['load']
Performance,/// Collect the set of header includes needed to construct the given; /// module and update the TopHeaders file set of the module.; ///; /// \param Module The module we're collecting includes from.; ///; /// \param Includes Will be augmented with the set of \#includes or \#imports; /// needed to load all of the named headers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:297,load,load,297,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,1,['load'],['load']
Performance,"/// Collect unswitch candidates by invariant conditions that are not immediately; /// present in the loop. However, they can be injected into the code if we; /// decide it's profitable.; /// An example of such conditions is following:; ///; /// for (...) {; /// x = load ...; /// if (! x <u C1) break;; /// if (! x <u C2) break;; /// <do something>; /// }; ///; /// We can unswitch by condition ""C1 <=u C2"". If that is true, then ""x <u C1 <=; /// C2"" automatically implies ""x <u C2"", so we can get rid of one of; /// loop-variant checks in unswitched loop version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:266,load,load,266,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['load'],['load']
Performance,/// Collects a set of attribute inference requests and performs them all in one; /// go on a single SCC Node. Inference involves scanning function bodies; /// looking for instructions that violate attribute assumptions.; /// As soon as all the bodies are fine we are free to set the attribute.; /// Customization of inference for individual attributes is performed by; /// providing a handful of predicates for each attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:55,perform,performs,55,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,2,['perform'],"['performed', 'performs']"
Performance,"/// Collects loads and stores grouped by ""equivalence class"", where:; /// - all elements in an eq class are a load or all are a store,; /// - they all load/store the same element size (it's OK to have e.g. i8 and; /// <4 x i8> in the same class, but not i32 and <4 x i8>), and; /// - they all have the same value for getUnderlyingObject().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:13,load,loads,13,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,3,['load'],"['load', 'loads']"
Performance,/// Collects the dependencies for imported modules into a directory. Users; /// should attach to the AST reader whenever a module is loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h:133,load,loaded,133,interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/Utils.h,1,['load'],['loaded']
Performance,/// Combine a G_EXTRACT_VECTOR_ELT of a load into a narrowed; /// load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:40,load,load,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,2,['load'],['load']
Performance,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:12,load,loads,12,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,11,['load'],"['load', 'loaded', 'loading', 'loads']"
Performance,"/// CombineBaseUpdate - Target-specific DAG combine function for VLDDUP,; /// NEON load/store intrinsics, and generic vector load/stores, to merge; /// base address updates.; /// For generic load/stores, the memory type is assumed to be a vector.; /// The caller is assumed to have checked legality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:83,load,load,83,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,3,['load'],['load']
Performance,/// Common features for diagnostics dealing with optimization remarks; /// that are used by IR passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:49,optimiz,optimization,49,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,/// Common features for diagnostics dealing with optimization remarks; /// that are used by both IR and MIR passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:49,optimiz,optimization,49,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,/// Common features for diagnostics dealing with optimization remarks; /// that are used by machine passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:49,optimiz,optimization,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,1,['optimiz'],['optimization']
Performance,"/// Compare one IRInstructionData class to another IRInstructionData class for; /// whether they are performing a the same operation, and can mapped to the; /// same value. For regular instructions if the hash value is the same, then; /// they will also be close.; ///; /// \param A - The first IRInstructionData class to compare; /// \param B - The second IRInstructionData class to compare; /// \returns true if \p A and \p B are similar enough to be mapped to the same; /// value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:101,perform,performing,101,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,1,['perform'],['performing']
Performance,"/// Compare two Instructions for equivalence, similar to; /// Instruction::isSameOperationAs.; ///; /// Stages are listed in ""most significant stage first"" order:; /// On each stage below, we do comparison between some left and right; /// operation parts. If parts are non-equal, we assign parts comparison; /// result to the operation comparison result and exit from method.; /// Otherwise we proceed to the next stage.; /// Stages:; /// 1. Operations opcodes. Compared as numbers.; /// 2. Number of operands.; /// 3. Operation types. Compared with cmpType method.; /// 4. Compare operation subclass optional data as stream of bytes:; /// just convert it to integers and call cmpNumbers.; /// 5. Compare in operation operand types with cmpType in; /// most significant operand first order.; /// 6. Last stage. Check operations for some specific attributes.; /// For example, for Load it would be:; /// 6.1.Load: volatile (as boolean flag); /// 6.2.Load: alignment (as integer numbers); /// 6.3.Load: ordering (as underlying enum class value); /// 6.4.Load: synch-scope (as integer numbers); /// 6.5.Load: range metadata (as integer ranges); /// On this stage its better to see the code, since its not more than 10-15; /// strings for particular instruction, and could change sometimes.; ///; /// Sets \p needToCmpOperands to true if the operands of the instructions; /// still must be compared afterwards. In this case it's already guaranteed; /// that both instructions have the same number of operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:880,Load,Load,880,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,6,['Load'],['Load']
Performance,"/// Compare types for equality with respect to possibly compatible; /// function types (noreturn adjustment, implicit calling conventions). If any; /// of parameter and argument is not a function, just perform type comparison.; ///; /// \param P the template parameter type.; ///; /// \param A the argument type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:202,perform,perform,202,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['perform'],['perform']
Performance,/// Compare-exchange. Keeps trying if there is a concurrent; /// \a loadOrGenerate() call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:49,concurren,concurrent,49,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,2,"['concurren', 'load']","['concurrent', 'loadOrGenerate']"
Performance,"/// Compare-exchange. Returns \c false if there is a concurrent \a; /// loadOrGenerate() call, setting \p ExistingValue to \c nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:53,concurren,concurrent,53,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,2,"['concurren', 'load']","['concurrent', 'loadOrGenerate']"
Performance,"/// Comparing internal representations of symbolic values (via; /// SVal::operator==()) is a valid way to check if the value was updated,; /// unless it's a LazyCompoundVal that may have a different internal; /// representation every time it is loaded from the state. In this function we; /// do an approximate comparison for lazy compound values, checking that they; /// are the immediate snapshots of the tracked region's bindings within the; /// node's respective states but not really checking that these snapshots; /// actually contain the same set of bindings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:245,load,loaded,245,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['load'],['loaded']
Performance,/// Compilation - A set of tasks to perform for a single driver; /// invocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h:36,perform,perform,36,interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Compilation.h,1,['perform'],['perform']
Performance,"/// Compile the merged optimized module \p ParallelismLevel output files each; /// representing a linkable partition of the module. If out contains more; /// than one element, code generation is done in parallel with \p; /// ParallelismLevel threads. Output files will be written to the streams; /// created using the \p AddStream callback. Returns true on success.; ///; /// Calls \a verifyMergedModuleOnce().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h:23,optimiz,optimized,23,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,1,['optimiz'],['optimized']
Performance,/// Compiler instance performing the incremental compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:22,perform,performing,22,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,1,['perform'],['performing']
Performance,"/// Compiles the merged optimized module into a single output file. It brings; /// the output to a buffer, and returns the buffer to the caller. Return NULL; /// if the compilation was not successful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h:24,optimiz,optimized,24,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,1,['optimiz'],['optimized']
Performance,/// ComplexPattern used on MipsInstrInfo; /// Used on Mips Load/Store instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp:59,Load,Load,59,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp,3,['Load'],['Load']
Performance,"/// CompoundAssignOperator - For compound assignments (e.g. +=), we keep; /// track of the type the operation is performed in. Due to the semantics of; /// these operators, the operands are promoted, the arithmetic performed, an; /// implicit conversion back to the result type done, then the assignment takes; /// place. This captures the intermediate type which the computation is done; /// in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:113,perform,performed,113,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,2,['perform'],['performed']
Performance,"/// Compute a DFSResult after DAG building is complete, and before any; /// queue comparisons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:76,queue,queue,76,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['queue'],['queue']
Performance,/// Compute a TokenFactor to force all the incoming stack arguments to be; /// loaded from the stack. This is used in tail call lowering to protect; /// stack arguments from being clobbered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:79,load,loaded,79,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['load'],['loaded']
Performance,"/// Compute a map of integer instructions to their minimum legal type; /// size.; ///; /// C semantics force sub-int-sized values (e.g. i8, i16) to be promoted to int; /// type (e.g. i32) whenever arithmetic is performed on them.; ///; /// For targets with native i8 or i16 operations, usually InstCombine can shrink; /// the arithmetic type down again. However InstCombine refuses to create; /// illegal types, so for targets without i8 or i16 registers, the lengthening; /// and shrinking remains.; ///; /// Most SIMD ISAs (e.g. NEON) however support vectors of i8 or i16 even when; /// their scalar equivalents do not, so during vectorization it is important to; /// remove these lengthens and truncates when deciding the profitability of; /// vectorization.; ///; /// This function analyzes the given range of instructions and determines the; /// minimum type size each can be converted to. It attempts to remove or; /// minimize type size changes across each def-use chain, so for example in the; /// following code:; ///; /// %1 = load i8, i8*; /// %2 = add i8 %1, 2; /// %3 = load i16, i16*; /// %4 = zext i8 %2 to i32; /// %5 = zext i16 %3 to i32; /// %6 = add i32 %4, %5; /// %7 = trunc i32 %6 to i16; ///; /// Instruction %6 must be done at least in i16, so computeMinimumValueSizes; /// will return: {%1: 16, %2: 16, %3: 16, %4: 16, %5: 16, %6: 16, %7: 16}.; ///; /// If the optional TargetTransformInfo is provided, this function tries harder; /// to do less work by only looking at illegal types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:211,perform,performed,211,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,3,"['load', 'perform']","['load', 'performed']"
Performance,"/// Compute a new lattice value for the given constant. The constant, after; /// stripping any pointer casts, should be a Function. We ignore null; /// pointers as an optimization, since calling these values is undefined; /// behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:167,optimiz,optimization,167,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,1,['optimiz'],['optimization']
Performance,/// Compute and return the use operand latency of a given itinerary; /// class and operand index if the value is produced by an instruction of the; /// specified itinerary class and def operand index. Return std::nullopt if; /// the information is not available for the operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h:39,latency,latency,39,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h,1,['latency'],['latency']
Performance,"/// Compute and return the use operand latency of a given pair of def and use.; /// In most cases, the static scheduling itinerary was enough to determine the; /// operand latency. But it may not be possible for instructions with variable; /// number of defs / uses.; ///; /// This is a raw interface to the itinerary that may be directly overridden; /// by a target. Use computeOperandLatency to get the best estimate of; /// latency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:39,latency,latency,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,3,['latency'],['latency']
Performance,/// Compute operand latency based on the available machine model.; ///; /// Compute and return the latency of the given data dependent def and use; /// when the operand indices are already known. UseMI may be NULL for an; /// unknown user.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:20,latency,latency,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,2,['latency'],['latency']
Performance,"/// Compute operand latency between a def of 'Reg' and an use in the current; /// loop, return true if the target considered it high.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:20,latency,latency,20,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['latency'],['latency']
Performance,/// Compute operand latency between a def of 'Reg'; /// and a use in the current loop. Return true if the target considered; /// it 'high'. This is used by optimization passes such as machine LICM to; /// determine whether it makes sense to hoist an instruction out even in a; /// high register pressure situation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:20,latency,latency,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,"['latency', 'optimiz']","['latency', 'optimization']"
Performance,/// Compute operand latency of a def of 'Reg'. Return true; /// if the target considered it 'low'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:20,latency,latency,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['latency'],['latency']
Performance,"/// Compute remaining latency. We need this both to determine whether the; /// overall schedule has become latency-limited and whether the instructions; /// outside this zone are resource or latency limited.; ///; /// The ""dependent"" latency is updated incrementally during scheduling as the; /// max height/depth of scheduled nodes minus the cycles since it was; /// scheduled:; /// DLat = max (N.depth - (CurrCycle - N.ReadyCycle) for N in Zone; ///; /// The ""independent"" latency is the max ready queue depth:; /// ILat = max N.depth for N in Available|Pending; ///; /// RemainingLatency is the greater of independent and dependent latency.; ///; /// These computations are expensive, especially in DAGs with many edges, so; /// only do them if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:22,latency,latency,22,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,7,"['latency', 'queue']","['latency', 'latency-limited', 'queue']"
Performance,"/// Compute the BlockData for the current function in one iteration.; /// Initialize - Whether this is the first iteration, we can optimize; /// the initial case a little bit by manual loop switch.; /// Returns whether the BlockData changes in this iteration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:131,optimiz,optimize,131,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['optimiz'],['optimize']
Performance,/// Compute the adjusted alignment for a load or store from an offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:41,load,load,41,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['load'],['load']
Performance,"/// Compute the cost of a representative reference in reference group \p RG; /// when the given loop \p L is considered as the innermost loop in the nest.; /// The computed cost is an estimate for the number of cache lines used by the; /// reference group. The representative reference cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if (a) loop \p L's; /// induction variable is used only in the reference subscript associated; /// with loop \p L, and (b) the reference stride is less than the cache; /// line size, or; /// - TripCount otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:211,cache,cache,211,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,2,['cache'],['cache']
Performance,"/// Compute the cost of the reference w.r.t. the given loop \p L when it is; /// considered in the innermost position in the loop nest.; /// The cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if:; /// + the reference stride is less than the cache line size, and; /// + the coefficient of this loop's index variable used in all other; /// subscripts is zero; /// - or otherwise equal to 'TripCount'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:330,cache,cache,330,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['cache'],['cache']
Performance,/// Compute the default -fmodule-cache-path.; /// \return True if the system provides a default cache directory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:33,cache,cache-path,33,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,2,['cache'],"['cache', 'cache-path']"
Performance,"/// Compute the instruction latency based on the available machine; /// model.; ///; /// Compute and return the expected latency of this instruction independent of; /// a particular use. computeOperandLatency is the preferred API, but this is; /// occasionally useful to help estimate instruction cost.; ///; /// If UseDefaultDefLatency is false and no new machine sched model is; /// present this method falls back to TII->getInstrLatency with an empty; /// instruction itinerary (this is so we preserve the previous behavior of the; /// if converter after moving it to TargetSchedModel).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:28,latency,latency,28,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,2,['latency'],['latency']
Performance,"/// Compute the instruction latency of a given instruction.; /// If the instruction has higher cost when predicated, it's returned via; /// PredCost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:28,latency,latency,28,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,['latency'],['latency']
Performance,"/// Compute the max cyclic critical path through the DAG. The scheduling DAG; /// only provides the critical path for single block loops. To handle loops that; /// span blocks, we could use the vreg path latencies provided by; /// MachineTraceMetrics instead. However, MachineTraceMetrics is not currently; /// available for use in the scheduler.; ///; /// The cyclic path estimation identifies a def-use pair that crosses the back; /// edge and considers the depth and height of the nodes. For example, consider; /// the following instruction sequence where each instruction has unit latency; /// and defines an eponymous virtual register:; ///; /// a->b(a,c)->c(b)->d(c)->exit; ///; /// The cyclic critical path is a two cycles: b->c->b; /// The acyclic critical path is four cycles: a->b->c->d->exit; /// LiveOutHeight = height(c) = len(c->d->exit) = 2; /// LiveOutDepth = depth(c) + 1 = len(a->b->c) + 1 = 3; /// LiveInHeight = height(b) + 1 = len(b->c->d->exit) + 1 = 4; /// LiveInDepth = depth(b) = len(a->b) = 1; ///; /// LiveOutDepth - LiveInDepth = 3 - 1 = 2; /// LiveInHeight - LiveOutHeight = 4 - 2 = 2; /// CyclicCriticalPath = min(2, 2) = 2; ///; /// This could be relevant to PostRA scheduling, but is currently implemented; /// assuming LiveIntervals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:585,latency,latency,585,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['latency'],['latency']
Performance,"/// Compute the memdep value for BB with Pointer/PointeeSize using either; /// cached information in Cache or by doing a lookup (which may use dirty cache; /// info if available).; ///; /// If we do a lookup, add the result to the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:79,cache,cached,79,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,4,"['Cache', 'cache']","['Cache', 'cache', 'cached']"
Performance,/// Compute the reciprocal block throughput from a set of processor resource; /// cycles. The reciprocal block throughput is computed as the MAX between:; /// - NumMicroOps / DispatchWidth; /// - ProcReleaseAtCycles / #ProcResourceUnits (for every consumed resource).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Support.h:33,throughput,throughput,33,interpreter/llvm-project/llvm/include/llvm/MCA/Support.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Support.h,2,['throughput'],['throughput']
Performance,/// Compute the reciprocal throughput of the given instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:27,throughput,throughput,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,1,['throughput'],['throughput']
Performance,"/// Compute the register class for the unfolded load.; ///; /// FIXME: This should probably live in X86InstrInfo, potentially by adding; /// a way to unfold into a newly created vreg rather than requiring a register; /// input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:48,load,load,48,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['load'],['load']
Performance,"/// Compute the set of input values and output values for the code.; ///; /// These can be used either when performing the extraction or to evaluate; /// the expected size of a call to the extracted function. Note that this; /// work cannot be cached between the two as once we decide to extract; /// a code sequence, that sequence is modified, including changing these; /// sets, before extraction occurs. These modifications won't have any; /// significant impact on the cost however.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:108,perform,performing,108,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,2,"['cache', 'perform']","['cached', 'performing']"
Performance,/// Compute the set of summaries needed for a ThinLTO backend compilation of; /// \p ModulePath.; //; /// This includes summaries from that module (in case any global summary based; /// optimizations were recorded) and from any definitions in other modules that; /// should be imported.; //; /// \p ModuleToSummariesForIndex will be populated with the needed summaries; /// from each required module path. Use a std::map instead of StringMap to get; /// stable order for bitcode emission.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h:186,optimiz,optimizations,186,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h,1,['optimiz'],['optimizations']
Performance,/// Computes instruction latency as max of latency of defined operands.; ///; /// \param Root is a machine instruction that could be replaced by NewRoot.; /// It is used to compute a more accurate latency information for NewRoot in; /// case there is a dependent instruction in the same trace (\p BlockTrace); /// \param NewRoot is the instruction for which the latency is computed; /// \param BlockTrace is a trace of machine instructions; ///; /// \returns Latency of \p NewRoot,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:25,latency,latency,25,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,5,"['Latency', 'latency']","['Latency', 'latency']"
Performance,"/// Concatenates the next (sub-)sequence of \p Tokens separated by '##'; /// starting with LHSTok - stopping when we encounter a token that is neither; /// '##' nor preceded by '##'. Places the result back into \p LHSTok and sets; /// \p CurIdx to point to the token following the last one that was pasted.; ///; /// Also performs the MSVC extension wide-literal token pasting involved with:; /// \code L #macro-arg. \endcode; ///; /// \param[in,out] LHSTok - Contains the token to the left of '##' in \p; /// Tokens upon entry and will contain the resulting concatenated Token upon; /// exit.; ///; /// \param[in] TokenStream - The stream of Tokens we are lexing from.; ///; /// \param[in,out] CurIdx - Upon entry, \pTokens[\pCurIdx] must equal '##'; /// (with the exception of the MSVC extension mentioned above). Upon exit, it; /// is set to the index of the token following the last token that was; /// concatenated together.; ///; /// \returns If this returns true, the caller should immediately return the; /// token.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenLexer.h:322,perform,performs,322,interpreter/llvm-project/clang/include/clang/Lex/TokenLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenLexer.h,1,['perform'],['performs']
Performance,"/// Concrete subclass of DominatorTreeBase that is used to compute a; /// normal dominator tree.; ///; /// Definition: A block is said to be forward statically reachable if there is; /// a path from the entry of the function to the block. A statically reachable; /// block may become statically unreachable during optimization.; ///; /// A forward unreachable block may appear in the dominator tree, or it may; /// not. If it does, dominance queries will return results as if all reachable; /// blocks dominate it. When asking for a Node corresponding to a potentially; /// unreachable block, calling code must handle the case where the block was; /// unreachable and the result of getNode() is nullptr.; ///; /// Generally, a block known to be unreachable when the dominator tree is; /// constructed will not be in the tree. One which becomes unreachable after; /// the dominator tree is initially constructed may still exist in the tree,; /// even if the tree is properly updated. Calling code should not rely on the; /// preceding statements; this is stated only to assist human understanding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h:314,optimiz,optimization,314,interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h,1,['optimiz'],['optimization']
Performance,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:4,Concurren,ConcurrentHashTable,4,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,4,"['Concurren', 'concurren']","['ConcurrentHashTable', 'ConcurrentHashTableByPtr', 'concurrent']"
Performance,"/// ConditionalCleanup stores the saved form of its parameters,; /// then restores them and performs the cleanup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/EHScopeStack.h:92,perform,performs,92,interpreter/llvm-project/clang/lib/CodeGen/EHScopeStack.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/EHScopeStack.h,1,['perform'],['performs']
Performance,"/// Conditionally gathers eight 32-bit floating-point values, either from the; /// 256-bit vector of [8 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_mask_i32gather_ps(__m256 a, const float *m, __m256i i,; /// __m256 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 256-bit vector of [8 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:961,load,loading,961,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers eight 32-bit integer values, either from the; /// 256-bit vector of [8 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i. The 256-bit vector; /// of [8 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi32(__m256i a, const int *m, __m256i i,; /// __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 256-bit vector of [8 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [8 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:952,load,loading,952,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i32gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:957,load,loading,957,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers four 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_mask_i64gather_ps(__m128 a, const float *m, __m256i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:960,load,loading,960,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:948,load,loading,948,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers four 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_mask_i64gather_epi32(__m128i a, const int *m, __m256i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:951,load,loading,951,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i32gather_pd(__m256d a, const double *m, __m128i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:967,load,loading,967,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers four 64-bit floating-point values, either from the; /// 256-bit vector of [4 x double] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_mask_i64gather_pd(__m256d a, const double *m, __m256i i,; /// __m256d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 256-bit vector of [4 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:967,load,loading,967,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i32gather_epi64(__m256i a, const long long *m,; /// __m128i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:957,load,loading,957,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers four 64-bit integer values, either from the; /// 256-bit vector of [4 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i. The 256-bit vector; /// of [4 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_mask_i64gather_epi64(__m256i a, const long long *m,; /// __m256i i, __m256i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 256-bit vector of [4 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param mask; /// A 256-bit vector of [4 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:957,load,loading,957,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers two 32-bit floating-point values, either from the; /// 128-bit vector of [4 x float] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x float] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_mask_i64gather_ps(__m128 a, const float *m, __m128i i,; /// __m128 mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param a; /// A 128-bit vector of [4 x float] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x float] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory. Only the first; /// two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1083,load,loading,1083,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers two 32-bit integer values, either from the; /// 128-bit vector of [4 x i32] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [4 x i32] in \a mask determines the source for the lower two; /// elements. The upper two elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// IF mask[j+31] == 0; /// result[j+31:j] := a[j+31:j]; /// ELSE; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi32(__m128i a, const int *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param a; /// A 128-bit vector of [4 x i32] used as the source when a mask bit is; /// zero. Only the first two elements are used.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing indexes into \a m.; /// \param mask; /// A 128-bit vector of [4 x i32] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory. Only the first two elements; /// are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:1074,load,loading,1074,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i64gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:963,load,loading,963,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers two 64-bit floating-point values, either from the; /// 128-bit vector of [2 x double] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x double] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_mask_i32gather_pd(__m128d a, const double *m, __m128i i,; /// __m128d mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param a; /// A 128-bit vector of [2 x double] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x double] containing the mask. The most; /// significant bit of each element in the mask vector represents the mask; /// bits. If a mask bit is zero, the corresponding value from vector \a a; /// is gathered; otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:963,load,loading,963,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i64gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:953,load,loading,953,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally gathers two 64-bit integer values, either from the; /// 128-bit vector of [2 x i64] in \a a, or from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i. The 128-bit vector; /// of [2 x i64] in \a mask determines the source for each element.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// IF mask[j+63] == 0; /// result[j+63:j] := a[j+63:j]; /// ELSE; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_mask_i32gather_epi64(__m128i a, const long long *m, __m128i i,; /// __m128i mask, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param a; /// A 128-bit vector of [2 x i64] used as the source when a mask bit is; /// zero.; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param mask; /// A 128-bit vector of [2 x i64] containing the mask. The most significant; /// bit of each element in the mask vector represents the mask bits. If a; /// mask bit is zero, the corresponding value from vector \a a is gathered;; /// otherwise the value is loaded from memory.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:953,load,loading,953,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Conditionally loads double-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [4 x double], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the double-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [4 x quadword] containing the mask. The most; /// significant bit of each quadword element represents the mask bits. If a; /// mask bit is zero, the corresponding value in the memory location is not; /// loaded and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [4 x double] containing the loaded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:18,load,loads,18,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,3,['load'],"['loaded', 'loads']"
Performance,"/// Conditionally loads eight 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [8 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 7; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [8 x i32] containing the mask bits.; /// \returns A 256-bit vector of [8 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:18,load,loads,18,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,3,['load'],"['loaded', 'loading', 'loads']"
Performance,"/// Conditionally loads four 32-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [4 x i32] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*32; /// IF __M[j+31] == 1; /// result[j+31:j] := Load32(__X+(i*4)); /// ELSE; /// result[j+31:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVD instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [4 x i32] containing the mask bits.; /// \returns A 128-bit vector of [4 x i32] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:18,load,loads,18,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,3,['load'],"['loaded', 'loading', 'loads']"
Performance,"/// Conditionally loads four 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 256-bit [4 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 3; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 256-bit vector of [4 x i64] containing the mask bits.; /// \returns A 256-bit vector of [4 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:18,load,loads,18,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,3,['load'],"['loaded', 'loading', 'loads']"
Performance,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 128-bit vector of; /// [4 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 128-bit integer vector containing the mask. The most significant bit of; /// each data element represents the mask bits. If a mask bit is zero, the; /// corresponding value in the memory location is not loaded and the; /// corresponding field in the return value is set to zero.; /// \returns A 128-bit vector of [4 x float] containing the loaded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:18,load,loads,18,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,3,['load'],"['loaded', 'loads']"
Performance,"/// Conditionally loads single-precision floating point elements from a; /// memory location pointed to by \a __p into a 256-bit vector of; /// [8 x float], depending on the mask bits associated with each data; /// element.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMASKMOVPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location that contains the single-precision; /// floating point values.; /// \param __m; /// A 256-bit integer vector of [8 x dword] containing the mask. The most; /// significant bit of each dword element represents the mask bits. If a mask; /// bit is zero, the corresponding value in the memory location is not loaded; /// and the corresponding field in the return value is set to zero.; /// \returns A 256-bit vector of [8 x float] containing the loaded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:18,load,loads,18,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,3,['load'],"['loaded', 'loads']"
Performance,"/// Conditionally loads two 64-bit integer elements from memory \a __X, if; /// the most significant bit of the corresponding element in the mask; /// \a __M is set; otherwise, sets that element of the result to zero.; /// Returns the 128-bit [2 x i64] result.; ///; /// \code{.operation}; /// FOR i := 0 TO 1; /// j := i*64; /// IF __M[j+63] == 1; /// result[j+63:j] := Load64(__X+(i*8)); /// ELSE; /// result[j+63:j] := 0; /// FI; /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VPMASKMOVQ instruction.; ///; /// \param __X; /// A pointer to the memory used for loading values.; /// \param __M; /// A 128-bit vector of [2 x i64] containing the mask bits.; /// \returns A 128-bit vector of [2 x i64] containing the loaded or zeroed; /// elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:18,load,loads,18,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,3,['load'],"['loaded', 'loading', 'loads']"
Performance,/// Configuration for the mach-o header of a JITDylib. Specify common load; /// commands that should be added to the header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOPlatform.h:70,load,load,70,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOPlatform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOPlatform.h,1,['load'],['load']
Performance,/// Connect the unrolling epilog code to the original loop.; /// The unrolling epilog code contains code to execute the; /// 'extra' iterations if the run-time trip count modulo the; /// unroll count is non-zero.; ///; /// This function performs the following:; /// - Update PHI nodes at the unrolling loop exit and epilog loop exit; /// - Create PHI nodes at the unrolling loop exit to combine; /// values that exit the unrolling loop code and jump around it.; /// - Update PHI operands in the epilog loop by the new PHI nodes; /// - Branch around the epilog loop if extra iters (ModVal) is zero.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:237,perform,performs,237,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,1,['perform'],['performs']
Performance,/// Connect the unrolling prolog code to the original loop.; /// The unrolling prolog code contains code to execute the; /// 'extra' iterations if the run-time trip count modulo the; /// unroll count is non-zero.; ///; /// This function performs the following:; /// - Create PHI nodes at prolog end block to combine values; /// that exit the prolog code and jump around the prolog.; /// - Add a PHI operand to a PHI node at the loop exit block; /// for values that exit the prolog and go around the loop.; /// - Branch around the original loop if the trip count is less; /// than the unroll factor.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:237,perform,performs,237,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,1,['perform'],['performs']
Performance,"/// Consider the pressure increase caused by traversing this instruction; /// bottom-up. Find the pressure set with the most change beyond its pressure; /// limit based on the tracker's current pressure, and return the change in; /// number of register units of that pressure set introduced by this; /// instruction.; ///; /// This assumes that the current LiveOut set is sufficient.; ///; /// This is expensive for an on-the-fly query because it calls; /// bumpUpwardPressure to recompute the pressure sets based on current; /// liveness. This mainly exists to verify correctness, e.g. with; /// -verify-misched. getUpwardPressureDelta is the fast version of this query; /// that uses the per-SUnit cache of the PressureDiff.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:700,cache,cache,700,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,1,['cache'],['cache']
Performance,/// Const forward iterator end-point to traverse all loaded modules,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:53,load,loaded,53,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,/// Const forward iterator to traverse all loaded modules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:43,load,loaded,43,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,/// Constant -> Globals that use this global cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalDCE.h:45,cache,cache,45,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalDCE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalDCE.h,1,['cache'],['cache']
Performance,"/// ConstantFoldInstOperands - Attempt to constant fold an instruction with the; /// specified operands. If successful, the constant result is returned, if not,; /// null is returned. Note that this function can fail when attempting to; /// fold instructions like loads and stores, which have no constant expression; /// form.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:264,load,loads,264,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,1,['load'],['loads']
Performance,"/// ConstantFoldInstruction - Try to constant fold the specified instruction.; /// If successful, the constant result is returned, if not, null is returned.; /// Note that this fails if not all of the operands are constant. Otherwise,; /// this function can only fail when attempting to fold instructions like loads; /// and stores, which have no constant expression form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:310,load,loads,310,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,1,['load'],['loads']
Performance,/// Constrained versions of libm-equivalent floating point intrinsics.; /// These will be lowered to the equivalent non-constrained pseudo-op; /// (or expanded to the equivalent library call) before final selection.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:244,optimiz,optimizations,244,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,['optimiz'],"['optimizations', 'optimized']"
Performance,/// Constrained versions of the binary floating point operators.; /// These will be lowered to the simple operators before final selection.; /// They are used to limit optimizations while the DAG is being; /// optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:168,optimiz,optimizations,168,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,['optimiz'],"['optimizations', 'optimized']"
Performance,/// Construct a CacheCost object for the loop nest described by \p Loops.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:16,Cache,CacheCost,16,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['Cache'],['CacheCost']
Performance,"/// Construct a FormatStyle based on ``StyleName``.; ///; /// ``StyleName`` can take several forms:; /// * ""{<key>: <value>, ...}"" - Set specic style parameters.; /// * ""<style name>"" - One of the style names supported by; /// getPredefinedStyle().; /// * ""file"" - Load style configuration from a file called ``.clang-format``; /// located in one of the parent directories of ``FileName`` or the current; /// directory if ``FileName`` is empty.; /// * ""file:<format_file_path>"" to explicitly specify the configuration file to; /// use.; ///; /// \param[in] StyleName Style name to interpret according to the description; /// above.; /// \param[in] FileName Path to start search for .clang-format if ``StyleName``; /// == ""file"".; /// \param[in] FallbackStyle The name of a predefined style used to fallback to; /// in case \p StyleName is ""file"" and no file can be found.; /// \param[in] Code The actual code to be formatted. Used to determine the; /// language if the filename isn't sufficient.; /// \param[in] FS The underlying file system, in which the file resides. By; /// default, the file system is the real file system.; /// \param[in] AllowUnknownOptions If true, unknown format options only; /// emit a warning. If false, errors are emitted on unknown format; /// options.; ///; /// \returns FormatStyle as specified by ``StyleName``. If ``StyleName`` is; /// ""file"" and no file is found, returns ``FallbackStyle``. If no style could be; /// determined, returns an Error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:265,Load,Load,265,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['Load'],['Load']
Performance,"/// Construct a bitcode writer pass around a particular output stream.; ///; /// If \c ShouldPreserveUseListOrder, encode use-list order so it can be; /// reproduced when deserialized.; ///; /// If \c EmitSummaryIndex, emit the summary index (currently; /// for use in ThinLTO optimization).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriterPass.h:277,optimiz,optimization,277,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriterPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriterPass.h,1,['optimiz'],['optimization']
Performance,"/// Construct a new RooWrapperPdf.; /// \param[in] name A name to identify this object.; /// \param[in] title Title (for e.g. plotting); /// \param[in] inputFunction Any RooAbsReal that should be converted into a PDF. Although it's possible; /// \param[in] selfNormalized The return value the RooAbsPdf::selfNormalized() function for the wrapped PDF object.; /// If it is `true`, then no automatic normalization will be; /// performed when evaluating the function. In this case, the; /// effect RooWrapperPdf is not to change the evaluated values,; /// but only to wrap the function in something that is of type; /// RooAbsPdf, which can be useful if some interface reqiures it.; /// to pass a PDF, it only makes sense for non-PDF functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWrapperPdf.h:425,perform,performed,425,roofit/roofitcore/inc/RooWrapperPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooWrapperPdf.h,1,['perform'],['performed']
Performance,/// Construct a pass with optional optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h:35,optimiz,optimizations,35,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/SimplifyCFG.h,1,['optimiz'],['optimizations']
Performance,"/// Construct from a C string.; ///; /// We take care here to optimize """" into the empty twine -- this will be; /// optimized out for string constants. This allows Twine arguments have; /// default """" values, without introducing unnecessary string constants.; /*implicit*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:62,optimiz,optimize,62,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,2,['optimiz'],"['optimize', 'optimized']"
Performance,"/// Construct jobs to perform the action \p JA, writing to the \p Outputs and; /// with \p Inputs, and add the jobs to \p C. The default implementation; /// assumes a single output and is expected to be overloaded for the tools; /// that support multiple inputs.; ///; /// \param TCArgs The argument list for this toolchain, with any; /// tool chain specific translations applied.; /// \param LinkingOutput If this output will eventually feed the; /// linker, then this is the final output name of the linked image.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Tool.h:22,perform,perform,22,interpreter/llvm-project/clang/include/clang/Driver/Tool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Tool.h,1,['perform'],['perform']
Performance,"/// Construct the RTreeColumnReader. Actual initialization is performed lazily by the Init method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:62,perform,performed,62,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,2,['perform'],['performed']
Performance,"/// Construct the core LLVM function canonicalization and simplification; /// pipeline.; ///; /// This is a long pipeline and uses most of the per-function optimization; /// passes in LLVM to canonicalize and simplify the IR. It is suitable to run; /// repeatedly over the IR and is not expected to destroy important; /// information about the semantics of the IR.; ///; /// Note that \p Level cannot be `O0` here. The pipelines produced are; /// only intended for use when attempting to optimize code. If frontends; /// require some transformations for semantic reasons, they should explicitly; /// build them.; ///; /// \p Phase indicates the current ThinLTO phase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:156,optimiz,optimization,156,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,2,['optimiz'],"['optimization', 'optimize']"
Performance,"/// Construct the core LLVM module canonicalization and simplification; /// pipeline.; ///; /// This pipeline focuses on canonicalizing and simplifying the entire module; /// of IR. Much like the function simplification pipeline above, it is; /// suitable to run repeatedly over the IR and is not expected to destroy; /// important information. It does, however, perform inlining and other; /// heuristic based simplifications that are not strictly reversible.; ///; /// Note that \p Level cannot be `O0` here. The pipelines produced are; /// only intended for use when attempting to optimize code. If frontends; /// require some transformations for semantic reasons, they should explicitly; /// build them.; ///; /// \p Phase indicates the current ThinLTO phase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:363,perform,perform,363,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,2,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"/// Construct the core LLVM module optimization pipeline.; ///; /// This pipeline focuses on optimizing the execution speed of the IR. It; /// uses cost modeling and thresholds to balance code growth against runtime; /// improvements. It includes vectorization and other information destroying; /// transformations. It also cannot generally be run repeatedly on a module; /// without potentially seriously regressing either runtime performance of; /// the code or serious code size growth.; ///; /// Note that \p Level cannot be `O0` here. The pipelines produced are; /// only intended for use when attempting to optimize code. If frontends; /// require some transformations for semantic reasons, they should explicitly; /// build them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:35,optimiz,optimization,35,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,4,"['optimiz', 'perform']","['optimization', 'optimize', 'optimizing', 'performance']"
Performance,/// Construct the module pipeline that performs inlining as well as; /// the inlining-driven cleanups.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:39,perform,performs,39,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['perform'],['performs']
Performance,/// Construct the module pipeline that performs inlining with; /// module inliner pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:39,perform,performs,39,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['perform'],['performs']
Performance,"/// ConstructJob - Construct jobs to perform the action \p JA,; /// writing to \p Output and with \p Inputs, and add the jobs to; /// \p C.; ///; /// \param TCArgs - The argument list for this toolchain, with any; /// tool chain specific translations applied.; /// \param LinkingOutput - If this output will eventually feed the; /// linker, then this is the final output name of the linked image.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Tool.h:37,perform,perform,37,interpreter/llvm-project/clang/include/clang/Driver/Tool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Tool.h,1,['perform'],['perform']
Performance,"/// Constructor for simple caches with RooAbsArg derived payload. A cache; /// made with this constructor is registered with its owner; /// and will receive information on server redirects and; /// cache operation mode changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:27,cache,caches,27,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,3,['cache'],"['cache', 'caches']"
Performance,"/// Constructor for simple caches without RooAbsArg payload. A cache; /// made with this constructor is not registered with its owner; /// and will not receive information on server redirects and; /// cache operation mode changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:27,cache,caches,27,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,3,['cache'],"['cache', 'caches']"
Performance,/// Constructor for the mapping of an instruction.; /// \p NumOperands must be equal to number of all the operands of; /// the related instruction.; /// The rationale is that it is more efficient for the optimizers; /// to be able to assume that the mapping of the ith operand is; /// at the index i.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:204,optimiz,optimizers,204,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['optimiz'],['optimizers']
Performance,"/// Constructor from data, from a full model pdf describing both parameter of interest and nuisance parameters; /// and from the set specifying the parameter of interest (POI).; /// There is no need to specify the nuisance parameters since they are all other parameters of the model.; /// When using the calculator for performing an hypothesis test one needs to provide also a snapshot (a copy); /// defining the null parameters and their value. There is no need to pass the alternate parameters. These; /// will be obtained by the value maximizing the likelihood function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProfileLikelihoodCalculator.h:319,perform,performing,319,roofit/roostats/inc/RooStats/ProfileLikelihoodCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProfileLikelihoodCalculator.h,1,['perform'],['performing']
Performance,/// Constructor of the action.; /// The constructor performs the related action on the IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:52,perform,performs,52,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['perform'],['performs']
Performance,/// Constructor replacement to ensure unique and stable sets are used for the; /// cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:83,cache,cache,83,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['cache'],['cache']
Performance,/// Constructor; ///; /// \param Functions The set of functions we are deriving attributes for.; /// \param InfoCache Cache to hold various information accessible for; /// the abstract attributes.; /// \param Configuration The Attributor configuration which determines what; /// generic features to use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:118,Cache,Cache,118,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['Cache'],['Cache']
Performance,"/// Constructs a clang tool to run over a list of files.; ///; /// \param Compilations The CompilationDatabase which contains the compile; /// command lines for the given source paths.; /// \param SourcePaths The source files to run over. If a source files is; /// not found in Compilations, it is skipped.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.; /// \param BaseFS VFS used for all underlying file accesses when running the; /// tool.; /// \param Files The file manager to use for underlying file operations when; /// running the tool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:366,load,loading,366,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,1,['load'],['loading']
Performance,"/// Constructs an IncomingWFRHandler from a function object that is callable; /// as void(shared::WrapperFunctionResult). The function object will be called; /// directly. This should be used with care as it may block listener threads; /// in remote EPCs. It is only suitable for simple tasks (e.g. setting a; /// future), or for performing some quick analysis before dispatching ""real""; /// work as a Task.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h:330,perform,performing,330,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,1,['perform'],['performing']
Performance,"/// Contains a set of libraries which we gave to the user via ResolveSymbol; /// call and next time we should check if the user loaded them to avoid; /// useless iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:128,load,loaded,128,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['load'],['loaded']
Performance,/// Contains cached results of getOrCreateObjectPair().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h:13,cache,cached,13,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,1,['cache'],['cached']
Performance,"/// Contains estimates of the number of operations (loads, stores, compute) required to lower a matrix operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:52,load,loads,52,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['load'],['loads']
Performance,/// Contents and directive tokens of a cached file entry. Single instance can; /// be shared between multiple entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:39,cache,cached,39,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cached']
Performance,/// Context in which we're performing a usual arithmetic conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:27,perform,performing,27,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,"/// Context-free CaptureInfo provider, which computes and caches whether an; /// object is captured in the function at all, but does not distinguish whether; /// it was captured before or after the context instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:58,cache,caches,58,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['cache'],['caches']
Performance,"/// Context-sensitive CaptureInfo provider, which computes and caches the; /// earliest common dominator closure of all captures. It provides a good; /// approximation to a precise ""captures before"" analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:63,cache,caches,63,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['cache'],['caches']
Performance,/// Convenience function for loading the file header given a data extractor at a; /// specified offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h:29,load,loading,29,interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/FileHeaderReader.h,1,['load'],['loading']
Performance,/// ConversionFunction - The function that will perform the; /// user-defined conversion. Null if the conversion is an; /// aggregate initialization from an initializer list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:48,perform,perform,48,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['perform'],['perform']
Performance,"/// Convert ({u,s}itofp vec) --> ({u,s}itofp ({s,z}ext vec)) so it doesn't get; /// split up into scalar instructions during legalization, and the vector; /// extending instructions are selected in performVectorExtendCombine below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:198,perform,performVectorExtendCombine,198,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['perform'],['performVectorExtendCombine']
Performance,"/// Convert Op, which must be of integer type, to the integer type VT, by; /// either truncating it or performing either zero or sign extension as; /// appropriate extension for the pointer's semantics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:103,perform,performing,103,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['perform'],['performing']
Performance,"/// Convert a DWARF compile unit file index into a GSYM global file index.; ///; /// Each compile unit in DWARF has its own file table in the line table; /// prologue. GSYM has a single large file table that applies to all files; /// from all of the info in a GSYM file. This function converts between the; /// two and caches and DWARF CU file index that has already been converted so; /// the first client that asks for a compile unit file index will end up; /// doing the conversion, and subsequent clients will get the cached GSYM; /// index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp:319,cache,caches,319,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,2,['cache'],"['cached', 'caches']"
Performance,/// Convert a JITTargetAddress to a callable function pointer.; ///; /// Casts the given address to a callable function pointer. This operation; /// will perform pointer signing for platforms that require it (e.g. arm64e).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h:154,perform,perform,154,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,1,['perform'],['perform']
Performance,"/// Convert a JITTargetAddress to a pointer.; ///; /// Note: This is a raw cast of the address bit pattern to the given pointer; /// type. When casting to a function pointer in order to execute JIT'd code; /// jitTargetAddressToFunction should be preferred, as it will also perform; /// pointer signing on targets that require it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h:274,perform,perform,274,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,1,['perform'],['perform']
Performance,"/// Convert a TLS address reference into the correct sequence of loads; /// and calls to compute the variable's address (for Darwin, currently) and; /// return an SDValue containing the final node.; /// Darwin only has one TLS scheme which must be capable of dealing with the; /// fully general situation, in the worst case. This means:; /// + ""extern __thread"" declaration.; /// + Defined in a possibly unknown dynamic library.; ///; /// The general system is that each __thread variable has a [3 x i64] descriptor; /// which contains information used by the runtime to calculate the address. The; /// only part of this the compiler needs to know about is the first xword, which; /// contains a function pointer that must be called with the address of the; /// entire descriptor in ""x0"".; ///; /// Since this descriptor may be in a different unit, in general even the; /// descriptor must be accessed via an indirect load. The ""ideal"" code sequence; /// is:; /// adrp x0, _var@TLVPPAGE; /// ldr x0, [x0, _var@TLVPPAGEOFF] ; x0 now contains address of descriptor; /// ldr x1, [x0] ; x1 contains 1st entry of descriptor,; /// ; the function pointer; /// blr x1 ; Uses descriptor address in x0; /// ; Address of _var is now in x0.; ///; /// If the address of _var's descriptor *is* known to the linker, then it can; /// change the first ""ldr"" instruction to an appropriate ""add x0, x0, #imm"" for; /// a slight efficiency gain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:65,load,loads,65,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['load'],"['load', 'loads']"
Performance,"/// Convert a TLS address reference into the correct sequence of loads; /// and calls to compute the variable's address for Darwin, and return an; /// SDValue containing the final node.; /// Darwin only has one TLS scheme which must be capable of dealing with the; /// fully general situation, in the worst case. This means:; /// + ""extern __thread"" declaration.; /// + Defined in a possibly unknown dynamic library.; ///; /// The general system is that each __thread variable has a [3 x i32] descriptor; /// which contains information used by the runtime to calculate the address. The; /// only part of this the compiler needs to know about is the first word, which; /// contains a function pointer that must be called with the address of the; /// entire descriptor in ""r0"".; ///; /// Since this descriptor may be in a different unit, in general access must; /// proceed along the usual ARM rules. A common sequence to produce is:; ///; /// movw rT1, :lower16:_var$non_lazy_ptr; /// movt rT1, :upper16:_var$non_lazy_ptr; /// ldr r0, [rT1]; /// ldr rT2, [r0]; /// blx rT2; /// [...address now in r0...]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:65,load,loads,65,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['loads']
Performance,"/// Convert a loop into a loop with bottom test. It may; /// perform loop latch simplication as well if the flag RotationOnly; /// is false. The flag Threshold represents the size threshold of the loop; /// header. If the loop header's size exceeds the threshold, the loop rotation; /// will give up. The flag IsUtilMode controls the heuristic used in the; /// LoopRotation. If it is true, the profitability heuristic will be ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h:61,perform,perform,61,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopRotationUtils.h,1,['perform'],['perform']
Performance,"/// Convert a template-argument that we parsed as a type into a template, if; /// possible. C++ permits injected-class-names to perform dual service as; /// template template arguments and as template type arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:128,perform,perform,128,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['perform'],['perform']
Performance,"/// Convert a vector load intrinsic into a simple llvm load instruction.; /// This is beneficial when the underlying object being addressed comes; /// from a constant, since we get constant-folding for free.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:21,load,load,21,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,2,['load'],['load']
Performance,"/// Convert a vector-predicated Op, which must be an integer vector, to the; /// vector-type VT, by performing either vector-predicated zext or truncating; /// it. The Op will be returned as-is if Op and VT are vectors containing; /// integer with same width.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:100,perform,performing,100,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['perform'],['performing']
Performance,"/// Convert a vector-predicated Op, which must be of integer type, to the; /// vector-type integer type VT, by either truncating it or performing either; /// vector-predicated zero or sign extension as appropriate extension for the; /// pointer's semantics. This function just redirects to getVPZExtOrTrunc; /// right now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:135,perform,performing,135,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['perform'],['performing']
Performance,"/// Convert an AccessSpecifier into the corresponding DINode flag.; /// As an optimization, return 0 if the access specifier equals the; /// default for the containing type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:78,optimiz,optimization,78,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['optimiz'],['optimization']
Performance,/// Convert an atomic load of a non-integral type to an integer load of the; /// equivalent bitwidth. See the function comment on; /// convertAtomicStoreToIntegerType for background.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:22,load,load,22,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,2,['load'],['load']
Performance,/// Convert the given Cmpxchg into primitive load and compare.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h:45,load,load,45,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h,1,['load'],['load']
Performance,"/// Convert the given RMWI into primitive load and stores,; /// assuming that doing so is legal. Return true if the lowering; /// succeeds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h:42,load,load,42,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerAtomic.h,1,['load'],['load']
Performance,/// ConvertSETCCToSubtract - looks at SETCC that compares ints. It replaces; /// SETCC with integer subtraction when (1) there is a legal way of doing it; /// (2) keeping the result of comparison in GPR has performance benefit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:207,perform,performance,207,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['perform'],['performance']
Performance,/// Converts the instrs in the chain into a single vectorized load or store.; /// Adds the old scalar loads/stores to ToErase.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:62,load,load,62,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,2,['load'],"['load', 'loads']"
Performance,"/// Copies a record (struct, class, or union) from `Src` to `Dst`.; ///; /// This performs a deep copy, i.e. it copies every field (including synthetic; /// fields) and recurses on fields of record type.; ///; /// If there is a `RecordValue` associated with `Dst` in the environment, this; /// function creates a new `RecordValue` and associates it with `Dst`; clients; /// need to be aware of this and must not assume that the `RecordValue`; /// associated with `Dst` remains the same after the call.; ///; /// Requirements:; ///; /// `Src` and `Dst` must have the same canonical unqualified type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/RecordOps.h:82,perform,performs,82,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/RecordOps.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/RecordOps.h,1,['perform'],['performs']
Performance,/// Copy a nonnull metadata node to a new load instruction.; ///; /// This handles mapping it to range metadata if the new load is an integer; /// load instead of a pointer load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:42,load,load,42,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,4,['load'],['load']
Performance,/// Copy a range metadata node to a new load instruction.; ///; /// This handles mapping it to nonnull metadata if the new load is a pointer; /// load instead of an integer load and the range doesn't cover null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:40,load,load,40,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,4,['load'],['load']
Performance,"/// Copy the underlying value.; ///; /// This should get optimized down to a simple copy. We need to actually; /// construct the value, rather than calling memcpy, to satisfy strict; /// aliasing rules.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:57,optimiz,optimized,57,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,1,['optimiz'],['optimized']
Performance,"/// CopyConstructor - The copy constructor that is used to perform; /// this conversion, when the conversion is actually just the; /// initialization of an object via copy constructor. Such; /// conversions are either identity conversions or derived-to-base; /// conversions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:59,perform,perform,59,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['perform'],['perform']
Performance,"/// Could in principle cache the integral in a Graph as it is done for the FFTW",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:23,cache,cache,23,hist/hist/src/TF1Convolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx,1,['cache'],['cache']
Performance,"/// Create RAction object, return RResultPtr for the action; /// Overload for the case in which all column types were specified (no jitting).; /// For most actions, `r` and `helperArg` will refer to the same object, because the only argument to forward to; /// the action helper is the result value itself. We need the distinction for actions such as Snapshot or Cache,; /// for which the constructor arguments of the action helper are different from the returned value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx:363,Cache,Cache,363,tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterfaceBase.hxx,1,['Cache'],['Cache']
Performance,"/// Create RooArgSet containing the objects that are both in the cached set 1; /// with a given index and an input argSet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:65,cache,cached,65,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['cache'],['cached']
Performance,"/// Create RooArgSet containing the objects that are both in the cached set 2; /// with a given index and an input argSet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:65,cache,cached,65,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['cache'],['cached']
Performance,/// Create a ASTUnit from an AST file.; ///; /// \param Filename - The AST file to load.; ///; /// \param PCHContainerRdr - The PCHContainerOperations to use for loading and; /// creating modules.; /// \param Diags - The diagnostics engine to use for reporting errors; its; /// lifetime is expected to extend past that of the returned ASTUnit.; ///; /// \returns - The initialized ASTUnit or null if the AST failed to load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:83,load,load,83,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,3,['load'],"['load', 'loading']"
Performance,/// Create a CacheCost for the loop nest rooted by \p Root.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:13,Cache,CacheCost,13,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['Cache'],['CacheCost']
Performance,/// Create a ExecutorProcessControl-based DebugObjectRegistrar that emits debug; /// objects to the GDB JIT interface. This will use the EPC's lookupSymbols; /// method to find the registration/deregistration function addresses by name.; ///; /// If RegistrationFunctionsDylib is non-None then it will be searched to find; /// the registration functions. If it is None then the process dylib will be; /// loaded to find the registration functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDebugObjectRegistrar.h:405,load,loaded,405,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDebugObjectRegistrar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDebugObjectRegistrar.h,1,['load'],['loaded']
Performance,"/// Create a binary operation that may resolve to an overloaded; /// operator.; ///; /// \param OpLoc The location of the operator itself (e.g., '+').; ///; /// \param Opc The BinaryOperatorKind that describes this operator.; ///; /// \param Fns The set of non-member functions that will be; /// considered by overload resolution. The caller needs to build this; /// set based on the context using, e.g.,; /// LookupOverloadedOperatorName() and ArgumentDependentLookup(). This; /// set should not contain any member functions; those will be added; /// by CreateOverloadedBinOp().; ///; /// \param LHS Left-hand argument.; /// \param RHS Right-hand argument.; /// \param PerformADL Whether to consider operator candidates found by ADL.; /// \param AllowRewrittenCandidates Whether to consider candidates found by; /// C++20 operator rewrites.; /// \param DefaultedFn If we are synthesizing a defaulted operator function,; /// the function in question. Such a function is never a candidate in; /// our overload resolution. This also enables synthesizing a three-way; /// comparison from < and == as described in C++20 [class.spaceship]p1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:670,Perform,PerformADL,670,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['Perform'],['PerformADL']
Performance,/// Create a cache control for the subtarget \p ST.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:13,cache,cache,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['cache'],['cache']
Performance,/// Create a call to Masked Expand Load intrinsic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:35,Load,Load,35,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['Load'],['Load']
Performance,/// Create a call to Masked Expand Load intrinsic; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:35,Load,Load,35,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,3,"['Load', 'load']","['Load', 'load']"
Performance,/// Create a call to Masked Load intrinsic,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:28,Load,Load,28,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['Load'],['Load']
Performance,/// Create a call to a Masked Gather intrinsic.; /// \p Ty - vector type to gather; /// \p Ptrs - vector of pointers for loading; /// \p Align - alignment for one element; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:121,load,loading,121,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,1,['load'],['loading']
Performance,/// Create a call to a Masked Load intrinsic.; /// \p Ty - vector type to load; /// \p Ptr - base pointer for the load; /// \p Alignment - alignment of the source location; /// \p Mask - vector of booleans which indicates what vector lanes should; /// be accessed in memory; /// \p PassThru - pass-through value that is used to fill the masked-off lanes; /// of the result; /// \p Name - name of the result variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp:30,Load,Load,30,interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IRBuilder.cpp,3,"['Load', 'load']","['Load', 'load']"
Performance,"/// Create a clone of Edge's callee and move Edge to that new callee node,; /// performing the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:80,perform,performing,80,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['perform'],['performing']
Performance,"/// Create a column major, strided matrix load.; /// \p EltTy - Matrix element type; /// \p DataPtr - Start address of the matrix read; /// \p Rows - Number of rows in matrix (must be a constant); /// \p Columns - Number of columns in matrix (must be a constant); /// \p Stride - Space between columns",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/MatrixBuilder.h:42,load,load,42,interpreter/llvm-project/llvm/include/llvm/IR/MatrixBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/MatrixBuilder.h,1,['load'],['load']
Performance,/// Create a legacy pass manager instance of the LoadStoreVectorizer pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h:49,Load,LoadStoreVectorizer,49,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoadStoreVectorizer.h,1,['Load'],['LoadStoreVectorizer']
Performance,"/// Create a local file system cache which uses the given cache name, temporary; /// file prefix, cache directory and file callback. This function does not; /// immediately create the cache directory if it does not yet exist; this is; /// done lazily the first time a file is added. The cache name appears in error; /// messages for errors during caching. The temporary file prefix is used in the; /// temporary file naming scheme used when writing files atomically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h:31,cache,cache,31,interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,5,['cache'],['cache']
Performance,"/// Create a machine node performing a notional SHL of Op by ShlAmount. If; /// ShlAmount is negative, do a (logical) right-shift instead. If ShlAmount is; /// 0, return Op unchanged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:26,perform,performing,26,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['perform'],['performing']
Performance,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:342,load,loads,342,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['load'],['loads']
Performance,"/// Create a new MachineInstr which is a copy of \p Orig, identical in all; /// ways except the instruction has no parent, prev, or next. Bundling flags; /// are reset.; ///; /// Note: Clones a single instruction, not whole instruction bundles.; /// Does not perform target specific adjustments; consider using; /// TargetInstrInfo::duplicate() instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:259,perform,perform,259,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['perform'],['perform']
Performance,/// Create a new ModuloScheduleExpander.; /// \arg InstrChanges Modifications to make to instructions with memory; /// operands.; /// FIXME: InstrChanges is opaque and is an implementation detail of an; /// optimization in MachinePipeliner that crosses abstraction boundaries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:207,optimiz,optimization,207,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['optimiz'],['optimization']
Performance,"/// Create a new descriptor for a parameter variable.; ///; /// \c Scope must be a \a DILocalScope, and thus its scope chain eventually; /// leads to a \a DISubprogram.; ///; /// \c ArgNo is the index (starting from \c 1) of this variable in the; /// subprogram parameters. \c ArgNo should not conflict with other; /// parameters of the same subprogram.; ///; /// If \c AlwaysPreserve, this variable will be referenced from its; /// containing subprogram, and will survive some optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h:478,optimiz,optimizations,478,interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h,1,['optimiz'],['optimizations']
Performance,"/// Create a new descriptor for an auto variable. This is a local variable; /// that is not a subprogram parameter.; ///; /// \c Scope must be a \a DILocalScope, and thus its scope chain eventually; /// leads to a \a DISubprogram.; ///; /// If \c AlwaysPreserve, this variable will be referenced from its; /// containing subprogram, and will survive some optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h:355,optimiz,optimizations,355,interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DIBuilder.h,1,['optimiz'],['optimizations']
Performance,/// Create a new hash_state structure and initialize it based on the; /// seed and the first 64-byte chunk.; /// This effectively performs the initial mix.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:130,perform,performs,130,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['perform'],['performs']
Performance,/// Create a new module for a C++ module implementation unit.; /// The interface module for this implementation (implicitly imported) must; /// exist and be loaded and present in the modules map.; ///; /// \returns The newly-created module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:157,load,loaded,157,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['load'],['loaded']
Performance,/// Create a new object to represent a bit-field access.; ///; /// \param Addr - The base address of the bit-field sequence this; /// bit-field refers to.; /// \param Info - The information describing how to perform the bit-field; /// access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h:208,perform,perform,208,interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGValue.h,1,['perform'],['perform']
Performance,"/// Create a new vector from a list of scalar values. Produces a sequence; /// which exploits values reused across lanes, and arranges the inserts; /// for ease of later optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:170,optimiz,optimization,170,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['optimiz'],['optimization']
Performance,/// Create a runtime call for kmpc_threadprivate_cached; ///; /// \param Loc The insert and source location description.; /// \param Pointer pointer to data to be cached; /// \param Size size of data to be cached; /// \param Name Name of call Instruction for callinst; ///; /// \returns CallInst to the thread private cache call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:163,cache,cached,163,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,3,['cache'],"['cache', 'cached']"
Performance,/// Create a stack guard loading and populate whether SelectionDAG SSP is; /// supported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:25,load,loading,25,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,1,['load'],['loading']
Performance,/// Create a tool invocation.; ///; /// \param CommandLine The command line arguments to clang. Note that clang; /// uses its binary name (CommandLine[0]) to locate its builtin headers.; /// Callers have to ensure that they are installed in a compatible location; /// (see clang driver implementation) or mapped in via mapVirtualFile.; /// \param FAction The action to be executed.; /// \param Files The FileManager used for the execution. Class does not take; /// ownership.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:535,load,loading,535,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,1,['load'],['loading']
Performance,/// Create a tool invocation.; ///; /// \param CommandLine The command line arguments to clang.; /// \param Action The action to be executed.; /// \param Files The FileManager used for the execution.; /// \param PCHContainerOps The PCHContainerOperations for loading and creating; /// clang modules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:259,load,loading,259,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,1,['load'],['loading']
Performance,"/// Create a unique name for the entry function using the source location; /// information of the current target region. The name will be something like:; ///; /// __omp_offloading_DD_FFFF_PP_lBB[_CC]; ///; /// where DD_FFFF is an ID unique to the file (device and file IDs), PP is the; /// mangled name of the function that encloses the target region and BB is the; /// line number of the target region. CC is a count added when more than one; /// region is located at the same location.; ///; /// If this target outline function is not an offload entry, we don't need to; /// register it. This may happen if it is guarded by an if clause that is; /// false at compile time, or no target archs have been specified.; ///; /// The created target region ID is used by the runtime library to identify; /// the current target region, so it only has to be unique and not; /// necessarily point to anything. It could be the pointer to the outlined; /// function that implements the target region, but we aren't using that so; /// that the compiler doesn't need to keep that, and could therefore inline; /// the host function if proven worthwhile during optimization. In the other; /// hand, if emitting code for the device, the ID has to be the function; /// address so that it can retrieved from the offloading entry and launched; /// by the runtime library. We also mark the outlined function to have; /// external linkage in case we are emitting code for the device, because; /// these functions will be entry points to the device.; ///; /// \param InfoManager The info manager keeping track of the offload entries; /// \param EntryInfo The entry information about the function; /// \param GenerateFunctionCallback The callback function to generate the code; /// \param OutlinedFunction Pointer to the outlined function; /// \param EntryFnIDName Name of the ID o be created",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:1147,optimiz,optimization,1147,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['optimiz'],['optimization']
Performance,"/// Create a vector constant without a load. SSE/AVX provide the bare minimum; /// functionality to do this, so it's all zeros, all ones, or some derivation; /// that is cheap to calculate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:39,load,load,39,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['load']
Performance,"/// Create an ASTUnit from a source file, via a CompilerInvocation; /// object, by invoking the optionally provided ASTFrontendAction.; ///; /// \param CI - The compiler invocation to use; it must have exactly one input; /// source file. The ASTUnit takes ownership of the CompilerInvocation object.; ///; /// \param PCHContainerOps - The PCHContainerOperations to use for loading and; /// creating modules.; ///; /// \param Diags - The diagnostics engine to use for reporting errors; its; /// lifetime is expected to extend past that of the returned ASTUnit.; ///; /// \param Action - The ASTFrontendAction to invoke. Its ownership is not; /// transferred.; ///; /// \param Unit - optionally an already created ASTUnit. Its ownership is not; /// transferred.; ///; /// \param Persistent - if true the returned ASTUnit will be complete.; /// false means the caller is only interested in getting info through the; /// provided \see Action.; ///; /// \param ErrAST - If non-null and parsing failed without any AST to return; /// (e.g. because the PCH could not be loaded), this accepts the ASTUnit; /// mainly to allow the caller to see the diagnostics.; /// This will only receive an ASTUnit if a new one was created. If an already; /// created ASTUnit was passed in \p Unit then the caller can check that.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:373,load,loading,373,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,2,['load'],"['loaded', 'loading']"
Performance,"/// Create an add instruction with appropriate flags when used for; /// addressing some offset of an object. i.e. if a load is split into multiple; /// components, create an add nuw from the base pointer to the offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:119,load,load,119,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['load'],['load']
Performance,/// Create an assume intrinsic call that allows the optimizer to; /// assume that the provided condition will be true.; ///; /// The optional argument \p OpBundles specifies operand bundles that are; /// added to the call instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:52,optimiz,optimizer,52,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['optimiz'],['optimizer']
Performance,"/// Create an empty collection of AliasSets, and use the specified alias; /// analysis object to disambiguate load and store addresses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h:110,load,load,110,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasSetTracker.h,1,['load'],['load']
Performance,"/// Create an instance of ScheduleDAGInstrs to be run within the standard; /// MachineScheduler pass for this function and target at the current; /// optimization level.; ///; /// This can also be used to plug a new MachineSchedStrategy into an instance; /// of the standard ScheduleDAGMI:; /// return new ScheduleDAGMI(C, std::make_unique<MyStrategy>(C), /*RemoveKillFlags=*/false); ///; /// Return NULL to select the default (generic) machine scheduler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:150,optimiz,optimization,150,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['optimiz'],['optimization']
Performance,/// Create and insert a LDM or STM with Base as base register and registers in; /// Regs as the register operands that would be loaded / stored. It returns; /// true if the transformation is done.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:128,load,loaded,128,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['load'],['loaded']
Performance,/// Create from a ExecutorProcessControl instance alone. This will use; /// the EPC's lookupSymbols method to find the registration/deregistration; /// function addresses by name.; ///; /// If RegistrationFunctionsDylib is non-None then it will be searched to; /// find the registration functions. If it is None then the process dylib; /// will be loaded to find the registration functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCEHFrameRegistrar.h:348,load,loaded,348,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCEHFrameRegistrar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCEHFrameRegistrar.h,1,['load'],['loaded']
Performance,"/// Create substitutions for any tracked values in \p Old, to point at; /// \p New. Needed when we re-create an instruction during optimization,; /// which has the same signature (i.e., def operands in the same place) but; /// a modified instruction type, flags, or otherwise. An example: X86 moves; /// are sometimes transformed into equivalent LEAs.; /// If the two instructions are not the same opcode, limit which operands to; /// examine for substitutions to the first N operands by setting; /// \p MaxOperand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:131,optimiz,optimization,131,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['optimiz'],['optimization']
Performance,"/// Create the TargetMachine object to query the backend for optimization; /// preferences.; ///; /// Ideally, this would be passed from the front-end to the OpenMPBuilder, but; /// e.g. Clang does not pass it to its CodeGen layer and creates it only when; /// needed for the LLVM pass pipline. We use some default options to avoid; /// having to pass too many settings from the frontend that probably do not; /// matter.; ///; /// Currently, TargetMachine is only used sometimes by the unrollLoopPartial; /// method. If we are going to use TargetMachine for more purposes, especially; /// those that are sensitive to TargetOptions, RelocModel and CodeModel, it; /// might become be worth requiring front-ends to pass on their TargetMachine,; /// or at least cache it between methods. Note that while fontends such as Clang; /// have just a single main TargetMachine per translation unit, ""target-cpu"" and; /// ""target-features"" that determine the TargetMachine are per-function and can; /// be overrided using __attribute__((target(""OPTIONS""))).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:61,optimiz,optimization,61,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"/// Create the initialization entity for the result of a; /// function, throwing an object, performing an explicit cast, or; /// initializing a parameter for which there is no declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:92,perform,performing,92,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['perform'],['performing']
Performance,"/// Create the loader, Module will be initialized in \p Context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:15,load,loader,15,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,1,['load'],['loader']
Performance,"/// CreateCoercedLoad - Create a load from \arg SrcPtr interpreted as; /// a pointer to an object of type \arg Ty, known to be aligned to; /// \arg SrcAlign bytes.; ///; /// This safely handles the case when the src type is smaller than the; /// destination type; in this situation the values of bits which not; /// present in the src are undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:33,load,load,33,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['load'],['load']
Performance,"/// CreateTempAlloca - This creates an alloca and inserts it into the entry; /// block if \p ArraySize is nullptr, otherwise inserts it at the current; /// insertion point of the builder. The caller is responsible for setting an; /// appropriate alignment on; /// the alloca.; ///; /// \p ArraySize is the number of array elements to be allocated if it; /// is not nullptr.; ///; /// LangAS::Default is the address space of pointers to local variables and; /// temporaries, as exposed in the source language. In certain; /// configurations, this is not the same as the alloca address space, and a; /// cast is needed to lift the pointer from the alloca AS into; /// LangAS::Default. This can happen when the target uses a restricted; /// address space for the stack but the source language requires; /// LangAS::Default to be a generic address space. The latter condition is; /// common for most programming languages; OpenCL is an exception in that; /// LangAS::Default is the private address space, which naturally maps; /// to the stack.; ///; /// Because the address of a temporary is often exposed to the program in; /// various ways, this function will perform the cast. The original alloca; /// instruction is returned through \p Alloca if it is not nullptr.; ///; /// The cast is not performaed in CreateTempAllocaWithoutCast. This is; /// more efficient if the caller knows that the address will not be exposed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:1159,perform,perform,1159,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,2,['perform'],"['perform', 'performaed']"
Performance,"/// Creates a FixedCompilationDatabase from the arguments after ""--"".; ///; /// Parses the given command line for ""--"". If ""--"" is found, the rest of; /// the arguments will make up the command line in the returned; /// FixedCompilationDatabase.; /// The arguments after ""--"" must not include positional parameters or the; /// argv[0] of the tool. Those will be added by the FixedCompilationDatabase; /// when a CompileCommand is requested. The argv[0] of the returned command; /// line will be ""clang-tool"".; ///; /// Returns NULL in case ""--"" is not found.; ///; /// The argument list is meant to be compatible with normal llvm command line; /// parsing in main methods.; /// int main(int argc, char **argv) {; /// std::unique_ptr<FixedCompilationDatabase> Compilations(; /// FixedCompilationDatabase::loadFromCommandLine(argc, argv));; /// cl::ParseCommandLineOptions(argc, argv);; /// ...; /// }; ///; /// \param Argc The number of command line arguments - will be changed to; /// the number of arguments before ""--"", if ""--"" was found in the argument; /// list.; /// \param Argv Points to the command line arguments.; /// \param ErrorMsg Contains error text if the function returns null pointer.; /// \param Directory The base directory used in the FixedCompilationDatabase.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:804,load,loadFromCommandLine,804,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,1,['load'],['loadFromCommandLine']
Performance,/// Creates a SymbolStringPtr for this entry *without* performing a retain; /// operation during construction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SymbolStringPool.h:55,perform,performing,55,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SymbolStringPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SymbolStringPool.h,1,['perform'],['performing']
Performance,"/// Creates a fresh flow condition and returns a token that identifies it. The; /// token can be used to perform various operations on the flow condition such; /// as adding constraints to it, forking it, joining it with another flow; /// condition, or checking implications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h:105,perform,perform,105,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h,1,['perform'],['perform']
Performance,/// Creates a new segment load command in the object and returns a reference; /// to the newly created load command. The caller should verify that SegName; /// is not too long (SegName.size() should be less than or equal to 16).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:26,load,load,26,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,2,['load'],['load']
Performance,/// Creates clause with a list of variables \a VL.; ///; /// \param C AST context.; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param EndLoc Ending location of the clause.; /// \param VL List of references to the variables.; /// \param SrcExprs List of helper expressions for proper generation of; /// assignment operation required for copyprivate clause. This list represents; /// sources.; /// \param DstExprs List of helper expressions for proper generation of; /// assignment operation required for copyprivate clause. This list represents; /// destinations.; /// \param AssignmentOps List of helper expressions that represents assignment; /// operation:; /// \code; /// DstExprs = SrcExprs;; /// \endcode; /// Required for proper codegen of final assignment performed by the; /// copyprivate clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:817,perform,performed,817,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,"/// Creates clause with a list of variables \a VL.; ///; /// \param C AST context.; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param EndLoc Ending location of the clause.; /// \param VL List of references to the variables.; /// \param SrcExprs List of helper expressions for proper generation of; /// assignment operation required for lastprivate clause. This list represents; /// private variables (for arrays, single array element).; /// \param DstExprs List of helper expressions for proper generation of; /// assignment operation required for lastprivate clause. This list represents; /// original variables (for arrays, single array element).; /// \param AssignmentOps List of helper expressions that represents assignment; /// operation:; /// \code; /// DstExprs = SrcExprs;; /// \endcode; /// Required for proper codegen of final assignment performed by the; /// lastprivate clause.; /// \param LPKind Lastprivate kind, e.g. 'conditional'.; /// \param LPKindLoc Location of the lastprivate kind.; /// \param ColonLoc Location of the ':' symbol if lastprivate kind is used.; /// \param PreInit Statement that must be executed before entering the OpenMP; /// region with this clause.; /// \param PostUpdate Expression that must be executed after exit from the; /// OpenMP region with this clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:903,perform,performed,903,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,"/// Creates clause with a list of variables \a VL.; ///; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param ColonLoc Location of ':'.; /// \param EndLoc Ending location of the clause.; /// \param VL The variables in the clause.; /// \param QualifierLoc The nested-name qualifier with location information; /// \param NameInfo The full name info for reduction identifier.; /// \param Privates List of helper expressions for proper generation of; /// private copies.; /// \param LHSExprs List of helper expressions for proper generation of; /// assignment operation required for copyprivate clause. This list represents; /// LHSs of the reduction expressions.; /// \param RHSExprs List of helper expressions for proper generation of; /// assignment operation required for copyprivate clause. This list represents; /// RHSs of the reduction expressions.; /// Also, variables in these expressions are used for proper initialization of; /// reduction copies.; /// \param ReductionOps List of helper expressions that represents reduction; /// expressions:; /// \code; /// LHSExprs binop RHSExprs;; /// operator binop(LHSExpr, RHSExpr);; /// <CutomReduction>(LHSExpr, RHSExpr);; /// \endcode; /// Required for proper codegen of final reduction operation performed by the; /// reduction clause.; /// \param PreInit Statement that must be executed before entering the OpenMP; /// region with this clause.; /// \param PostUpdate Expression that must be executed after exit from the; /// OpenMP region with this clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:1300,perform,performed,1300,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,"/// Creates clause with a list of variables \a VL.; ///; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param ColonLoc Location of ':'.; /// \param EndLoc Ending location of the clause.; /// \param VL The variables in the clause.; /// \param QualifierLoc The nested-name qualifier with location information; /// \param NameInfo The full name info for reduction identifier.; /// \param Privates List of helper expressions for proper generation of; /// private copies.; /// \param LHSExprs List of helper expressions for proper generation of; /// assignment operation required for copyprivate clause. This list represents; /// LHSs of the reduction expressions.; /// \param RHSExprs List of helper expressions for proper generation of; /// assignment operation required for copyprivate clause. This list represents; /// RHSs of the reduction expressions.; /// Also, variables in these expressions are used for proper initialization of; /// reduction copies.; /// \param ReductionOps List of helper expressions that represents reduction; /// expressions:; /// \code; /// LHSExprs binop RHSExprs;; /// operator binop(LHSExpr, RHSExpr);; /// <CutomReduction>(LHSExpr, RHSExpr);; /// \endcode; /// Required for proper codegen of final reduction operation performed by the; /// reduction clause.; /// \param TaskgroupDescriptors List of helper taskgroup descriptors for; /// corresponding items in parent taskgroup task_reduction clause.; /// \param PreInit Statement that must be executed before entering the OpenMP; /// region with this clause.; /// \param PostUpdate Expression that must be executed after exit from the; /// OpenMP region with this clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:1300,perform,performed,1300,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,"/// Creates clause with a list of variables \a VL.; ///; /// \param StartLoc Starting location of the clause.; /// \param LParenLoc Location of '('.; /// \param ModifierLoc Modifier location.; /// \param ColonLoc Location of ':'.; /// \param EndLoc Ending location of the clause.; /// \param VL The variables in the clause.; /// \param QualifierLoc The nested-name qualifier with location information; /// \param NameInfo The full name info for reduction identifier.; /// \param Privates List of helper expressions for proper generation of; /// private copies.; /// \param LHSExprs List of helper expressions for proper generation of; /// assignment operation required for copyprivate clause. This list represents; /// LHSs of the reduction expressions.; /// \param RHSExprs List of helper expressions for proper generation of; /// assignment operation required for copyprivate clause. This list represents; /// RHSs of the reduction expressions.; /// Also, variables in these expressions are used for proper initialization of; /// reduction copies.; /// \param ReductionOps List of helper expressions that represents reduction; /// expressions:; /// \code; /// LHSExprs binop RHSExprs;; /// operator binop(LHSExpr, RHSExpr);; /// <CutomReduction>(LHSExpr, RHSExpr);; /// \endcode; /// Required for proper codegen of final reduction operation performed by the; /// reduction clause.; /// \param CopyOps List of copy operations for inscan reductions:; /// \code; /// TempExprs = LHSExprs;; /// \endcode; /// \param CopyArrayTemps Temp arrays for prefix sums.; /// \param CopyArrayElems Temp arrays for prefix sums.; /// \param PreInit Statement that must be executed before entering the OpenMP; /// region with this clause.; /// \param PostUpdate Expression that must be executed after exit from the; /// OpenMP region with this clause.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:1343,perform,performed,1343,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['perform'],['performed']
Performance,/// Creates value range metadata on an workitemid.* intrinsic call or load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.h:70,load,load,70,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.h,1,['load'],['load']
Performance,"/// Current AA implementation, just a cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:38,cache,cache,38,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['cache'],['cache']
Performance,/// Current optimization remark emitter. Used to report failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h:12,optimiz,optimization,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,2,['optimiz'],['optimization']
Performance,/// Current optimization remark emitter.; /// Used to report things like combines and FastISel failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:12,optimiz,optimization,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,1,['optimiz'],['optimization']
Performance,/// Cursor - The primary query interface for the block interference cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:68,cache,cache,68,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,1,['cache'],['cache']
Performance,"/// Cursor associated with the lazy-loading of Metadata. This is the easy way; /// to keep around the right ""context"" (Abbrev list) to be able to jump in; /// the middle of the metadata block and load any record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:36,load,loading,36,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,2,['load'],"['load', 'loading']"
Performance,"/// Cursor position of the start of the global decl attachments, to enable; /// loading using the index built for lazy loading, instead of forward; /// references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:80,load,loading,80,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,2,['load'],['loading']
Performance,/// Custom lowers floating point to integer conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:146,load,load,146,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['load']
Performance,/// Custom lowers integer to floating point conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:146,load,load,146,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['load']
Performance,/// DLL can be relocated at load time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:28,load,load,28,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,1,['load'],['load']
Performance,"/// DWARFContextState; /// This structure contains all member variables for DWARFContext that need; /// to be protected in multi-threaded environments. Threading support can be; /// enabled by setting the ThreadSafe to true when constructing a; /// DWARFContext to allow DWARRContext to be able to be used in a; /// multi-threaded environment, or not enabled to allow for maximum; /// performance in single threaded environments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h:123,multi-thread,multi-threaded,123,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h,3,"['multi-thread', 'perform']","['multi-threaded', 'performance']"
Performance,/// Data cache line size for LoopDataPrefetch pass. Has no use before GFX12.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.h:9,cache,cache,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.h,1,['cache'],['cache']
Performance,"/// Data structure to hold cached (LLVM-IR) information.; ///; /// All attributes are given an InformationCache object at creation time to; /// avoid inspection of the IR by all of them individually. This default; /// InformationCache will hold information required by 'default' attributes,; /// thus the ones deduced when Attributor::identifyDefaultAbstractAttributes(..); /// is called.; ///; /// If custom abstract attributes, registered manually through; /// Attributor::registerAA(...), need more information, especially if it is not; /// reusable, it is advised to inherit from the InformationCache and cast the; /// instance down in the abstract attributes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:27,cache,cached,27,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['cache'],['cached']
Performance,"/// DataLayout for the target: keep ABI type size and alignment.; ///; /// The DataLayout is created based on the string representation provided; /// during construction. It is kept here only to avoid reparsing the string; /// but should not really be used during compilation, because it has an; /// internal cache that is context specific.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h:309,cache,cache,309,interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,1,['cache'],['cache']
Performance,/// Decide if @MI is a spill instruction and return true if it is. We use 2; /// criteria to make this decision:; /// - Is this instruction a store to a spill slot?; /// - Is there a register operand that is both used and killed?; /// TODO: Store optimization can fold spills into other stores (including; /// other spills). We do not handle this yet (more than one memory operand).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:247,optimiz,optimization,247,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,2,['optimiz'],['optimization']
Performance,"/// Decide whether we want to split a constant structure or array store into a; /// sequence of its fields' stores. This may cost us code size and compilation; /// speed, but plays better with store optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:199,optimiz,optimizations,199,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['optimiz'],['optimizations']
Performance,/// Declaration updates for already-loaded declarations that we need; /// to apply once we finish processing an import.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:36,load,loaded,36,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// Declarations that have already been loaded from the chain.; ///; /// When the pointer at index I is non-NULL, the declaration with ID; /// = I + 1 has already been loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:40,load,loaded,40,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,2,['load'],['loaded']
Performance,"/// Decode a VPPERM mask from a raw array of constants such as from; /// BUILD_VECTOR.; /// This can only basic masks (permutes + zeros), not any of the other; /// operations that VPPERM can perform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h:191,perform,perform,191,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86ShuffleDecode.h,1,['perform'],['perform']
Performance,"/// Dedicated, process-wide RDirectory.; ///; /// \note This is *not* thread-safe. You will need to syncronize yourself. In; /// general it's a bad idea to use a global collection in a multi-threaded; /// environment; ROOT itself does not make use of it. It is merely offered for; /// historical, process-wide object registration by name. Instead, pass a; /// pointer to the object where you need to access it - this is also much; /// faster than a lookup by name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RDirectory.hxx:185,multi-thread,multi-threaded,185,core/base/v7/inc/ROOT/RDirectory.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RDirectory.hxx,1,['multi-thread'],['multi-threaded']
Performance,"/// Deduce template arguments for a function template when there is; /// nothing to deduce against (C++0x [temp.arg.explicit]p3).; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicitly-specified template; /// arguments.; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param IsAddressOfFunction If \c true, we are deducing as part of taking; /// the address of a function template in a context where we do not have a; /// target type, per [over.over]. If \c false, we are looking up a function; /// template specialization based on its signature, which only happens when; /// deducing a function parameter type from an argument that is a template-id; /// naming a function template specialization.; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:203,perform,performing,203,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['perform'],['performing']
Performance,"/// Deduce template arguments when taking the address of a function; /// template (C++ [temp.deduct.funcaddr]) or matching a specialization to; /// a template.; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicitly-specified template; /// arguments.; ///; /// \param ArgFunctionType the function type that will be used as the; /// ""argument"" type (A) when performing template argument deduction from the; /// function template's function type. This type may be NULL, if there is no; /// argument type to compare against, in C++0x [temp.arg.explicit]p3.; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param IsAddressOfFunction If \c true, we are deducing as part of taking; /// the address of a function template per [temp.deduct.funcaddr] and; /// [over.over]. If \c false, we are looking up a function template; /// specialization based on its signature, per [temp.deduct.decl].; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:233,perform,performing,233,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,['perform'],['performing']
Performance,"/// Deduce the template arguments by comparing the parameter type and; /// the argument type (C++ [temp.deduct.type]).; ///; /// \param S the semantic analysis object within which we are deducing; ///; /// \param TemplateParams the template parameters that we are deducing; ///; /// \param P the parameter type; ///; /// \param A the argument type; ///; /// \param Info information about the template argument deduction itself; ///; /// \param Deduced the deduced template arguments; ///; /// \param TDF bitwise OR of the TemplateDeductionFlags bits that describe; /// how template argument deduction is performed.; ///; /// \param PartialOrdering Whether we're performing template argument deduction; /// in the context of partial ordering (C++0x [temp.deduct.partial]).; ///; /// \returns the result of template argument deduction so far. Note that a; /// ""success"" result means that template argument deduction has not yet failed,; /// but it may still fail, later, for other reasons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:604,perform,performed,604,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,['perform'],"['performed', 'performing']"
Performance,/// Deduced return type updates that have been loaded but not yet propagated; /// across the relevant redeclaration chain. The map key is the canonical; /// declaration and the value is the deduced return type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:47,load,loaded,47,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// DefMaxInstsToScan - the default number of maximum instructions; /// to scan in the block, used by FindAvailableLoadedValue().; /// FindAvailableLoadedValue() was introduced in r60148, to improve jump; /// threading in part by eliminating partially redundant loads.; /// At that point, the value of MaxInstsToScan was already set to '6'; /// without documented explanation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:262,load,loads,262,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['load'],['loads']
Performance,"/// Default I/O performance counters that get registered in `fMetrics`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:16,perform,performance,16,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['perform'],['performance']
Performance,"/// Default I/O performance counters that get registered in fMetrics",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:16,perform,performance,16,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['perform'],['performance']
Performance,"/// Default Load/Store Unit (LS Unit) for simulated processors.; ///; /// Each load (or store) consumes one entry in the load (or store) queue.; ///; /// Rules are:; /// 1) A younger load is allowed to pass an older load only if there are no; /// stores nor barriers in between the two loads.; /// 2) An younger store is not allowed to pass an older store.; /// 3) A younger store is not allowed to pass an older load.; /// 4) A younger load is allowed to pass an older store only if the load does; /// not alias with the store.; ///; /// This class optimistically assumes that loads don't alias store operations.; /// Under this assumption, younger loads are always allowed to pass older; /// stores (this would only affects rule 4).; /// Essentially, this class doesn't perform any sort alias analysis to; /// identify aliasing loads and stores.; ///; /// To enforce aliasing between loads and stores, flag `AssumeNoAlias` must be; /// set to `false` by the constructor of LSUnit.; ///; /// Note that this class doesn't know about the existence of different memory; /// types for memory operations (example: write-through, write-combining, etc.).; /// Derived classes are responsible for implementing that extra knowledge, and; /// provide different sets of rules for loads and stores by overriding method; /// `isReady()`.; /// To emulate a write-combining memory type, rule 2. must be relaxed in a; /// derived class to enable the reordering of non-aliasing store operations.; ///; /// No assumptions are made by this class on the size of the store buffer. This; /// class doesn't know how to identify cases where store-to-load forwarding may; /// occur.; ///; /// LSUnit doesn't attempt to predict whether a load or store hits or misses; /// the L1 cache. To be more specific, LSUnit doesn't know anything about; /// cache hierarchy and memory types.; /// It only knows if an instruction ""mayLoad"" and/or ""mayStore"". For loads, the; /// scheduling model provides an ""optimistic"" load-to-use laten",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:12,Load,Load,12,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,15,"['Load', 'load', 'perform', 'queue']","['Load', 'load', 'loads', 'perform', 'queue']"
Performance,/// Default constructor turns off all optimization flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:38,optimiz,optimization,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['optimiz'],['optimization']
Performance,/// Defined functions that are also known library functions which the; /// optimizer can reason about and therefore might introduce calls to out of; /// thin air.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:75,optimiz,optimizer,75,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['optimiz'],['optimizer']
Performance,/// Definitions for which we have added merged definitions but not yet; /// performed deduplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:76,perform,performed,76,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['perform'],['performed']
Performance,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists and finally get deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. When both DT and PDT are nullptrs, DelBB; /// will be queued until flush() is called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:247,queue,queued,247,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,2,['queue'],['queued']
Performance,"/// Delete DelBB. DelBB will be removed from its Parent and; /// erased from available trees if it exists. Then the callback will; /// be called. Finally, DelBB will be deleted.; /// Under Eager UpdateStrategy, DelBB will be processed immediately.; /// Under Lazy UpdateStrategy, DelBB will be queued until a flush event and; /// all available trees are up-to-date. Assert if any instruction of DelBB is; /// modified while awaiting deletion. Multiple callbacks can be queued for one; /// DelBB under Lazy UpdateStrategy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h:294,queue,queued,294,interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomTreeUpdater.h,2,['queue'],['queued']
Performance,"/// DeltaTree - a multiway search tree (BTree) structure with some fancy; /// features. B-Trees are generally more memory and cache efficient than; /// binary trees, because they store multiple keys/values in each node. This; /// implements a key/value mapping from index to delta, and allows fast lookup; /// on index. However, an added (important) bonus is that it can also; /// efficiently tell us the full accumulated delta for a specific file offset; /// as well, without traversing the whole tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Core/DeltaTree.h:126,cache,cache,126,interpreter/llvm-project/clang/include/clang/Rewrite/Core/DeltaTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Core/DeltaTree.h,1,['cache'],['cache']
Performance,/// Denormalize - Perform the inverse transform on the expression with the; /// given loop set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp:18,Perform,Perform,18,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolutionNormalization.cpp,1,['Perform'],['Perform']
Performance,"/// Depending on uarch and/or optimizing for size, we might prefer to use a; /// vector operation in place of the typical scalar operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:30,optimiz,optimizing,30,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['optimiz'],['optimizing']
Performance,/// Depth of optimized loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp:13,optimiz,optimized,13,interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CmovConversion.cpp,1,['optimiz'],['optimized']
Performance,/// Describes an exported module that has not yet been resolved; /// (perhaps because the module it refers to has not yet been loaded).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h:127,load,loaded,127,interpreter/llvm-project/clang/include/clang/Basic/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Module.h,1,['load'],['loaded']
Performance,"/// Describes the kind of initialization being performed, along with; /// location information for tokens related to the initialization (equal sign,; /// parentheses).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:47,perform,performed,47,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['perform'],['performed']
Performance,/// Describes the kind of lookup being performed. The lookup kind is passed to; /// symbol generators (if they're invoked) to help them determine what; /// definitions to generate.; ///; /// Static -- Lookup is being performed as-if at static link time (e.g.; /// generators representing static archives should pull in new; /// definitions).; ///; /// DLSym -- Lookup is being performed as-if at runtime (e.g. generators; /// representing static archives should not pull in new definitions).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:39,perform,performed,39,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,3,['perform'],['performed']
Performance,"/// Describes the kind of merge to perform for availability; /// attributes (including ""deprecated"", ""unavailable"", and ""availability"").",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:35,perform,perform,35,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['perform']
Performance,/// Describes the result of attempting to load a module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:42,load,load,42,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,1,['load'],['load']
Performance,/// Describes the result of the name lookup and resolution performed; /// by \c ClassifyName().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:59,perform,performed,59,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performed']
Performance,/// Describes what happened when we tried to load a module map file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:45,load,load,45,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['load'],['load']
Performance,/// Description of the task to be performed. Used for logging.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TaskDispatch.h:34,perform,performed,34,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TaskDispatch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/TaskDispatch.h,1,['perform'],['performed']
Performance,"/// Destroy a __strong variable.; ///; /// At -O0, emit a call to store 'null' into the address;; /// instrumenting tools prefer this because the address is exposed,; /// but it's relatively cumbersome to optimize.; ///; /// At -O1 and above, just load and call objc_release.; ///; /// call void \@objc_storeStrong(i8** %addr, i8* null)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:205,optimiz,optimize,205,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,2,"['load', 'optimiz']","['load', 'optimize']"
Performance,"/// Destroy the underlying value.; ///; /// This should get optimized down to a no-op. We could skip it if we could; /// add a static assert on \a std::is_trivially_copyable(), but we currently; /// support versions of GCC that don't understand that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:60,optimiz,optimized,60,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,1,['optimiz'],['optimized']
Performance,"/// Destruct this instance. If a multi-threaded instance, waits for all; /// compile threads to complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h:33,multi-thread,multi-threaded,33,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,1,['multi-thread'],['multi-threaded']
Performance,/// Detect 0-sample input profile and report to output stream. This interface; /// should be called after loadProfiles().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:106,load,loadProfiles,106,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['load'],['loadProfiles']
Performance,"/// Detect vector gather/scatter index generation and convert it from being a; /// bunch of shuffles and extracts into a somewhat faster sequence.; /// For i686, the best sequence is apparently storing the value and loading; /// scalars back, while for x64 we should use 64-bit extracts and shifts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:216,load,loading,216,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['loading']
Performance,/// Determine if it is possible to modify the \p RHS and predicate \p P of a; /// G_ICMP instruction such that the right-hand side is an arithmetic immediate.; ///; /// \returns A pair containing the updated immediate and predicate which may; /// be used to optimize the instruction.; ///; /// \note This assumes that the comparison has been legalized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp:258,optimiz,optimize,258,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerLowering.cpp,1,['optimiz'],['optimize']
Performance,/// Determine if the call should not perform indirect branch tracking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:37,perform,perform,37,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['perform'],['perform']
Performance,/// Determine if the function should not perform indirect branch tracking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:41,perform,perform,41,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['perform'],['perform']
Performance,/// Determine if the value maintained in the given global variable can be; /// tracked interprocedurally. A value can be tracked if the global variable; /// has local linkage and is only used by non-volatile loads and stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h:208,load,loads,208,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,1,['load'],['loads']
Performance,"/// Determine if two fusion candidates have the same trip count (i.e., they; /// execute the same number of iterations).; ///; /// This function will return a pair of values. The first is a boolean,; /// stating whether or not the two candidates are known at compile time to; /// have the same TripCount. The second is the difference in the two; /// TripCounts. This information can be used later to determine whether or not; /// peeling can be performed on either one of the candidates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:445,perform,performed,445,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['perform'],['performed']
Performance,/// Determine if we are performing code completion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:24,perform,performing,24,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['perform'],['performing']
Performance,/// Determine if we need to exit the instruction replacement optimization; /// passes early. This makes sure that no compile time is spent in this pass; /// for targets with no need for any of these optimizations.; /// Return true if early exit of the pass is recommended.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:61,optimiz,optimization,61,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,2,['optimiz'],"['optimization', 'optimizations']"
Performance,/// Determine if we need to exit this pass for a kind of instruction replacement; /// early. This makes sure that no compile time is spent in this pass for; /// targets with no need for any of these optimizations beyond performing this; /// check.; /// Return true if early exit of this pass for a kind of instruction; /// replacement is recommended for a target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:199,optimiz,optimizations,199,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,2,"['optimiz', 'perform']","['optimizations', 'performing']"
Performance,"/// Determine the degree of POD-ness for an expression.; /// Incomplete types are considered POD, since this check can be performed; /// when we're in an unevaluated context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:122,perform,performed,122,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['perform'],['performed']
Performance,/// Determine the kind of rewrite that should be performed for this; /// candidate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:49,perform,performed,49,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['perform'],['performed']
Performance,/// Determine the kind of template substitution being performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h:54,perform,performed,54,interpreter/llvm-project/clang/include/clang/Sema/Template.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h,1,['perform'],['performed']
Performance,/// Determine the number of preprocessed entities that were; /// loaded (or can be loaded) from an external source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:65,load,loaded,65,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,2,['load'],['loaded']
Performance,/// Determine the range for a particular SCEV.; /// NOTE: This returns a reference to an entry in a cache. It must be; /// copied if its needed for longer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:100,cache,cache,100,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['cache'],['cache']
Performance,/// Determine what action should be taken to legalize the described; /// instruction. Requires computeTables to have been called.; ///; /// \returns a description of the next legalization step to perform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:196,perform,perform,196,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['perform'],['perform']
Performance,"/// Determine what action should be taken to legalize the given generic; /// instruction opcode, type-index and type. Requires computeTables to have; /// been called.; ///; /// \returns a pair consisting of the kind of legalization that should be; /// performed and the destination type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h:252,perform,performed,252,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h,1,['perform'],['performed']
Performance,/// Determine what action should be taken to legalize the given generic; /// instruction.; ///; /// \returns a description of the next legalization step to perform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:156,perform,perform,156,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['perform'],['perform']
Performance,"/// Determine whether a call to an unprototyped functions under; /// the given calling convention should use the variadic; /// convention or the non-variadic convention.; ///; /// There's a good reason to make a platform's variadic calling; /// convention be different from its non-variadic calling; /// convention: the non-variadic arguments can be passed in; /// registers (better for performance), and the variadic arguments; /// can be passed on the stack (also better for performance). If; /// this is done, however, unprototyped functions *must* use the; /// non-variadic convention, because C99 states that a call; /// through an unprototyped function type must succeed if the; /// function was defined with a non-variadic prototype with; /// compatible parameters. Therefore, splitting the conventions; /// makes it impossible to call a variadic function through an; /// unprototyped type. Since function prototypes came out in the; /// late 1970s, this is probably an acceptable trade-off.; /// Nonetheless, not all platforms are willing to make it, and in; /// particularly x86-64 bends over backwards to make the; /// conventions compatible.; ///; /// The default is false. This is correct whenever:; /// - the conventions are exactly the same, because it does not; /// matter and the resulting IR will be somewhat prettier in; /// certain cases; or; /// - the conventions are substantively different in how they pass; /// arguments, because in this case using the variadic convention; /// will lead to C99 violations.; ///; /// However, some platforms make the conventions identical except; /// for passing additional out-of-band information to a variadic; /// function: for example, x86-64 passes the number of SSE; /// arguments in %al. On these platforms, it is desirable to; /// call unprototyped functions using the variadic convention so; /// that unprototyped calls to varargs functions still succeed.; ///; /// Relatedly, platforms which pass the fixed arguments to this:; /// A fo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h:387,perform,performance,387,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,2,['perform'],['performance']
Performance,"/// Determine whether a lookup table should be built for this switch, based on; /// the number of cases, size of the table, and the types of the results.; // TODO: We could support larger than legal types by limiting based on the; // number of loads required and/or table size. If the constants are small we; // could use smaller table entries and extend after the load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:244,load,loads,244,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,['load'],"['load', 'loads']"
Performance,"/// Determine whether a variable is extern ""C"" prior to attaching; /// an initializer. We can't just call isExternC() here, because that; /// will also compute and cache whether the declaration is externally; /// visible, which might change when we attach the initializer.; ///; /// This can only be used if the declaration is known to not be a; /// redeclaration of an internal linkage declaration.; ///; /// For instance:; ///; /// auto x = []{};; ///; /// Attaching the initializer here makes this declaration not externally; /// visible, because its type has internal linkage.; ///; /// FIXME: This is a hack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:164,cache,cache,164,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['cache'],['cache']
Performance,"/// Determine whether any of the given template arguments are dependent.; ///; /// The converted arguments should be supplied when known; whether an; /// argument is dependent can depend on the conversions performed on it; /// (for example, a 'const int' passed as a template argument might be; /// dependent if the parameter is a reference but non-dependent if the; /// parameter is an int).; ///; /// Note that the \p Args parameter is unused: this is intentional, to remind; /// the caller that they need to pass in the converted arguments, not the; /// specified arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:206,perform,performed,206,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['perform'],['performed']
Performance,/// Determine whether input can be interpreted as TAPI text file.; /// This allows one to exit early when file is not recognized as TAPI file; /// as opposed to `get` which attempts to full parse and load of library; /// attributes.; ///; /// \param InputBuffer Buffer holding contents of TAPI text file.; /// \return The file format version of TAPI text file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/TextAPIReader.h:200,load,load,200,interpreter/llvm-project/llvm/include/llvm/TextAPI/TextAPIReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/TextAPIReader.h,1,['load'],['load']
Performance,"/// Determine whether the callee-saved register saves and restores should; /// be generated via inline code. If this function returns ""true"", inline; /// code will be generated. If this function returns ""false"", additional; /// checks are performed, which may still lead to the inline code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:239,perform,performed,239,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['perform'],['performed']
Performance,/// Determine whether the frontend token information for this; /// identifier has changed since it was loaded from an AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:103,load,loaded,103,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['load'],['loaded']
Performance,/// Determine whether the given AST file is acceptable to load into a; /// translation unit with the given language and target options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:58,load,load,58,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['load']
Performance,/// Determine whether there is an existing expansion of S that can be reused.; /// This is used to check whether S can be expanded cheaply.; ///; /// L is a hint which tells in which loop to look for the suitable value.; ///; /// Note that this function does not perform an exhaustive search. I.e if it; /// didn't find any value it does not mean that there is no such value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:263,perform,perform,263,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,1,['perform'],['perform']
Performance,/// Determine whether this TargetInfo supports tune in target attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:47,tune,tune,47,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['tune'],['tune']
Performance,"/// Determine whether this class has a member with the given name, possibly; /// in a non-dependent base class.; ///; /// No check for ambiguity is performed, so this should never be used when; /// implementing language semantics, but it may be appropriate for warnings,; /// static analysis, or similar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:148,perform,performed,148,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['perform'],['performed']
Performance,/// Determine whether this cleanup should be performed at the end of the; /// given kind of scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:45,perform,performed,45,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['perform'],['performed']
Performance,"/// Determine whether this dictionary literal has any pack expansions.; ///; /// If the dictionary literal has pack expansions, then there will; /// be an array of pack expansion data following the array of; /// key/value pairs, which provide the locations of the ellipses (if; /// any) and number of elements in the expansion (if known). If; /// there are no pack expansions, we optimize away this storage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:380,optimiz,optimize,380,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,1,['optimiz'],['optimize']
Performance,/// Determine whether this identifier has changed since it was loaded; /// from an AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:63,load,loaded,63,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['load'],['loaded']
Performance,"/// Determine whether this initialization allows the named return; /// value optimization, which also applies to thrown objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:77,optimiz,optimization,77,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['optimiz'],['optimization']
Performance,"/// Determine whether this is an Objective-C writeback conversion,; /// used for parameter passing when performing automatic reference counting.; ///; /// \param FromType The type we're converting form.; ///; /// \param ToType The type we're converting to.; ///; /// \param ConvertedType The type that will be produced after applying; /// this conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:104,perform,performing,104,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['perform'],['performing']
Performance,"/// Determine whether this local variable can be used with the named; /// return value optimization (NRVO).; ///; /// The named return value optimization (NRVO) works by marking certain; /// non-volatile local variables of class type as NRVO objects. These; /// locals can be allocated within the return slot of their containing; /// function, in which case there is no need to copy the object to the; /// return slot when returning from the function. Within the function body,; /// each return that returns the NRVO object will have this variable as its; /// NRVO candidate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:87,optimiz,optimization,87,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,2,['optimiz'],['optimization']
Performance,/// Determine whether this scope is some OpenMP directive with; /// order clause which specifies concurrent scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Scope.h:97,concurren,concurrent,97,interpreter/llvm-project/clang/include/clang/Sema/Scope.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Scope.h,1,['concurren'],['concurrent']
Performance,/// Determine whether we are currently performing template instantiation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:39,perform,performing,39,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,/// Determine whether we can perform aggregate initialization for the purposes; /// of overload resolution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:29,perform,perform,29,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['perform']
Performance,/// Determine whether we can perform an elementwise array copy for this kind; /// of entity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:29,perform,perform,29,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['perform']
Performance,"/// Determine whether we tried to load the global index, but failed,; /// e.g., because it is out-of-date or does not exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:34,load,load,34,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['load']
Performance,"/// Determine which bits of V are known to be either zero or one and return; /// them in the Known bit set.; ///; /// NOTE: we cannot consider 'undef' to be ""IsZero"" here. The problem is that; /// we cannot optimize based on the assumption that it is zero without changing; /// it to be an explicit zero. If we don't change it to zero, other code could; /// optimized based on the contradictory assumption that it is non-zero.; /// Because instcombine aggressively folds operations with undef args anyway,; /// this won't lose us code quality.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the demanded elements in the vector specified by DemandedElts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:207,optimiz,optimize,207,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,2,['optimiz'],"['optimize', 'optimized']"
Performance,"/// Determine which floating-point classes are valid for \p V, and return them; /// in KnownFPClass bit sets.; ///; /// This function is defined on values with floating-point type, values vectors; /// of floating-point type, and arrays of floating-point type.; /// \p InterestedClasses is a compile time optimization hint for which floating; /// point classes should be queried. Queries not specified in \p; /// InterestedClasses should be reliable if they are determined during the; /// query.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:304,optimiz,optimization,304,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['optimiz'],['optimization']
Performance,/// Determine which kind of bridge is being performed via this cast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:44,perform,performed,44,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,1,['perform'],['performed']
Performance,"/// Determines if we can perform a correct type check for \p D as a; /// redeclaration of \p PrevDecl. If not, we can generally still perform a; /// best-effort check.; ///; /// \param NewD The new declaration.; /// \param OldD The old declaration.; /// \param NewT The portion of the type of the new declaration to check.; /// \param OldT The portion of the type of the old declaration to check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,perform,perform,25,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['perform'],['perform']
Performance,"/// Determines the lookups to perform, as well as their order. See; /// \c RedirectKind for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h:30,perform,perform,30,interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/VirtualFileSystem.h,1,['perform'],['perform']
Performance,/// Determines the optimal series of memory ops to replace the memset / memcpy.; /// Return true if the number of memory ops is below the threshold (Limit).; /// Note that this is always the case when Limit is ~0.; /// It returns the types of the sequence of memory ops to perform; /// memset / memcpy by reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:273,perform,perform,273,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['perform']
Performance,"/// Determines the order of a source location and a source location; /// offset in the ""source location address space"".; ///; /// Note that we always consider source locations loaded from",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:176,load,loaded,176,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,/// Determines the supported types of records that could be seen in XRay traces.; /// This may or may not correspond to actual record types in the raw trace (as; /// the loader implementation may synthesize this information in the process of; /// of loading).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h:170,load,loader,170,interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/XRayRecord.h,2,['load'],"['loader', 'loading']"
Performance,/// Determines whether the module failed to load due to a configuration; /// mismatch with an explicitly-named .pcm file from the command line.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:44,load,load,44,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,1,['load'],['load']
Performance,"/// Determines whether the module, which failed to load, was; /// actually a submodule that we expected to see (based on implying the; /// submodule from header structure), but didn't materialize in the actual; /// module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:51,load,load,51,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,1,['load'],['load']
Performance,"/// Determines whether there is a user-defined conversion sequence; /// (C++ [over.ics.user]) that converts expression From to the type; /// ToType. If such a conversion exists, User will contain the; /// user-defined conversion sequence that performs such a conversion; /// and this routine will return true. Otherwise, this routine returns; /// false and User is unspecified.; ///; /// \param AllowExplicit true if the conversion should consider C++0x; /// ""explicit"" conversion functions as well as non-explicit conversion; /// functions (C++0x [class.conv.fct]p2).; ///; /// \param AllowObjCConversionOnExplicit true if the conversion should; /// allow an extra Objective-C pointer conversion on uses of explicit; /// constructors. Requires \c AllowExplicit to also be set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:243,perform,performs,243,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['perform'],['performs']
Performance,"/// Determines whether this is a normal return, whether or not loading the; /// module was successful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:63,load,loading,63,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,1,['load'],['loading']
Performance,"/// Diag - If this is non-null, it will be filled in with a stack of notes; /// indicating why evaluation failed (or why it failed to produce a constant; /// expression).; /// If the expression is unfoldable, the notes will indicate why it's not; /// foldable. If the expression is foldable, but not a constant expression,; /// the notes will describes why it isn't a constant expression. If the; /// expression *is* a constant expression, no notes will be produced.; ///; /// FIXME: this causes significant performance concerns and should be; /// refactored at some point. Not all evaluations of the constant; /// expression interpreter will display the given diagnostics, this means; /// those kinds of uses are paying the expense of generating a diagnostic; /// (which may include expensive operations like converting APValue objects; /// to a string representation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:508,perform,performance,508,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['perform'],['performance']
Performance,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:177,perform,performing,177,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['perform'],['performing']
Performance,/// Diagnostic information for applied optimization remarks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:39,optimiz,optimization,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,2,['optimiz'],['optimization']
Performance,/// Diagnostic information for missed-optimization remarks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:38,optimiz,optimization,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,2,['optimiz'],['optimization']
Performance,/// Diagnostic information for optimization analysis remarks related to; /// floating-point non-commutativity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:31,optimiz,optimization,31,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,/// Diagnostic information for optimization analysis remarks related to; /// pointer aliasing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:31,optimiz,optimization,31,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,/// Diagnostic information for optimization analysis remarks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:31,optimiz,optimization,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,2,['optimiz'],['optimization']
Performance,/// Diagnostic information for optimization failures.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:31,optimiz,optimization,31,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,/// Diagnostics produced while performing code completion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp:31,perform,performing,31,interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexCodeCompletion.cpp,1,['perform'],['performing']
Performance,"/// Direct I/O requires that all buffers and write lengths are aligned. It seems 512 byte alignment is the minimum; /// for Direct I/O to work, but further testing showed that it results in worse performance than 4kB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:196,perform,performance,196,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,1,['perform'],['performance']
Performance,"/// Directives should contain the description on how to compile and link a; /// shared lib. This description can be any valid shell command, including; /// the use of ';' to separate several instructions. However, shell specific; /// construct should be avoided. In particular this description can contain; /// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).; /// ~~~ {.cpp}; /// Five special variables will be expanded before execution:; /// Variable name Expands to; /// ------------- ----------; /// $SourceFiles Name of source files to be compiled; /// $SharedLib Name of the shared library being created; /// $LibName Name of shared library without extension; /// $BuildDir Directory where the files will be created; /// $IncludePath value of fIncludePath; /// $LinkedLibs value of fLinkedLibs; /// $DepLibs libraries on which this library depends on; /// $ObjectFiles Name of source files to be compiler with; /// their extension changed to .o or .obj; /// $Opt location of the optimization/debug options; /// set fFlagsDebug and fFlagsOpt; /// ~~~; /// e.g.:; /// ~~~ {.cpp}; /// gSystem->SetMakeSharedLib(; /// ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; /// --no_exceptions --signed_chars --display_error_number; /// --diag_suppress 68 -o $SharedLib"");; ///; /// gSystem->setMakeSharedLib(; /// ""Cxx $IncludePath -c $SourceFile;; /// ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; /// \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; /// -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc""; ///; /// gSystem->SetMakeSharedLib(; /// ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; /// -shared -o $SharedLib"");; ///; /// gSystem->SetMakeSharedLib(; /// ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN32; /// -D_WINDOWS $IncludePath $SourceFile; /// /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLOGO; /// $LinkedLibs -entry:_DllMainCRTStartup@12 -dll /out:$SharedLib""); /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:1082,optimiz,optimization,1082,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['optimiz'],['optimization']
Performance,"/// Disable all caches for sub-branches in an expression tree.; /// This is helpful when an expression with cached sub-branches needs to be integrated numerically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/res/RooFitImplHelpers.h:16,cache,caches,16,roofit/roofitcore/res/RooFitImplHelpers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/res/RooFitImplHelpers.h,2,['cache'],"['cached', 'caches']"
Performance,"/// Disable as many optimizations as possible. This doesn't completely; /// disable the optimizer in all cases, for example always_inline functions; /// can be required to be inlined for correctness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:20,optimiz,optimizations,20,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,2,['optimiz'],"['optimizations', 'optimizer']"
Performance,"/// Disable entirely the optimizer, including importing for ThinLTO",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:25,optimiz,optimizer,25,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['optimiz'],['optimizer']
Performance,"/// Disable normalizing; /// select(N0&N1, X, Y) => select(N0, select(N1, X, Y), Y) and; /// select(N0|N1, X, Y) => select(N0, select(N1, X, Y, Y)); /// RISC-V doesn't have flags so it's better to perform the and/or in a GPR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:197,perform,perform,197,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['perform'],['perform']
Performance,/// Disable tail call on x86-64. The epilogue code before the tail jump blocks; /// autoreleaseRV/retainRV and autoreleaseRV/unsafeClaimRV optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:139,optimiz,optimizations,139,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['optimiz'],['optimizations']
Performance,/// Disable the behavior of expanding expressions in canonical form rather; /// than in a more literal form. Non-canonical mode is useful for late; /// optimization passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:152,optimiz,optimization,152,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,1,['optimiz'],['optimization']
Performance,/// Disable the select optimization pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:23,optimiz,optimization,23,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['optimiz'],['optimization']
Performance,/// DisableFramePointerElim - This returns true if frame pointer elimination; /// optimization should be disabled for the given machine function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:82,optimiz,optimization,82,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,2,['optimiz'],['optimization']
Performance,/// Disables vectorization with scalable vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:32,scalab,scalable,32,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['scalab'],['scalable']
Performance,"/// Disconnect an edge from the given node.; ///; /// Removes the given edge from the adjacency list of the given node.; /// This operation leaves the edge in an 'asymmetric' state: It will no; /// longer appear in an iteration over the given node's (NId's) edges, but; /// will appear in an iteration over the 'other', unnamed node's edges.; ///; /// This does not correspond to any normal graph operation, but exists to; /// support efficient PBQP graph-reduction based solvers. It is used to; /// 'effectively' remove the unnamed node from the graph while the solver; /// is performing the reduction. The solver will later call reconnectNode; /// to restore the edge in the named node's adjacency list.; ///; /// Since the degree of a node is the number of connected edges,; /// disconnecting an edge from a node 'u' will cause the degree of 'u' to; /// drop by 1.; ///; /// A disconnected edge WILL still appear in an iteration over the graph; /// edges.; ///; /// A disconnected edge should not be removed from the graph, it should be; /// reconnected first.; ///; /// A disconnected edge can be reconnected by calling the reconnectEdge; /// method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h:578,perform,performing,578,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,1,['perform'],['performing']
Performance,/// Do not merge vector stores after legalization because that may conflict; /// with x86-specific store splitting optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:115,optimiz,optimizations,115,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['optimiz'],['optimizations']
Performance,/// Do not optimize this function (-O0).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:11,optimiz,optimize,11,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['optimiz'],['optimize']
Performance,"/// Do not perform checks in case of copy/move construct/assign, because the; /// checks have been performed when building `Other`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Alignment.h:11,perform,perform,11,interpreter/llvm-project/llvm/include/llvm/Support/Alignment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Alignment.h,4,['perform'],"['perform', 'performed']"
Performance,"/// Do not set GLC for RMW atomic operations as L0/L1 cache is automatically; /// bypassed, and the GLC bit is instead used to indicate if they are; /// return or no-return.; /// Note: there is no L2 cache coherent bypass control at the ISA level.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:54,cache,cache,54,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,2,['cache'],['cache']
Performance,"/// Do not set glc for RMW atomic operations as they implicitly bypass; /// the L1 cache, and the glc bit is instead used to indicate if they are; /// return or no-return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:83,cache,cache,83,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['cache'],['cache']
Performance,/// Do not set glc for store atomic operations as they implicitly write; /// through the L1 cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:92,cache,cache,92,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['cache'],['cache']
Performance,"/// Do semantic checks to allow the complete destructor variant to be emitted; /// when the destructor is defined in another translation unit. In the Itanium; /// C++ ABI, destructor variants are emitted together. In the MS C++ ABI, they; /// can be emitted in separate TUs. To emit the complete variant, run a subset; /// of the checks performed when emitting a regular destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:337,perform,performed,337,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performed']
Performance,"/// Do we have an efficient pattern in a .td file for this node?; ///; /// \param V - pointer to the BuildVectorSDNode being matched; /// \param HasDirectMove - does this subtarget have VSR <-> GPR direct moves?; ///; /// There are some patterns where it is beneficial to keep a BUILD_VECTOR; /// node as a BUILD_VECTOR node rather than expanding it. The patterns where; /// the opposite is true (expansion is beneficial) are:; /// - The node builds a vector out of integers that are not 32 or 64-bits; /// - The node builds a vector out of constants; /// - The node is a ""load-and-splat""; /// In all other cases, we will choose to keep the BUILD_VECTOR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:573,load,load-and-splat,573,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['load-and-splat']
Performance,/// Do we have an optimized use?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:18,optimiz,optimized,18,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['optimiz'],['optimized']
Performance,/// Do we need to gather this sequence or vectorize it; /// (either with vector instruction or with scatter/gather; /// intrinsics for store/load)?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:141,load,load,141,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['load']
Performance,"/// DoPromotion - This method actually performs the promotion of the specified; /// arguments, and returns the new function. At this point, we know that it's; /// safe to do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:39,perform,performs,39,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['perform'],['performs']
Performance,/// Does this node represent a load/store node whose address can be represented; /// with a register plus an immediate that's a multiple of \p Val:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:31,load,load,31,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['load'],['load']
Performance,"/// Does this runtime provide the objc_alloc_init entrypoint? This can apply; /// the same optimization as objc_alloc, but also sends an -init message,; /// reducing code size on the caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h:91,optimiz,optimization,91,interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,1,['optimiz'],['optimization']
Performance,/// Does this runtime supports optimized setter entrypoints?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h:31,optimiz,optimized,31,interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,1,['optimiz'],['optimized']
Performance,"/// Drop the very first edge in a path, which should be a function entry edge.; ///; /// If the first edge is not a function entry edge (say, because the first; /// statement had an invalid source location), this function does nothing.; // FIXME: We should just generate invalid edges anyway and have the optimizer; // deal with them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:305,optimiz,optimizer,305,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['optimiz'],['optimizer']
Performance,"/// Dummy constructor which needs model loading afterwards",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RSofieReader.hxx:40,load,loading,40,tmva/tmva/inc/TMVA/RSofieReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RSofieReader.hxx,1,['load'],['loading']
Performance,/// Dump the UUID load command.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:18,load,load,18,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,1,['load'],['load']
Performance,"/// During operand reordering, we are trying to select the operand at lane; /// that matches best with the operand at the neighboring lane. Our; /// selection is based on the type of value we are looking for. For example,; /// if the neighboring lane has a load, we need to look for a load that is; /// accessing a consecutive address. These strategies are summarized in the; /// 'ReorderingMode' enumerator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:257,load,load,257,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['load'],['load']
Performance,"/// During the expansion of a RecordType, an incomplete TypeString is placed; /// into the cache as a means to identify and break recursion.; /// If there is a Recursive encoding in the cache, it is swapped out and will; /// be reinserted by removeIncomplete().; /// All other types of encoding should have been used rather than arriving here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:91,cache,cache,91,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,2,['cache'],['cache']
Performance,/// DwarfLLVMRegPair - Emitted by tablegen so Dwarf<->LLVM reg mappings can be; /// performed with a binary search.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h:84,perform,performed,84,interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCRegisterInfo.h,1,['perform'],['performed']
Performance,"/// Dynamic (non-constant condition) vector blend where only the sign bits; /// of the condition elements are used. This is used to enforce that the; /// condition mask is not valid for generic VSELECT optimizations. This; /// is also used to implement the intrinsics.; /// Operands are in VSELECT order: MASK, TRUE, FALSE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:202,optimiz,optimizations,202,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['optimiz'],['optimizations']
Performance,"/// Dynamic loader prefix, if present",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:12,load,loader,12,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['load'],['loader']
Performance,"/// Dynamically load a library and throw exception in case of failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/Initialisation.cxx:16,load,load,16,roofit/batchcompute/src/Initialisation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/Initialisation.cxx,1,['load'],['load']
Performance,"/// EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR.; /// Let the result type be T, then IDX represents the starting element number; /// from which a subvector of type T is extracted. IDX must be a constant; /// multiple of T's known minimum vector length. If T is a scalable vector,; /// IDX is first scaled by the runtime scaling factor of T. Elements IDX; /// through (IDX + num_elements(T) - 1) must be valid VECTOR indices. If this; /// condition cannot be determined statically but is false at runtime, then; /// the result vector is undefined. The IDX parameter must be a vector index; /// constant type, which for most targets will be an integer pointer type.; ///; /// This operation supports extracting a fixed-width vector from a scalable; /// vector, but not the other way around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:284,scalab,scalable,284,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,['scalab'],['scalable']
Performance,"/// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR; /// identified by the (potentially variable) element number IDX. If the return; /// type is an integer type larger than the element type of the vector, the; /// result is extended to the width of the return type. In that case, the high; /// bits are undefined.; ///; /// If VECTOR is a scalable vector, then IDX may be larger than the minimum; /// vector width. IDX is not first scaled by the runtime scaling factor of; /// VECTOR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:362,scalab,scalable,362,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['scalab'],['scalable']
Performance,/// Each OpenCL kernel has nine implicit parameters that are stored in the; /// first nine dwords of a Vertex Buffer. These implicit parameters are; /// lowered to load instructions which retrieve the values from the Vertex; /// Buffer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.h:164,load,load,164,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.h,1,['load'],['load']
Performance,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in the direction of movement, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:54,queue,queues,54,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['queue'],['queues']
Performance,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in whichever direction at has moved, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:54,queue,queues,54,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,1,['queue'],['queues']
Performance,/// EarlyIfConverter - This pass performs if-conversion on SSA form by; /// inserting cmov instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:33,perform,performs,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,/// EarlyIfPredicator - This pass performs if-conversion on SSA form by; /// predicating if/else block and insert select at the join point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:34,perform,performs,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,"/// Efficiently stores a list of ExplodedNodes, or an optional flag.; ///; /// NodeGroup provides opaque storage for a list of ExplodedNodes, optimizing; /// for the case when there is only one node in the group. This is a fairly; /// common case in an ExplodedGraph, where most nodes have only one; /// predecessor and many have only one successor. It can also be used to; /// store a flag rather than a node list, which ExplodedNode uses to mark; /// whether a node is a sink. If the flag is set, the group is implicitly; /// empty and no nodes may be added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h:142,optimiz,optimizing,142,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,1,['optimiz'],['optimizing']
Performance,"/// Either set all the counters in the instr profile entry \p IFE to; /// -1 / -2 /in order to drop the profile or scale up the; /// counters in \p IFP to be above hot / cold threshold. We use; /// the ratio of zero counters in the profile of a function to; /// decide the profile is helpful or harmful for performance,; /// and to choose whether to scale up or drop it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:307,perform,performance,307,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['perform'],['performance']
Performance,"/// Eliminates partially redundant \p Load, replacing it with \p; /// AvailableLoads (connected by Phis if needed).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:38,Load,Load,38,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,1,['Load'],['Load']
Performance,"/// Emit a ""vtable"" message send. We emit a weak hidden-visibility; /// struct, initially containing the selector pointer and a pointer to; /// a ""fixup"" variant of the appropriate objc_msgSend. To call, we; /// load and call the function pointer, passing the address of the; /// struct as the second parameter. The runtime determines whether; /// the selector is currently emitted using vtable dispatch; if so, it; /// substitutes a stub function which simply tail-calls through the; /// appropriate vtable slot, and if not, it substitues a stub function; /// which tail-calls objc_msgSend. Both stubs adjust the selector; /// argument to correctly point to the selector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:212,load,load,212,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['load'],['load']
Performance,/// Emit a Linker Optimization Hint (LOH) directive.; /// \param Args - Arguments of the LOH.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:18,Optimiz,Optimization,18,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['Optimiz'],['Optimization']
Performance,"/// Emit a TB(N)Z instruction which tests \p Bit in \p TestReg.; /// \p IsNegative is true if the test should be ""not zero"".; /// This will also optimize the test bit instruction when possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:145,optimiz,optimize,145,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['optimiz'],['optimize']
Performance,"/// Emit a _bittest* intrinsic. These intrinsics take a pointer to an array of; /// bits and a bit position and read and optionally modify the bit at that; /// position. The position index can be arbitrarily large, i.e. it can be larger; /// than 31 or 63, so we need an indexed load in the general case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:279,load,load,279,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['load'],['load']
Performance,/// Emit a branch to select whether or not to perform guarded initialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:46,perform,perform,46,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['perform'],['perform']
Performance,/// Emit a code for initialization of threadprivate variable. It emits; /// a call to runtime library which adds initial value to the newly created; /// threadprivate variable (if it is not constant) and registers destructor; /// for the variable (if any).; /// \param VD Threadprivate variable.; /// \param VDAddr Address of the global variable \a VD.; /// \param Loc Location of threadprivate declaration.; /// \param PerformInit true if initialization expression is not constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:420,Perform,PerformInit,420,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,2,['Perform'],['PerformInit']
Performance,"/// Emit a code for reduction clause. Next code should be emitted for; /// reduction:; /// \code; ///; /// static kmp_critical_name lock = { 0 };; ///; /// void reduce_func(void *lhs[<n>], void *rhs[<n>]) {; /// ...; /// *(Type<i>*)lhs[i] = RedOp<i>(*(Type<i>*)lhs[i], *(Type<i>*)rhs[i]);; /// ...; /// }; ///; /// ...; /// void *RedList[<n>] = {&<RHSExprs>[0], ..., &<RHSExprs>[<n>-1]};; /// switch (__kmpc_reduce{_nowait}(<loc>, <gtid>, <n>, sizeof(RedList),; /// RedList, reduce_func, &<lock>)) {; /// case 1:; /// ...; /// <LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]);; /// ...; /// __kmpc_end_reduce{_nowait}(<loc>, <gtid>, &<lock>);; /// break;; /// case 2:; /// ...; /// Atomic(<LHSExprs>[i] = RedOp<i>(*<LHSExprs>[i], *<RHSExprs>[i]));; /// ...; /// break;; /// default:;; /// }; /// \endcode; ///; /// \param Privates List of private copies for original reduction arguments.; /// \param LHSExprs List of LHS in \a ReductionOps reduction operations.; /// \param RHSExprs List of RHS in \a ReductionOps reduction operations.; /// \param ReductionOps List of reduction operations in form 'LHS binop RHS'; /// or 'operator binop(LHS, RHS)'.; /// \param Options List of options for reduction codegen:; /// WithNowait true if parent directive has also nowait clause, false; /// otherwise.; /// SimpleReduction Emit reduction operation only. Used for omp simd; /// directive on the host.; /// ReductionKind The kind of reduction to perform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:1446,perform,perform,1446,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,2,['perform'],['perform']
Performance,"/// Emit a code for reduction clause.; ///; /// \param Privates List of private copies for original reduction arguments.; /// \param LHSExprs List of LHS in \a ReductionOps reduction operations.; /// \param RHSExprs List of RHS in \a ReductionOps reduction operations.; /// \param ReductionOps List of reduction operations in form 'LHS binop RHS'; /// or 'operator binop(LHS, RHS)'.; /// \param Options List of options for reduction codegen:; /// WithNowait true if parent directive has also nowait clause, false; /// otherwise.; /// SimpleReduction Emit reduction operation only. Used for omp simd; /// directive on the host.; /// ReductionKind The kind of reduction to perform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h:671,perform,perform,671,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.h,1,['perform'],['perform']
Performance,"/// Emit a constant in a register using target-specific logic, such as; /// constant pool loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:90,load,loads,90,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,1,['load'],['loads']
Performance,"/// Emit a diagnostic that describes an effect on the run-time behavior; /// of the program being compiled.; ///; /// This routine emits the given diagnostic when the code currently being; /// type-checked is ""potentially evaluated"", meaning that there is a; /// possibility that the code will actually be executable. Code in sizeof(); /// expressions, code used only during overload resolution, etc., are not; /// potentially evaluated. This routine will suppress such diagnostics or,; /// in the absolutely nutty case of potentially potentially evaluated; /// expressions (C++ typeid), queue the diagnostic to potentially emit it; /// later.; ///; /// This routine should be used for all diagnostics that describe the run-time; /// behavior of a program, such as passing a non-POD value through an ellipsis.; /// Failure to do so will likely result in spurious diagnostics or failures; /// during overload resolution or within sizeof/alignof/typeof/typeid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:588,queue,queue,588,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['queue'],['queue']
Performance,"/// Emit a helper that reduces data across two OpenMP threads (lanes); /// in the same warp. It uses shuffle instructions to copy over data from; /// a remote lane's stack. The reduction algorithm performed is specified; /// by the fourth parameter.; ///; /// Algorithm Versions.; /// Full Warp Reduce (argument value 0):; /// This algorithm assumes that all 32 lanes are active and gathers; /// data from these 32 lanes, producing a single resultant value.; /// Contiguous Partial Warp Reduce (argument value 1):; /// This algorithm assumes that only a *contiguous* subset of lanes; /// are active. This happens for the last warp in a parallel region; /// when the user specified num_threads is not an integer multiple of; /// 32. This contiguous subset always starts with the zeroth lane.; /// Partial Warp Reduce (argument value 2):; /// This algorithm gathers data from any number of lanes at any position.; /// All reduced values are stored in the lowest possible lane. The set; /// of problems every algorithm addresses is a super set of those; /// addressable by algorithms with a lower version number. Overhead; /// increases as algorithm version increases.; ///; /// Terminology; /// Reduce element:; /// Reduce element refers to the individual data field with primitive; /// data types to be combined and reduced across threads.; /// Reduce list:; /// Reduce list refers to a collection of local, thread-private; /// reduce elements.; /// Remote Reduce list:; /// Remote Reduce list refers to a collection of remote (relative to; /// the current thread) reduce elements.; ///; /// We distinguish between three states of threads that are important to; /// the implementation of this function.; /// Alive threads:; /// Threads in a warp executing the SIMT instruction, as distinguished from; /// threads that are inactive due to divergent control flow.; /// Active threads:; /// The minimal set of threads that has to be alive upon entry to this; /// function. The computation is correct iff a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp:197,perform,performed,197,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntimeGPU.cpp,1,['perform'],['performed']
Performance,/// Emit a leaf load of a single value. This is called at the leaves of the; /// recursive emission to actually load values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:16,load,load,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,2,['load'],['load']
Performance,/// Emit a load from an i1 flag variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h:11,load,load,11,interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuilder.h,1,['load'],['load']
Performance,/// Emit a load from an l-value of atomic type. Note that the r-value; /// we produce is an r-value of the atomic *value* type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:11,load,load,11,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['load'],['load']
Performance,/// Emit a load instruction with an immediate offset. DstReg and TmpReg are; /// permitted to be the same register iff DstReg is distinct from BaseReg and; /// DstReg is a GPR. It is the callers responsibility to identify such cases; /// and pass the appropriate register in TmpReg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp:11,load,load,11,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsTargetStreamer.cpp,1,['load'],['load']
Performance,/// Emit a load of return address if tail call; /// optimization is performed and it is required.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:11,load,load,11,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,6,"['load', 'optimiz', 'perform']","['load', 'optimization', 'performed']"
Performance,"/// Emit a load-pair instruction for frame-destroy.; /// If Reg2 is AArch64::NoRegister, emit LDR instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp:11,load,load-pair,11,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp,1,['load'],['load-pair']
Performance,"/// Emit a load/store instruction with the same value register as `MemI`, but; /// using the address from `AM`. The addressing mode must have been obtained; /// from `canFoldIntoAddr` for the same memory instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:11,load,load,11,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['load'],['load']
Performance,"/// Emit a locked operation on a stack location which does not change any; /// memory location, but does involve a lock prefix. Location is chosen to be; /// a) very likely accessed only by a single thread to minimize cache traffic,; /// and b) definitely dereferenceable. Returns the new Chain result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:218,cache,cache,218,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['cache'],['cache']
Performance,"/// Emit a log entry.; /// \param entry - the RLogEntry to be emitted.; /// \returns false if further emission of this Log should be suppressed.; ///; /// \note This function is called concurrently; log emission must be locked; /// if needed. (The default log handler using ROOT's DefaultErrorHandler is locked.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx:185,concurren,concurrently,185,core/foundation/inc/ROOT/RLogger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RLogger.hxx,1,['concurren'],['concurrently']
Performance,"/// Emit a machine register location. As an optimization this may also consume; /// the prefix of a DwarfExpression if a more efficient representation for; /// combining the register location and the first operation exists.; ///; /// \param FragmentOffsetInBits If this is one fragment out of a; /// fragmented; /// location, this is the offset of the; /// fragment inside the entire variable.; /// \return false if no DWARF register exists; /// for MachineReg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h:44,optimiz,optimization,44,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.h,1,['optimiz'],['optimization']
Performance,/// Emit a post-increment load operation with given size. The instructions; /// will be added to BB at Pos.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:26,load,load,26,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['load'],['load']
Performance,/// Emit a remark generically.; ///; /// This template function can be used to generically emit a remark. The; /// RemarkKind should be one of the following:; /// - OptimizationRemark to indicate a successful optimization attempt; /// - OptimizationRemarkMissed to report a failed optimization attempt; /// - OptimizationRemarkAnalysis to provide additional information about an; /// optimization attempt; ///; /// The remark is built using a callback function \p RemarkCB that takes a; /// RemarkKind as input and returns a RemarkKind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:165,Optimiz,OptimizationRemark,165,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,6,"['Optimiz', 'optimiz']","['OptimizationRemark', 'OptimizationRemarkAnalysis', 'OptimizationRemarkMissed', 'optimization']"
Performance,"/// Emit a sequence of instructions representing a constant \p CV for a; /// vector register \p Dst. (E.g. a MOV, or a load from a constant pool.); ///; /// \returns the last instruction in the sequence on success, and nullptr; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:119,load,load,119,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['load'],['load']
Performance,"/// Emit a series of instructions to load an immediate. If NewImm is a; /// non-NULL parameter, the last instruction is not emitted, but instead; /// its immediate operand is returned in NewImm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:37,load,load,37,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,1,['load'],['load']
Performance,/// Emit a series of instructions to load an immediate.; // This is to adjust some FrameReg. We return the new register to be used; // in place of FrameReg and the adjusted immediate field (&NewImm),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h:37,load,load,37,interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/Mips16InstrInfo.h,1,['load'],['load']
Performance,/// Emit a store of the return address if tail call; /// optimization is performed and it is required (FPDiff!=0).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:57,optimiz,optimization,57,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,4,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"/// Emit a store/load combination to the stack. This stores; /// SrcOp to a stack slot of type SlotVT, truncating it if needed. It then does; /// a load from the stack slot to DestVT, extending it if needed.; /// The resultant code need not be legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:17,load,load,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,2,['load'],['load']
Performance,/// Emit a type checked load from the given vtable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:24,load,load,24,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['load'],['load']
Performance,/// Emit all Linker Optimization Hint in one big table.; /// Each line of the table is emitted by LOHDirective::emit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h:20,Optimiz,Optimization,20,interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,1,['Optimiz'],['Optimization']
Performance,/// Emit an optimization remark.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:12,optimiz,optimization,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,1,['optimiz'],['optimization']
Performance,/// Emit assumption load for all bases. Requires to be called only on; /// most-derived class and not under construction of the object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:20,load,load,20,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['load'],['load']
Performance,/// Emit assumption that vptr load == global vtable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:30,load,load,30,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['load'],['load']
Performance,/// Emit code for handling declare target functions in the runtime.; /// \param FD Declare target function.; /// \param Addr Address of the global \a FD.; /// \param PerformInit true if initialization expression is not constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:166,Perform,PerformInit,166,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,1,['Perform'],['PerformInit']
Performance,"/// Emit code in this function to perform a guarded variable; /// initialization. Guarded initializations are used when it's not; /// possible to prove that an initialization will be done exactly; /// once, e.g. with a static local variable or a static data member; /// of a class template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:34,perform,perform,34,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['perform'],['perform']
Performance,/// Emit final update of reduction values to original variables at; /// the end of the directive.; ///; /// \param D Directive that has at least one 'reduction' directives.; /// \param ReductionKind The kind of reduction to perform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:224,perform,perform,224,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['perform'],['perform']
Performance,"/// Emit initial code for lastprivate variables. If some variable is; /// not also firstprivate, then the default initialization is used. Otherwise; /// initialization of this variable is performed by EmitOMPFirstprivateClause; /// method.; ///; /// \param D Directive that may have 'lastprivate' directives.; /// \param PrivateScope Private scope for capturing lastprivate variables for; /// proper codegen in internal captured statement.; ///; /// \returns true if there is at least one lastprivate variable, false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:188,perform,performed,188,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['perform'],['performed']
Performance,"/// Emit loads and stores that perform the given memcpy.; /// Assumes \p MI is a G_MEMCPY_INLINE; /// TODO: implement dynamically sized inline memcpy,; /// and rename: s/bool tryEmit/void emit/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:9,load,loads,9,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,2,"['load', 'perform']","['loads', 'perform']"
Performance,"/// Emit nops until the byte alignment \p ByteAlignment is reached.; ///; /// This used to align code where the alignment bytes may be executed. This; /// can emit different bytes for different sizes to optimize execution.; ///; /// \param Alignment - The alignment to reach.; /// \param STI - The MCSubtargetInfo in operation when padding is emitted.; /// \param MaxBytesToEmit - The maximum numbers of bytes to emit, or 0. If; /// the alignment cannot be reached in this many bytes, no bytes are; /// emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:203,optimiz,optimize,203,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['optimiz'],['optimize']
Performance,"/// Emit target-specific code that performs a memchr, in cases where that is; /// faster than a libcall. The first returned SDValue is the result of the; /// memchr and the second is the chain. Both SDValues can be null if a normal; /// libcall should be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,perform,performs,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,1,['perform'],['performs']
Performance,"/// Emit target-specific code that performs a memcmp/bcmp, in cases where that is; /// faster than a libcall. The first returned SDValue is the result of the; /// memcmp and the second is the chain. Both SDValues can be null if a normal; /// libcall should be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,perform,performs,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,1,['perform'],['performs']
Performance,"/// Emit target-specific code that performs a memcpy.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.; ///; /// If AlwaysInline is true, the size is constant and the target should not; /// emit any calls and is strongly encouraged to attempt to emit inline code; /// even if it is beyond the usual threshold because this intrinsic is being; /// expanded in a place where calls are not feasible (e.g. within the prologue; /// for another call). If the target chooses to decline an AlwaysInline; /// request here, legalize will resort to using simple loads and stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,perform,performs,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,3,"['load', 'perform']","['loads', 'performs']"
Performance,/// Emit target-specific code that performs a memmove.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple loads/stores and can be; /// more efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,perform,performs,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,2,"['load', 'perform']","['loads', 'performs']"
Performance,/// Emit target-specific code that performs a memset.; /// This can be used by targets to provide code sequences for cases; /// that don't fit the target's parameters for simple stores and can be more; /// efficient than using a library call. This function can return a null; /// SDValue if the target declines to use custom code and a different; /// lowering strategy should be used. Note that if AlwaysInline is true the; /// function has to return a valid SDValue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,perform,performs,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,1,['perform'],['performs']
Performance,"/// Emit target-specific code that performs a strcmp, in cases where that is; /// faster than a libcall.; /// The first returned SDValue is the result of the strcmp and the second is; /// the chain. Both SDValues can be null if a normal libcall should be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,perform,performs,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,1,['perform'],['performs']
Performance,"/// Emit target-specific code that performs a strcpy or stpcpy, in cases; /// where that is faster than a libcall.; /// The first returned SDValue is the result of the copy (the start; /// of the destination string for strcpy, a pointer to the null terminator; /// for stpcpy) and the second is the chain. Both SDValues can be null; /// if a normal libcall should be used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h:35,perform,performs,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGTargetInfo.h,1,['perform'],['performs']
Performance,/// Emit the function that initializes the specified global (if PerformInit is; /// true) and registers its destructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:64,Perform,PerformInit,64,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['Perform'],['PerformInit']
Performance,/// Emit the function that performs cleanup associated with C++ globals.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:27,perform,performs,27,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['perform'],['performs']
Performance,/// Emit the target dependent code to load a value of; /// \arg Ty from the \c __builtin_ms_va_list pointed to by \arg VAListAddr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h:38,load,load,38,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h,1,['load'],['load']
Performance,/// Emit warnings for forced (i.e. user-defined) loop transformations which have; /// still not been performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp:101,perform,performed,101,interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp,1,['perform'],['performed']
Performance,"/// EmitARCUnsafeUnretainedScalarExpr - Semantically equivalent to; /// immediately releasing the resut of EmitARCRetainScalarExpr, but; /// avoiding any spurious retains, including by performing reclaims; /// with objc_unsafeClaimAutoreleasedReturnValue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:185,perform,performing,185,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['perform'],['performing']
Performance,"/// EmitDelegateCallArg - We are performing a delegate call; that; /// is, the current function is delegating to another one. Produce; /// a r-value suitable for passing the given parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:33,perform,performing,33,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['perform'],['performing']
Performance,"/// EmitFinalDestCopy - Perform the final copy to DestPtr, if desired.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:24,Perform,Perform,24,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,2,['Perform'],['Perform']
Performance,"/// EmitFinalDestCopy - Perform the final copy to DestPtr, if desired.; /// SrcIsRValue is true if source comes from an RValue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:24,Perform,Perform,24,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['Perform'],['Perform']
Performance,/// EmitFloatToBoolConversion - Perform an FP to boolean conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:32,Perform,Perform,32,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['Perform'],['Perform']
Performance,/// EmitFunctionProlog - Emit the target specific LLVM code to load the; /// arguments for the given function. This is also responsible for naming the; /// LLVM function arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:63,load,load,63,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['load'],['load']
Performance,/// EmitLoadOfComplex - Load a complex number from the specified address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp:24,Load,Load,24,interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,1,['Load'],['Load']
Performance,/// EmitLoadOfComplex - Load a complex number from the specified l-value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:24,Load,Load,24,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['Load'],['Load']
Performance,"/// EmitLoadOfLValue - Given an RValue reference for a complex, emit code to; /// load the real and imaginary pieces, returning them as Real/Imag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp:82,load,load,82,interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,1,['load'],['load']
Performance,"/// EmitLoadOfLValue - Given an expression that represents a value lvalue, this; /// method emits the address of the lvalue, then loads the result as an rvalue,; /// returning the rvalue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:130,load,loads,130,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['load'],['loads']
Performance,"/// EmitLoadOfLValue - Given an expression that represents a value lvalue,; /// this method emits the address of the lvalue, then loads the result as an; /// rvalue, returning the rvalue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:130,load,loads,130,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['load'],['loads']
Performance,"/// EmitLoadOfLValue - Given an expression with complex type that represents a; /// value l-value, this method emits the address of the l-value, then loads; /// and returns the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp:150,load,loads,150,interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,2,['load'],['loads']
Performance,"/// EmitLoadOfScalar - Load a scalar value from an address, taking; /// care to appropriately convert from the memory representation to; /// the LLVM value representation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:23,Load,Load,23,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['Load'],['Load']
Performance,"/// EmitLoadOfScalar - Load a scalar value from an address, taking; /// care to appropriately convert from the memory representation to; /// the LLVM value representation. The l-value must be a simple; /// l-value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:23,Load,Load,23,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['Load'],['Load']
Performance,/// EmitObjCWeakRead - Code gen for loading value of a __weak; /// object: objc_read_weak (id *src); ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:36,load,loading,36,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['load'],['loading']
Performance,/// EmitPointerToBoolConversion - Perform a pointer to boolean conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:34,Perform,Perform,34,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['Perform'],['Perform']
Performance,/// EmitTCFPAndRetAddrLoad - Emit load from frame pointer and return address; /// stack slot. Returns the chain as result and the loaded frame pointers in; /// LROpOut/FPOpout. Used when tail calling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:34,load,load,34,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['load'],"['load', 'loaded']"
Performance,/// EmitTailCallStoreFPAndRetAddr - Move the frame pointer and return address to; /// the appropriate stack slot for the tail call optimized function call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:131,optimiz,optimized,131,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['optimiz'],['optimized']
Performance,"/// EmitVAArg - Emit the target dependent code to load a value of; /// \arg Ty from the va_list pointed to by \arg VAListAddr.; // FIXME: This is a gaping layering violation if we wanted to drop; // the ABI information any lower than CodeGen. Of course, for; // VAArg handling it has to be at this level; there is no way to; // abstract this out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h:50,load,load,50,interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ABIInfo.h,1,['load'],['load']
Performance,/// Emits atomic load as LLVM instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:17,load,load,17,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['load'],['load']
Performance,/// Emits atomic load as a libcall.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:17,load,load,17,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['load'],['load']
Performance,/// Emits atomic load.; /// \returns Loaded value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:17,load,load,17,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,2,"['Load', 'load']","['Loaded', 'load']"
Performance,"/// Emits latency information in DC->CommentStream for \p Inst, based; /// on the information available in \p DC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:10,latency,latency,10,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,1,['latency'],['latency']
Performance,/// Emits optimized code for unique scalar value reused \p Cnt times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10,optimiz,optimized,10,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['optimiz'],['optimized']
Performance,"/// Emulate a lookup to replace one nested name specifier with another using as; /// few additional namespace qualifications as possible.; ///; /// This does not perform a full C++ lookup so ADL will not work.; ///; /// \param Use The nested name to be replaced.; /// \param UseLoc The location of name to be replaced.; /// \param UseContext The context in which the nested name is contained. This; /// will be used to minimize namespace qualifications.; /// \param FromDecl The declaration to which the nested name points.; /// \param ReplacementString The replacement nested name. Must be fully; /// qualified including a leading ""::"".; /// \returns The new name to be inserted in place of the current nested name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h:162,perform,perform,162,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/Lookup.h,1,['perform'],['perform']
Performance,"/// Enable F16C intruction set intrinsics.; /// Defining this to 1 enables the use of [F16C compiler intrinsics](https://en.wikipedia.org/wiki/F16C) for converting; /// between half-precision and single-precision values which may result in improved performance. This will not perform; /// additional checks for support of the F16C instruction set, so an appropriate target platform is required when; /// enabling this feature.; ///; /// Unless predefined it will be enabled automatically when the `__F16C__` symbol is defined, which some compilers do on; /// supporting platforms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RFloat16.hxx:249,perform,performance,249,core/base/v7/inc/ROOT/RFloat16.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RFloat16.hxx,2,['perform'],"['perform', 'performance']"
Performance,/// Enable matching of interleaved access groups that contain predicated; /// accesses or gaps and therefore vectorized using masked; /// vector loads/stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:145,load,loads,145,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['loads']
Performance,"/// Enable performance measurements (decompression time, bytes read from storage, etc.); ///; /// **Example: inspect the reader metrics after loading every entry**; /// ~~~ {.cpp}; /// #include <ROOT/RNTupleReader.hxx>; /// using ROOT::Experimental::ENTupleInfo;; /// using ROOT::Experimental::RNTupleReader;; ///; /// #include <iostream>; ///; /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; /// // metrics must be turned on beforehand; /// ntuple->EnableMetrics();; ///; /// for (auto i : ntuple->GetEntryRange()) {; /// ntuple->LoadEntry(i);; /// }; /// ntuple->PrintInfo(ENTupleInfo::kMetrics);; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:11,perform,performance,11,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,3,"['Load', 'load', 'perform']","['LoadEntry', 'loading', 'performance']"
Performance,/// Enable sinking of instructions in MachineSink where a computation can be; /// folded into the addressing mode of a memory load/store instruction or; /// replace a copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:126,load,load,126,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['load'],['load']
Performance,/// Enable source-range based diagnostic messages.; ///; /// If diagnostic messages with source-range information are to be expected; /// and AST comes not from file (e.g. after LoadFromCompilerInvocation) this; /// function has to be called.; /// The function is to be called only once and the AST should be associated; /// with the same source file afterwards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:178,Load,LoadFromCompilerInvocation,178,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['Load'],['LoadFromCompilerInvocation']
Performance,/// Enable store-to-load forwarding conflict detection. This option can; /// be disabled for correctness testing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:20,load,load,20,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['load'],['load']
Performance,/// Enable the Freestanding mode: indicate that the optimizer should not; /// assume builtins are present on the target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h:52,optimiz,optimizer,52,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,2,['optimiz'],['optimizer']
Performance,/// Enables or disables PRE of loads in GVN.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:31,load,loads,31,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,2,['load'],['loads']
Performance,"/// Encapsulates all of the information needed to generate a stack protector; /// check, and signals to isel when initialized that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point wer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:753,optimiz,optimization,753,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,2,['optimiz'],['optimization']
Performance,"/// Encode information on a single operation to perform on a byte; /// sequence (e.g., an encoded instruction) which requires assemble- or run-; /// time patching.; ///; /// Fixups are used any time the target instruction encoder needs to represent; /// some value in an instruction which is not yet concrete. The encoder will; /// encode the instruction assuming the value is 0, and emit a fixup which; /// communicates to the assembler backend how it should rewrite the encoded; /// value.; ///; /// During the process of relaxation, the assembler will apply fixups as; /// symbolic values become concrete. When relaxation is complete, any remaining; /// fixups become relocations in the object file (or errors, if the fixup cannot; /// be encoded on the target).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFixup.h:48,perform,perform,48,interpreter/llvm-project/llvm/include/llvm/MC/MCFixup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFixup.h,1,['perform'],['perform']
Performance,"/// Encode this function info into the internal byte cache and return the size; /// in bytes.; ///; /// When segmenting GSYM files we need to know how big each FunctionInfo will; /// encode into so we can generate segments of the right size. We don't want; /// to have to encode a FunctionInfo twice, so we can cache the encoded bytes; /// and re-use then when calling FunctionInfo::encode(...).; ///; /// \returns The size in bytes of the FunctionInfo if it were to be encoded; /// into a byte stream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h:53,cache,cache,53,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h,2,['cache'],['cache']
Performance,"/// Encodes a location in the source. The SourceManager can decode this; /// to get at the full include stack, line and column information.; ///; /// Technically, a source location is simply an offset into the manager's view; /// of the input source, which is all input buffers (including macro; /// expansions) concatenated in an effectively arbitrary order. The manager; /// actually maintains two blocks of input buffers. One, starting at offset; /// 0 and growing upwards, contains all buffers from this module. The other,; /// starting at the highest possible offset and growing downwards, contains; /// buffers of loaded modules.; ///; /// In addition, one bit of SourceLocation is used for quick access to the; /// information whether the location is in a file or a macro expansion.; ///; /// It is important that this type remains small. It is currently 32 bits wide.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h:620,load,loaded,620,interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceLocation.h,1,['load'],['loaded']
Performance,/// Encodes the `PTRREGS` operand to a load or store instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.h:39,load,load,39,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.h,1,['load'],['load']
Performance,"/// End iterator for local, non-loaded, preprocessed entities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:32,load,loaded,32,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['load'],['loaded']
Performance,/// Ensure that all forward-references and placeholders are resolved.; /// Iteratively lazy-loading metadata on-demand if needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:92,load,loading,92,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,1,['load'],['loading']
Performance,/// Ensure that the memory in \p Load does not alias \p Store by potentially; /// copying it to a new location. This new or otherwise the original location; /// is returned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:33,Load,Load,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['Load'],['Load']
Performance,"/// Ensure that the type T is a complete type.; ///; /// This routine checks whether the type @p T is complete in any; /// context where a complete type is required. If @p T is a complete; /// type, returns false. If @p T is a class template specialization,; /// this routine then attempts to perform class template; /// instantiation. If instantiation fails, or if @p T is incomplete; /// and cannot be completed, issues the diagnostic @p diag (giving it; /// the type @p T) and returns true.; ///; /// @param Loc The location in the source that the incomplete type; /// diagnostic should refer to.; ///; /// @param T The type that this routine is examining for completeness.; ///; /// @param Kind Selects which completeness rules should be applied.; ///; /// @returns @c true if @p T is incomplete and a diagnostic was emitted,; /// @c false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:293,perform,perform,293,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['perform'],['perform']
Performance,"/// Ensure that the type of the given expression is complete.; ///; /// This routine checks whether the expression \p E has a complete type. If the; /// expression refers to an instantiable construct, that instantiation is; /// performed as needed to complete its type. Furthermore; /// Sema::RequireCompleteType is called for the expression's type (or in the; /// case of a reference type, the referred-to type).; ///; /// \param E The expression whose type is required to be complete.; /// \param Kind Selects which completeness rules should be applied.; /// \param Diagnoser The object that will emit a diagnostic if the type is; /// incomplete.; ///; /// \returns \c true if the type of \p E is incomplete and diagnosed, \c false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:228,perform,performed,228,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['perform'],['performed']
Performance,/// Ensures that all external skipped ranges have been loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:55,load,loaded,55,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['load'],['loaded']
Performance,"/// Enter a cleanup to destroy a __block variable. Note that this; /// cleanup should be a no-op if the variable hasn't left the stack; /// yet; if a cleanup is required for the variable itself, that needs; /// to be done externally.; ///; /// \param Kind Cleanup kind.; ///; /// \param Addr When \p LoadBlockVarAddr is false, the address of the __block; /// structure that will be passed to _Block_object_dispose. When; /// \p LoadBlockVarAddr is true, the address of the field of the block; /// structure that holds the address of the __block structure.; ///; /// \param Flags The flag that will be passed to _Block_object_dispose.; ///; /// \param LoadBlockVarAddr Indicates whether we need to emit a load from; /// \p Addr to get the address of the __block structure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:300,Load,LoadBlockVarAddr,300,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,4,"['Load', 'load']","['LoadBlockVarAddr', 'load']"
Performance,/// Entry - A cache entry containing interference information for all aliases; /// of PhysReg in all basic blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h:14,cache,cache,14,interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterferenceCache.h,1,['cache'],['cache']
Performance,"/// Enum representing the optimizer used for training.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Functions.h:26,optimiz,optimizer,26,tmva/tmva/inc/TMVA/DNN/Functions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/DNN/Functions.h,1,['optimiz'],['optimizer']
Performance,"/// Enum that specifies what an atomic load/AtomicRMWInst is expanded; /// to, if at all. Exists because different targets have different levels of; /// support for these atomic instructions, and also have different options; /// w.r.t. what they should expand to.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:39,load,load,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,/// Erase stale entry from phiTranslate cache so phiTranslate can be computed; /// again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:40,cache,cache,40,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['cache'],['cache']
Performance,/// Errors of this type should be returned if a module contains definitions for; /// symbols that are not claimed by the module's associated; /// MaterializationResponsibility. If this error is returned it is indicative of; /// a broken transformation / compiler / object cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:272,cache,cache,272,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['cache'],['cache']
Performance,/// Errors of this type should be returned if a module fails to include; /// definitions that are claimed by the module's associated; /// MaterializationResponsibility. If this error is returned it is indicative of; /// a broken transformation / compiler / object cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:264,cache,cache,264,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['cache'],['cache']
Performance,"/// Estimate the ""quality"" of a given node order in CFG. The higher the score,; /// the better the order is. The score is designed to reflect the locality of; /// the given order, which is anti-correlated with the number of I-cache misses; /// in a typical execution of the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:226,cache,cache,226,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,1,['cache'],['cache']
Performance,"/// Estimate the cost of a GEP operation when lowered.; ///; /// \p PointeeType is the source element type of the GEP.; /// \p Ptr is the base pointer operand.; /// \p Operands is the list of indices following the base pointer.; ///; /// \p AccessType is a hint as to what type of memory might be accessed by; /// users of the GEP. getGEPCost will use it to determine if the GEP can be; /// folded into the addressing mode of a load/store. If AccessType is null,; /// then the resulting target type based off of PointeeType will be used as an; /// approximation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:428,load,load,428,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,/// Estimate the cost of a chain of pointers (typically pointer operands of a; /// chain of loads or stores within same block) operations set when lowered.; /// \p AccessTy is the type of the loads/stores that will ultimately use the; /// \p Ptrs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:92,load,loads,92,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,2,['load'],['loads']
Performance,"/// Estimate the latency of the new and original instruction sequence by summing; /// up the latencies of the inserted and deleted instructions. This assumes; /// that the inserted and deleted instructions are dependent instruction chains,; /// which might not hold in all cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp:17,latency,latency,17,interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCombiner.cpp,1,['latency'],['latency']
Performance,"/// Estimate the median cluster size for the TTree.; /// This value provides e.g. a reasonable cache size default if other heuristics fail.; /// Clusters with size 0 and the very last cluster range, that might not have been committed to fClusterSize yet,; /// are ignored for the purposes of the calculation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:95,cache,cache,95,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['cache'],['cache']
Performance,"/// Evaluate as a constant expression. Stop if we find that the expression; /// is not a constant expression. Some expressions can be retried in the; /// optimizer if we don't constant fold them here, but in an unevaluated; /// context we try to fold them immediately since the optimizer never; /// gets a chance to look at it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:154,optimiz,optimizer,154,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,2,['optimiz'],['optimizer']
Performance,/// Evaluate as boolean \param E without using the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:51,cache,cache,51,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['cache'],['cache']
Performance,"/// EvaluateAsRValue - Try to evaluate this expression, performing an implicit; /// lvalue-to-rvalue cast if it is an lvalue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:56,perform,performing,56,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['perform'],['performing']
Performance,"/// EvaluateExprAsBool - Perform the usual unary conversions on the specified; /// expression and compare the result against zero, returning an Int1Ty value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:25,Perform,Perform,25,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,2,['Perform'],['Perform']
Performance,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:55,perform,performed,55,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,1,['perform'],['performed']
Performance,/// Evaluates the computation and (potentially) updates the accumulator \c; /// Result. \c Result is undefined in the case of an error. `Result` is an; /// out parameter to optimize case where the computation involves composing; /// the result of sub-computation evaluations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h:173,optimiz,optimize,173,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/MatchConsumer.h,1,['optimiz'],['optimize']
Performance,"/// Every cluster pool is responsible for exactly one page source that triggers loading of the clusters; /// (GetCluster()) and is used for implementing the I/O and cluster memory allocation (PageSource::LoadClusters()).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:80,load,loading,80,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,2,"['Load', 'load']","['LoadClusters', 'loading']"
Performance,/// Examines the G_PTR_ADD instruction \p PtrAdd and determines if performing; /// a re-association of its operands would break an existing legal addressing; /// mode that the address computation currently represents.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:67,perform,performing,67,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['perform'],['performing']
Performance,/// Exception specification updates that have been loaded but not yet; /// propagated across the relevant redeclaration chain. The map key is the; /// canonical declaration (used only for deduplication) and the value is a; /// declaration that has an exception specification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:51,load,loaded,51,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// ExecuteProgram - Execute the program specified by ""ProgramFile"" (which is; /// either a .s file, or a .c file, specified by FileType), with the specified; /// arguments. Standard input is specified with InputFile, and standard; /// Output is captured to the specified OutputFile location. The SharedLibs; /// option specifies optional native shared objects that can be loaded into; /// the program for execution.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h:373,load,loaded,373,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.h,1,['load'],['loaded']
Performance,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:278,load,loads,278,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,5,['load'],"['load', 'loaded', 'loads']"
Performance,/// Expand check for floating point class.; /// \param ResultVT The type of intrinsic call result.; /// \param Op The tested value.; /// \param Test The test to perform.; /// \param Flags The optimization flags.; /// \returns The expansion result or SDValue() if it fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:161,perform,perform,161,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"/// Expand rotations.; /// \param N Node to expand; /// \param AllowVectorOps expand vector rotate, this should only be performed; /// if the legalization is happening outside of LegalizeVectorOps; /// \returns The expansion if successful, SDValue() otherwise",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:120,perform,performed,120,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['performed']
Performance,"/// Expands an unaligned load to 2 half-size loads for an integer, and; /// possibly more for vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:25,load,load,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],"['load', 'loads']"
Performance,"/// Expands load operation \p MI. Returns true if instructions are; /// added/deleted or \p MI is modified, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp:12,load,load,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMemoryLegalizer.cpp,1,['load'],['load']
Performance,/// Expands the Constant node to a load from the constant pool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:35,load,load,35,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['load'],['load']
Performance,/// Expands the ConstantFP node to an integer constant or; /// a load from the constant pool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:65,load,load,65,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['load'],['load']
Performance,"/// ExposesReturnsTwice - True if the function calls setjmp or related; /// functions with attribute ""returns twice"", but doesn't have; /// the attribute itself.; /// This is used to limit optimizations which cannot reason; /// about the control flow of such functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:189,optimiz,optimizations,189,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['optimiz'],['optimizations']
Performance,/// Express \p EltTy vectors strictly using vectors with \p NumElts elements; /// (or scalars when \p NumElts equals 1).; /// First pad with undef elements to nearest larger multiple of \p NumElts.; /// Then perform split with all sub-instructions having the same type.; /// Using clampMaxNumElements (non-strict) can result in leftover instruction; /// with different type (fewer elements then \p NumElts or scalar).; /// No effect if the type is not a vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:208,perform,perform,208,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['perform'],['perform']
Performance,"/// Extend the current definition as far as possible down.; ///; /// Stop when meeting an existing def or when leaving the live; /// range of VNI. End points where VNI is no longer live are added to Kills.; ///; /// We only propagate DBG_VALUES locally here. LiveDebugValues performs a; /// data-flow analysis to propagate them beyond basic block boundaries.; ///; /// \param Idx Starting point for the definition.; /// \param DbgValue value to propagate.; /// \param LiveIntervalInfo For each location number key in this map,; /// restricts liveness to where the LiveRange has the value equal to the\; /// VNInfo.; /// \param [out] Kills Append end points of VNI's live range to Kills.; /// \param LIS Live intervals analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:275,perform,performs,275,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['perform'],['performs']
Performance,"/// Extend/Truncate \p Expr to \p ToTy considering post-inc uses in \p Loops.; /// For all PostIncLoopSets in \p Loops, first de-normalize \p Expr, then; /// perform the extension/truncate and normalize again, as the normalized form; /// can result in folds that are not valid in the post-inc use contexts. The; /// expressions for all PostIncLoopSets must match, otherwise return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:158,perform,perform,158,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['perform'],['perform']
Performance,"/// Extension to memcmp to handle hash code representation. If both are hash; /// values, Lhs and Rhs are both null, function returns 0 (and needs an extra; /// comparison using getIntValue). If only one is hash code, it is considered; /// less than the StringRef one. Otherwise perform normal string comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h:279,perform,perform,279,interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/FunctionId.h,1,['perform'],['perform']
Performance,/// Extensions to this class implement mechanisms to disable passes and; /// individual optimizations at compile time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h:88,optimiz,optimizations,88,interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/OptBisect.h,1,['optimiz'],['optimizations']
Performance,/// Extra modules inspected when performing a lookup during a template; /// instantiation. Computed lazily.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:33,perform,performing,33,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,"/// Extract a 24-bit unsigned value from \a *offset_ptr and return it; /// in a uint32_t.; ///; /// Extract 3 bytes from the binary data at the offset pointed to by; /// \a offset_ptr, construct a uint32_t from them and update the offset; /// on success.; ///; /// @param[in,out] OffsetPtr; /// A pointer to an offset within the data that will be advanced; /// by the 3 bytes if the value is extracted correctly. If the offset; /// is out of bounds or there are not enough bytes to extract this value,; /// the offset will be left unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted 24-bit value represented in a uint32_t.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:796,perform,performed,796,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['perform'],['performed']
Performance,"/// Extract a C string from \a *offset_ptr.; ///; /// Returns a StringRef for the C String from the data at the offset; /// pointed to by \a offset_ptr. A variable length NULL terminated C; /// string will be extracted and the \a offset_ptr will be; /// updated with the offset of the byte that follows the NULL; /// terminator byte.; ///; /// \param[in,out] OffsetPtr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// \return; /// A StringRef for the C string value in the data. If the offset; /// pointed to by \a offset_ptr is out of bounds, or if the; /// offset plus the length of the C string is out of bounds,; /// a default-initialized StringRef will be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:900,perform,performed,900,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['perform'],['performed']
Performance,"/// Extract a C string from \a *offset_ptr.; ///; /// Returns a pointer to a C String from the data at the offset; /// pointed to by \a offset_ptr. A variable length NULL terminated C; /// string will be extracted and the \a offset_ptr will be; /// updated with the offset of the byte that follows the NULL; /// terminator byte.; ///; /// @param[in,out] OffsetPtr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// A pointer to the C string value in the data. If the offset; /// pointed to by \a offset_ptr is out of bounds, or if the; /// offset plus the length of the C string is out of bounds,; /// NULL will be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:895,perform,performed,895,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['perform'],['performed']
Performance,"/// Extract a fixed number of bytes from the specified offset.; ///; /// Returns a StringRef for the bytes from the data at the offset; /// pointed to by \a OffsetPtr. A fixed length C string will be extracted; /// and the \a OffsetPtr will be advanced by \a Length bytes.; ///; /// \param[in,out] OffsetPtr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// \param[in] Length; /// The number of bytes to extract. If there are not enough bytes in the; /// data to extract all of the bytes, the offset will be left unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// \return; /// A StringRef for the extracted bytes. If the offset pointed to by; /// \a OffsetPtr is out of bounds, or if the offset plus the length; /// is out of bounds, a default-initialized StringRef will be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:1016,perform,performed,1016,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['perform'],['performed']
Performance,"/// Extract a signed LEB128 value from \a *offset_ptr.; ///; /// Extracts an signed LEB128 number from this object's data; /// starting at the offset pointed to by \a offset_ptr. The offset; /// pointed to by \a offset_ptr will be updated with the offset of; /// the byte following the last extracted byte.; ///; /// @param[in,out] OffsetPtr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted signed integer value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:873,perform,performed,873,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['perform'],['performed']
Performance,"/// Extract a uint32_t value from \a *offset_ptr.; ///; /// Extract a single uint32_t from the binary data at the offset; /// pointed to by \a offset_ptr, and update the offset on success.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted uint32_t value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:756,perform,performed,756,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['perform'],['performed']
Performance,"/// Extract a uint64_t value from \a *offset_ptr.; ///; /// Extract a single uint64_t from the binary data at the offset; /// pointed to by \a offset_ptr, and update the offset on success.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted uint64_t value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:756,perform,performed,756,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['perform'],['performed']
Performance,"/// Extract a uint8_t value from \a *offset_ptr.; ///; /// Extract a single uint8_t from the binary data at the offset; /// pointed to by \a offset_ptr, and advance the offset on success.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted uint8_t value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:755,perform,performed,755,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['perform'],['performed']
Performance,"/// Extract a unsigned LEB128 value from \a *offset_ptr.; ///; /// Extracts an unsigned LEB128 number from this object's data; /// starting at the offset pointed to by \a offset_ptr. The offset; /// pointed to by \a offset_ptr will be updated with the offset of; /// the byte following the last extracted byte.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The extracted unsigned integer value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:878,perform,performed,878,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['perform'],['performed']
Performance,"/// Extract all but the specified basic blocks into their own functions. The; /// only detail is that M is actually a module cloned from the one the BBs are; /// in, so some mapping needs to be performed. If this operation fails for; /// some reason (ie the implementation is buggy), this function should return; /// null, otherwise it returns a new Module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:194,perform,performed,194,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['perform'],['performed']
Performance,"/// Extract an unsigned integer of size \a byte_size from \a; /// *offset_ptr.; ///; /// Extract a single unsigned integer value and update the offset; /// pointed to by \a offset_ptr. The size of the extracted integer; /// is specified by the \a byte_size argument. \a byte_size should; /// have a value greater than or equal to one and less than or equal; /// to eight since the return value is 64 bits wide. Any; /// \a byte_size values less than 1 or greater than 8 will result in; /// nothing being extracted, and zero being returned.; ///; /// @param[in,out] offset_ptr; /// A pointer to an offset within the data that will be advanced; /// by the appropriate number of bytes if the value is extracted; /// correctly. If the offset is out of bounds or there are not; /// enough bytes to extract this value, the offset will be left; /// unmodified.; ///; /// @param[in] byte_size; /// The size in byte of the integer to extract.; ///; /// @param[in,out] Err; /// A pointer to an Error object. Upon return the Error object is set to; /// indicate the result (success/failure) of the function. If the Error; /// object is already set when calling this function, no extraction is; /// performed.; ///; /// @return; /// The unsigned integer value that was extracted, or zero on; /// failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h:1187,perform,performed,1187,interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DataExtractor.h,1,['perform'],['performed']
Performance,"/// Extract the `<vlen>` information from the mangled string, and; /// sets `ParsedVF` accordingly. A `<vlen> == ""x""` token is interpreted as a; /// scalable vector length and the boolean is set to true, otherwise a nonzero; /// unsigned integer will be directly used as a VF. On success, the `<vlen>`; /// token is removed from the input string `ParseString`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp:149,scalab,scalable,149,interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/VFABIDemangler.cpp,1,['scalab'],['scalable']
Performance,"/// Extracting a scalar FP value from vector element 0 is free, so extract each; /// operand first, then perform the math as a scalar op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:105,perform,perform,105,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['perform']
Performance,"/// Extracts a debug info entry, which is a child of a given unit,; /// starting at a given offset. If DIE can't be extracted, returns false and; /// doesn't change OffsetPtr.; /// High performance extraction should use this call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugInfoEntry.h:186,perform,performance,186,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugInfoEntry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugInfoEntry.h,1,['perform'],['performance']
Performance,/// FAddCombine is the class for optimizing an unsafe fadd/fsub along; /// with its neighboring at most two instructions.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:33,optimiz,optimizing,33,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['optimiz'],['optimizing']
Performance,/// FIXME: a bitfield is not a reasonable abstraction for talking about; /// which elements are needed from a scalable vector,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:110,scalab,scalable,110,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,1,['scalab'],['scalable']
Performance,/// FMA - Perform a * b + c with no intermediate rounding step.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:10,Perform,Perform,10,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Perform'],['Perform']
Performance,"/// FMAD - Perform a * b + c, while getting the same result as the; /// separately rounded operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:11,Perform,Perform,11,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Perform'],['Perform']
Performance,"/// FMINNUM/FMAXNUM - Perform floating-point minimum or maximum on two; /// values.; //; /// In the case where a single input is a NaN (either signaling or quiet),; /// the non-NaN input is returned.; ///; /// The return value of (FMINNUM 0.0, -0.0) could be either 0.0 or -0.0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:22,Perform,Perform,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Perform'],['Perform']
Performance,"/// FMINNUM_IEEE/FMAXNUM_IEEE - Perform floating-point minimum or maximum on; /// two values, following the IEEE-754 2008 definition. This differs from; /// FMINNUM/FMAXNUM in the handling of signaling NaNs. If one input is a; /// signaling NaN, returns a quiet NaN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:32,Perform,Perform,32,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Perform'],['Perform']
Performance,"/// FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions; /// and truncation for half-precision (16 bit) floating numbers. These nodes; /// form a semi-softened interface for dealing with f16 (as an i16), which; /// is often a storage-only type but has native conversions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:57,perform,perform,57,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['perform'],['perform']
Performance,/// Factory function to load a Module for a given identifier,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h:24,load,load,24,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionImport.h,1,['load'],['load']
Performance,/// Fake module loader: the AST unit doesn't need to load any modules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:16,load,loader,16,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,2,['load'],"['load', 'loader']"
Performance,/// FastPriorityQueue - A degenerate priority queue that considers; /// all nodes to have the same priority.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp:46,queue,queue,46,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGFast.cpp,1,['queue'],['queue']
Performance,/// Fetches a debug binary by searching the default local cache directory and; /// server URLs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h:58,cache,cache,58,interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,1,['cache'],['cache']
Performance,/// Fetches a specified source file by searching the default local cache; /// directory and server URLs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h:67,cache,cache,67,interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,1,['cache'],['cache']
Performance,/// Fetches an executable by searching the default local cache directory and; /// server URLs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h:57,cache,cache,57,interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,1,['cache'],['cache']
Performance,/// Fetches any debuginfod artifact using the default local cache directory and; /// server URLs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h:60,cache,cache,60,interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,1,['cache'],['cache']
Performance,"/// Fetches any debuginfod artifact using the specified local cache directory,; /// server URLs, and request timeout (in milliseconds). If the artifact is; /// found, uses the UniqueKey for the local cache file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h:62,cache,cache,62,interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,2,['cache'],['cache']
Performance,/// Figure out how many bits are really needed for this division. \p AtLeast is; /// an optimization hint to bypass the second ComputeNumSignBits call if we the; /// first one is insufficient. Returns -1 on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:88,optimiz,optimization,88,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['optimiz'],['optimization']
Performance,/// File is an explicitly-loaded module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:26,load,loaded,26,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,1,['load'],['loaded']
Performance,/// File is an implicitly-loaded module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:26,load,loaded,26,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,1,['load'],['loaded']
Performance,/// File status cache used when finding the same file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:16,cache,cache,16,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,1,['cache'],['cache']
Performance,"/// FileSystemStatCache::get - Get the 'stat' information for the specified; /// path, using the cache to accelerate it if possible. This returns true if; /// the path does not exist or false if it exists.; ///; /// If isFile is true, then this lookup should only return success for files; /// (not directories). If it is false this lookup should only return; /// success for directories (not files). On a successful file lookup, the; /// implementation can optionally fill in FileDescriptor with a valid; /// descriptor and the client guarantees that it will close it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp:97,cache,cache,97,interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileSystemStatCache.cpp,1,['cache'],['cache']
Performance,"/// Fill an entry into this context, but don't commit the cluster. The calling code must pass an RNTupleFillStatus; /// and check RNTupleFillStatus::ShouldFlushCluster.; ///; /// This method will perform a light check whether the entry comes from the context's own model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx:196,perform,perform,196,tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,1,['perform'],['perform']
Performance,"/// Fill an entry into this context. This method will perform a light check whether the entry comes from the; /// context's own model.; /// \return The number of uncompressed bytes written.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx:54,perform,perform,54,tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleFillContext.hxx,1,['perform'],['perform']
Performance,/// Filter on the checks performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp:25,perform,performed,25,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/IvarInvalidationChecker.cpp,1,['perform'],['performed']
Performance,"/// FilterChooser - FilterChooser chooses the best filter among a set of Filters; /// in order to perform the decoding of instructions at the current level.; ///; /// Decoding proceeds from the top down. Based on the well-known encoding bits; /// of instructions available, FilterChooser builds up the possible Filters that; /// can further the task of decoding by distinguishing among the remaining; /// candidate instructions.; ///; /// Once a filter has been chosen, it is called upon to divide the decoding task; /// into sub-tasks and delegates them to its inferior FilterChoosers for further; /// processings.; ///; /// It is useful to think of a Filter as governing the switch stmts of the; /// decoding tree. And each case is delegated to an inferior FilterChooser to; /// decide what further remaining bits to look at.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:98,perform,perform,98,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['perform'],['perform']
Performance,/// Finalize emission of the shuffles.; /// \param Action the action (if any) to be performed before final applying of; /// the \p ExtMask mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:84,perform,performed,84,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['perform'],['performed']
Performance,/// FinalizeDeclaration - called by ParseDeclarationAfterDeclarator to perform; /// any semantic actions necessary after any initializer has been attached.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:71,perform,perform,71,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['perform'],['perform']
Performance,"/// Find a combination of metadata (""llvm.loop.vectorize.width"" and; /// ""llvm.loop.vectorize.scalable.enable"") for a loop and use it to construct a; /// ElementCount. If the metadata ""llvm.loop.vectorize.width"" cannot be found; /// then std::nullopt is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:94,scalab,scalable,94,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,1,['scalab'],['scalable']
Performance,/// Find a condition code used by the instruction.; /// Returns AArch64CC::Invalid if either the instruction does not use condition; /// codes or we don't optimize CmpInstr in the presence of such instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:155,optimiz,optimize,155,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['optimiz'],['optimize']
Performance,"/// Find a layout of nodes (basic blocks) of a given CFG optimizing jump; /// locality and thus processor I-cache utilization. This is achieved via; /// increasing the number of fall-through jumps and co-locating frequently; /// executed nodes together.; /// The nodes are assumed to be indexed by integers from [0, |V|) so that the; /// current order is the identity permutation.; /// \p NodeSizes: The sizes of the nodes (in bytes).; /// \p NodeCounts: The execution counts of the nodes in the profile.; /// \p EdgeCounts: The execution counts of every edge (jump) in the profile. The; /// map also defines the edges in CFG and should include 0-count edges.; /// \returns The best block order found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h:57,optimiz,optimizing,57,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeLayout.h,2,"['cache', 'optimiz']","['cache', 'optimizing']"
Performance,"/// Find a module, potentially compiling it, before reading its AST. This is; /// the guts of loadModule.; ///; /// For prebuilt modules, the Module is not expected to exist in; /// HeaderSearch's ModuleMap. If a ModuleFile by that name is in the; /// ModuleManager, then it will be loaded and looked up.; ///; /// For implicit modules, the Module is expected to already be in the; /// ModuleMap. First attempt to load it from the given path on disk. If that; /// fails, defer to compileModuleAndReadAST, which will first build and then; /// load it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:94,load,loadModule,94,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,4,['load'],"['load', 'loadModule', 'loaded']"
Performance,/// Find and instantiate the register allocation pass requested by this target; /// at the current optimization level. Different register allocators are; /// defined as separate passes because they may require different analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:99,optimiz,optimization,99,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,1,['optimiz'],['optimization']
Performance,"/// Find and instantiate the register allocation pass requested by this target; /// at the current optimization level. Different register allocators are; /// defined as separate passes because they may require different analysis.; ///; /// This helper ensures that the regalloc= option is always available,; /// even for targets that override the default allocator.; ///; /// FIXME: When MachinePassRegistry register pass IDs instead of function ptrs,; /// this can be folded into addPass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:99,optimiz,optimization,99,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['optimiz'],['optimization']
Performance,"/// Find any visible decls for the given typo correction candidate.; /// If none are found, it to the set of candidates for which qualified lookups; /// will be performed to find possible nested name specifier changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h:161,perform,performed,161,interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h,1,['perform'],['performed']
Performance,/// Find candidates for load/store multiple merge in list of MemOpQueueEntries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['load'],['load']
Performance,/// Find linked dbg.assign and generate a new one with the correct; /// FragmentInfo. Link Inst to the new dbg.assign. If Value is nullptr the; /// value component is copied from the old dbg.assign to the new.; /// \param OldAlloca Alloca for the variable before splitting.; /// \param IsSplit True if the store (not necessarily alloca); /// is being split.; /// \param OldAllocaOffsetInBits Offset of the slice taken from OldAlloca.; /// \param SliceSizeInBits New number of bits being written to.; /// \param OldInst Instruction that is being split.; /// \param Inst New instruction performing this part of the; /// split store.; /// \param Dest Store destination.; /// \param Value Stored value.; /// \param DL Datalayout.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:585,perform,performing,585,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['perform'],['performing']
Performance,"/// Find subreg index with a given Offset and Size, return 0 if there is no; /// such subregister index. The result is cached in SubRegs data-member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp:119,cache,cached,119,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,1,['cache'],['cached']
Performance,"/// Find the appropriate .crash diagonostic file for the child crash; /// under this driver and copy it out to a temporary destination with the; /// other reproducer related files (.sh, .cache, etc). If not found, suggest a; /// directory for the user to look at.; ///; /// \param ReproCrashFilename The file path to copy the .crash to.; /// \param CrashDiagDir The suggested directory for the user to look at; /// in case the search or copy fails.; ///; /// \returns If the .crash is found and successfully copied return true,; /// otherwise false and return the suggested directory in \p CrashDiagDir.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:187,cache,cache,187,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['cache'],['cache']
Performance,"/// Find the base class to decompose in a built-in decomposition of a class type.; /// This base class search is, unfortunately, not quite like any other that we; /// perform anywhere else in C++.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:167,perform,perform,167,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['perform'],['perform']
Performance,"/// Find the first executable file \p Name in \p Paths.; ///; /// This does not perform hashing as a shell would but instead stats each PATH; /// entry individually so should generally be avoided. Core LLVM library; /// functions and options should instead require fully specified paths.; ///; /// \param Name name of the executable to find. If it contains any system; /// slashes, it will be returned as is.; /// \param Paths optional list of paths to search for \p Name. If empty it; /// will use the system PATH environment instead.; ///; /// \returns The fully qualified path to the first \p Name in \p Paths if it; /// exists. \p Name if \p Name has slashes in it. Otherwise an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:80,perform,perform,80,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['perform'],['perform']
Performance,"/// Find the first not-yet-loaded shared object that contains the symbol; ///; ///\param[in] mangledName - the mangled name to look for.; ///\param[in] searchSystem - whether to decend into system libraries.; ///; ///\returns the library name if found, and empty string otherwise.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h:27,load,loaded,27,interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLibraryManager.h,1,['load'],['loaded']
Performance,/// Find the functions that use this Value and remove them from FnTree and; /// queue the functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:80,queue,queue,80,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['queue'],['queue']
Performance,"/// Find the instantiation of the given declaration within the; /// current instantiation.; ///; /// This routine is intended to be used when \p D is a declaration; /// referenced from within a template, that needs to mapped into the; /// corresponding declaration within an instantiation. For example,; /// given:; ///; /// \code; /// template<typename T>; /// struct X {; /// enum Kind {; /// KnownValue = sizeof(T); /// };; ///; /// bool getKind() const { return KnownValue; }; /// };; ///; /// template struct X<int>;; /// \endcode; ///; /// In the instantiation of X<int>::getKind(), we need to map the \p; /// EnumConstantDecl for \p KnownValue (which refers to; /// X<T>::<Kind>::KnownValue) to its instantiation (X<int>::<Kind>::KnownValue).; /// \p FindInstantiatedDecl performs this mapping from within the instantiation; /// of X<int>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:779,perform,performs,779,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['perform'],['performs']
Performance,"/// Find the maximal addressing mode that a load/store of V can fold,; /// give an access type of AccessTy. This returns a list of involved; /// instructions in AddrModeInsts.; /// \p InsertedInsts The instructions inserted by other CodeGenPrepare; /// optimizations.; /// \p PromotedInsts maps the instructions to their type before promotion.; /// \p The ongoing transaction where every action should be registered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:44,load,load,44,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,2,"['load', 'optimiz']","['load', 'optimizations']"
Performance,/// Find the nearest def or phi that `From` can legally be optimized to.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:59,optimiz,optimized,59,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['optimiz'],['optimized']
Performance,"/// Find the underlying defining instruction / operand for a COPY instruction; /// while in SSA form. Copies do not actually define values -- they move them; /// between registers. Labelling a COPY-like instruction with an instruction; /// number is to be avoided as it makes value numbers non-unique later in; /// compilation. This method follows the definition chain for any sequence of; /// COPY-like instructions to find whatever non-COPY-like instruction defines; /// the copied value; or for parameters, creates a DBG_PHI on entry.; /// May insert instructions into the entry block!; /// \p MI The copy-like instruction to salvage.; /// \p DbgPHICache A container to cache already-solved COPYs.; /// \returns An instruction/operand pair identifying the defining value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:673,cache,cache,673,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['cache'],['cache']
Performance,/// Finds all the visible declarations with a given name.; /// The current implementation of this method just loads the entire; /// lookup table as unmaterialized references.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:110,load,loads,110,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loads']
Performance,/// Finds the incoming stack arguments which overlap the given fixed stack; /// object and incorporates their load into the current chain. This prevents; /// an upcoming store from clobbering the stack argument before it's used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:110,load,load,110,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,1,['load'],['load']
Performance,"/// Finds the nearest clobber for the given query, optimizing phis if; /// possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:51,optimiz,optimizing,51,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['optimiz'],['optimizing']
Performance,"/// Finish parsing a C++ unqualified-id that is a template-id of; /// some form.; ///; /// This routine is invoked when a '<' is encountered after an identifier or; /// operator-function-id is parsed by \c ParseUnqualifiedId() to determine; /// whether the unqualified-id is actually a template-id. This routine will; /// then parse the template arguments and form the appropriate template-id to; /// return to the caller.; ///; /// \param SS the nested-name-specifier that precedes this template-id, if; /// we're actually parsing a qualified-id.; ///; /// \param ObjectType if this unqualified-id occurs within a member access; /// expression, the type of the base object whose member is being accessed.; ///; /// \param ObjectHadErrors this unqualified-id occurs within a member access; /// expression, indicates whether the original subexpressions had any errors.; ///; /// \param Name for constructor and destructor names, this is the actual; /// identifier that may be a template-name.; ///; /// \param NameLoc the location of the class-name in a constructor or; /// destructor.; ///; /// \param EnteringContext whether we're entering the scope of the; /// nested-name-specifier.; ///; /// \param Id as input, describes the template-name or operator-function-id; /// that precedes the '<'. If template arguments were parsed successfully,; /// will be updated with the template-id.; ///; /// \param AssumeTemplateId When true, this routine will assume that the name; /// refers to a template without performing name lookup to verify.; ///; /// \returns true if a parse error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1505,perform,performing,1505,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['perform'],['performing']
Performance,/// FinishCXXForRangeStmt - Attach the body to a C++0x for-range statement.; /// This is a separate step from ActOnCXXForRangeStmt because analysis of the; /// body cannot be performed until after the type of the range variable is; /// determined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:175,perform,performed,175,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['perform'],['performed']
Performance,/// Fix the shadow stack using the previously saved SSP pointer.; /// \sa emitSetJmpShadowStackFix; /// \param [in] MI The temporary Machine Instruction for the builtin.; /// \param [in] MBB The Machine Basic Block that will be modified.; /// \return The sink MBB that will perform the future indirect branch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:274,perform,perform,274,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['perform']
Performance,/// Flag indicating that all inter-connected units are loaded; /// and the dwarf linking process for these units is started.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h:55,load,loaded,55,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerImpl.h,1,['load'],['loaded']
Performance,"/// Flag indicating whether the register is actually restored in the epilog.; /// In most cases, if a register is saved, it is also restored. There are; /// some situations, though, when this is not the case. For example, the; /// LR register on ARM is usually saved, but on exit from the function its; /// saved value may be loaded directly into PC. Since liveness tracking of; /// physical registers treats callee-saved registers are live outside of; /// the function, LR would be treated as live-on-exit, even though in these; /// scenarios it is not. This flag is added to indicate that the saved; /// register described by this object is not restored in the epilog.; /// The long-term solution is to model the liveness of callee-saved registers; /// by implicit uses on the return instructions, however, the required; /// changes in the ARM backend would be quite extensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:326,load,loaded,326,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['load'],['loaded']
Performance,"/// Flag to enable/disable CodeGen. When set to true, the process stops after; /// optimizations and a bitcode is produced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:83,optimiz,optimizations,83,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['optimiz'],['optimizations']
Performance,"/// Flag to indicate that only the CodeGen will be performed, no cross-module; /// importing or optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:51,perform,performed,51,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,2,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,/// Flag to indicate that the optimizer should not assume builtins are present; /// on the target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:30,optimiz,optimizer,30,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,2,['optimiz'],['optimizer']
Performance,"/// Flags all the clients of a given node dirty. This is a separate non-inlined; /// function such that we can see in performance profiles how long this takes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx:118,perform,performance,118,roofit/roofitcore/src/RooFit/Evaluator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx,1,['perform'],['performance']
Performance,/// Flags indicating whether loads or stores have been seen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:29,load,loads,29,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,1,['load'],['loads']
Performance,/// Flags indicating whether loads or stores with no underlying objects have; /// been seen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:29,load,loads,29,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,1,['load'],['loads']
Performance,"/// Flags that indicate what kind of AST loading failures the client; /// of the AST reader can directly handle.; ///; /// When a client states that it can handle a particular kind of failure,; /// the AST reader will not emit errors when producing that kind of failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:41,load,loading,41,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loading']
Performance,/// Flush all of the statements and expressions that have; /// been added to the queue via AddStmt().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h:81,queue,queue,81,interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTRecordWriter.h,1,['queue'],['queue']
Performance,/// Flush all of the statements that have been added to the; /// queue via AddStmt().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp:65,queue,queue,65,interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterStmt.cpp,1,['queue'],['queue']
Performance,"/// Fold ""masked merge"" expressions like `(m & x) | (~m & y)` into the; /// equivalent `((x ^ y) & m) ^ y)` pattern.; /// This is typically a better representation for targets without a fused; /// ""and-not"" operation. This function is intended to be called from a; /// `TargetLowering::PerformDAGCombine` callback on `ISD::OR` nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:286,Perform,PerformDAGCombine,286,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Perform'],['PerformDAGCombine']
Performance,"/// Fold; /// (sext (select c, load x, load y)) -> (select c, sextload x, sextload y); /// (zext (select c, load x, load y)) -> (select c, zextload x, zextload y); /// (aext (select c, load x, load y)) -> (select c, extload x, extload y); /// This function is called by the DAGCombiner when visiting sext/zext/aext; /// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,load,load,31,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,6,['load'],['load']
Performance,"/// For First, Lane is the index into the first N elements of a; /// fixed-vector <N x <ElTy>> or a scalable vector <vscale x N x <ElTy>>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:100,scalab,scalable,100,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['scalab'],['scalable']
Performance,"/// For ScalableLast, Lane is the offset from the start of the last; /// N-element subvector in a scalable vector <vscale x N x <ElTy>>. For; /// example, a Lane of 0 corresponds to lane `(vscale - 1) * N`, a Lane of; /// 1 corresponds to `((vscale - 1) * N) + 1`, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:8,Scalab,ScalableLast,8,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,2,"['Scalab', 'scalab']","['ScalableLast', 'scalable']"
Performance,"/// For a filename that's not yet associated with any entry in the caches,; /// uses the underlying filesystem to either look up the entry based in the; /// shared cache indexed by unique ID, or creates new entry from scratch.; /// \p FilenameForLookup will always be an absolute path, and different than; /// \p OriginalFilename if \p OriginalFilename is relative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:67,cache,caches,67,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,2,['cache'],"['cache', 'caches']"
Performance,"/// For a given floating point load / store pair, if the load value isn't used; /// by any other operations, then consider transforming the pair to integer; /// load / store operations if the target deems the transformation profitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:31,load,load,31,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,['load'],['load']
Performance,"/// For a given statement performing a bind, attempt to syntactically; /// match the expression resulting in the bound value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:26,perform,performing,26,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['perform'],['performing']
Performance,"/// For a variable \p Var with the live-in value \p Value, attempts to resolve; /// the DbgValue to a concrete DBG_VALUE, emitting that value and loading the; /// tracking information to track Var throughout the block.; /// \p ValueToLoc is a map containing the best known location for every; /// ValueIDNum that Value may use.; /// \p MBB is the basic block that we are loading the live-in value for.; /// \p DbgOpStore is the map containing the DbgOpID->DbgOp mapping needed to; /// determine the values used by Value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:146,load,loading,146,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,2,['load'],['loading']
Performance,"/// For an inline function definition in C, or for a gnu_inline function; /// in C++, determine whether the definition will be externally visible.; ///; /// Inline function definitions are always available for inlining optimizations.; /// However, depending on the language dialect, declaration specifiers, and; /// attributes, the definition of an inline function may or may not be; /// ""externally"" visible to other translation units in the program.; ///; /// In C99, inline definitions are not externally visible by default. However,; /// if even one of the global-scope declarations is marked ""extern inline"", the; /// inline definition becomes externally visible (C99 6.7.4p6).; ///; /// In GNU89 mode, or if the gnu_inline attribute is attached to the function; /// definition, we use the GNU semantics for inline, which are nearly the; /// opposite of C99 semantics. In particular, ""inline"" by itself will create; /// an externally visible symbol, but ""extern inline"" will not create an; /// externally visible symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:219,optimiz,optimizations,219,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['optimiz'],['optimizations']
Performance,"/// For consumptions, just emit the subexpression and perform the; /// consumption like normal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:54,perform,perform,54,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['perform'],['perform']
Performance,"/// For each 16-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the word in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the word in the second source is positive,; /// copy the corresponding word from the first source to the destination. If; /// the word in the second source is zero, clear the corresponding word in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGNW instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control words corresponding to; /// positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,perform,perform,57,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,1,['perform'],['perform']
Performance,"/// For each 16-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the word in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the word in the second source is positive,; /// copy the corresponding word from the first source to the destination. If; /// the word in the second source is zero, clear the corresponding word in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNW instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control words corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,perform,perform,57,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,1,['perform'],['perform']
Performance,"/// For each 32-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the doubleword in the second source is negative, calculate the two's; /// complement of the corresponding doubleword in the first source, and; /// write that value to the destination. If the doubleword in the second; /// source is positive, copy the corresponding doubleword from the first; /// source to the destination. If the doubleword in the second source is; /// zero, clear the corresponding doubleword in the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGND instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing two control doublewords corresponding; /// to positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,perform,perform,57,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,1,['perform'],['perform']
Performance,"/// For each 32-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the doubleword in the second source is negative, calculate the two's; /// complement of the corresponding word in the first source, and write that; /// value to the destination. If the doubleword in the second source is; /// positive, copy the corresponding word from the first source to the; /// destination. If the doubleword in the second source is zero, clear the; /// corresponding word in the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGND instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control doublewords corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:57,perform,perform,57,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,1,['perform'],['perform']
Performance,"/// For each 8-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the byte in the second source is negative, calculate the two's; /// complement of the corresponding byte in the first source, and write that; /// value to the destination. If the byte in the second source is positive,; /// copy the corresponding byte from the first source to the destination. If; /// the byte in the second source is zero, clear the corresponding byte in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PSIGNB instruction.; ///; /// \param __a; /// A 64-bit integer vector containing the values to be copied.; /// \param __b; /// A 64-bit integer vector containing control bytes corresponding to; /// positions in the destination.; /// \returns A 64-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:56,perform,perform,56,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,1,['perform'],['perform']
Performance,"/// For each 8-bit integer in the first source operand, perform one of; /// the following actions as specified by the second source operand.; ///; /// If the byte in the second source is negative, calculate the two's; /// complement of the corresponding byte in the first source, and write that; /// value to the destination. If the byte in the second source is positive,; /// copy the corresponding byte from the first source to the destination. If; /// the byte in the second source is zero, clear the corresponding byte in; /// the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c VPSIGNB instruction.; ///; /// \param __a; /// A 128-bit integer vector containing the values to be copied.; /// \param __b; /// A 128-bit integer vector containing control bytes corresponding to; /// positions in the destination.; /// \returns A 128-bit integer vector containing the resultant values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h:56,perform,perform,56,interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tmmintrin.h,1,['perform'],['perform']
Performance,"/// For each allocation in LoadedSLocEntryTable, we keep the first FileID.; /// We assume exactly one allocation per AST file, and use that to determine; /// whether two FileIDs come from the same AST file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:27,Load,LoadedSLocEntryTable,27,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['Load'],['LoadedSLocEntryTable']
Performance,"/// For each indexed mode and each value type, keep a quad of LegalizeAction; /// that indicates how instruction selection should deal with the load /; /// store / maskedload / maskedstore.; ///; /// The first dimension is the value_type for the reference. The second; /// dimension represents the various modes for load store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:144,load,load,144,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],['load']
Performance,"/// For each load extension type and each value type, keep a LegalizeAction; /// that indicates how instruction selection should deal with a load of a; /// specific value type and extension type. Uses 4-bits to store the action; /// for each of the 4 load ext types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:13,load,load,13,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,3,['load'],['load']
Performance,"/// For each store we execute, we update this map. Loads check this to get; /// the most up-to-date value. If evaluation is successful, this state is; /// committed to the process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h:51,Load,Loads,51,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h,1,['Load'],['Loads']
Performance,"/// For field list members which have been parsed and cached, stores a mapping; /// from (IndexOfClass, MemberIndex) to the corresponding SymIndexId of the; /// cached symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h:54,cache,cached,54,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,2,['cache'],['cached']
Performance,"/// For instructions where an immediate operand could be split into two; /// separate immediate instructions, use the splitTwoPartImm two handle the; /// optimization.; ///; /// To implement, the following function types must be passed to; /// splitTwoPartImm. A SplitAndOpcFunc must be implemented that determines if; /// splitting the immediate is valid and returns the associated new opcode. A; /// BuildMIFunc must be implemented to build the two immediate instructions.; ///; /// Example Pattern (where IMM would require 2+ MOV instructions):; /// %dst = <Instr>rr %src IMM [...]; /// becomes:; /// %tmp = <Instr>ri %src (encode half IMM) [...]; /// %dst = <Instr>ri %tmp (encode half IMM) [...]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp:154,optimiz,optimization,154,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MIPeepholeOpt.cpp,1,['optimiz'],['optimization']
Performance,"/// For reclaims, perform an unsafeClaim if that's enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:18,perform,perform,18,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['perform'],['perform']
Performance,"/// For the given DC, return the DC that is safe to perform lookups on. This is; /// the DC we actually want to work with most of the time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:52,perform,perform,52,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,1,['perform'],['perform']
Performance,"/// For the given dangling debuginfo record, perform last-ditch efforts to; /// resolve the debuginfo to something that is represented in this DAG. If; /// this cannot be done, produce an Undef debug value record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:45,perform,perform,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,1,['perform'],['perform']
Performance,"/// For type records from the TPI stream which have been paresd and cached,; /// stores a mapping to SymIndexId of the cached symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h:68,cache,cached,68,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/SymbolCache.h,2,['cache'],['cached']
Performance,/// ForceUnitLatencies - Return true if all scheduling edges should be given; /// a latency value of one. The default is to return false; schedulers may; /// override this as needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h:84,latency,latency,84,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.h,1,['latency'],['latency']
Performance,"/// Form a template name from a name that is syntactically required to name a; /// template, either due to use of the 'template' keyword or because a name in; /// this syntactic context is assumed to name a template (C++ [temp.names]p2-4).; ///; /// This action forms a template name given the name of the template and its; /// optional scope specifier. This is used when the 'template' keyword is used; /// or when the parsing context unambiguously treats a following '<' as; /// introducing a template argument list. Note that this may produce a; /// non-dependent template name if we can perform the lookup now and identify; /// the named template.; ///; /// For example, given ""x.MetaFun::template apply"", the scope specifier; /// \p SS will be ""MetaFun::"", \p TemplateKWLoc contains the location; /// of the ""template"" keyword, and ""apply"" is the \p Name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:591,perform,perform,591,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['perform'],['perform']
Performance,/// FormSVEBuiltinResult - Returns the struct of scalable vectors as a wider; /// vector. It extracts the scalable vector from the struct and inserts into; /// the wider vector. This avoids the error when allocating space in llvm; /// for struct of scalable vectors if a function returns struct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:49,scalab,scalable,49,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,3,['scalab'],['scalable']
Performance,/// Forward iterator end-point to traverse all loaded modules,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:47,load,loaded,47,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,/// Forward iterator to traverse all loaded modules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:37,load,loaded,37,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,"/// Fraction of the number of nodes to optimize per iteration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/reinsertion_optimizer.h:39,optimiz,optimize,39,geom/geom/inc/bvh/v2/reinsertion_optimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/reinsertion_optimizer.h,1,['optimiz'],['optimize']
Performance,"/// FreshBBs is like worklist, it collected the updated BBs which need; /// to be optimized again.; /// Note: Consider building time in this pass, when a BB updated, we need; /// to insert such BB into FreshBBs for huge function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:82,optimiz,optimized,82,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimized']
Performance,"/// From the list of IRSimilarityCandidates, perform a comparison between each; /// IRSimilarityCandidate to determine if there are overlapping; /// IRInstructionData, or if they do not have the same structure.; ///; /// \param [in] CandsForRepSubstring - The vector containing the; /// IRSimilarityCandidates.; /// \param [out] StructuralGroups - the mapping of unsigned integers to vector; /// of IRSimilarityCandidates where each of the IRSimilarityCandidates in the; /// vector are structurally similar to one another.; /// \param [in] IndexToIncludedCand - Mapping of index of the an instruction in; /// a circuit to the IRSimilarityCandidates that include this instruction.; /// \param [in] CandToOverallGroup - Mapping of IRSimilarityCandidate to a; /// number representing the structural group assigned to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp:45,perform,perform,45,interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IRSimilarityIdentifier.cpp,1,['perform'],['perform']
Performance,/// Function for getting the dependency preprocessor directives of a file.; ///; /// These are directives derived from a special form of lexing where the; /// source input is scanned for the preprocessor directives that might have an; /// effect on the dependencies for a compilation unit.; ///; /// Enables a client to cache the directives for a file and provide them; /// across multiple compiler invocations.; /// FIXME: Allow returning an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:320,cache,cache,320,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,1,['cache'],['cache']
Performance,"/// Function performing the actual merge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:13,perform,performing,13,hist/hist/src/TH1Merger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx,1,['perform'],['performing']
Performance,/// Function that will perform the actual internalization. The reason for a; /// callback is that the linker cannot call internalizeModule without; /// creating a circular dependency between IPO and the linker.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp:23,perform,perform,23,interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/LinkModules.cpp,1,['perform'],['perform']
Performance,"/// Function to construct a VFInfo out of a mangled names in the; /// following format:; ///; /// <VFABI_name>{(<redirection>)}; ///; /// where <VFABI_name> is the name of the vector function, mangled according; /// to the rules described in the Vector Function ABI of the target vector; /// extension (or <isa> from now on). The <VFABI_name> is in the following; /// format:; ///; /// _ZGV<isa><mask><vlen><parameters>_<scalarname>[(<redirection>)]; ///; /// This methods support demangling rules for the following <isa>:; ///; /// * AArch64: https://developer.arm.com/docs/101129/latest; ///; /// * x86 (libmvec): https://sourceware.org/glibc/wiki/libmvec and; /// https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&do=view&target=VectorABI.txt; ///; /// \param MangledName -> input string in the format; /// _ZGV<isa><mask><vlen><parameters>_<scalarname>[(<redirection>)].; /// \param FTy -> FunctionType of the scalar function which we're trying to find; /// a vectorized variant for. This is required to determine the vectorization; /// factor for scalable vectors, since the mangled name doesn't encode that;; /// it needs to be derived from the widest element types of vector arguments; /// or return values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h:1062,scalab,scalable,1062,interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/VFABIDemangler.h,1,['scalab'],['scalable']
Performance,/// Function to perform atomic copies of C++ objects with nontrivial copy; /// constructors from Objective-C ivars.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:16,perform,perform,16,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['perform'],['perform']
Performance,/// Function to perform atomic copies of C++ objects with nontrivial copy; /// constructors to Objective-C ivars.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:16,perform,perform,16,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['perform'],['perform']
Performance,"/// Functions that attempt to perform the combining. They detect if that is; /// legal, and if so they update the inputs \a Inputs and the offload action; /// that were collapsed in \a CollapsedOffloadAction. A tool that deals with; /// the combined action is returned. If the combining is not legal or if the; /// tool does not exist, null is returned.; /// Currently three kinds of collapsing are supported:; /// - Assemble + Backend + Compile;; /// - Assemble + Backend ;; /// - Backend + Compile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:30,perform,perform,30,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['perform'],['perform']
Performance,/// Functor for receiving object-loaded notifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h:33,load,loaded,33,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h,1,['load'],['loaded']
Performance,/// Fuse address generation and loads or stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MacroFusion.cpp:32,load,loads,32,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MacroFusion.cpp,1,['load'],['loads']
Performance,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:559,perform,performed,559,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['perform'],['performed']
Performance,/// GCLowering Pass - Used by gc.root to perform its default lowering; /// operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:41,perform,perform,41,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,2,['perform'],['perform']
Performance,"/// GC_TRANSITION_START/GC_TRANSITION_END - These operators mark the; /// beginning and end of GC transition sequence, and carry arbitrary; /// information that target might need for lowering. The first operand is; /// a chain, the rest are specified by the target and not touched by the DAG; /// optimizers. GC_TRANSITION_START..GC_TRANSITION_END pairs may not be; /// nested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:297,optimiz,optimizers,297,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['optimiz'],['optimizers']
Performance,"/// GPRC = TOC_ENTRY GA, TOC; /// Loads the entry for GA from the TOC, where the TOC base is given by; /// the last operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:34,Load,Loads,34,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['Load'],['Loads']
Performance,"/// GPRC, CHAIN = LBRX CHAIN, Ptr, Type - This is a; /// byte-swapping load instruction. It loads ""Type"" bits, byte swaps it,; /// then puts it in the bottom bits of the GPRC. TYPE can be either i16; /// or i32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:71,load,load,71,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,2,['load'],"['load', 'loads']"
Performance,"/// GPRC, CHAIN = LFIWAX CHAIN, Ptr - This is a floating-point; /// load which sign-extends from a 32-bit integer value into the; /// destination 64-bit register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:68,load,load,68,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['load'],['load']
Performance,"/// GPRC, CHAIN = LFIWZX CHAIN, Ptr - This is a floating-point; /// load which zero-extends from a 32-bit integer value into the; /// destination 64-bit register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:68,load,load,68,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['load'],['load']
Performance,"/// GPRC, CHAIN = LXSIZX, CHAIN, Ptr, ByteWidth - This is a load of an; /// integer smaller than 64 bits into a VSR. The integer is zero-extended.; /// This can be used for converting loaded integers to floating point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:60,load,load,60,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,2,['load'],"['load', 'loaded']"
Performance,"/// Gather information about the function, returns false if we can't perform; /// this optimization for some reason.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CompressJumpTables.cpp:69,perform,perform,69,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CompressJumpTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CompressJumpTables.cpp,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"/// Gather the information that is difficult to gather for an Instruction, or; /// is changed. i.e. the operands of an Instruction and the Types of those; /// operands. This extra information allows for similarity matching to make; /// assertions that allow for more flexibility when checking for whether an; /// Instruction performs the same operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:325,perform,performs,325,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,1,['perform'],['performs']
Performance,"/// Gathers eight 32-bit floating-point values from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256 _mm256_i32gather_ps(const float *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x float] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:585,load,loading,585,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers eight 32-bit floating-point values from memory \a m using scaled; /// indexes from the 256-bit vector of [8 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 7; /// j := element*32; /// k := element*32; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_i32gather_epi32(const int *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [8 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [8 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:587,load,loading,587,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers four 32-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_i32gather_ps(const float *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPS instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:581,load,loading,581,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers four 32-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*32; /// result[j+31:j] := Load32(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_i32gather_epi32(const int *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:583,load,loading,583,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers four 32-bit floating-point values from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// result[j+31:j] := Load32(m + SignExtend(i[k+64:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm256_i64gather_ps(const float *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:584,load,loading,584,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers four 32-bit integer values from memory \a m using scaled indexes; /// from the 256-bit vector of [4 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*32; /// k := element*64; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm256_i64gather_epi32(const int *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:579,load,loading,579,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers four 64-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_i32gather_pd(const double *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:586,load,loading,586,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers four 64-bit floating-point values from memory \a m using scaled; /// indexes from the 256-bit vector of [4 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256d _mm256_i64gather_pd(const double *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x double] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:586,load,loading,586,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers four 64-bit integer values from memory \a m using scaled indexes; /// from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*32; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_i32gather_epi64(const long long *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:585,load,loading,585,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers four 64-bit integer values from memory \a m using scaled indexes; /// from the 256-bit vector of [4 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 3; /// j := element*64; /// k := element*64; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m256i _mm256_i64gather_epi64(const long long *m, __m256i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 256-bit vector of [4 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 256-bit vector of [4 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:585,load,loading,585,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers two 32-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i. The upper two; /// elements of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128 _mm_i64gather_ps(const float *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPS instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x float] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:659,load,loading,659,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers two 32-bit integer values from memory \a m using scaled indexes; /// from the 128-bit vector of [2 x i64] in \a i. The upper two elements; /// of the result are zeroed.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*32; /// k := element*64; /// result[j+31:j] := Load32(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// result[127:64] := 0; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_i64gather_epi32(const int *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [4 x i32] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:654,load,loading,654,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers two 64-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [2 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_i64gather_pd(const double *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERQPD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:582,load,loading,582,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers two 64-bit floating-point values from memory \a m using scaled; /// indexes from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128d _mm_i32gather_pd(const double *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VGATHERDPD instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x double] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:582,load,loading,582,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers two 64-bit integer values from memory \a m using scaled indexes; /// from the 128-bit vector of [2 x i64] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*64; /// result[j+63:j] := Load64(m + SignExtend(i[k+63:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_i64gather_epi64(const long long *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERQQ instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [2 x i64] containing signed indexes into \a m.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:581,load,loading,581,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// Gathers two 64-bit integer values from memory \a m using scaled indexes; /// from the 128-bit vector of [4 x i32] in \a i.; ///; /// \code{.operation}; /// FOR element := 0 to 1; /// j := element*64; /// k := element*32; /// result[j+63:j] := Load64(m + SignExtend(i[k+31:k])*s); /// ENDFOR; /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_i32gather_epi64(const long long *m, __m128i i, const int s);; /// \endcode; ///; /// This intrinsic corresponds to the \c VPGATHERDQ instruction.; ///; /// \param m; /// A pointer to the memory used for loading values.; /// \param i; /// A 128-bit vector of [4 x i32] containing signed indexes into \a m. Only; /// the first two elements are used.; /// \param s; /// A literal constant scale factor for the indexes in \a i. Must be; /// 1, 2, 4, or 8.; /// \returns A 128-bit vector of [2 x i64] containing the gathered values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:581,load,loading,581,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,1,['load'],['loading']
Performance,"/// General implementation of bulk read. Loop over the required range and read values that are required; /// and not already present. Derived classes may implement more optimized versions of this method.; /// See ReadBulk() for the return value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:169,optimiz,optimized,169,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['optimiz'],['optimized']
Performance,"/// Generate a function preamble for a method with the specified; /// types.; // FIXME: Current this just generates the Function definition, but really this; // should also be generating the loads of the parameters, as the runtime; // should have full control over how parameters are passed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h:191,load,loads,191,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,1,['load'],['loads']
Performance,/// Generate an Objective-C message send operation.; ///; /// This variant allows for the call to be substituted with an optimized; /// variant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h:121,optimiz,optimized,121,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,1,['optimiz'],['optimized']
Performance,/// Generate an equality comparison for one or more pairs of loaded values.; /// This is used in the case where the memcmp() call is compared equal or not; /// equal to zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp:61,load,loaded,61,interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ExpandMemCmp.cpp,1,['load'],['loaded']
Performance,/// Generate control flow and cleanup for cancellation.; ///; /// \param CancelFlag Flag indicating if the cancellation is performed.; /// \param CanceledDirective The kind of directive that is cancled.; /// \param ExitCB Extra code to be generated in the exit block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:123,perform,performed,123,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['perform'],['performed']
Performance,"/// Generate diagnostics for an invalid function redeclaration.; ///; /// This routine handles generating the diagnostic messages for an invalid; /// function redeclaration, including finding possible similar declarations; /// or performing typo correction if there are no previous declarations with; /// the same name.; ///; /// Returns a NamedDecl iff typo correction was performed and substituting in; /// the new declaration name does not cause new errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:230,perform,performing,230,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['perform'],"['performed', 'performing']"
Performance,/// Generate llvm.loop.parallel metadata for loads and stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.h:45,load,loads,45,interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.h,1,['load'],['loads']
Performance,/// Generate the checks and store it. This also performs the grouping; /// of pointers to reduce the number of memchecks necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:48,perform,performs,48,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['perform'],['performs']
Performance,"/// Generate the parameters to tune the inline cost analysis based on command; /// line options. If -inline-threshold option is not explicitly passed,; /// \p Threshold is used as the default threshold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:31,tune,tune,31,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,1,['tune'],['tune']
Performance,"/// Generate the parameters to tune the inline cost analysis based on command; /// line options. If -inline-threshold option is not explicitly passed,; /// the default threshold is computed from \p OptLevel and \p SizeOptLevel.; /// An \p OptLevel value above 3 is considered an aggressive optimization mode.; /// \p SizeOptLevel of 1 corresponds to the -Os flag and 2 corresponds to; /// the -Oz flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:31,tune,tune,31,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,2,"['optimiz', 'tune']","['optimization', 'tune']"
Performance,/// Generate the parameters to tune the inline cost analysis based only on the; /// commandline options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:31,tune,tune,31,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,1,['tune'],['tune']
Performance,/// Generate the sequence of instructions to load the slice; /// represented by this object and redirect the uses of this slice to; /// this new sequence of instructions.; /// \pre this->Inst && this->Origin are valid Instructions and this; /// object passed the legal check: LoadedSlice::isLegal returned true.; /// \return The last instruction of the sequence used to load the slice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:45,load,load,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,"['Load', 'load']","['LoadedSlice', 'load']"
Performance,"/// Generate the wide load or store, and shuffles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:22,load,load,22,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['load'],['load']
Performance,/// Generate the wide load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:22,load,load,22,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['load'],['load']
Performance,"/// Generates IR to load shadow and origin corresponding to bytes [\p; /// Addr, \p Addr + \p Size), where addr has alignment \p; /// InstAlignment, and take the union of each of those shadows. The returned; /// shadow always has primitive type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:20,load,load,20,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['load'],['load']
Performance,"/// Generates IR to load shadow and origin corresponding to bytes [\p; /// Addr, \p Addr + \p Size), where addr has alignment \p; /// InstAlignment, and take the union of each of those shadows. The returned; /// shadow always has primitive type.; ///; /// When tracking loads is enabled, the returned origin is a chain at the; /// current stack if the returned shadow is tainted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:20,load,load,20,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,2,['load'],"['load', 'loads']"
Performance,"/// Generates the TargetMachine.; /// Leaves TM unchanged if it is unable to create the target machine.; /// Some of our clang tests specify triples which are not built; /// into clang. This is okay because these tests check the generated; /// IR, and they require DataLayout which depends on the triple.; /// In this case, we allow this method to fail and not report an error.; /// When MustCreateTM is used, we print an error if we are unable to load; /// the requested target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:448,load,load,448,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['load'],['load']
Performance,"/// Generic LiveDebugValues pass. Calls through to VarLocBasedLDV or; /// InstrRefBasedLDV to perform location propagation, via the LDVImpl; /// base class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp:94,perform,perform,94,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/LiveDebugValues.cpp,1,['perform'],['perform']
Performance,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:104,load,load,104,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,2,['load'],['load']
Performance,"/// Generic reduction nodes. These nodes represent horizontal vector; /// reduction operations, producing a scalar result.; /// The SEQ variants perform reductions in sequential order. The first; /// operand is an initial scalar accumulator value, and the second operand; /// is the vector to reduce.; /// E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, <4 x f32> SRC_VEC; /// ... is equivalent to; /// RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:145,perform,perform,145,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['perform'],['perform']
Performance,/// Generic_GCC - A tool chain using the 'gcc' command to perform; /// all subcommands; this relies on gcc translating the majority of; /// command line options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:58,perform,perform,58,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,1,['perform'],['perform']
Performance,"/// Generic_GCC - A tool chain using the 'gcc' command to perform; /// all subcommands; this relies on gcc translating the majority of; /// command line options.; /// Less-than for GCCVersion, implementing a Strict Weak Ordering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:58,perform,perform,58,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['perform'],['perform']
Performance,/// Get a cached analysis result or return null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:10,cache,cached,10,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['cached']
Performance,"/// Get a cached analysis. If the analysis can be invalidated, this will; /// assert.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:10,cache,cached,10,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['cached']
Performance,"/// Get a global palette by name. Returns an empty palette if no palette with that name is known.; /// This function is not thread safe; any concurrent call to global Palette manipulation must be synchronized!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPalette.hxx:141,concurren,concurrent,141,graf2d/gpadv7/inc/ROOT/RPalette.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPalette.hxx,1,['concurren'],['concurrent']
Performance,"/// Get a human-readable name for the declaration, even if it is one of the; /// special kinds of names (C++ constructor, Objective-C selector, etc).; ///; /// Creating this name requires expensive string manipulation, so it should; /// be called only when performance doesn't matter. For simple declarations,; /// getNameAsCString() should suffice.; //; // FIXME: This function should be renamed to indicate that it is not just an; // alternate form of getName(), and clients should move as appropriate.; //; // FIXME: Deprecated, move clients to getName().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:257,perform,performance,257,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['perform'],['performance']
Performance,"/// Get a lazy one-at-time loading module from bitcode.; ///; /// This isn't always used in a lazy context. In particular, it's also used by; /// \a parseModule(). If this is truly lazy, then we need to eagerly pull; /// in forward-referenced functions from block address references.; ///; /// \param[in] MaterializeAll Set to \c true if we should materialize; /// everything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:27,load,loading,27,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['load'],['loading']
Performance,/// Get a loaded SLocEntry. This is exposed for indexing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:10,load,loaded,10,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,/// Get a low-level scalable vector of some number of elements and element; /// type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:20,scalab,scalable,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,1,['scalab'],['scalable']
Performance,/// Get a low-level scalable vector of some number of elements and element; /// width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:20,scalab,scalable,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,1,['scalab'],['scalable']
Performance,"/// Get a unique name, not currently exisiting in the filesystem. Subject; /// to race conditions, prefer to use createUniqueFile instead.; ///; /// Similar to createUniqueFile, but instead of creating a file only; /// checks if it exists. This function is subject to race conditions, if you; /// want to use the returned name to actually create a file, use; /// createUniqueFile instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:82,race condition,race conditions,82,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,['race condition'],['race conditions']
Performance,"/// Get a unique temporary file name, not currently exisiting in the; /// filesystem. Subject to race conditions, prefer to use createTemporaryFile; /// instead.; ///; /// Similar to createTemporaryFile, but instead of creating a file only; /// checks if it exists. This function is subject to race conditions, if you; /// want to use the returned name to actually create a file, use; /// createTemporaryFile instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:97,race condition,race conditions,97,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,2,['race condition'],['race conditions']
Performance,/// Get all the loads/store uses for global variable \p GV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:16,load,loads,16,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['load'],['loads']
Performance,"/// Get an access that keeps us from optimizing to the given phi.; ///; /// PausedSearches is an array of indices into the Paths array. Its incoming; /// value is the indices of searches that stopped at the last phi optimization; /// target. It's left in an unspecified state.; ///; /// If this returns std::nullopt, NewPaused is a vector of searches that; /// terminated at StopWhere. Otherwise, NewPaused is left in an unspecified; /// state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:37,optimiz,optimizing,37,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,2,['optimiz'],"['optimization', 'optimizing']"
Performance,"/// Get executor class for multi-thread usage; /// In case when MT is not enabled will return a serial executor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Config.h:27,multi-thread,multi-thread,27,tmva/tmva/inc/TMVA/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/Config.h,1,['multi-thread'],['multi-thread']
Performance,"/// Get maximum # of load operations permitted for memcmp; ///; /// This function returns the maximum number of load operations permitted; /// to replace a call to memcmp. The value is set by the target at the; /// performance threshold for such a replacement. If OptSize is true,; /// return the limit for functions that have OptSize attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:21,load,load,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,3,"['load', 'perform']","['load', 'performance']"
Performance,"/// Get maximum # of store operations permitted for llvm.memcpy; ///; /// This function returns the maximum number of store operations permitted; /// to replace a call to llvm.memcpy. The value is set by the target at the; /// performance threshold for such a replacement. If OptSize is true,; /// return the limit for functions that have OptSize attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:227,perform,performance,227,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['performance']
Performance,"/// Get maximum # of store operations permitted for llvm.memmove; ///; /// This function returns the maximum number of store operations permitted; /// to replace a call to llvm.memmove. The value is set by the target at the; /// performance threshold for such a replacement. If OptSize is true,; /// return the limit for functions that have OptSize attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:229,perform,performance,229,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['performance']
Performance,"/// Get maximum # of store operations permitted for llvm.memset; ///; /// This function returns the maximum number of store operations permitted; /// to replace a call to llvm.memset. The value is set by the target at the; /// performance threshold for such a replacement. If OptSize is true,; /// return the limit for functions that have OptSize attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:227,perform,performance,227,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['performance']
Performance,"/// Get the 'stat' information for the specified path, using the cache; /// to accelerate it if possible.; ///; /// \returns \c true if the path does not exist or \c false if it exists.; ///; /// If isFile is true, then this lookup should only return success for files; /// (not directories). If it is false this lookup should only return; /// success for directories (not files). On a successful file lookup, the; /// implementation can optionally fill in \p F with a valid \p File object and; /// the client guarantees that it will close it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h:65,cache,cache,65,interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileSystemStatCache.h,1,['cache'],['cache']
Performance,"/// Get the DWARF discriminator.; ///; /// DWARF discriminators distinguish identical file locations between; /// instructions that are on different basic blocks.; ///; /// There are 3 components stored in discriminator, from lower bits:; ///; /// Base discriminator: assigned by AddDiscriminators pass to identify IRs; /// that are defined by the same source line, but; /// different basic blocks.; /// Duplication factor: assigned by optimizations that will scale down; /// the execution frequency of the original IR.; /// Copy Identifier: assigned by optimizations that clones the IR.; /// Each copy of the IR will be assigned an identifier.; ///; /// Encoding:; ///; /// The above 3 components are encoded into a 32bit unsigned integer in; /// order. If the lowest bit is 1, the current component is empty, and the; /// next component will start in the next bit. Otherwise, the current; /// component is non-empty, and its content starts in the next bit. The; /// value of each components is either 5 bit or 12 bit: if the 7th bit; /// is 0, the bit 2~6 (5 bits) are used to represent the component; if the; /// 7th bit is 1, the bit 2~6 (5 bits) and 8~14 (7 bits) are combined to; /// represent the component. Thus, the number of bits used for a component; /// is either 0 (if it and all the next components are empty); 1 - if it is; /// empty; 7 - if its value is up to and including 0x1f (lsb and msb are both; /// 0); or 14, if its value is up to and including 0x1ff. Note that the last; /// component is also capped at 0x1ff, even in the case when both first; /// components are 0, and we'd technically have 29 bits available.; ///; /// For precise control over the data being encoded in the discriminator,; /// use encodeDiscriminator/decodeDiscriminator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h:436,optimiz,optimizations,436,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfoMetadata.h,2,['optimiz'],['optimizations']
Performance,/// Get the EEW for a load or store instruction. Return std::nullopt if MI is; /// not a load or store which ignores SEW.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:22,load,load,22,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,2,['load'],['load']
Performance,"/// Get the FileEntryRef for stdin, returning an error if stdin cannot be; /// read.; ///; /// This reads and caches stdin before returning. Subsequent calls return the; /// same file entry, and a reference to the cached input is returned by calls; /// to getBufferForFile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:110,cache,caches,110,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,2,['cache'],"['cached', 'caches']"
Performance,"/// Get the action definition builder for the given set of opcodes. Use this; /// to define the action definitions for multiple opcodes at once. The first; /// opcode given will be considered the representative opcode and will hold; /// the definitions whereas the other opcodes will be configured to refer to; /// the representative opcode. This lowers memory requirements and very; /// slightly improves performance.; ///; /// It would be very easy to introduce unexpected side-effects as a result of; /// this aliasing if it were permitted to request different but intersecting; /// sets of opcodes but that is difficult to keep track of. It is therefore an; /// error to request the same opcode twice using this API, to request an; /// opcode that already has definitions, or to use the single-opcode API on an; /// opcode that has already been requested by this API.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:406,perform,performance,406,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['perform'],['performance']
Performance,/// Get the alignment of the load used for this slice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:29,load,load,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['load']
Performance,/// Get the base register and byte offset of a load/store instr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:47,load,load,47,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,2,['load'],['load']
Performance,"/// Get the cached assumptions for a function.; ///; /// If no assumptions are cached, this will scan the function. Otherwise, the; /// existing cache will be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:12,cache,cached,12,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,3,['cache'],"['cache', 'cached']"
Performance,/// Get the cached result of an analysis pass for a Function.; ///; /// This method never runs the analysis.; ///; /// \returns null if there is no cached result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:12,cache,cached,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,2,['cache'],['cached']
Performance,/// Get the cached result of an analysis pass for a MachineFunction.; ///; /// This method never runs the analysis.; ///; /// returns null if there is no cached result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:12,cache,cached,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,2,['cache'],['cached']
Performance,/// Get the cached result of an analysis pass for a Module.; ///; /// This method never runs the analysis.; ///; /// \returns null if there is no cached result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:12,cache,cached,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,2,['cache'],['cached']
Performance,/// Get the cached result of an analysis pass for a given IR unit.; ///; /// This method never runs the analysis.; ///; /// \returns null if there is no cached result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:12,cache,cached,12,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,2,['cache'],['cached']
Performance,"/// Get the connection level of a subtree.; ///; /// For bottom-up trees, the connection level is the latency depth (in cycles); /// of the deepest connection to another subtree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:102,latency,latency,102,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,1,['latency'],['latency']
Performance,/// Get the correct cursor and offset for loading a declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:42,load,loading,42,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['load'],['loading']
Performance,/// Get the correct cursor and offset for loading a type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:42,load,loading,42,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['load'],['loading']
Performance,/// Get the definition register of the loaded value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h:39,load,loaded,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,2,['load'],['loaded']
Performance,"/// Get the directory used for cached reads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:31,cache,cached,31,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['cache'],['cached']
Performance,"/// Get the directory where installed packages should put their; /// machine-local cache, e.g. $XDG_CACHE_HOME.; ///; /// @param result Holds the resulting path name.; /// @result True if the appropriate path was determined, it need not exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Path.h:83,cache,cache,83,interpreter/llvm-project/llvm/include/llvm/Support/Path.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Path.h,1,['cache'],['cache']
Performance,/// Get the filename of the loaded plugin.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h:28,load,loaded,28,interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,1,['load'],['loaded']
Performance,"/// Get the full function info for an address.; ///; /// This should be called when a client will store a copy of the complete; /// FunctionInfo for a given address. For one off lookups, use the lookup(); /// function below.; ///; /// Symbolication server processes might want to parse the entire function; /// info for a given address and cache it if the process stays around to; /// service many symbolication addresses, like for parsing profiling; /// information.; ///; /// \param Addr A virtual address from the orignal object file to lookup.; ///; /// \returns An expected FunctionInfo that contains the function info object; /// or an error object that indicates reason for failing to lookup the; /// address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:340,cache,cache,340,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['cache'],['cache']
Performance,/// Get the index ID for the loaded SourceLocation offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:29,load,loaded,29,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,/// Get the index ID for the loaded SourceLocation offset.; ///; /// \returns Invalid index ID (0) if an error occurred that prevented the; /// SLocEntry from being loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:29,load,loaded,29,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,2,['load'],['loaded']
Performance,"/// Get the initializations to perform when importing a module, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:31,perform,perform,31,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['perform'],['perform']
Performance,"/// Get the loaded lookup tables for \p Primary, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:12,load,loaded,12,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// Get the location for the currently active ""\#pragma clang optimize; /// off"". If this location is invalid, then the state of the pragma is ""on"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:62,optimiz,optimize,62,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['optimiz'],['optimize']
Performance,"/// Get the location of the last cached token, suitable for setting the end; /// location of an annotation token.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:33,cache,cached,33,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['cache'],['cached']
Performance,/// Get the maximum error permitted by this operation in ULPs. An accuracy of; /// 0.0 means that the operation should be performed with the default; /// precision.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Operator.h:122,perform,performed,122,interpreter/llvm-project/llvm/include/llvm/IR/Operator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Operator.h,1,['perform'],['performed']
Performance,"/// Get the number of latency cycles ""covered"" by the scheduled; /// instructions. This is the larger of the critical path within the zone; /// and the number of cycles required to issue the instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:22,latency,latency,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['latency'],['latency']
Performance,/// Get the number of loaded SLocEntries we have.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:22,load,loaded,22,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,"/// Get the padding size that must be inserted before this fragment.; /// Used for bundling. By default, no padding is inserted.; /// Note that padding size is restricted to 8 bits. This is an optimization; /// to reduce the amount of space used for each fragment. In practice, larger; /// padding should never be required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h:193,optimiz,optimization,193,interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCFragment.h,1,['optimiz'],['optimization']
Performance,/// Get the primary declaration for a declaration from an AST file. That; /// will be the first-loaded declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h:96,load,loaded,96,interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,1,['load'],['loaded']
Performance,"/// Get the process's page size.; /// This may fail if the underlying syscall returns an error. In most cases,; /// page size information is used for optimization, and this error can be; /// safely discarded by calling consumeError, and an estimated page size; /// substituted instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:150,optimiz,optimization,150,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,1,['optimiz'],['optimization']
Performance,/// Get the result of an analysis pass for a Function.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:88,cache,cached,88,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,1,['cache'],['cached']
Performance,/// Get the result of an analysis pass for a MachineFunction.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:95,cache,cached,95,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,1,['cache'],['cached']
Performance,/// Get the result of an analysis pass for a Module.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h:86,cache,cached,86,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachinePassManager.h,1,['cache'],['cached']
Performance,/// Get the result of an analysis pass for a given IR unit.; ///; /// Runs the analysis if a cached result is not available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:93,cache,cached,93,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['cached']
Performance,/// Get the scale factor applied to the immediate in the given load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:63,load,load,63,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,1,['load'],['load']
Performance,/// Get the size of the offset supported by the given load/store/inline asm.; /// The result includes the effects of any scale factors applied to the; /// instruction immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp:54,load,load,54,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSERegisterInfo.cpp,1,['load'],['load']
Performance,/// Get the size of the slice to be loaded in bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:36,load,loaded,36,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loaded']
Performance,"/// Get the sorted sequence of successors for this MachineBasicBlock, possibly; /// computing it if it was not already cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:119,cache,cached,119,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['cache'],['cached']
Performance,"/// Get the source location for the given file:line:col triplet.; ///; /// The difference with SourceManager::getLocation is that this method checks; /// whether the requested location points inside the precompiled preamble; /// in which case the returned source location will be a ""loaded"" one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:283,load,loaded,283,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['load'],['loaded']
Performance,/// Get the specific kind of LTO being performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:39,perform,performed,39,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['perform'],['performed']
Performance,"/// Get the streamer info records for custom classes. Currently requires the corresponding dictionaries to be loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:110,load,loaded,110,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,1,['load'],['loaded']
Performance,/// Get the tag as it was written in the document. This does not; /// perform tag resolution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h:70,perform,perform,70,interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,1,['perform'],['perform']
Performance,/// Get the template for which this guide performs deduction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:42,perform,performs,42,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['perform'],['performs']
Performance,/// Get the type from the cache or create a new partial type if; /// necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:26,cache,cache,26,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['cache'],['cache']
Performance,/// Get the type from the cache or create a new type if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:26,cache,cache,26,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['cache'],['cache']
Performance,/// Get the type that will be loaded for this slice.; /// Note: This may not be the final type for the slice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,load,loaded,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['load'],['loaded']
Performance,"/// Get the underlying values of a phi.; ///; /// This returns the cached value if PN has previously been processed,; /// otherwise it processes it first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:67,cache,cached,67,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,1,['cache'],['cached']
Performance,/// Get the vector of assumptions which affect a value from the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:64,cache,cache,64,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['cache'],['cache']
Performance,/// Get the verbatium tag for a given Node. This performs tag resoluton; /// and substitution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h:49,perform,performs,49,interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,1,['perform'],['performs']
Performance,/// GetAddressOfBaseClass - This function will add the necessary delta to the; /// load of 'this' and returns address of the base class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:83,load,load,83,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['load'],['load']
Performance,/// GetInstSeqLs - Get instruction sequences to load immediate Imm.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:48,load,load,48,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,1,['load'],['load']
Performance,/// GetInstSeqLsADDiu - Get instruction sequences which end with an ADDiu to; /// load immediate Imm,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:82,load,load,82,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,1,['load'],['load']
Performance,/// GetInstSeqLsORi - Get instrutcion sequences which end with an ORi to; /// load immediate Imm,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:78,load,load,78,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,1,['load'],['load']
Performance,/// GetInstSeqLsSLL - Get instruction sequences which end with a SLL to; /// load immediate Imm,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h:77,load,load,77,interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsAnalyzeImmediate.h,1,['load'],['load']
Performance,/// GetInterfaceEHType - Get the cached ehtype for the given Objective-C; /// interface. The return value has type EHTypePtrTy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:33,cache,cached,33,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['cache'],['cached']
Performance,"/// GetPreds - Get a cached list for the null-terminated predecessor list of; /// the specified block. This can be used in a loop like this:; /// for (BasicBlock **PI = PredCache->GetPreds(BB); *PI; ++PI); /// use(*PI);; /// instead of:; /// for (pred_iterator PI = pred_begin(BB), E = pred_end(BB); PI != E; ++PI)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h:21,cache,cached,21,interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h,1,['cache'],['cached']
Performance,"/// GetScratchRegister - Get a temp register for performing work in the; /// segmented stack and the Erlang/HiPE stack prologue. Depending on platform; /// and the properties of the function either one or two registers will be; /// needed. Set primary to true for the first register, false for the second.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:49,perform,performing,49,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['perform'],['performing']
Performance,"/// GetTestResult - Get the test result for the \p Changes from the; /// cache, executing the test if necessary.; ///; /// \param Changes - The change set to test.; /// \return - The test result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h:73,cache,cache,73,interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DeltaAlgorithm.h,1,['cache'],['cache']
Performance,"/// GetTestResult - Get the test result for the active set \p Changes with; /// \p Required changes from the cache, executing the test if necessary.; ///; /// \param Changes - The set of active changes being minimized, which should; /// have their pred closure included in the test.; /// \param Required - The set of changes which have previously been; /// established to be required.; /// \return - The test result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DAGDeltaAlgorithm.cpp:109,cache,cache,109,interpreter/llvm-project/llvm/lib/Support/DAGDeltaAlgorithm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/DAGDeltaAlgorithm.cpp,1,['cache'],['cache']
Performance,/// GetVLDSTAlign - Get the alignment (in bytes) for the alignment operand; /// of a NEON VLD or VST instruction. The supported values depend on the; /// number of registers being loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:180,load,loaded,180,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['load'],['loaded']
Performance,"/// Gets a node for an atomic cmpxchg op. There are two; /// valid Opcodes. ISD::ATOMIC_CMO_SWAP produces the value loaded and a; /// chain result. ISD::ATOMIC_CMP_SWAP_WITH_SUCCESS produces the value loaded,; /// a success flag (initially i1), and a chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:116,load,loaded,116,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,2,['load'],['loaded']
Performance,"/// Gets all the parameters of the RooAbsReal. This is in principle not; /// necessary, because we can always ask the RooAbsReal itself, but the; /// Evaluator has the cached information to get the answer quicker.; /// Therefore, this is not meant to be used in general, just where it matters.; /// \warning If we find another solution to get the parameters efficiently,; /// this function might be removed without notice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx:168,cache,cached,168,roofit/roofitcore/src/RooFit/Evaluator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx,1,['cache'],['cached']
Performance,"/// Gets latency information for \p Inst from the itinerary; /// scheduling model, based on \p DC information.; /// \return The maximum expected latency over all the operands or -1; /// if no information is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:9,latency,latency,9,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,2,['latency'],['latency']
Performance,"/// Gets latency information for \p Inst, based on \p DC information.; /// \return The maximum expected latency over all the definitions or -1; /// if no information is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp:9,latency,latency,9,interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCDisassembler/Disassembler.cpp,2,['latency'],['latency']
Performance,"/// Gets the conditions under which memory accessing instructions will overflow.; ///; /// \p Ptr is the pointer that will be read/written, and \p InstVal is either; /// the result from the load or the value being stored. It is used to determine; /// the size of memory block that is touched.; ///; /// Returns the condition under which the access will overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:190,load,load,190,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,1,['load'],['load']
Performance,/// Gets the element type of the vector that the chain will load or store.; /// This is nontrivial because the chain may contain elements of different; /// types; e.g. it's legal to have a chain that contains both i32 and float.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:60,load,load,60,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['load'],['load']
Performance,/// Gets the kind of lookup to perform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:31,perform,perform,31,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['perform'],['perform']
Performance,"/// Gets the type contained by this atomic type, i.e.; /// the type returned by performing an atomic load of this atomic type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:80,perform,performing,80,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,2,"['load', 'perform']","['load', 'performing']"
Performance,/// Getter for the cache of @llvm.assume intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,cache,cache,19,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['cache'],['cache']
Performance,/// Getting the minimal register class of a physreg is expensive.; /// Cache this information as we get it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:71,Cache,Cache,71,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['Cache'],['Cache']
Performance,"/// Give the target a chance to manipulate state related to instruction; /// alignment (e.g. padding for optimization), instruction relaxablility, etc.; /// before and after actually emitting the instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h:105,optimiz,optimization,105,interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h,1,['optimiz'],['optimization']
Performance,"/// Given a Count of resource usage and a Latency value, return true if a; /// SchedBoundary becomes resource limited.; /// If we are checking after scheduling a node, we should return true when; /// we just reach the resource limit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,Latency,Latency,42,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Latency'],['Latency']
Performance,"/// Given a LEA instruction which is unprofitable; /// on SNB+ try to replace it with other instructions.; /// According to Intel's Optimization Reference Manual:; /// "" For LEA instructions with three source operands and some specific; /// situations, instruction latency has increased to 3 cycles, and must; /// dispatch via port 1:; /// - LEA that has all three source operands: base, index, and offset; /// - LEA that uses base and index registers where the base is EBP, RBP,; /// or R13; /// - LEA that uses RIP relative addressing mode; /// - LEA that uses 16-bit addressing mode ""; /// This function currently handles the first 2 cases only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:132,Optimiz,Optimization,132,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,2,"['Optimiz', 'latency']","['Optimization', 'latency']"
Performance,/// Given a \p Def clobbering a load from \p Ptr according to the MSSA check; /// if this is actually a memory update or an artificial clobber to facilitate; /// ordering constraints.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.h:32,load,load,32,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Utils/AMDGPUMemoryUtils.h,1,['load'],['load']
Performance,"/// Given a call to the intrinsic \@llvm.type.checked.load, find all; /// devirtualizable call sites based on the call and return them in DevirtCalls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h:54,load,load,54,interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h,1,['load'],['load']
Performance,"/// Given a critical edge from Pred to LoadBB, find a load instruction; /// which is identical to Load from another successor of Pred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:39,Load,LoadBB,39,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,3,"['Load', 'load']","['Load', 'LoadBB', 'load']"
Performance,"/// Given a list of non-local dependencies, determine if a value is; /// available for the load in each specified block. If it is, add it to; /// ValuesPerBlock. If not, add it to UnavailableBlocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:91,load,load,91,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,1,['load'],['load']
Performance,"/// Given a list of possible callee implementation for a call site, select one; /// that fits the \p Threshold. If none are found, the Reason will give the last; /// reason for the failure (last, in the order of CalleeSummaryList entries).; ///; /// FIXME: select ""best"" instead of first that fits. But what is ""best""?; /// - The smallest: more likely to be inlined.; /// - The one with the least outgoing edges (already well optimized).; /// - One from a module already being imported from in order to reduce the; /// number of source modules parsed/linked.; /// - One that has PGO data attached.; /// - [insert you fancy metric here]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:426,optimiz,optimized,426,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['optimiz'],['optimized']
Performance,"/// Given a load instruction and its pointer operand, fold the result or return; /// null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:12,load,load,12,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,1,['load'],['load']
Performance,/// Given a local dependency (Def or Clobber) determine if a value is; /// available for the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:93,load,load,93,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,1,['load'],['load']
Performance,"/// Given a loop, check if we can convert it to a hardware loop.; /// If so, then perform the conversion and return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:82,perform,perform,82,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['perform'],['perform']
Performance,"/// Given a map from byte offsets in memory to indices in a load/store,; /// determine if that map corresponds to a little or big endian byte pattern.; ///; /// \param MemOffset2Idx maps memory offsets to address offsets.; /// \param LowestIdx is the lowest index in \p MemOffset2Idx.; ///; /// \returns true if the map corresponds to a big endian byte pattern, false if; /// it corresponds to a little endian byte pattern, and std::nullopt otherwise.; ///; /// E.g. given a 32-bit type x, and x[AddrOffset], the in-memory byte patterns; /// are as follows:; ///; /// AddrOffset Little endian Big endian; /// 0 0 3; /// 1 1 2; /// 2 2 1; /// 3 3 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:60,load,load,60,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['load'],['load']
Performance,"/// Given a masked memory load/store operation, return true if it has one mask; /// bit set. If it has one mask bit set, then also return the memory address of; /// the scalar element to load/store, the vector index to insert/extract that; /// scalar element, and the alignment for the scalar memory access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,load,load,26,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['load'],['load']
Performance,"/// Given a memcpy/memset/memmove instruction, return the number of memory; /// operations performed, via querying findOptimalMemOpLowering. Returns -1 if a; /// call is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:91,perform,performed,91,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['perform'],['performed']
Performance,"/// Given a memory Mod/Ref/ModRef'ing instruction, calling this; /// will give you the nearest dominating MemoryAccess that Mod's the location; /// the instruction accesses (by skipping any def which AA can prove does not; /// alias the location(s) accessed by the instruction given).; ///; /// Note that this will return a single access, and it must dominate the; /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,; /// this will return the MemoryPhi, not the operand. This means that; /// given:; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// } else {; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// 3 = MemoryPhi(2, 1); /// MemoryUse(3); /// load %a; ///; /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef; /// in the if (a) branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:699,load,load,699,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,2,['load'],['load']
Performance,"/// Given a memory access, invalidate anything this walker knows about; /// that access.; /// This API is used by walkers that store information to perform basic cache; /// invalidation. This will be called by MemorySSA at appropriate times for; /// the walker it uses or returns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:148,perform,perform,148,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,2,"['cache', 'perform']","['cache', 'perform']"
Performance,"/// Given a node, compute flags that are used for address computation when; /// selecting load and store instructions. The flags computed are stored in; /// FlagSet. This function takes into account whether the node is a constant,; /// an ADD, OR, or a constant, and computes the address flags accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:90,load,load,90,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['load'],['load']
Performance,"/// Given a non-indexed load or store instruction \p MI, find an offset that; /// can be usefully and legally folded into it as a post-indexing operation.; ///; /// \returns true if a candidate is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:24,load,load,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['load'],['load']
Performance,"/// Given a non-indexed load or store instruction \p MI, find an offset that; /// can be usefully and legally folded into it as a pre-indexing operation.; ///; /// \returns true if a candidate is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:24,load,load,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['load'],['load']
Performance,"/// Given a number of pointers, inform the optimizer that they're; /// being intrinsically used up until this point in the program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:43,optimiz,optimizer,43,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['optimiz'],['optimizer']
Performance,"/// Given a number of shuffles of the form shuffle(binop(x,y)), convert them; /// to binop(shuffle(x), shuffle(y)) to allow the formation of an; /// interleaving load. Any newly created shuffles that operate on \p LI will; /// be added to \p Shuffles. Returns true, if any changes to the IR have been; /// made.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp:162,load,load,162,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedAccessPass.cpp,1,['load'],['load']
Performance,"/// Given a saved r-value produced by SaveRValue, perform the code; /// necessary to restore it to usability at the current insertion; /// point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:50,perform,perform,50,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,1,['perform'],['perform']
Performance,"/// Given a select instruction that was understood by; /// analyzeSelect and returned Optimizable = true, attempt to optimize MI by; /// merging it with one of its operands. Returns NULL on failure.; ///; /// When successful, returns the new select instruction. The client is; /// responsible for deleting MI.; ///; /// If both sides of the select can be optimized, PreferFalse is used to pick; /// a side.; ///; /// @param MI Optimizable select instruction.; /// @param NewMIs Set that record all MIs in the basic block up to \p; /// MI. Has to be updated with any newly created MI or deleted ones.; /// @param PreferFalse Try to optimize FalseOp instead of TrueOp.; /// @returns Optimized instruction or NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:86,Optimiz,Optimizable,86,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,6,"['Optimiz', 'optimiz']","['Optimizable', 'Optimized', 'optimize', 'optimized']"
Performance,"/// Given a set in interconnected phis of type 'From' that are loaded/stored; /// or bitcast to type 'To', return true if the set should be converted to; /// 'To'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:63,load,loaded,63,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['loaded']
Performance,"/// Given a set of VectorInfo containing candidates for a given interleave; /// factor, find a set that represents a 'factor' interleaved load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:138,load,load,138,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['load'],['load']
Performance,"/// Given a set of loads specified by ValuesPerBlock,; /// construct SSA form, allowing us to eliminate Load. This returns the value; /// that should be used at Load's definition site.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:19,load,loads,19,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,3,"['Load', 'load']","['Load', 'loads']"
Performance,"/// Given a sign/zero extend instruction \p Ext, return the appropriate; /// action to promote the operand of \p Ext instead of using Ext.; /// \return NULL if no promotable action is possible with the current; /// sign extension.; /// \p InsertedInsts keeps track of all the instructions inserted by the; /// other CodeGenPrepare optimizations. This information is important; /// because we do not want to promote these instructions as CodeGenPrepare; /// will reinsert them later. Thus creating an infinite loop: create/remove.; /// \p PromotedInsts maps the instructions to their type before promotion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:331,optimiz,optimizations,331,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimizations']
Performance,"/// Given a symbol for an ivar, return the ivar region it was loaded from.; /// Returns nullptr if the instance symbol cannot be found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:62,load,loaded,62,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,1,['load'],['loaded']
Performance,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:430,optimiz,optimizer,430,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,4,"['optimiz', 'perform']","['optimization', 'optimizer', 'performing']"
Performance,"/// Given an expression of ObjC pointer type, check whether it was; /// immediately loaded from an ARC __weak l-value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:84,load,loaded,84,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['load'],['loaded']
Performance,"/// Given an extend instruction, determine the correct shift-extend type for; /// that instruction.; ///; /// If the instruction is going to be used in a load or store, pass; /// \p IsLoadStore = true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:154,load,load,154,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['load'],['load']
Performance,"/// Given an instruction Other in the same basic block as this instruction,; /// return true if this instruction comes before Other. In this worst case,; /// this takes linear time in the number of instructions in the block. The; /// results are cached, so in common cases when the block remains unmodified,; /// it takes constant time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:246,cache,cached,246,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['cache'],['cached']
Performance,"/// Given an instruction and a container, it fills all the relevant operands of; /// that instruction, with respect to the Trunc expression graph optimizaton.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp:146,optimiz,optimizaton,146,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/TruncInstCombine.cpp,1,['optimiz'],['optimizaton']
Performance,"/// Given an overloaded function, tries to turn it into a non-overloaded; /// function reference using resolveAddressOfSingleOverloadCandidate. This; /// will perform access checks, diagnose the use of the resultant decl, and, if; /// requested, potentially perform a function-to-pointer decay.; ///; /// Returns false if resolveAddressOfSingleOverloadCandidate fails.; /// Otherwise, returns true. This may emit diagnostics and return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:159,perform,perform,159,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['perform'],['perform']
Performance,"/// Given operands for the multiplication of a FMA, fold the result or return; /// null. In contrast to simplifyFMulInst, this function will not perform; /// simplifications whose unrounded results differ when rounded to the argument; /// type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:145,perform,perform,145,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,1,['perform'],['perform']
Performance,"/// Given that expression S represents a pointer that would be dereferenced,; /// try to find a sub-expression from which the pointer came from.; /// This is used for tracking down origins of a null or undefined value:; /// ""this is null because that is null because that is null"" etc.; /// We wipe away field and element offsets because they merely add offsets.; /// We also wipe away all casts except lvalue-to-rvalue casts, because the; /// latter represent an actual pointer dereference; however, we remove; /// the final lvalue-to-rvalue cast before returning from this function; /// because it demonstrates more clearly from where the pointer rvalue was; /// loaded. Examples:; /// x->y.z ==> x (lvalue); /// foo()->y.z ==> foo() (rvalue)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:665,load,loaded,665,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['load'],['loaded']
Performance,"/// Given that the given expression is some sort of call (which does; /// not return retained), perform an unsafeClaim following it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:96,perform,perform,96,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['perform'],['perform']
Performance,"/// Given that we are within the definition of the given function,; /// will that definition behave like C99's 'inline', where the; /// definition is discarded except for optimization purposes?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:171,optimiz,optimization,171,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['optimiz'],['optimization']
Performance,"/// Given the following code, v1 is partially available on some edges, but not; /// available on the edge from PredBB. This function tries to find if there is; /// another identical load in the other successor of PredBB.; ///; /// v0 = load %addr; /// br %LoadBB; ///; /// LoadBB:; /// v1 = load %addr; /// ...; ///; /// PredBB:; /// ...; /// br %cond, label %LoadBB, label %SuccBB; ///; /// SuccBB:; /// v2 = load %addr; /// ...; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:182,load,load,182,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,7,"['Load', 'load']","['LoadBB', 'load']"
Performance,"/// Given the initializing elements 'Elts' of a vector of type 'VT', see if the; /// elements can be replaced by a single large load which has the same value as; /// a build_vector or insert_subvector whose loaded operands are 'Elts'.; ///; /// Example: <load i32 *a, load i32 *a+4, zero, undef> -> zextload a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:128,load,load,128,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,4,['load'],"['load', 'loaded']"
Performance,"/// Given the language and code-generation options that Clang was configured; /// with, set the default LLVM IR attributes for a function definition.; /// The attributes set here are mostly global target-configuration and; /// pipeline-configuration options like the target CPU, variant stack; /// rules, whether to optimize for size, and so on. This is useful for; /// frontends (such as Swift) that generally intend to interoperate with; /// C code and rely on Clang's target configuration logic.; ///; /// As a general rule, this function assumes that meaningful attributes; /// haven't already been added to the builder. It won't intentionally; /// displace any existing attributes, but it also won't check to avoid; /// overwriting them. Callers should generally apply customizations after; /// making this call.; ///; /// This function assumes that the caller is not defining a function that; /// requires special no-builtin treatment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenABITypes.h:316,optimiz,optimize,316,interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenABITypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenABITypes.h,1,['optimiz'],['optimize']
Performance,"/// Given the set of return statements within a function body,; /// compute the variables that are subject to the named return value; /// optimization.; ///; /// Each of the variables that is subject to the named return value; /// optimization will be marked as NRVO variables in the AST, and any; /// return statement that has a marked NRVO variable as its NRVO candidate can; /// use the named return value optimization.; ///; /// This function applies a very simplistic algorithm for NRVO: if every return; /// statement in the scope of a variable has the same NRVO candidate, that; /// candidate is an NRVO variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:138,optimiz,optimization,138,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,3,['optimiz'],['optimization']
Performance,"/// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,perform,perform,62,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 128-bit floating-point vectors of [2 x double], perform an; /// element-by-element comparison of the double-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [2 x double].; /// \param __b; /// A 128-bit vector of [2 x double].; /// \returns the CF flag in the EFLAGS register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,perform,perform,62,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,perform,perform,61,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,perform,perform,61,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 128-bit floating-point vectors of [4 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 128-bit vector of [4 x float].; /// \param __b; /// A 128-bit vector of [4 x float].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,perform,perform,61,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,perform,perform,62,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,perform,perform,62,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 256-bit floating-point vectors of [4 x double], perform an; /// element-by-element comparison of the double-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of double-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of double-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double].; /// \param __b; /// A 256-bit vector of [4 x double].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:62,perform,perform,62,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns the CF flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,perform,perform,61,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision element in the; /// first source vector and the corresponding element in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,perform,perform,61,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 256-bit floating-point vectors of [8 x float], perform an; /// element-by-element comparison of the single-precision elements in the; /// first source vector and the corresponding elements in the second source; /// vector.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of single-precision elements where the; /// sign-bits of both elements are 1, the ZF flag is set to 0. Otherwise the; /// ZF flag is set to 1. \n; /// If there is at least one pair of single-precision elements where the; /// sign-bit of the first element is 0 and the sign-bit of the second element; /// is 1, the CF flag is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VTESTPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float].; /// \param __b; /// A 256-bit vector of [8 x float].; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:61,perform,perform,61,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns 1 if both the ZF and CF flags are set to 0,; /// otherwise it returns 0.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns 1 if both the ZF and CF flags are set to 0, otherwise returns 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the CF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns the CF flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two 256-bit integer vectors, perform a bit-by-bit comparison; /// of the two source vectors.; ///; /// The EFLAGS register is updated as follows: \n; /// If there is at least one pair of bits where both bits are 1, the ZF flag; /// is set to 0. Otherwise the ZF flag is set to 1. \n; /// If there is at least one pair of bits where the bit from the first source; /// vector is 0 and the bit from the second source vector is 1, the CF flag; /// is set to 0. Otherwise the CF flag is set to 1. \n; /// This intrinsic returns the value of the ZF flag.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VPTEST </c> instruction.; ///; /// \param __a; /// A 256-bit integer vector.; /// \param __b; /// A 256-bit integer vector.; /// \returns the ZF flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:39,perform,perform,39,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['perform'],['perform']
Performance,"/// Given two pointers operations by their RuntimePointerChecking; /// indices, return true if they require an alias check.; ///; /// We need a check if one is a pointer for a candidate load and the other is; /// a pointer for a possibly intervening store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:186,load,load,186,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['load'],['load']
Performance,"/// Global (loaded or local) ID for a preprocessed entity.; /// Negative values are used to indicate preprocessed entities; /// loaded from the external source while non-negative values are used to; /// indicate preprocessed entities introduced by the current preprocessor.; /// Value -1 corresponds to element 0 in the loaded entities vector,; /// value -2 corresponds to element 1 in the loaded entities vector, etc.; /// Value 0 is an invalid value, the index to local entities is 1-based,; /// value 1 corresponds to element 0 in the local entities vector,; /// value 2 corresponds to element 1 in the local entities vector, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:12,load,loaded,12,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,4,['load'],['loaded']
Performance,"/// Global variable summary information to aid decisions and; /// implementation of importing.; ///; /// Global variable summary has two extra flag, telling if it is; /// readonly or writeonly. Both readonly and writeonly variables; /// can be optimized in the backed: readonly variables can be; /// const-folded, while writeonly vars can be completely eliminated; /// together with corresponding stores. We let both things happen; /// by means of internalizing such variables after ThinLTO import.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:244,optimiz,optimized,244,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['optimiz'],['optimized']
Performance,"/// GlobalISel - return true if it's profitable to perform the combine:; /// shl ([sza]ext x), y => zext (shl x, y)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:51,perform,perform,51,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['perform']
Performance,/// GlobalMerge - This pass merges internal (by default) globals into structs; /// to enable reuse of a base pointer by indexed addressing modes.; /// It can also be configured to focus on size optimizations only.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:194,optimiz,optimizations,194,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['optimiz'],['optimizations']
Performance,"/// Go through the operands of \p LHS and \p RHS recursively until; /// MaxLevel, and return the cummulative score. \p U1 and \p U2 are; /// the users of \p LHS and \p RHS (that is \p LHS and \p RHS are operands; /// of \p U1 and \p U2), except at the beginning of the recursion where; /// these are set to nullptr.; ///; /// For example:; /// \verbatim; /// A[0] B[0] A[1] B[1] C[0] D[0] B[1] A[1]; /// \ / \ / \ / \ /; /// + + + +; /// G1 G2 G3 G4; /// \endverbatim; /// The getScoreAtLevelRec(G1, G2) function will try to match the nodes at; /// each level recursively, accumulating the score. It starts from matching; /// the additions at level 0, then moves on to the loads (level 1). The; /// score of G1 and G2 is higher than G1 and G3, because {A[0],A[1]} and; /// {B[0],B[1]} match with LookAheadHeuristics::ScoreConsecutiveLoads, while; /// {A[0],C[0]} has a score of LookAheadHeuristics::ScoreFail.; /// Please note that the order of the operands does not matter, as we; /// evaluate the score of all profitable combinations of operands. In; /// other words the score of G1 and G4 is the same as G1 and G2. This; /// heuristic is based on ideas described in:; /// Look-ahead SLP: Auto-vectorization in the presence of commutative; /// operations, CGO 2018 by Vasileios Porpodas, Rodrigo C. O. Rocha,; /// Luís F. W. Góes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:673,load,loads,673,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['loads']
Performance,/// Greedy register allocation pass - This pass implements a global register; /// allocator for optimized builds.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:96,optimiz,optimized,96,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['optimiz'],['optimized']
Performance,"/// Growing stack that can be used for BVH traversal. Its performance may be lower than a small,; /// fixed-size stack, depending on the architecture.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/stack.h:58,perform,performance,58,geom/geom/inc/bvh/v2/stack.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/stack.h,1,['perform'],['performance']
Performance,"/// GsymReader is used to read GSYM data from a file or buffer.; ///; /// This class is optimized for very quick lookups when the endianness matches; /// the host system. The Header, address table, address info offsets, and file; /// table is designed to be mmap'ed as read only into memory and used without; /// any parsing needed. If the endianness doesn't match, we swap these objects; /// and tables into GsymReader::SwappedData and then point our header and; /// ArrayRefs to this swapped internal data.; ///; /// GsymReader objects must use one of the static functions to create an; /// instance: GsymReader::openFile(...) and GsymReader::copyBuffer(...).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:88,optimiz,optimized,88,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['optimiz'],['optimized']
Performance,"/// GuaranteedTailCallOpt - This flag is enabled when -tailcallopt is; /// specified on the commandline. When the flag is on, participating targets; /// will perform tail call optimization on all calls which use the fastcc; /// calling convention and which satisfy certain target-independent; /// criteria (being at the end of a function, having the same return type; /// as their parent function, etc.), using an alternate ABI if necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:158,perform,perform,158,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"/// Handle any DIE (debug info entry) from the DWARF.; ///; /// This function will find all DW_TAG_subprogram DIEs that convert them into; /// GSYM FuntionInfo objects and add them to the GsymCreator supplied during; /// construction. The DIE and all its children will be recursively parsed; /// with calls to this function.; ///; /// \param Strm The thread specific log stream for any non fatal errors and; /// warnings. Once a thread has finished parsing an entire compile unit, all; /// information in this temporary stream will be forwarded to the member; /// variable log. This keeps logging thread safe. If the value is NULL, then; /// don't log.; ///; /// \param CUI The compile unit specific information that contains the DWARF; /// line table, cached file list, and other compile unit specific; /// information.; ///; /// \param Die The DWARF debug info entry to parse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h:753,cache,cached,753,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h,1,['cache'],['cached']
Performance,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:11,load,load,11,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,4,['load'],"['load', 'loaded']"
Performance,"/// Handle non-loop phi nodes. Return a VPValue, if all incoming values match; /// or a new VPBlendRecipe otherwise. Currently all such phi nodes are turned; /// into a sequence of select instructions as the vectorizer currently; /// performs full if-conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:234,perform,performs,234,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,1,['perform'],['performs']
Performance,/// Handle optimizer options which are encoded in the executable name.; /// Same semantics as in 'handleExecNameEncodedBEOpts'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FuzzMutate/FuzzerCLI.h:11,optimiz,optimizer,11,interpreter/llvm-project/llvm/include/llvm/FuzzMutate/FuzzerCLI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FuzzMutate/FuzzerCLI.h,1,['optimiz'],['optimizer']
Performance,"/// Handle the cases when we prefer one instruction over another. Case 1 - we; /// prefer not to generate multiple loads in the packet to avoid a potential; /// bank conflict. Case 2 - if a packet contains a dot cur instruction, then we; /// prefer the instruction that can use the dot cur result. However, if the use; /// is not scheduled in the same packet, then prefer other instructions in the; /// subsequent packet. Case 3 - we prefer a vector store that can be converted; /// to a .new store. The packetizer will not generate the .new store if the; /// store doesn't have resources to fit in the packet (but the .new store may; /// have resources). We attempt to schedule the store as soon as possible to; /// help packetize the two instructions together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:115,load,loads,115,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,1,['load'],['loads']
Performance,/// Handle the clang \#pragma module load extension.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:37,load,load,37,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['load'],['load']
Performance,"/// Handle the loop unroll optimization pragmas.; /// #pragma unroll; /// #pragma unroll unroll-hint-value; /// #pragma unroll '(' unroll-hint-value ')'; /// #pragma nounroll; /// #pragma unroll_and_jam; /// #pragma unroll_and_jam unroll-hint-value; /// #pragma unroll_and_jam '(' unroll-hint-value ')'; /// #pragma nounroll_and_jam; ///; /// unroll-hint-value:; /// constant-expression; ///; /// Loop unrolling hints can be specified with '#pragma unroll' or; /// '#pragma nounroll'. '#pragma unroll' can take a numeric argument optionally; /// contained in parentheses. With no argument the directive instructs llvm to; /// try to unroll the loop completely. A positive integer argument can be; /// specified to indicate the number of times the loop should be unrolled. To; /// maximize compatibility with other compilers the unroll count argument can be; /// specified with or without parentheses. Specifying, '#pragma nounroll'; /// disables unrolling of the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:27,optimiz,optimization,27,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,1,['optimiz'],['optimization']
Performance,/// Handle transitive invalidation when the cached analysis results go away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:44,cache,cached,44,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['cache'],['cached']
Performance,"/// Handle vector load-like intrinsics.; ///; /// Instrument intrinsics that look like a simple SIMD load: reads memory,; /// has 1 pointer argument, returns a vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:18,load,load-like,18,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,2,['load'],"['load', 'load-like']"
Performance,"/// Handler for invalidation of the proxy for a particular function.; ///; /// If the proxy, \c LoopInfo, and associated analyses are preserved, this; /// will merely forward the invalidation event to any cached loop analysis; /// results for loops within this function.; ///; /// If the necessary loop infrastructure is not preserved, this will forcibly; /// clear all of the cached analysis results that are keyed on the \c; /// LoopInfo for this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:205,cache,cached,205,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,2,['cache'],['cached']
Performance,"/// Handles assumptions on symbolic values.; ///; /// This method is called when a symbolic expression is assumed to be true or; /// false. For example, the assumptions are performed when evaluating a; /// condition at a branch. The callback allows checkers track the assumptions; /// performed on the symbols of interest and change the state accordingly.; ///; /// eval::Assume",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:173,perform,performed,173,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,2,['perform'],['performed']
Performance,/// Harden a load by hardening the loaded value in the defined register.; ///; /// We can harden a non-leaking load into a register without touching the; /// address by just hiding all of the loaded bits during misspeculation. We use; /// an `or` instruction to do this because we set up our poison value as all; /// ones. And the goal is just for the loaded bits to not be exposed to; /// execution and coercing them to one is sufficient.; ///; /// Returns the newly hardened register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:13,load,load,13,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,5,['load'],"['load', 'loaded']"
Performance,"/// Harden a return instruction.; ///; /// Returns implicitly perform a load which we need to harden. Without hardening; /// this load, an attacker my speculatively write over the return address to; /// steer speculation of the return to an attacker controlled address. This is; /// called Spectre v1.1 or Bounds Check Bypass Store (BCBS) and is described in; /// this paper:; /// https://people.csail.mit.edu/vlk/spectre11.pdf; ///; /// We can harden this by introducing an LFENCE that will delay any load of the; /// return address until prior instructions have retired (and thus are not being; /// speculated), or we can harden the address used by the implicit load: the; /// stack pointer.; ///; /// If we are not using an LFENCE, hardening the stack pointer has an additional; /// benefit: it allows us to pass the predicate state accumulated in this; /// function back to the caller. In the absence of a BCBS attack on the return,; /// the caller will typically be resumed and speculatively executed due to the; /// Return Stack Buffer (RSB) prediction which is very accurate and has a high; /// priority. It is possible that some code from the caller will be executed; /// speculatively even during a BCBS-attacked return until the steering takes; /// effect. Whenever this happens, the caller can recover the (poisoned); /// predicate state from the stack pointer and continue to harden loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:62,perform,perform,62,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,6,"['load', 'perform']","['load', 'loads', 'perform']"
Performance,"/// Harden a value in a register.; ///; /// This is the low-level logic to fully harden a value sitting in a register; /// against leaking during speculative execution.; ///; /// Unlike hardening an address that is used by a load, this routine is required; /// to hide *all* incoming bits in the register.; ///; /// `Reg` must be a virtual register. Currently, it is required to be a GPR no; /// larger than the predicate state register. FIXME: We should support vector; /// registers here by broadcasting the predicate state.; ///; /// The new, hardened virtual register is returned. It will have the same; /// register class as `Reg`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:225,load,load,225,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['load'],['load']
Performance,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:136,perform,perform,136,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,2,['perform'],"['perform', 'performing']"
Performance,"/// Have a worker ask for a task-message from the queue; ///; /// \param[out] job_task JobTask reference to put the Job ID and the task index into.; /// \return true if a task was popped from the queue successfully, false if the queue was empty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Queue.h:50,queue,queue,50,roofit/multiprocess/res/RooFit/MultiProcess/Queue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/res/RooFit/MultiProcess/Queue.h,3,['queue'],['queue']
Performance,"/// Helper class for building and checking a defaulted comparison.; ///; /// Defaulted functions are built in two phases:; ///; /// * First, the set of operations that the function will perform are; /// identified, and some of them are checked. If any of the checked; /// operations is invalid in certain ways, the comparison function is; /// defined as deleted and no body is built.; /// * Then, if the function is not defined as deleted, the body is built.; ///; /// This is accomplished by performing two visitation steps over the eventual; /// body of the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:186,perform,perform,186,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,['perform'],"['perform', 'performing']"
Performance,/// Helper class for performant LiveRange bulk updates.; ///; /// Calling LiveRange::addSegment() repeatedly can be expensive on large; /// live ranges because segments after the insertion point may need to be; /// shifted. The LiveRangeUpdater class can defer the shifting when adding; /// many segments in order.; ///; /// The LiveRange will be in an invalid state until flush() is called.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:21,perform,performant,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,1,['perform'],['performant']
Performance,"/// Helper class for promoting a collection of loads and stores into SSA; /// Form using the SSAUpdater.; ///; /// This handles complexities that SSAUpdater doesn't, such as multiple loads; /// and stores in one block.; ///; /// Clients of this class are expected to subclass this and implement the; /// virtual methods.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:47,load,loads,47,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,2,['load'],['loads']
Performance,"/// Helper class for the (cluster, column list) pairs that should be loaded in the background",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:69,load,loaded,69,tree/ntuple/v7/src/RClusterPool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx,1,['load'],['loaded']
Performance,"/// Helper class that detects loops which require us to lower an i1 COPY into; /// bitwise manipulation.; ///; /// Unfortunately, we cannot use LoopInfo because LoopInfo does not distinguish; /// between loops with the same header. Consider this example:; ///; /// A-+-+; /// | | |; /// B-+ |; /// | |; /// C---+; ///; /// A is the header of a loop containing A, B, and C as far as LoopInfo is; /// concerned. However, an i1 COPY in B that is used in C must be lowered to; /// bitwise operations to combine results from different loop iterations when; /// B has a divergent branch (since by default we will compile this code such; /// that threads in a wave are merged at the entry of C).; ///; /// The following rule is implemented to determine whether bitwise operations; /// are required: use the bitwise lowering for a def in block B if a backward; /// edge to B is reachable without going through the nearest common; /// post-dominator of B and all uses of the def.; ///; /// TODO: This rule is conservative because it does not check whether the; /// relevant branches are actually divergent.; ///; /// The class is designed to cache the CFG traversal so that it can be re-used; /// for multiple defs within the same basic block.; ///; /// TODO: We could use region analysis to quickly skip over SESE regions during; /// the traversal.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp:1133,cache,cache,1133,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,1,['cache'],['cache']
Performance,/// Helper class that handles loading Metadatas and keeping them available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:30,load,loading,30,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,1,['load'],['loading']
Performance,/// Helper class to simplify emission of cycle counts into optimization remarks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:59,optimiz,optimization,59,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,1,['optimiz'],['optimization']
Performance,"/// Helper for Errors used as out-parameters.; ///; /// This helper is for use with the Error-as-out-parameter idiom, where an error; /// is passed to a function or method by reference, rather than being returned.; /// In such cases it is helpful to set the checked bit on entry to the function; /// so that the error can be written to (unchecked Errors abort on assignment); /// and clear the checked bit on exit so that clients cannot accidentally forget; /// to check the result. This helper performs these actions automatically using; /// RAII:; ///; /// @code{.cpp}; /// Result foo(Error &Err) {; /// ErrorAsOutParameter ErrAsOutParam(&Err); // 'Checked' flag set; /// // <body of foo>; /// // <- 'Checked' flag auto-cleared when ErrAsOutParam is destructed.; /// }; /// @endcode; ///; /// ErrorAsOutParameter takes an Error* rather than Error& so that it can be; /// used with optional Errors (Error pointers that are allowed to be null). If; /// ErrorAsOutParameter took an Error reference, an instance would have to be; /// created inside every condition that verified that Error was non-null. By; /// taking an Error pointer we can just create one instance at the top of the; /// function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:495,perform,performs,495,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['perform'],['performs']
Performance,"/// Helper for processing MC instructions that have been successfully matched; /// by MatchAndEmitInstruction. Modifications to the emitted instructions,; /// like the expansion of pseudo instructions (e.g., ""li""), can be performed; /// in this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp:222,perform,performed,222,interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp,1,['perform'],['performed']
Performance,"/// Helper for unstreaming a page. This is commonly used in derived, concrete page sources. The implementation; /// currently always makes a memory copy, even if the sealed page is uncompressed and in the final memory layout.; /// The optimization of directly mapping pages is left to the concrete page source implementations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:235,optimiz,optimization,235,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['optimiz'],['optimization']
Performance,"/// Helper function for 'Queue::loop()'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Queue.cxx:25,Queue,Queue,25,roofit/multiprocess/src/Queue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Queue.cxx,1,['Queue'],['Queue']
Performance,"/// Helper function for EmitStaticExternCAliases() to redirect ifuncs that; /// have a resolver name that matches 'Elem' to instead resolve to the name of; /// 'CppFunc'. This redirection is necessary in cases where 'Elem' has a name; /// that will be emitted as an alias of the name bound to 'CppFunc'; ifuncs; /// may not reference aliases. Redirection is only performed if 'Elem' is only; /// used by ifuncs in which case, 'Elem' is destroyed. 'true' is returned if; /// redirection is successful, and 'false' is returned otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:363,perform,performed,363,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['perform'],['performed']
Performance,"/// Helper function for LoadClusters: it prepares the memory buffer (page map) and the; /// read requests for a given cluster and columns. The reead requests are appended to; /// the provided vector. This way, requests can be collected for multiple clusters before; /// sending them to RRawFile::ReadV().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:24,Load,LoadClusters,24,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,1,['Load'],['LoadClusters']
Performance,"/// Helper function for \c LoadFromCompilerInvocation() and; /// \c LoadFromCommandLine(), which loads an AST from a compiler invocation.; ///; /// \param PrecompilePreambleAfterNParses After how many parses the preamble; /// of this translation unit should be precompiled, to improve the performance; /// of reparsing. Set to zero to disable preambles.; ///; /// \param VFS - A llvm::vfs::FileSystem to be used for all file accesses.; /// Note that preamble is saved to a temporary directory on a RealFileSystem,; /// so in order for it to be loaded correctly, VFS should have access to; /// it(i.e., be an overlay over RealFileSystem).; ///; /// \returns \c true if a catastrophic failure occurred (which means that the; /// \c ASTUnit itself is invalid), or \c false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:27,Load,LoadFromCompilerInvocation,27,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,5,"['Load', 'load', 'perform']","['LoadFromCommandLine', 'LoadFromCompilerInvocation', 'loaded', 'loads', 'performance']"
Performance,/// Helper function for building a load instruction for loading a builtin global; /// variable of \p BuiltinValue value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:35,load,load,35,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,2,['load'],"['load', 'loading']"
Performance,/// Helper function for building a load instruction loading into the; /// \p DestinationReg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:35,load,load,35,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,2,['load'],"['load', 'loading']"
Performance,/// Helper function for building an atomic load instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp:43,load,load,43,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVBuiltins.cpp,2,['load'],['load']
Performance,"/// Helper function for findLoadOffsetsForLoadOrCombine.; ///; /// Check if \p Reg is the result of loading a \p MemSizeInBits wide value,; /// and then moving that value into a specific byte offset.; ///; /// e.g. x[i] << 24; ///; /// \returns The load instruction and the byte offset it is moved into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:100,load,loading,100,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,2,['load'],"['load', 'loading']"
Performance,/// Helper function for matchLoadOrCombine. Searches for Registers; /// which may have been produced by a load instruction + some arithmetic.; ///; /// \param [in] Root - The search root.; ///; /// \returns The Registers found during the search.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:106,load,load,106,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['load'],['load']
Performance,"/// Helper function for matchLoadOrCombine.; ///; /// Checks if every register in \p RegsToVisit is defined by a load; /// instruction + some arithmetic.; ///; /// \param [out] MemOffset2Idx - Maps the byte positions each load ends up; /// at to the index of the load.; /// \param [in] MemSizeInBits - The number of bits each load should produce.; ///; /// \returns On success, a 3-tuple containing lowest-index load found, the; /// lowest index, and the last load in the sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:113,load,load,113,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,6,['load'],['load']
Performance,"/// Helper function that creates a poller for Queue::loop()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx:46,Queue,Queue,46,roofit/multiprocess/src/Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx,1,['Queue'],['Queue']
Performance,/// Helper function to calculate whether the given Load/Store can have its; /// width reduced to ExtVT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:51,Load,Load,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Load'],['Load']
Performance,/// Helper function to generate a set of extension loads to load a vector with; /// a resulting wider type. It takes:; /// LdChain: list of chains for the load to be generated.; /// Ld: load to widen; /// ExtType: extension element type,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h:51,load,loads,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,4,['load'],"['load', 'loads']"
Performance,/// Helper function to generate a set of operations to perform; /// a vector operation for a wider type.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h:55,perform,perform,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.h,1,['perform'],['perform']
Performance,/// Helper function to remove a field from a queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp:45,queue,queue,45,interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/OptimizedStructLayout.cpp,1,['queue'],['queue']
Performance,"/// Helper function to select vector load intrinsics like; /// @llvm.aarch64.neon.ld2.*, @llvm.aarch64.neon.ld4.*, etc.; /// \p Opc is the opcode that the selected instruction should use.; /// \p NumVecs is the number of vector destinations for the instruction.; /// \p I is the original G_INTRINSIC_W_SIDE_EFFECTS instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:37,load,load,37,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['load'],['load']
Performance,"/// Helper function to truncate an optional APInt to a given BitWidth.; /// When solving addrec-related equations, it is preferable to return a value; /// that has the same bit width as the original addrec's coefficients. If the; /// solution fits in the original bit width, truncate it (except for i1).; /// Returning a value of a different bit width may inhibit some optimizations.; ///; /// In general, a solution to a quadratic equation generated from an addrec; /// may require BW+1 bits, where BW is the bit width of the addrec's; /// coefficients. The reason is that the coefficients of the quadratic; /// equation are BW+1 bits wide (to avoid truncation when converting from; /// the addrec to the equation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:369,optimiz,optimizations,369,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['optimiz'],['optimizations']
Performance,"/// Helper object for a multi-thread Snapshot action",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:24,multi-thread,multi-thread,24,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['multi-thread'],['multi-thread']
Performance,/// Helper struct to parse and store a memory address as base + index + offset.; /// We ignore sign extensions when it is safe to do so.; /// The following two expressions are not equivalent. To differentiate we need; /// to store whether there was a sign extension involved in the index; /// computation.; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (add (i8 load %index); /// (i8 1)))); /// vs; ///; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (i32 add (i32 signextend (i8 load %index)); /// (i32 1))))),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h:312,load,load,312,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h,4,['load'],['load']
Performance,"/// Helper structure used to slice a load in smaller loads.; /// Basically a slice is obtained from the following sequence:; /// Origin = load Ty1, Base; /// Shift = srl Ty1 Origin, CstTy Amount; /// Inst = trunc Shift to Ty2; ///; /// Then, it will be rewritten into:; /// Slice = load SliceTy, Base + SliceOffset; /// [Inst = zext Slice to Ty2], only if SliceTy <> Ty2; ///; /// SliceTy is deduced from the number of bits that are actually used to; /// build Inst.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:37,load,load,37,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,['load'],"['load', 'loads']"
Performance,/// Helper that resolves and caches fragments of file paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h:29,cache,caches,29,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h,1,['cache'],['caches']
Performance,"/// Helper to combine a load to a new type.; ///; /// This just does the work of combining a load to a new type. It handles; /// metadata, etc., and returns the new instruction. The \c NewTy should be the; /// loaded *value* type. This will convert it to a pointer, cast the operand to; /// that pointer type, load it, etc.; ///; /// Note that this will create all of the instructions with whatever insert; /// point the \c InstCombinerImpl currently is using.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,4,['load'],"['load', 'loaded']"
Performance,"/// Helper to compute the value number for a memory instruction; /// (LoadInst/StoreInst), including checking the memory ordering and; /// volatility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:70,Load,LoadInst,70,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,1,['Load'],['LoadInst']
Performance,/// Helper to create a load from a constant offset given a base address. Load; /// the type of \p Dst from \p Offset from the given base address and memory; /// operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:23,load,load,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,2,"['Load', 'load']","['Load', 'load']"
Performance,/// Helper to load on demand a Module from file and cache it for subsequent; /// queries during function importing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:14,load,load,14,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,2,"['cache', 'load']","['cache', 'load']"
Performance,"/// Helper to obtain the unpromoted name for a global value (or the original; /// name if not promoted). Split off the rightmost "".llvm.${hash}"" suffix,; /// because it is possible in certain clients (not clang at the moment) for; /// two rounds of ThinLTO optimization and therefore promotion to occur.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:257,optimiz,optimization,257,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['optimiz'],['optimization']
Performance,/// Helper to scan a function for loads vulnerable to misspeculation that we; /// want to harden.; ///; /// We use this to avoid making changes to functions where there is nothing we; /// need to do to harden against misspeculation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:34,load,loads,34,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['load'],['loads']
Performance,/// Helper to test for a load that can be folded with x86 shuffles.; ///; /// This is particularly important because the set of instructions varies; /// significantly based on whether the operand is a load or not.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:25,load,load,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['load'],['load']
Performance,"/// Helper used in BuildJobsForAction. Doesn't use the cache when building; /// jobs specifically for the given action, but will use the cache when; /// building jobs for the Action's inputs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:55,cache,cache,55,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,2,['cache'],['cache']
Performance,"/// Helper used to make a call to a library function that has one argument of; /// pointer type.; ///; /// Such functions include 'fegetmode', 'fesetenv' and some others, which are; /// used to get or set floating-point state. They have one argument of pointer; /// type, which points to the memory region containing bits of the; /// floating-point state. The value returned by such function is ignored in the; /// created call.; ///; /// \param LibFunc Reference to library function (value of RTLIB::Libcall).; /// \param Ptr Pointer used to save/load state.; /// \param InChain Ingoing token chain.; /// \returns Outgoing chain token.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:548,load,load,548,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['load'],['load']
Performance,/// Hepler class to perform type promotion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:20,perform,perform,20,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['perform'],['perform']
Performance,/// Heuristically determine the best-performant unroll factor for \p CLI. This; /// depends on the target processor. We are re-using the same heuristics as the; /// LoopUnrollPass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:37,perform,performant,37,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['perform'],['performant']
Performance,"/// Hidden option to stress test load slicing, i.e., when this option; /// is enabled, load slicing bypasses most of its profitability guards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:33,load,load,33,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],['load']
Performance,"/// High level function that adds all passes necessary to go from llvm IR; /// representation to the MI representation.; /// Adds IR based lowering and target specific optimization passes and finally; /// the core instruction selection passes.; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:168,optimiz,optimization,168,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['optimiz'],['optimization']
Performance,/// Hint that pairing the given load or store is unprofitable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:32,load,load,32,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,/// Hint to hardware that the cache line that contains \p __P should be demoted; /// from the cache closest to the processor core to a level more distant from; /// the processor core.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> CLDEMOTE </c> instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h:30,cache,cache,30,interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/cldemoteintrin.h,2,['cache'],['cache']
Performance,"/// Hint whether to load data from the external AST in order to provide; /// full results. If false, declarations from the preamble may be omitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:20,load,load,20,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['load'],['load']
Performance,"/// Hint whether to load data from the external AST to provide full results.; /// If false, namespace-level declarations and macros from the preamble may be; /// omitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteOptions.h:20,load,load,20,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteOptions.h,1,['load'],['load']
Performance,"/// Hoist any common code in the successor blocks up into the block. This; /// function guarantees that BB dominates all successors. If EqTermsOnly is; /// given, only perform hoisting in case both blocks only contain a terminator.; /// In that case, only the original BI will be replaced and selects for PHIs are; /// added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:168,perform,perform,168,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['perform'],['perform']
Performance,"/// Hold subclass data that can be dropped.; ///; /// This member is similar to SubclassData, however it is for holding; /// information which may be used to aid optimization, but which may be; /// cleared to zero without affecting conservative interpretation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h:162,optimiz,optimization,162,interpreter/llvm-project/llvm/include/llvm/IR/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h,1,['optimiz'],['optimization']
Performance,/// Holds CFG and other derived context that is needed to perform dataflow; /// analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/ControlFlowContext.h:58,perform,perform,58,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/ControlFlowContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/ControlFlowContext.h,1,['perform'],['perform']
Performance,/// Holds a SCEV and the version number of the SCEV predicate used to; /// perform the rewrite of the expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:75,perform,perform,75,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['perform'],['perform']
Performance,/// Holds the cache used by isBeforeInTranslationUnit.; ///; /// The cache structure is complex enough to be worth breaking out of; /// SourceManager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:14,cache,cache,14,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,2,['cache'],['cache']
Performance,/// Holds the maximum number of concurrent live intervals in the loop.; /// The key is ClassID of target-provided register class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:32,concurren,concurrent,32,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['concurren'],['concurrent']
Performance,/// How much before a load we should place the prefetch instruction.; /// This is currently measured in number of IR instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.h:22,load,load,22,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.h,1,['load'],['load']
Performance,"/// I/O performance counters that get registered in fMetrics",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx:8,perform,performance,8,tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,1,['perform'],['performance']
Performance,"/// INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2; /// inserted into VECTOR1. IDX represents the starting element number at which; /// VECTOR2 will be inserted. IDX must be a constant multiple of T's known; /// minimum vector length. Let the type of VECTOR2 be T, then if T is a; /// scalable vector, IDX is first scaled by the runtime scaling factor of T.; /// The elements of VECTOR1 starting at IDX are overwritten with VECTOR2.; /// Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR1; /// indices. If this condition cannot be determined statically but is false at; /// runtime, then the result vector is undefined. The IDX parameter must be a; /// vector index constant type, which for most targets will be an integer; /// pointer type.; ///; /// This operation supports inserting a fixed-width vector into a scalable; /// vector, but not the other way around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:310,scalab,scalable,310,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,['scalab'],['scalable']
Performance,"/// INSERT_VECTOR_ELT(VECTOR, VAL, IDX) - Returns VECTOR with the element; /// at IDX replaced with VAL. If the type of VAL is larger than the vector; /// element type then VAL is truncated before replacement.; ///; /// If VECTOR is a scalable vector, then IDX may be larger than the minimum; /// vector width. IDX is not first scaled by the runtime scaling factor of; /// VECTOR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:235,scalab,scalable,235,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['scalab'],['scalable']
Performance,"/// IO constructor (both for ROOT IO and LoadText()).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBDT.hxx:41,Load,LoadText,41,tmva/tmva/inc/TMVA/RBDT.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBDT.hxx,1,['Load'],['LoadText']
Performance,/// IR Optimization Level [0-3].,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:7,Optimiz,Optimization,7,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['Optimiz'],['Optimization']
Performance,/// IR optimization level: from 0 to 3.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:7,optimiz,optimization,7,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['optimiz'],['optimization']
Performance,"/// Ident_pixel - cached IdentifierInfos for ""pixel"" fast comparison.; /// Only present if AltiVec enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:18,cache,cached,18,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['cache'],['cached']
Performance,"/// Ident_vector, Ident_bool, Ident_Bool - cached IdentifierInfos for ""vector""; /// and ""bool"" fast comparison. Only present if AltiVec or ZVector are; /// enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:43,cache,cached,43,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['cache'],['cached']
Performance,/// Identifier of the mapping.; /// This is used to communicate between the target and the optimizers; /// which mapping should be realized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:91,optimiz,optimizers,91,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['optimiz'],['optimizers']
Performance,/// Identifies the Deinterleave operation applied to a vector containing; /// complex numbers. There are two ways to represent the Deinterleave; /// operation:; /// * Using two shufflevectors with even indices for /pReal instruction and; /// odd indices for /pImag instructions (only for fixed-width vectors); /// * Using two extractvalue instructions applied to `vector.deinterleave2`; /// intrinsic (for both fixed and scalable vectors),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:421,scalab,scalable,421,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['scalab'],['scalable']
Performance,/// Identifies the path of the file which can be used to load the ASTUnit; /// for a given function.; ///; /// \param FunctionName USR name of the function.; /// \param CrossTUDir Path to the directory used to store CTU related files.; /// \param IndexName Name of the file inside \p CrossTUDir which maps; /// function USR names to file paths. These files contain the corresponding; /// AST-dumps.; ///; /// \return An Expected instance containing the filepath.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:57,load,load,57,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['load'],['load']
Performance,/// Identify DAG roots and setup scheduler queues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:43,queue,queues,43,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['queue'],['queues']
Performance,/// Identify and cache salvageable DVI locations and expressions along with the; /// corresponding SCEV(s). Also ensure that the DVI is not deleted between; /// cacheing and salvaging.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:17,cache,cache,17,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,2,['cache'],"['cache', 'cacheing']"
Performance,"/// If 'Partial' is false, it means the profile being used to optimize; /// a target is collected from the same target.; /// If 'Partial' is true, it means the profile is for common/shared; /// code. The common profile is usually merged from profiles collected; /// from running other targets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ProfileSummary.h:62,optimiz,optimize,62,interpreter/llvm-project/llvm/include/llvm/IR/ProfileSummary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ProfileSummary.h,1,['optimiz'],['optimize']
Performance,"/// If C is a constant patterned array and all valid loaded results for given; /// alignment are same to a constant, return that constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:53,load,loaded,53,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['load'],['loaded']
Performance,"/// If P exists in CachedNonLocalPointerInfo or NonLocalDefsCache, remove it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:19,Cache,CachedNonLocalPointerInfo,19,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['Cache'],['CachedNonLocalPointerInfo']
Performance,"/// If \arg Loc is a loaded location from the preamble, returns; /// the corresponding local location of the main file, otherwise it returns; /// \arg Loc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:21,load,loaded,21,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['load'],['loaded']
Performance,"/// If \arg Loc is a local location of the main file but inside the; /// preamble chunk, returns the corresponding loaded location from the; /// preamble, otherwise it returns \arg Loc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:115,load,loaded,115,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['load'],['loaded']
Performance,"/// If \p CachedOnly is true, no pass is created, just existing results are; /// used. Also available per request.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:10,Cache,CachedOnly,10,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['Cache'],['CachedOnly']
Performance,"/// If \p Loc is a loaded location from the preamble, returns; /// the corresponding local location of the main file, otherwise it returns; /// \p Loc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:19,load,loaded,19,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['load'],['loaded']
Performance,"/// If \p Loc is a local location of the main file but inside the; /// preamble chunk, returns the corresponding loaded location from the; /// preamble, otherwise it returns \p Loc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:113,load,loaded,113,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['load'],['loaded']
Performance,"/// If \p MI is extend that consumes the result of a load, try to combine it.; /// Returns true if MI changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:53,load,load,53,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['load'],['load']
Performance,"/// If \p OffsetIsScalable is set to 'true', the offset is scaled by `vscale`.; /// This is true for some SVE instructions like ldr/str that have a; /// 'reg + imm' addressing mode where the immediate is an index to the; /// scalable vector located at 'reg + imm * vscale x #bytes'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:225,scalab,scalable,225,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['scalab'],['scalable']
Performance,"/// If a load has multiple candidates associated (i.e. different; /// stores), it means that it could be forwarding from multiple stores; /// depending on control flow. Remove these candidates.; ///; /// Here, we rely on LAA to include the relevant loop-independent dependences.; /// LAA is known to omit these in the very simple case when the read and the; /// write within an alias set always takes place using the *same* pointer.; ///; /// However, we know that this is not the case here, i.e. we can rely on LAA; /// to provide us with loop-independent dependences for the cases we're; /// interested. Consider the case for example where a loop-independent; /// dependece S1->S2 invalidates the forwarding S3->S2.; ///; /// A[i] = ... (S1); /// ... = A[i] (S2); /// A[i+1] = ... (S3); ///; /// LAA will perform dependence analysis here because there are two; /// *different* pointers involved in the same alias set (&A[i] and &A[i+1]).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:9,load,load,9,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,2,"['load', 'perform']","['load', 'perform']"
Performance,"/// If a symbol has a Fragment, the section is implied, so we only need; /// one pointer.; /// The special AbsolutePseudoFragment value is for absolute symbols.; /// If this is a variable symbol, this caches the variable value's fragment.; /// FIXME: We might be able to simplify this by having the asm streamer create; /// dummy fragments.; /// If this is a section, then it gives the symbol is defined in. This is null; /// for undefined symbols.; ///; /// If this is a fragment, then it gives the fragment this symbol's value is; /// relative to, if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h:201,cache,caches,201,interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h,1,['cache'],['caches']
Performance,"/// If a vector binop is performed on splat values, it may be profitable to; /// extract, scalarize, and insert/splat.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,perform,performed,25,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['perform'],['performed']
Performance,"/// If an existing load has uses of its chain, create a token factor node with; /// that chain and the new memory node's chain and update users of the old; /// chain to the token factor. This ensures that the new memory node will have; /// the same relative memory dependency position as the old load. Returns the; /// new merged load chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:19,load,load,19,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,6,['load'],['load']
Performance,"/// If analyzeLoadFromClobberingMemInst returned an offset, this function can be; /// used to actually perform the extraction of the bits from the memory; /// intrinsic. It inserts instructions to do so at InsertPt, and returns the; /// extracted value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:103,perform,perform,103,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,1,['perform'],['perform']
Performance,"/// If analyzeLoadFromClobberingStore/Load returned an offset, this function; /// can be used to actually perform the extraction of the bits from the store.; /// It inserts instructions to do so at InsertPt, and returns the extracted; /// value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:38,Load,Load,38,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,2,"['Load', 'perform']","['Load', 'perform']"
Performance,"/// If any user of a VPWidenIntOrFpInductionRecipe needs scalar values,; /// provide them by building scalar steps off of the canonical scalar IV and; /// update the original IV's users. This is an optional optimization to reduce; /// the needs of vector extracts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:207,optimiz,optimization,207,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,1,['optimiz'],['optimization']
Performance,"/// If bit I is set, this rule set contains a rule that may handle (predicate; /// or perform an action upon (or both)) the type index I. The uncertainty; /// comes from free-form rules executing user-provided lambda functions. We; /// conservatively assume such rules do the right thing and cover all type; /// indices. The bitset is intentionally 1 bit wider than it absolutely needs; /// to be to distinguish such cases from the cases where all type indices are; /// individually handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:86,perform,perform,86,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['perform'],['perform']
Performance,"/// If conveniently available, return the content of the given Section.; ///; /// When the section is available in the local address space, in relocated; /// (loaded) form, e.g. because it was relocated by a JIT for execution, this; /// function should provide the contents of said section in `Data`. If the; /// loaded section is not available, or the cost of retrieving it would be; /// prohibitive, this function should return false. In that case, relocations; /// will be read from the local (unrelocated) object file and applied on the; /// fly. Note that this method is used purely for optimzation purposes in the; /// common case of JITting in the local address space, so returning false; /// should always be correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h:159,load,loaded,159,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h,2,['load'],['loaded']
Performance,"/// If counting leading or trailing zeros is an expensive operation and a zero; /// input is defined, add a check for zero to avoid calling the intrinsic.; ///; /// We want to transform:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 false); ///; /// into:; /// entry:; /// %cmpz = icmp eq i64 %A, 0; /// br i1 %cmpz, label %cond.end, label %cond.false; /// cond.false:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 true); /// br label %cond.end; /// cond.end:; /// %ctz = phi i64 [ 64, %entry ], [ %z, %cond.false ]; ///; /// If the transform is performed, return true and set ModifiedDT to true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:544,perform,performed,544,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['perform'],['performed']
Performance,"/// If enableBreakExceptions is not enabled then must be 0, otherwise must be; /// non-0 and specifies the set of HSAIL exceptions that must have the BREAK; /// policy enabled. If this set is not empty then the generated code may have; /// lower performance than if the set is empty. If the kernel being finalized; /// has any enablebreakexceptions control directives, then the values specified; /// by this argument are unioned with the values in these control; /// directives. If any of the functions the kernel calls have an; /// enablebreakexceptions control directive, then they must be equal or a; /// subset of, this union.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:246,perform,performance,246,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['perform'],['performance']
Performance,"/// If enableDetectExceptions is not enabled then must be 0, otherwise must be; /// non-0 and specifies the set of HSAIL exceptions that must have the DETECT; /// policy enabled. If this set is not empty then the generated code may have; /// lower performance than if the set is empty. However, an implementation; /// should endeavour to make the performance impact small. If the kernel being; /// finalized has any enabledetectexceptions control directives, then the; /// values specified by this argument are unioned with the values in these; /// control directives. If any of the functions the kernel calls have an; /// enabledetectexceptions control directive, then they must be equal or a; /// subset of, this union.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:248,perform,performance,248,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,2,['perform'],['performance']
Performance,"/// If exactly one element of the mask is set for a non-extending masked load,; /// it is a scalar load and vector insert.; /// Note: It is expected that the degenerate cases of an all-zeros or all-ones; /// mask have already been optimized in IR, so we don't bother with those here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:73,load,load,73,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,"['load', 'optimiz']","['load', 'optimized']"
Performance,"/// If exactly one element of the mask is set for a non-truncating masked store,; /// it is a vector extract and scalar store.; /// Note: It is expected that the degenerate cases of an all-zeros or all-ones; /// mask have already been optimized in IR, so we don't bother with those here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:235,optimiz,optimized,235,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['optimiz'],['optimized']
Performance,"/// If flag is true the RooHistFunc that represent the cache histogram; /// will use special boundary conditions for use with cumulative distribution; /// functions: at the lower bound the function is forced to converge at zero and the upper; /// bound is the function is forced to converge at 1.0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedReal.h:55,cache,cache,55,roofit/roofitcore/inc/RooCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedReal.h,1,['cache'],['cache']
Performance,"/// If given, the name of the target CPU to tune code for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetOptions.h:44,tune,tune,44,interpreter/llvm-project/clang/include/clang/Basic/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetOptions.h,1,['tune'],['tune']
Performance,"/// If non-null, indicates that this predicate is a predefined memory VT; /// predicate (checking only the scalar type) for load/store and returns the; /// ValueType record for the memory VT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:124,load,load,124,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['load'],['load']
Performance,"/// If non-null, indicates that this predicate is a predefined memory VT; /// predicate for a load/store and returns the ValueType record for the memory VT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:94,load,load,94,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['load'],['load']
Performance,"/// If our passthru is an implicit_def, use noreg instead. This side; /// steps issues with MachineCSE not being able to CSE expressions with; /// IMPLICIT_DEF operands while preserving the semantic intent. See; /// pr64282 for context. Note that this transform is the last one; /// performed at ISEL DAG to DAG.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:283,perform,performed,283,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['perform'],['performed']
Performance,"/// If positive, the index of the first argument that only appear in; /// the optimization records and not in the remark printed in the compiler; /// output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:78,optimiz,optimization,78,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,1,['optimiz'],['optimization']
Performance,"/// If requestedWorkgroupsPerCu is not enabled then must be 0, and the; /// finalizer is free to generate ISA that may result in any number of; /// work-groups executing on a single compute unit. Otherwise, the finalizer; /// should attempt to generate ISA that will allow the specified number of; /// work-groups to execute on a single compute unit. This is only a hint and; /// can be ignored by the finalizer. If the kernel being finalized, or any of; /// the functions it calls, has a requested control directive, then the values; /// must be the same. This can be used to determine the number of resources; /// that should be allocated to a single work-group and work-item. For example,; /// a low value may allow more resources to be allocated, resulting in higher; /// per work-item performance, as it is known there will never be more than the; /// specified number of work-groups actually executing on the compute; /// unit. Conversely, a high value may allocate fewer resources, resulting in; /// lower per work-item performance, which is offset by the fact it allows more; /// work-groups to actually execute on the compute unit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:790,perform,performance,790,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,2,['perform'],['performance']
Performance,"/// If requiredDim is not enabled then must be 0 and the produced kernel code; /// can be dispatched with 1, 2 or 3 dimensions. If enabled then the value is; /// 1..3 and the code produced must only be dispatched with a dimension that; /// matches. Other values are illegal. If the kernel being finalized, or any of; /// the functions it calls, has a requireddimsize control directive, then the; /// values must be the same. This can be used to optimize the code generated to; /// compute the absolute and flat work-group and work-item id, and the dim; /// HSAIL operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:445,optimiz,optimize,445,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['optimiz'],['optimize']
Performance,"/// If requiredWorkgroupSize is not enabled then all elements for Dim3 must be; /// 0, and the produced code can be dispatched with any legal work-group range; /// consistent with the dispatch dimensions. Otherwise, the code produced must; /// always be dispatched with the specified work-group range. No element of the; /// specified range must be 0. It must be consistent with required_dimensions; /// and max_flat_workgroup_size. If the kernel being finalized, or any of the; /// functions it calls, has a requiredworkgroupsize control directive, then the; /// values must be the same. Specifying a value can allow the finalizer to; /// optimize work-group id operations, and if the number of work-items in the; /// work-group is less than the WAVESIZE then barrier operations can be; /// optimized to just a memory fence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:640,optimiz,optimize,640,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,2,['optimiz'],"['optimize', 'optimized']"
Performance,"/// If runtime relocation is enabled, this maps functions to the load; /// instruction that produces the profile relocation bias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:65,load,load,65,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['load'],['load']
Performance,"/// If target has efficient vector element load/store instructions, it can; /// return true here so that insertion/extraction costs are not added to; /// the scalarization cost of a load/store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:43,load,load,43,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,2,['load'],['load']
Performance,"/// If the SUnit has a zero latency edge, return the other SUnit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:28,latency,latency,28,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['latency'],['latency']
Performance,"/// If the cache is valid, compute the result given the; /// specified offsets in the LHS/RHS FileID's.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:11,cache,cache,11,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['cache'],['cache']
Performance,"/// If the cached entry represents an error, promotes it into `ErrorOr`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:11,cache,cached,11,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cached']
Performance,"/// If the given MemoryBuffer holds a bitcode image, return a Module; /// for it which does lazy deserialization of function bodies. Otherwise,; /// attempt to parse it as LLVM Assembly and return a fully populated; /// Module. The ShouldLazyLoadMetadata flag is passed down to the bitcode; /// reader to optionally enable lazy metadata loading. This takes ownership; /// of \p Buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h:337,load,loading,337,interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h,1,['load'],['loading']
Performance,"/// If the given file holds a bitcode image, return a Module; /// for it which does lazy deserialization of function bodies. Otherwise,; /// attempt to parse it as LLVM Assembly and return a fully populated; /// Module. The ShouldLazyLoadMetadata flag is passed down to the bitcode; /// reader to optionally enable lazy metadata loading.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h:329,load,loading,329,interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IRReader/IRReader.h,1,['load'],['loading']
Performance,"/// If the given load, \p LI, is used only by trunc or trunc(lshr); /// operations, split it in the various pieces being extracted.; ///; /// This sort of thing is introduced by SROA.; /// This slicing takes care not to insert overlapping loads.; /// \pre LI is a simple load (i.e., not an atomic or volatile load).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:17,load,load,17,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,['load'],"['load', 'loads']"
Performance,"/// If the given nested-name-specifier begins with a bare identifier; /// (e.g., Base::), perform name lookup for that identifier as a; /// nested-name-specifier within the given scope, and return the result of that; /// name lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:90,perform,perform,90,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['perform'],['perform']
Performance,"/// If the identifier refers to a type name within this scope,; /// return the declaration of that type.; ///; /// This routine performs ordinary name lookup of the identifier II; /// within the given scope, with optional C++ scope specifier SS, to; /// determine whether the name refers to a type. If so, returns an; /// opaque pointer (actually a QualType) corresponding to that; /// type. Otherwise, returns NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:128,perform,performs,128,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['perform'],['performs']
Performance,"/// If the image is on network media, fully load it and copy it to swap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:44,load,load,44,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,1,['load'],['load']
Performance,"/// If the image is on removable media, fully load it and copy it to swap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:46,load,load,46,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,1,['load'],['load']
Performance,"/// If the inlined function has noalias arguments,; /// then add new alias scopes for each noalias argument, tag the mapped noalias; /// parameters with noalias metadata specifying the new scope, and tag all; /// non-derived loads, stores and memory intrinsics with the new alias scopes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:225,load,loads,225,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['load'],['loads']
Performance,"/// If the input is an 'or' instruction, we may be doing shifts and ors to; /// assemble the elements of the vector manually.; /// Try to rip the code out and replace it with insertelements. This is to; /// optimize code like this:; ///; /// %tmp37 = bitcast float %inc to i32; /// %tmp38 = zext i32 %tmp37 to i64; /// %tmp31 = bitcast float %inc5 to i32; /// %tmp32 = zext i32 %tmp31 to i64; /// %tmp33 = shl i64 %tmp32, 32; /// %ins35 = or i64 %tmp33, %tmp38; /// %tmp43 = bitcast i64 %ins35 to <2 x float>; ///; /// Into two insertelements that do ""buildvector{%inc, %inc5}"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:207,optimiz,optimize,207,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['optimiz'],['optimize']
Performance,"/// If the loop has memory dependence involving an invariant address, i.e. two; /// stores or a store and a load, then return true, else return false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:108,load,load,108,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['load'],['load']
Performance,"/// If the result of a load is shifted/masked/truncated to an effectively; /// narrower type, try to transform the load to a narrower type and/or; /// use an extending load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,load,load,23,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,['load'],['load']
Performance,"/// If the section was loaded, return the section's load address,; /// otherwise return std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:23,load,loaded,23,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,2,['load'],"['load', 'loaded']"
Performance,"/// If the specified instruction is not yet processed, process it if it's a; /// copy. For a copy instruction, we find the physical registers the; /// source and destination registers might be mapped to. These are kept in; /// point-to maps used to determine future optimizations. e.g.; /// v1024 = mov r0; /// v1025 = mov r1; /// v1026 = add v1024, v1025; /// r1 = mov r1026; /// If 'add' is a two-address instruction, v1024, v1026 are both potentially; /// coalesced to r0 (from the input side). v1025 is mapped to r1. v1026 is; /// potentially joined with r1 on the output side. It's worthwhile to commute; /// 'add' to eliminate a copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:266,optimiz,optimizations,266,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['optimiz'],['optimizations']
Performance,"/// If the specified machine instruction has a load from a stack slot,; /// return true along with the FrameIndices of the loaded stack slot and the; /// machine mem operands containing the reference.; /// If not, return false. Unlike isLoadFromStackSlot, this returns true for; /// any instructions that loads from the stack. This is just a hint, as some; /// cases may be missed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:47,load,load,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,3,['load'],"['load', 'loaded', 'loads']"
Performance,"/// If the specified machine instruction has a store to a stack slot,; /// return true along with the FrameIndices of the loaded stack slot and the; /// machine mem operands containing the reference.; /// If not, return false. Unlike isStoreToStackSlot,; /// this returns true for any instructions that stores to the; /// stack. This is just a hint, as some cases may be missed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:122,load,loaded,122,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['load'],['loaded']
Performance,"/// If the specified machine instruction is a direct; /// load from a stack slot, return the virtual or physical register number of; /// the destination along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than loading from the stack slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:58,load,load,58,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,9,['load'],"['load', 'loaded', 'loading']"
Performance,"/// If the specified machine instruction is a direct; /// store to a stack slot, return the virtual or physical register number of; /// the source reg along with the FrameIndex of the loaded stack slot. If; /// not, return 0. This predicate must return 0 if the instruction has; /// any side effects other than storing to the stack slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:184,load,loaded,184,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,4,['load'],['loaded']
Performance,"/// If the specified mangled name is not in the module, create and; /// return threadprivate cache object. This object is a pointer's worth of; /// storage that's reserved for use by the OpenMP runtime.; /// \param VD Threadprivate variable.; /// \return Cache variable for the specified threadprivate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:93,cache,cache,93,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,2,"['Cache', 'cache']","['Cache', 'cache']"
Performance,"/// If the specified predicate checks whether a generic pointer falls within; /// a specified address space, return that generic pointer and the address; /// space being queried.; ///; /// Such predicates could be specified in @llvm.assume intrinsics for the; /// optimizer to assume that the given generic pointer always falls within; /// the address space based on that predicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h:264,optimiz,optimizer,264,interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,1,['optimiz'],['optimizer']
Performance,/// If the stored value is a strided load in the same loop with the same stride; /// this may be transformable into a memcpy. This kicks in for stuff like; /// for (i) A[i] = B[i];,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:37,load,load,37,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['load'],['load']
Performance,"/// If the target has a standard stack protection check function that; /// performs validation and error handling, returns the function. Otherwise,; /// returns nullptr. Must be previously inserted by insertSSPDeclarations.; /// Should be used only when getIRStackGuard returns nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:75,perform,performs,75,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['performs']
Performance,"/// If there are any memory operands, use OptimizeMemoryInst to sink their; /// address computing into the block when possible / profitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:42,Optimiz,OptimizeMemoryInst,42,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Optimiz'],['OptimizeMemoryInst']
Performance,"/// If there is a section at the given local address, return its load; /// address, otherwise return std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h:65,load,load,65,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h,1,['load'],['load']
Performance,"/// If there's a use of this ADDlow that's not itself a load/store then we'll; /// need to create a real ADD instruction from it anyway and there's no point in; /// folding it into the mem op. Theoretically, it shouldn't matter, but there's; /// a single pseudo-instruction for an ADRP/ADD pair so over-aggressive folding; /// leads to duplicated ADRP instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:56,load,load,56,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['load'],['load']
Performance,"/// If this expression refers to a bit-field, retrieve the; /// declaration of that bit-field.; ///; /// Note that this returns a non-null pointer in subtly different; /// places than refersToBitField returns true. In particular, this can; /// return a non-null pointer even for r-values loaded from; /// bit-fields, but it will return null for a conditional bit-field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:288,load,loaded,288,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['load'],['loaded']
Performance,"/// If this field is set, the set of passes run in the middle-end optimizer; /// will be the one specified by the string. Only works with the new pass; /// manager as the old one doesn't have this ability.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:66,optimiz,optimizer,66,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['optimiz'],['optimizer']
Performance,"/// If this file has a \#ifndef XXX (or equivalent) guard that; /// protects the entire contents of the file, this is the identifier; /// for the macro that controls whether or not it has any effect.; ///; /// Note: Most clients should use getControllingMacro() to access; /// the controlling macro of this header, since; /// getControllingMacro() is able to load a controlling macro from; /// external storage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:359,load,load,359,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['load'],['load']
Performance,"/// If this is a *dynamic* select (non-constant condition) and we can match; /// this node with one of the variable blend instructions, restructure the; /// condition so that blends can use the high (sign) bit of each element.; /// This function will also call SimplifyDemandedBits on already created; /// BLENDV to perform additional simplifications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:316,perform,perform,316,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['perform']
Performance,"/// If this is a generic lambda, and the template parameter; /// list has been created (from the TemplateParams) then store; /// a reference to it (cache it to avoid reconstructing it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:148,cache,cache,148,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,1,['cache'],['cache']
Performance,"/// If this is a zero/all-bits result that is bitwise-anded with a low bits; /// mask. (Mask == 1 for the x86 lowering of a SETCC + ZEXT), replace the 'and'; /// with a shift-right to eliminate loading the vector constant mask value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:194,load,loading,194,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['load'],['loading']
Performance,"/// If this is true, we cannot perform code motion but can still remove; /// retain/release pairs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:31,perform,perform,31,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,1,['perform'],['perform']
Performance,"/// If this queue only has one ready candidate, return it. As a side effect,; /// advance the cycle until at least one node is ready. If multiple instructions; /// are ready, return NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:12,queue,queue,12,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['queue'],['queue']
Performance,"/// If this queue only has one ready candidate, return it. As a side effect,; /// defer any nodes that now hit a hazard, and advance the cycle until at least; /// one node is ready. If multiple instructions are ready, return NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:12,queue,queue,12,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['queue'],['queue']
Performance,"/// If this set is of pointer values, transparently switch over to using; /// SmallPtrSet for performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h:94,perform,performance,94,interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,1,['perform'],['performance']
Performance,"/// If true then we're performing analysis of IR module, or parsing along with; /// the IR from assembly. The value of 'false' means we're reading summary; /// from BC or YAML source. Affects the type of value stored in NameOrGV; /// union.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:23,perform,performing,23,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['perform'],['performing']
Performance,"/// If true, only perform beneficial early IR transforms. Do not introduce new; /// vector operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h:18,perform,perform,18,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,2,['perform'],['perform']
Performance,"/// If true, selector should try to optimize for minimum code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:36,optimiz,optimize,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['optimiz'],['optimize']
Performance,"/// If true, the target has custom DAG combine transformations that it can; /// perform for the specified node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:80,perform,perform,80,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['perform']
Performance,"/// If true, treat this inline assembly as having side effects.; /// This assembly statement should not be optimized, deleted or moved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h:107,optimiz,optimized,107,interpreter/llvm-project/clang/include/clang/AST/Stmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h,1,['optimiz'],['optimized']
Performance,"/// If we are extracting a subvector from a wide vector load, convert to a; /// narrow load to eliminate the extraction:; /// (extract_subvector (load wide vector)) --> (load narrow vector)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:56,load,load,56,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,['load'],['load']
Performance,"/// If we are loading a relocatable PCH or module file, and the filename; /// is not an absolute path, add the system or module root to the beginning of; /// the file name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:14,load,loading,14,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['load'],['loading']
Performance,"/// If we are loading a vector and then inserting it into a larger vector with; /// undefined elements, try to load the larger vector and eliminate the insert.; /// This removes a shuffle in IR and may allow combining of other loaded values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:14,load,loading,14,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,3,['load'],"['load', 'loaded', 'loading']"
Performance,"/// If we encode a FunctionInfo during segmenting so we know its size, we can; /// cache that encoding here so we don't need to re-encode it when saving the; /// GSYM file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h:83,cache,cache,83,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h,1,['cache'],['cache']
Performance,"/// If we have a build_vector where each lane is binop X, C, where C; /// is a constant (but not necessarily the same constant on all lanes),; /// form binop (build_vector x1, x2, ...), (build_vector c1, c2, c3, ..).; /// We assume that materializing a constant build vector will be no more; /// expensive that performing O(n) binops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:311,perform,performing,311,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['perform'],['performing']
Performance,"/// If we have a shift-by-constant of a bitwise logic op that itself has a; /// shift-by-constant operand with identical opcode, we may be able to convert; /// that into 2 independent shifts followed by the logic op. This is a; /// throughput improvement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:232,throughput,throughput,232,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['throughput'],['throughput']
Performance,"/// If we saw a store of a value to memory, and then a load from a must-aliased; /// pointer of a different type, try to coerce the stored value to the loaded; /// type. LoadedTy is the type of the load we want to replace. IRB is; /// IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h:55,load,load,55,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/VNCoercion.h,4,"['Load', 'load']","['LoadedTy', 'load', 'loaded']"
Performance,"/// If we saw a store of a value to memory, and; /// then a load from a must-aliased pointer of a different type, try to coerce; /// the stored value. LoadedTy is the type of the load we want to replace.; /// IRB is IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:60,load,load,60,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,3,"['Load', 'load']","['LoadedTy', 'load']"
Performance,"/// If whole-program virtual table optimization is enabled, emit an assumption; /// that VTable is a member of RD's type identifier. Or, if vptr CFI is; /// enabled, emit a check that VTable is a member of RD's type identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:35,optimiz,optimization,35,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['optimiz'],['optimization']
Performance,/// IfConverter - This pass performs machine code if conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:28,perform,performs,28,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,"/// IgnoredValueConversions - Given that an expression's result is; /// syntactically ignored, perform any conversions that are; /// required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:95,perform,perform,95,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['perform']
Performance,"/// Implement SimplifyDemandedVectorElts for amdgcn buffer and image intrinsics.; ///; /// The result of simplifying amdgcn image and buffer store intrinsics is updating; /// definitions of the intrinsics vector argument, not Uses of the result like; /// image and buffer loads.; /// Note: This only supports non-TFE/LWE image intrinsic calls; those have; /// struct returns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:272,load,loads,272,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['load'],['loads']
Performance,"/// Implement the combining of integral values into a hash_code.; ///; /// This overload is selected when the value type of the iterator is integral; /// and when the input iterator is actually a pointer. Rather than computing; /// a hash_code for each object and then combining them, this (as an; /// optimization) directly combines the integers. Also, because the integers; /// are stored in contiguous memory, this routine avoids copying each value; /// and directly reads from the underlying memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:302,optimiz,optimization,302,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['optimiz'],['optimization']
Performance,"/// Implement the combining of integral values into a hash_code.; ///; /// This overload is selected when the value type of the iterator is; /// integral. Rather than computing a hash_code for each object and then; /// combining them, this (as an optimization) directly combines the integers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:247,optimiz,optimization,247,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['optimiz'],['optimization']
Performance,"/// Implementation of fixed size array delinearization. Try to delinearize; /// access function for a fixed size multi-dimensional array, by deriving; /// subscripts from GEP instructions. Returns true upon success and false; /// otherwise. \p Inst is the load/store instruction whose pointer operand is; /// the one we want to delinearize. \p AccessFn is its corresponding SCEV; /// expression w.r.t. the surrounding loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h:256,load,load,256,interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Delinearization.h,1,['load'],['load']
Performance,"/// Implements an efficient mapping from strings to IdentifierInfo nodes.; ///; /// This has no other purpose, but this is an extremely performance-critical; /// piece of the code, as each occurrence of every identifier goes through; /// here when lexed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:136,perform,performance-critical,136,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['perform'],['performance-critical']
Performance,/// Implements the naive hardening approach of putting an LFENCE after every; /// potentially mis-predicted control flow construct.; ///; /// We include this as an alternative mostly for the purpose of comparison. The; /// performance impact of this is expected to be extremely severe and not; /// practical for any real-world users.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:223,perform,performance,223,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['perform'],['performance']
Performance,"/// Implements the simple state machine that the Lexer class uses to; /// detect files subject to the 'multiple-include' optimization.; ///; /// The public methods in this class are triggered by various; /// events that occur when a file is lexed, and after the entire file is lexed,; /// information about which macro (if any) controls the header is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h:121,optimiz,optimization,121,interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,1,['optimiz'],['optimization']
Performance,/// In case we optimize for size we use repmovsb even if it's less efficient; /// so we can save the loads/stores of the leftover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp:15,optimiz,optimize,15,interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp,2,"['load', 'optimiz']","['loads', 'optimize']"
Performance,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:700,perform,performs,700,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['perform'],['performs']
Performance,"/// In order to form an interleaved access group X86InterleavedAccessGroup; /// requires a wide-load instruction \p 'I', a group of interleaved-vectors; /// \p Shuffs, reference to the first indices of each interleaved-vector; /// \p 'Ind' and the interleaving stride factor \p F. In order to generate; /// X86-specific instructions/intrinsics it also requires the underlying; /// target information \p STarget.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:96,load,load,96,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,1,['load'],['load']
Performance,"/// In what follows, the term ""input IR"" refers to code that is fed into the; /// vectorizer whereas the term ""output IR"" refers to code that is generated by; /// the vectorizer.; /// VPLane provides a way to access lanes in both fixed width and scalable; /// vectors, where for the latter the lane index sometimes needs calculating; /// as a runtime expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:246,scalab,scalable,246,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['scalab'],['scalable']
Performance,"/// In-memory cache for modules.; ///; /// This is a cache for modules for use across a compilation, sharing state; /// between the CompilerInstances in an implicit modules build. It must be; /// shared by each CompilerInstance, ASTReader, ASTWriter, and ModuleManager; /// that are coordinating.; ///; /// Critically, it ensures that a single process has a consistent view of each; /// PCM. This is used by \a CompilerInstance when building PCMs to ensure that; /// each \a ModuleManager sees the same files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h:14,cache,cache,14,interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/InMemoryModuleCache.h,2,['cache'],['cache']
Performance,"/// Increment the counters for the number of token paste operations; /// performed.; ///; /// If fast was specified, this is a 'fast paste' case we handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:73,perform,performed,73,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['perform'],['performed']
Performance,/// Indexed (pre/post inc/dec) load matching code for ARM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:31,load,load,31,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['load'],['load']
Performance,/// Indicate that the specified indexed load does or does not work with the; /// specified type and indicate what to do abort it.; ///; /// NOTE: All indexed mode loads are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:40,load,load,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],"['load', 'loads']"
Performance,/// Indicate that the specified indexed masked load does or does not work with; /// the specified type and indicate what to do about it.; ///; /// NOTE: All indexed mode masked loads are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:47,load,load,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],"['load', 'loads']"
Performance,/// Indicate that the specified load with extension does not work with the; /// specified type and indicate what to do about it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:32,load,load,32,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,/// Indicates a problem trying to load the preprocessed entity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:34,load,load,34,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['load'],['load']
Performance,"/// Indicates if a read (load) of \c errno is allowed in a non-condition part; /// of \c if, \c switch, loop and conditional statements when the errno; /// value may be undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp:25,load,load,25,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,1,['load'],['load']
Performance,/// Indicates if gaps between members of the group need to be masked out or if; /// unusued gaps can be loaded speculatively.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:104,load,loaded,104,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['load'],['loaded']
Performance,"/// Indicates that the definition of this class is now complete,; /// and provides a final overrider map to help determine; ///; /// \param FinalOverriders The final overrider map for this class, which can; /// be provided as an optimization for abstract-class checking. If NULL,; /// final overriders will be computed if they are needed to complete the; /// definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:229,optimiz,optimization,229,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['optimiz'],['optimization']
Performance,/// Indicates that the ivar cache does not yet include ivars; /// declared in the implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:28,cache,cache,28,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['cache'],['cache']
Performance,"/// Indicates when the AST writing is actively performing; /// serialization, rather than just queueing updates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h:47,perform,performing,47,interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,2,"['perform', 'queue']","['performing', 'queueing']"
Performance,"/// Indicates whether timestamps should be written to the produced; /// module file. This is the case for files implicitly written to the; /// module cache, where we need the timestamps to determine if the module; /// file is up to date, but not otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h:150,cache,cache,150,interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTWriter.h,1,['cache'],['cache']
Performance,/// Indicates whether we should trigger deserialization of nodes that had; /// not already been loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTNodeTraverser.h:96,load,loaded,96,interpreter/llvm-project/clang/include/clang/AST/ASTNodeTraverser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTNodeTraverser.h,1,['load'],['loaded']
Performance,"/// Indicates, whether a new load operation is permitted, it is within the; /// threshold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:29,load,load,29,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['load'],['load']
Performance,/// Inequality comparison for DenseMap.; ///; /// Equivalent to !(LHS == RHS). See operator== for performance notes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:98,perform,performance,98,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,1,['perform'],['performance']
Performance,/// Inequality comparison for DenseSet.; ///; /// Equivalent to !(LHS == RHS). See operator== for performance notes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h:98,perform,performance,98,interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseSet.h,1,['perform'],['performance']
Performance,/// Inequality comparison for SmallSet.; ///; /// Equivalent to !(LHS == RHS). See operator== for performance notes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h:98,perform,performance,98,interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,1,['perform'],['performance']
Performance,/// Infer alignment of a load / store address. Return std::nullopt if it; /// cannot be inferred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:25,load,load,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['load'],['load']
Performance,/// InferPtrAlignment - Infer alignment of a load / store address. Return; /// std::nullopt if it cannot be inferred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:45,load,load,45,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['load'],['load']
Performance,/// Inform safety info that we are planning to remove the instruction \p Inst; /// from its block. It will make all cache updates to keep it correct after; /// this removal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:116,cache,cache,116,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['cache'],['cache']
Performance,/// Inform the analysis cache that we have erased a block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:24,cache,cache,24,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,1,['cache'],['cache']
Performance,/// Inform the analysis cache that we have threaded an edge from; /// PredBB to OldSucc to be from PredBB to NewSucc instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:24,cache,cache,24,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,1,['cache'],['cache']
Performance,/// Inform the cache that a given value has been deleted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:15,cache,cache,15,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['cache'],['cache']
Performance,/// Inform the memory manager about the total amount of memory required to; /// allocate all sections to be loaded:; /// \p CodeSize - the total size of all code sections; /// \p DataSizeRO - the total size of all read-only data sections; /// \p DataSizeRW - the total size of all read-write data sections; ///; /// Note that by default the callback is disabled. To enable it; /// redefine the method needsToReserveAllocationSpace to return true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:108,load,loaded,108,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['load'],['loaded']
Performance,/// Inform the safety info that we are planning to insert a new instruction; /// \p Inst into the basic block \p BB. It will make all cache updates to keep; /// it correct after this insertion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:134,cache,cache,134,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['cache'],['cache']
Performance,/// Information about a load/store intrinsic defined by the target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:24,load,load,24,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,"/// Information about a module that has been loaded by the ASTReader.; ///; /// Each instance of the Module class corresponds to a single AST file, which; /// may be a precompiled header, precompiled preamble, a module, or an AST file; /// of some sort loaded as the main file, all of which are specific formulations; /// of the general notion of a ""module"". A module may depend on any number of; /// other modules.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h:45,load,loaded,45,interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleFile.h,2,['load'],['loaded']
Performance,/// Information about operands; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:74,optimiz,optimizations,74,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['optimiz'],['optimizations']
Performance,/// Information about the loaded object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:26,load,loaded,26,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['load'],['loaded']
Performance,/// Information about the plugin required to load its passes; ///; /// This struct defines the core interface for pass plugins and is supposed to; /// be filled out by plugin implementors. LLVM-side users of a plugin are; /// expected to use the \c PassPlugin class below to interface with it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h:45,load,load,45,interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassPlugin.h,1,['load'],['load']
Performance,"/// Information about which #includes were actually performed,; /// created by preprocessor callbacks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:52,perform,performed,52,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,1,['perform'],['performed']
Performance,"/// Initial processing of memory accesses determined that we may need; /// to add memchecks. Perform the analysis to determine the necessary checks.; ///; /// Note that, this is different from isDependencyCheckNeeded. When we retry; /// memcheck analysis without dependency checking; /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is; /// cleared while this remains set if we have potentially dependent accesses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:93,Perform,Perform,93,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['Perform'],['Perform']
Performance,/// Initial processing of memory accesses determined that we need to; /// perform dependency checking.; ///; /// Note that this can later be cleared if we retry memcheck analysis without; /// dependency checking (i.e. FoundNonConstantDistanceDependence).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:74,perform,perform,74,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['perform'],['perform']
Performance,/// Initialization functions perform any necessary setup for a checker.; /// They should include a call to CheckerManager::registerChecker.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerRegistryData.h:29,perform,perform,29,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerRegistryData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerRegistryData.h,1,['perform'],['perform']
Performance,/// Initialize AllowedToHoistLoads with information about whether invariant; /// loads can be moved outside a given loop,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:81,load,loads,81,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['load'],['loads']
Performance,"/// Initialize a GCCInstallationDetector from the driver.; ///; /// This performs all of the autodetection and sets up the various paths.; /// Once constructed, a GCCInstallationDetector is essentially immutable.; ///; /// FIXME: We shouldn't need an explicit TargetTriple parameter here, and; /// should instead pull the target out of the driver. This is currently; /// necessary because the driver doesn't store the final version of the target; /// triple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:73,perform,performs,73,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['perform'],['performs']
Performance,"/// Initialize all nodes of the functional graph before running the event loop.; /// This method is called once per event-loop and performs generic initialization; /// operations that do not depend on the specific processing slot (i.e. operations; /// that are common for all threads).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:131,perform,performs,131,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['perform'],['performs']
Performance,/// Initialize some target-specific data structures for the store merging; /// optimization. \p AddrSpace indicates which address space to use when; /// probing the legalizer info for legal stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h:79,optimiz,optimization,79,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,1,['optimiz'],['optimization']
Performance,/// Initialize the function information cache \p FI for the function \p F.; ///; /// This method needs to be called for all function that might be looked at; /// through the information cache interface *prior* to looking at them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:40,cache,cache,40,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,2,['cache'],['cache']
Performance,/// Initialize the semantic consumer with the Sema instance; /// being used to perform semantic analysis on the abstract syntax; /// tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaConsumer.h:79,perform,perform,79,interpreter/llvm-project/clang/include/clang/Sema/SemaConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaConsumer.h,1,['perform'],['perform']
Performance,/// Initialize the semantic source with the Sema instance; /// being used to perform semantic analysis on the abstract syntax; /// tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h:77,perform,perform,77,interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,3,['perform'],['perform']
Performance,"/// Initialize the state with the information in the Attributor \p A.; ///; /// This function is called by the Attributor once all abstract attributes; /// have been identified. It can and shall be used for task like:; /// - identify existing knowledge in the IR and use it for the ""known state""; /// - perform any work that is not going to change over time, e.g., determine; /// a subset of the IR, or attributes in-flight, that have to be looked at; /// in the `updateImpl` method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:303,perform,perform,303,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['perform'],['perform']
Performance,"/// Initializes the region of memory represented by \p loc with an initial; /// value. Once initialized, all values loaded from any sub-regions of that; /// region will be equal to \p V, unless overwritten later by the program.; /// This method should not be used on regions that are already initialized.; /// If you need to indicate that memory contents have suddenly become unknown; /// within a certain region of memory, consider invalidateRegions().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h:116,load,loaded,116,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,1,['load'],['loaded']
Performance,/// Initiates and performs a specific refactoring action.; ///; /// The specific rule will invoke an appropriate \c handle method on a; /// consumer to propagate the result of the refactoring action.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h:18,perform,performs,18,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/RefactoringActionRule.h,1,['perform'],['performs']
Performance,"/// InnerLoopVectorizer vectorizes loops which contain only one basic; /// block to a specified vectorization factor (VF).; /// This class performs the widening of scalars into vectors, or multiple; /// scalars. This class also implements the following features:; /// * It inserts an epilogue loop for handling loops that don't have iteration; /// counts that are known to be a multiple of the vectorization factor.; /// * It handles the code generation for reduction variables.; /// * Scalarization (implementation using scalars) of un-vectorizable; /// instructions.; /// InnerLoopVectorizer does not perform any vectorization-legality; /// checks, and relies on the caller to check for the different legality; /// aspects. The InnerLoopVectorizer relies on the; /// LoopVectorizationLegality class to provide information about the induction; /// and reduction variables that were found to a given vectorization factor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:139,perform,performs,139,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['perform'],"['perform', 'performs']"
Performance,/// Input DWARF is loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:19,load,loaded,19,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,1,['load'],['loaded']
Performance,"/// Insert a definition into the MemorySSA IR. RenameUses will rename any use; /// below the new def block (and any inserted phis). RenameUses should be set; /// to true if the definition may cause new aliases for loads below it. This; /// is not the case for hoisting or sinking or other forms of code *movement*.; /// It *is* the case for straight code insertion.; /// For example:; /// store a; /// if (foo) { }; /// load a; ///; /// Moving the store into the if block, and calling insertDef, does not; /// require RenameUses.; /// However, changing it to:; /// store a; /// if (foo) { store b }; /// load a; /// Where a mayalias b, *does* require RenameUses be set to true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:214,load,loads,214,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,3,['load'],"['load', 'loads']"
Performance,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1059,cache,cached,1059,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,2,"['cache', 'optimiz']","['cached', 'optimize']"
Performance,"/// Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:35,cache,cache,35,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['cache'],['cache']
Performance,/// InsertStackProtectors - Insert code into the prologue and epilogue of the; /// function.; ///; /// - The prologue code loads and stores the stack guard onto the stack.; /// - The epilogue checks the value stored in the prologue against the original; /// value. It calls __stack_chk_fail if they differ.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:123,load,loads,123,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,1,['load'],['loads']
Performance,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// check mechanism. When the image is loaded, the loader puts the appropriate; /// guard check function pointer in the __guard_check_icall_fptr global; /// symbol. This checks that the target address is a valid address-taken; /// function. The address of the target function is passed to the guard check; /// function in an architecture-specific register (e.g. ECX on 32-bit X86,; /// X15 on Aarch64, and R0 on ARM). The guard check function has no return; /// value (if the target is invalid, the guard check funtion will raise an; /// error).; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load void (i8*)*, void (i8*)** @__guard_check_icall_fptr; /// %2 = bitcast i32 ()* %0 to i8*; /// call cfguard_checkcc void %1(i8* %2); /// %3 = call i32 %0(); /// \endcode; ///; /// For example, the following X86 assembly code:; /// \code; /// movl $_target_func, %eax; /// calll *%eax; /// \endcode; ///; /// is transformed to:; /// \code; /// 	movl	$_target_func, %ecx; /// 	calll	*___guard_check_icall_fptr; /// 	calll	*%ecx; /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:119,load,loaded,119,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,5,['load'],"['load', 'loaded', 'loader']"
Performance,"/// Inserts a Control Flow Guard (CFG) check on an indirect call using the CFG; /// dispatch mechanism. When the image is loaded, the loader puts the; /// appropriate guard check function pointer in the; /// __guard_dispatch_icall_fptr global symbol. This checks that the target; /// address is a valid address-taken function and, if so, tail calls the; /// target. The target address is passed in an architecture-specific register; /// (e.g. RAX on X86_64), with all other arguments for the target function; /// passed as usual.; ///; /// For example, the following LLVM IR:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = call i32 %0(); /// \endcode; ///; /// is transformed to:; /// \code; /// %func_ptr = alloca i32 ()*, align 8; /// store i32 ()* @target_func, i32 ()** %func_ptr, align 8; /// %0 = load i32 ()*, i32 ()** %func_ptr, align 8; /// %1 = load i32 ()*, i32 ()** @__guard_dispatch_icall_fptr; /// %2 = call i32 %1() [ ""cfguardtarget""(i32 ()* %0) ]; /// \endcode; ///; /// For example, the following X86_64 assembly code:; /// \code; /// leaq target_func(%rip), %rax; ///	 callq *%rax; /// \endcode; ///; /// is transformed to:; /// \code; /// leaq target_func(%rip), %rax; /// callq *__guard_dispatch_icall_fptr(%rip); /// \endcode; ///; /// \param CB indirect call to instrument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp:122,load,loaded,122,interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/CFGuard/CFGuard.cpp,5,['load'],"['load', 'loaded', 'loader']"
Performance,/// Inserts a llvm.dbg.value intrinsic before a load of an alloca'd value; /// that has an associated llvm.dbg.declare intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:48,load,load,48,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,1,['load'],['load']
Performance,/// Inspect and optimize the given instruction. Note that erasing; /// instructions is not allowed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:16,optimiz,optimize,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['optimiz'],['optimize']
Performance,"/// Inspect hardware capabilities, and load the optimal library for RooFit computations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/Initialisation.cxx:39,load,load,39,roofit/batchcompute/src/Initialisation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/src/Initialisation.cxx,1,['load'],['load']
Performance,/// Installs the provided FileSystemStatCache object within; /// the FileManager.; ///; /// Ownership of this object is transferred to the FileManager.; ///; /// \param statCache the new stat cache to install. Ownership of this; /// object is transferred to the FileManager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:192,cache,cache,192,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['cache'],['cache']
Performance,/// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:88,optimiz,optimized,88,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,3,['optimiz'],['optimized']
Performance,"/// Instantiate the definition of a class from a given pattern.; ///; /// \param PointOfInstantiation The point of instantiation within the; /// source code.; ///; /// \param Instantiation is the declaration whose definition is being; /// instantiated. This will be either a class template specialization; /// or a member class of a class template specialization.; ///; /// \param Pattern is the pattern from which the instantiation; /// occurs. This will be either the declaration of a class template or; /// the declaration of a member class of a class template.; ///; /// \param TemplateArgs The template arguments to be substituted into; /// the pattern.; ///; /// \param TSK the kind of implicit or explicit instantiation to perform.; ///; /// \param Complain whether to complain if the class cannot be instantiated due; /// to the lack of a definition.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:730,perform,perform,730,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['perform'],['perform']
Performance,"/// Instantiate the definition of an enum from a given pattern.; ///; /// \param PointOfInstantiation The point of instantiation within the; /// source code.; /// \param Instantiation is the declaration whose definition is being; /// instantiated. This will be a member enumeration of a class; /// temploid specialization, or a local enumeration within a; /// function temploid specialization.; /// \param Pattern The templated declaration from which the instantiation; /// occurs.; /// \param TemplateArgs The template arguments to be substituted into; /// the pattern.; /// \param TSK The kind of implicit or explicit instantiation to perform.; ///; /// \return \c true if an error occurred, \c false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:637,perform,perform,637,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['perform'],['perform']
Performance,"/// Instantiate the definition of the given function from its; /// template.; ///; /// \param PointOfInstantiation the point at which the instantiation was; /// required. Note that this is not precisely a ""point of instantiation""; /// for the function, but it's close.; ///; /// \param Function the already-instantiated declaration of a; /// function template specialization or member function of a class template; /// specialization.; ///; /// \param Recursive if true, recursively instantiates any functions that; /// are required by this instantiation.; ///; /// \param DefinitionRequired if true, then we are performing an explicit; /// instantiation where the body of the function is required. Complain if; /// there is no such body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:613,perform,performing,613,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['perform'],['performing']
Performance,"/// Instantiate the definition of the given variable from its; /// template.; ///; /// \param PointOfInstantiation the point at which the instantiation was; /// required. Note that this is not precisely a ""point of instantiation""; /// for the variable, but it's close.; ///; /// \param Var the already-instantiated declaration of a templated variable.; ///; /// \param Recursive if true, recursively instantiates any functions that; /// are required by this instantiation.; ///; /// \param DefinitionRequired if true, then we are performing an explicit; /// instantiation where a definition of the variable is required. Complain; /// if there is no such definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:530,perform,performing,530,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['perform'],['performing']
Performance,"/// Instead of '[[MyClass alloc] init]', try to generate; /// 'objc_alloc_init(MyClass)'. This provides a code size improvement on the; /// caller side, as well as the optimized objc_alloc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:168,optimiz,optimized,168,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['optimiz'],['optimized']
Performance,"/// Instrument LoadInst; ///; /// Loads the corresponding shadow and (optionally) origin.; /// Optionally, checks that the load address is fully defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:15,Load,LoadInst,15,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,3,"['Load', 'load']","['LoadInst', 'Loads', 'load']"
Performance,"/// Instrument memcpy; ///; /// Similar to memmove: avoid copying shadow twice. This is somewhat; /// unfortunate as it may slowdown small constant memcpys.; /// FIXME: consider doing manual inline for small constant sizes and proper; /// alignment.; ///; /// Note: This also handles memcpy.inline, which promises no calls to external; /// functions as an optimization. However, with instrumentation enabled this; /// is difficult to promise; additionally, we know that the MSan runtime; /// exists and provides __msan_memcpy(). Therefore, we assume that with; /// instrumentation it's safe to turn memcpy.inline into a call to; /// __msan_memcpy(). Should this be wrong, such as when implementing memcpy(); /// itself, instrumentation should be disabled with the no_sanitize attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:356,optimiz,optimization,356,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['optimiz'],['optimization']
Performance,"/// Integer reductions may have a result type larger than the vector element; /// type. However, the reduction is performed using the vector element type; /// and the value in the top bits is unspecified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:114,perform,performed,114,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['perform'],['performed']
Performance,/// Intel processors have a unified instruction and data cache,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:57,cache,cache,57,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['cache'],['cache']
Performance,"/// Interface for printing of cache guts in tree mode printing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCache.h:30,cache,cache,30,roofit/roofitcore/inc/RooAbsCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCache.h,1,['cache'],['cache']
Performance,"/// Interface for processing of cache mode optimization calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCache.h:32,cache,cache,32,roofit/roofitcore/inc/RooAbsCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCache.h,2,"['cache', 'optimiz']","['cache', 'optimization']"
Performance,"/// Interface function to cache add contents to output in tree printing mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:26,cache,cache,26,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['cache'],['cache']
Performance,"/// Interface function to intercept cache operation mode changes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:36,cache,cache,36,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['cache'],['cache']
Performance,"/// Interface function to perform post-insert operations on cached object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:26,perform,perform,26,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,2,"['cache', 'perform']","['cached', 'perform']"
Performance,/// Interface to emit optimization remarks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:22,optimiz,optimization,22,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,7,['optimiz'],['optimization']
Performance,/// InterleavedLoadCombines Pass - This pass identifies interleaved loads and; /// combines them into wide loads detectable by InterleavedAccessPass; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:68,load,loads,68,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,2,['load'],['loads']
Performance,"/// Internal method to perform minimization; /// template on the type of method function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLNLSMinimizer.h:23,perform,perform,23,math/mathmore/inc/Math/GSLNLSMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/inc/Math/GSLNLSMinimizer.h,1,['perform'],['perform']
Performance,/// Interpret values loaded into registers by \p CurMI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:21,load,loaded,21,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['load'],['loaded']
Performance,/// Invalidate - Permanently mark this file as not being suitable for the; /// include-file optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h:92,optimiz,optimization,92,interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,1,['optimiz'],['optimization']
Performance,"/// Invalidate cached analyses for an IR unit.; ///; /// Walk through all of the analyses pertaining to this unit of IR and; /// invalidate them, unless they are preserved by the PreservedAnalyses set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:15,cache,cached,15,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['cached']
Performance,"/// Invalidate cached information about MBB. This must be called *before* MBB; /// is erased, or the CFG is otherwise changed.; ///; /// This invalidates per-block information about resource usage for MBB only,; /// and it invalidates per-trace information for any trace that passes; /// through MBB.; ///; /// Call Ensemble::getTrace() again to update any trace handles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h:15,cache,cached,15,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineTraceMetrics.h,1,['cache'],['cached']
Performance,"/// Invalidate groups that require a scalar epilogue (due to gaps). This can; /// happen when optimizing for size forbids a scalar epilogue, and the gap; /// cannot be filtered by masking the load/store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:94,optimiz,optimizing,94,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,2,"['load', 'optimiz']","['load', 'optimizing']"
Performance,"/// Invalidate instruction cache for code sections.; ///; /// Some platforms with separate data cache and instruction cache require; /// explicit cache flush, otherwise JIT code manipulations (like resolved; /// relocations) will get to the data cache but not to the instruction cache.; ///; /// This method is called from finalizeMemory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h:27,cache,cache,27,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/SectionMemoryManager.h,6,['cache'],['cache']
Performance,/// InvalidateInstructionCache - Before the JIT can run a block of code; /// that has been emitted it must invalidate the instruction cache on some; /// platforms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h:134,cache,cache,134,interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Memory.h,1,['cache'],['cache']
Performance,/// Invalidates all levels of the cache hierarchy and flushes modified data to; /// memory for the cache line specified by the address \a __m.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c CLFLUSHOPT instruction.; ///; /// \param __m; /// An address within the cache line to flush and invalidate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h:34,cache,cache,34,interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/clflushoptintrin.h,3,['cache'],['cache']
Performance,"/// Invalidates cached information about the specified pointer, because it; /// may be too conservative in memdep.; ///; /// This is an optional call that can be used when the client detects an; /// equivalence between the pointer and some other value and replaces the; /// other value with ptr. This can make Ptr available in more places that; /// cached info does not necessarily keep.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:16,cache,cached,16,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,2,['cache'],['cached']
Performance,/// Invalidates the cached analyses. Valid only when using the new pass; /// manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:20,cache,cached,20,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['cache'],['cached']
Performance,/// IrregularPartialArrayDestroy - a cleanup which performs a; /// partial array destroy where the end pointer is irregularly; /// determined and must be loaded from a local.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:51,perform,performs,51,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,2,"['load', 'perform']","['loaded', 'performs']"
Performance,/// Is the special member function which would be selected to perform the; /// specified operation on the specified class type a constexpr constructor?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:62,perform,perform,62,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['perform'],['perform']
Performance,"/// Is the user of the Attributor a module pass or not. This determines what; /// IR we can look at and modify. If it is a module pass we might deduce facts; /// outside the initial function set and modify functions outside that set,; /// but only as part of the optimization of the functions in the initial; /// function set. For CGSCC passes we can look at the IR of the module slice; /// but never run any deduction, or perform any modification, outside the; /// initial function set (which we assume is the SCC).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:263,optimiz,optimization,263,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,/// Is there an llvm.stacksave or llvm.stackrestore in the scheduling; /// region? Used to optimize the dependence calculation for the; /// common case where there isn't.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:91,optimiz,optimize,91,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['optimiz'],['optimize']
Performance,/// Is this a context in which we can perform class template argument; /// deduction?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:38,perform,perform,38,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['perform'],['perform']
Performance,/// Is this predicate the predefined any-extend load predicate?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:48,load,load,48,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['load'],['load']
Performance,/// Is this predicate the predefined non-extending load predicate?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:51,load,load,51,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['load'],['load']
Performance,/// Is this predicate the predefined sign-extend load predicate?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:49,load,load,49,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['load'],['load']
Performance,/// Is this predicate the predefined unindexed load predicate?; /// Is this predicate the predefined unindexed store predicate?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:47,load,load,47,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['load'],['load']
Performance,/// Is this predicate the predefined zero-extend load predicate?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:49,load,load,49,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['load'],['load']
Performance,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:94,optimiz,optimization,94,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,1,['optimiz'],['optimization']
Performance,/// IsEligibleForTailCallOptimization - Check whether the call is eligible; /// for tail call optimization. Targets which want to do tail call; /// optimization should implement this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:94,optimiz,optimization,94,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,10,['optimiz'],['optimization']
Performance,"/// IsStandardConversion - Determines whether there is a standard; /// conversion sequence (C++ [conv], C++ [over.ics.scs]) from the; /// expression From to the type ToType. Standard conversion sequences; /// only consider non-class types; for conversions that involve class; /// types, use TryImplicitConversion. If a conversion exists, SCS will; /// contain the standard conversion sequence required to perform this; /// conversion and this routine will return true. Otherwise, this; /// routine will return false and the value of SCS is unspecified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:405,perform,perform,405,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['perform'],['perform']
Performance,/// Issue an instruction without updating the ready queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:52,queue,queue,52,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['queue'],['queue']
Performance,/// Issues instruction(s) to restore all callee saved registers and returns; /// true if it isn't possible / profitable to do so by issuing a series of; /// load instructions via loadRegToStackSlot(). Returns false otherwise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h:157,load,load,157,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.h,2,['load'],"['load', 'loadRegToStackSlot']"
Performance,"/// It is possible for the addressing mode of the machine to fold the specified; /// instruction into a load or store that ultimately uses it.; /// However, the specified instruction has multiple uses.; /// Given this, it may actually increase register pressure to fold it; /// into the load. For example, consider this code:; ///; /// X = ...; /// Y = X+1; /// use(Y) -> nonload/store; /// Z = Y+1; /// load Z; ///; /// In this case, Y has multiple uses, and can be folded into the load of Z; /// (yielding load [X+2]). However, doing this will cause both ""X"" and ""X+1"" to; /// be live at the use(Y) line. If we don't fold Y into load Z, we use one; /// fewer register. Since Y can't be folded into ""use(Y)"" we don't increase the; /// number of computations either.; ///; /// Note that this (like most of CodeGenPrepare) is just a rough heuristic. If; /// X was live across 'load Z' for other reasons, we actually *would* want to; /// fold the addressing mode in the Z case. This would make Y die earlier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:104,load,load,104,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,7,['load'],['load']
Performance,"/// It is possible that there is a basic block that already performs the same; /// stores. This returns a duplicate block, if it exists; ///; /// \param OutputBBs [in] the blocks we are looking for a duplicate of.; /// \param OutputStoreBBs [in] The existing output blocks.; /// \returns an optional value with the number output block if there is a match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:60,perform,performs,60,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,1,['perform'],['performs']
Performance,/// Iterate over local declarations (locally parsed if this is a parsed; /// source file or the loaded declarations of the primary module if this is an; /// AST file).; /// \returns true if the iteration was complete or false if it was aborted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:96,load,loaded,96,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['load'],['loaded']
Performance,/// Iterate over the cached postorder blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:21,cache,cached,21,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,1,['cache'],['cached']
Performance,"/// Iterate through the block and record base, offset pairs of loads which can; /// be widened into a single load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:63,load,loads,63,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,2,['load'],"['load', 'loads']"
Performance,"/// Iteration over the elements in the vector.; ///; /// In a complete iteration, the iterator walks the range [-M, N),; /// where negative values are used to indicate elements; /// loaded from the external source while non-negative values are used to; /// indicate elements added via \c push_back().; /// However, to provide iteration in source order (for, e.g., chained; /// precompiled headers), dereferencing the iterator flips the negative; /// values (corresponding to loaded entities), so that position -M; /// corresponds to element 0 in the loaded entities vector, position -M+1; /// corresponds to element 1 in the loaded entities vector, etc. This; /// gives us a reasonably efficient, source-order walk.; ///; /// We define this as a wrapping iterator around an int. The; /// iterator_adaptor_base class forwards the iterator methods to basic integer; /// arithmetic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h:182,load,loaded,182,interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,4,['load'],['loaded']
Performance,"/// Iteration over the preprocessed entities.; ///; /// In a complete iteration, the iterator walks the range [-M, N),; /// where negative values are used to indicate preprocessed entities; /// loaded from the external source while non-negative values are used to; /// indicate preprocessed entities introduced by the current preprocessor.; /// However, to provide iteration in source order (for, e.g., chained; /// precompiled headers), dereferencing the iterator flips the negative; /// values (corresponding to loaded entities), so that position -M; /// corresponds to element 0 in the loaded entities vector, position -M+1; /// corresponds to element 1 in the loaded entities vector, etc. This; /// gives us a reasonably efficient, source-order walk.; ///; /// We define this as a wrapping iterator around an int. The; /// iterator_adaptor_base class forwards the iterator methods to basic; /// integer arithmetic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:194,load,loaded,194,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,4,['load'],['loaded']
Performance,"/// Iteratively inline hot callsites of a function.; ///; /// Iteratively traverse all callsites of the function \p F, so as to; /// find out callsites with corresponding inline instances.; ///; /// For such callsites,; /// - If it is hot enough, inline the callsites and adds callsites of the callee; /// into the caller. If the call is an indirect call, first promote; /// it to direct call. Each indirect call is limited with a single target.; ///; /// - If a callsite is not inlined, merge the its profile to the outline; /// version (if --sample-profile-merge-inlinee is true), or scale the; /// counters of standalone function based on the profile of inlined; /// instances (if --sample-profile-merge-inlinee is false).; ///; /// Later passes may consume the updated profiles.; ///; /// \param F function to perform iterative inlining.; /// \param InlinedGUIDs a set to be updated to include all GUIDs that are; /// inlined in the profiled binary.; ///; /// \returns True if there is any inline happened.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:814,perform,perform,814,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['perform'],['perform']
Performance,/// Iteratively perform simplification on a worklist of users of the; /// specified induction variable. This is the top-level driver that applies; /// all simplifications to users of an IV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:16,perform,perform,16,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['perform'],['perform']
Performance,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:16,perform,perform,16,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,/// Iterators over all possible lookups within this context that are; /// currently loaded; don't attempt to retrieve anything from an external; /// source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:84,load,loaded,84,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['load'],['loaded']
Performance,/// JobList - A sequence of jobs to perform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Job.h:36,perform,perform,36,interpreter/llvm-project/clang/include/clang/Driver/Job.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Job.h,1,['perform'],['perform']
Performance,"/// Keep a cache of UniqueInstrs for each MachineInstr. In GISel,; /// often instructions are mutated (while their ID has completely changed).; /// Whenever mutation happens, invalidate the UniqueMachineInstr for the; /// MachineInstr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:11,cache,cache,11,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,1,['cache'],['cache']
Performance,/// Keep information for referenced clang module: already loaded DWARF info; /// of the clang module and a CompileUnit of the module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h:58,load,loaded,58,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinker.h,2,['load'],['loaded']
Performance,/// Keep track of Allocas for which we believe we may get SROA optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:63,optimiz,optimization,63,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['optimiz'],['optimization']
Performance,"/// Keep track of the probabilities to the successors. This vector has the; /// same order as Successors, or it is empty if we don't use it (disable; /// optimization).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:154,optimiz,optimization,154,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['optimiz'],['optimization']
Performance,"/// Keeps a set of PHINodes.; ///; /// This is a minimal set implementation for a specific use case:; /// It is very fast when there are very few elements, but also provides good; /// performance when there are many. It is similar to SmallPtrSet, but also; /// provides iteration by insertion order, which is deterministic and stable; /// across runs. It is also similar to SmallSetVector, but provides removing; /// elements in O(1) time. This is achieved by not actually removing the element; /// from the underlying vector, so comes at the cost of using more memory, but; /// that is fine, since PhiNodeSets are used as short lived objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:184,perform,performance,184,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['perform'],['performance']
Performance,/// Keeps macro expanded tokens for TokenLexers.; //; /// Works like a stack; a TokenLexer adds the macro expanded tokens that is; /// going to lex in the cache and when it finishes the tokens are removed; /// from the end of the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:155,cache,cache,155,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,2,['cache'],['cache']
Performance,/// Keeps track and caches skipped ranges and also retrieves a prior skipped; /// range if the same block is re-visited.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:20,cache,caches,20,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['cache'],['caches']
Performance,/// Keeps track of each lookup performed by LookupFile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:31,perform,performed,31,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['perform'],['performed']
Performance,/// Keeps track of non-local addresses that have been sunk into a block.; /// This allows us to avoid inserting duplicate code for blocks with; /// multiple load/stores of the same address. The usage of WeakTrackingVH; /// enables SunkAddrs to be treated as a cache whose entries can be; /// invalidated if a sunken address computation has been erased.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:157,load,load,157,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,2,"['cache', 'load']","['cache', 'load']"
Performance,/// Keeps track of options that affect how file operations are performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileSystemOptions.h:63,perform,performed,63,interpreter/llvm-project/clang/include/clang/Basic/FileSystemOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileSystemOptions.h,1,['perform'],['performed']
Performance,/// Kernel (=GPU) optimizations and utility functions; ///; ///{{; /// Cache to remember the unique kernel for a function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:18,optimiz,optimizations,18,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,2,"['Cache', 'optimiz']","['Cache', 'optimizations']"
Performance,"/// Kinds of access we can perform on an object, for diagnostics. Note that; /// we consider a member function call to be a kind of access, even though; /// it is not formally an access of the object, because it has (largely) the; /// same set of semantic restrictions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h:27,perform,perform,27,interpreter/llvm-project/clang/lib/AST/Interp/State.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/State.h,1,['perform'],['perform']
Performance,"/// LICalc - Cache for computing live ranges and SSA update. Each instance; /// can only handle non-overlapping live ranges, so use a separate; /// LiveIntervalCalc instance for the complement interval when in spill mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:13,Cache,Cache,13,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,1,['Cache'],['Cache']
Performance,"/// LLVM IR: we accept this so that we can run the optimizer on it,; /// and compile it to assembly or object code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangStandard.h:51,optimiz,optimizer,51,interpreter/llvm-project/clang/include/clang/Basic/LangStandard.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangStandard.h,1,['optimiz'],['optimizer']
Performance,/// LLVM i8 type. Cached here to avoid repeatedly getting it in all of the; /// places where it's used,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:18,Cache,Cached,18,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['Cache'],['Cached']
Performance,"/// LLVM_MARK_AS_BITMASK_ENUM lets you opt in an individual enum type so you can; /// perform bitwise operations on it without putting static_cast everywhere.; ///; /// \code; /// enum MyEnum {; /// E1 = 1, E2 = 2, E3 = 4, E4 = 8,; /// LLVM_MARK_AS_BITMASK_ENUM(/* LargestValue = */ E4); /// };; ///; /// void Foo() {; /// MyEnum A = (E1 | E2) & E3 ^ ~E4; // Look, ma: No static_cast!; /// }; /// \endcode; ///; /// Normally when you do a bitwise operation on an enum value, you get back an; /// instance of the underlying type (e.g. int). But using this macro, bitwise; /// ops on your enum will return you back instances of the enum. This is; /// particularly useful for enums which represent a combination of flags.; ///; /// The parameter to LLVM_MARK_AS_BITMASK_ENUM should be the largest individual; /// value in your enum.; ///; /// All of the enum's values must be non-negative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h:86,perform,perform,86,interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitmaskEnum.h,1,['perform'],['perform']
Performance,"/// LOAD and STORE have token chains as their first operand, then the same; /// operands as an LLVM load/store instruction, then an offset node that; /// is added / subtracted from the base pointer to form the address (for; /// indexed memory ops).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,LOAD,LOAD,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,"['LOAD', 'load']","['LOAD', 'load']"
Performance,"/// LXVRZX - Load VSX Vector Rightmost and Zero Extend; /// This node represents v1i128 BUILD_VECTOR of a zero extending load; /// instruction from <byte, halfword, word, or doubleword> to i128.; /// Allows utilization of the Load VSX Vector Rightmost Instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:13,Load,Load,13,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,3,"['Load', 'load']","['Load', 'load']"
Performance,"/// Last chance recoloring has a high compile time cost especially for; /// targets with a lot of registers.; /// This method is used to decide whether or not \p VirtReg should; /// go through this expensive heuristic.; /// When this target hook is hit, by returning false, there is a high; /// chance that the register allocation will fail altogether (usually with; /// ""ran out of registers"").; /// That said, this error usually points to another problem in the; /// optimization pipeline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:469,optimiz,optimization,469,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['optimiz'],['optimization']
Performance,"/// LastDecl - The last declaration stored within this declaration; /// context. FIXME: We could probably cache this value somewhere; /// outside of the DeclContext, to reduce the size of DeclContext by; /// another pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:106,cache,cache,106,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['cache'],['cache']
Performance,"/// Late ARC optimizations; ///; /// These change the IR in a way that makes it difficult to be analyzed by; /// ObjCARCOpt, so it's run late.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:13,optimiz,optimizations,13,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['optimiz'],['optimizations']
Performance,/// Layout pointer alignment element.; ///; /// Stores the alignment data associated with a given pointer and address space.; ///; /// \note The unusual order of elements in the structure attempts to reduce; /// padding and make the structure slightly more cache friendly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:257,cache,cache,257,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,1,['cache'],['cache']
Performance,"/// Leave a delayed-diagnostic state that was previously pushed.; /// Do not emit any of the diagnostics. This is performed as part; /// of the bookkeeping of popping a pool ""properly"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:114,perform,performed,114,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performed']
Performance,"/// Legalize a single operand \p OpIdx of the machine instruction \p MI as a; /// Def by performing it with additional vector elements and extracting the; /// result elements, and replacing the vreg of the operand in place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h:89,perform,performing,89,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,1,['perform'],['performing']
Performance,/// Legalize a value that's loaded from kernel arguments. This is only used by; /// legacy intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:28,load,loaded,28,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['load'],['loaded']
Performance,"/// Legalize an instruction by performing the operation on a wider scalar type; /// (for example a 16-bit addition can be safely performed at 32-bits; /// precision, ignoring the unused bits).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h:31,perform,performing,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,2,['perform'],"['performed', 'performing']"
Performance,"/// Legalize instruction \p MI where operands in \p OpIndices must be SGPRs. If; /// any of the required SGPR operands are VGPRs, perform a waterfall loop to; /// execute the instruction for each unique combination of values in all lanes; /// in the wave. The block will be split such that rest of the instructions are; /// moved to a new block.; ///; /// Essentially performs this loop:; //; /// Save Execution Mask; /// For (Lane : Wavefront) {; /// Enable Lane, Disable all other lanes; /// SGPR = read SGPR value for current lane from VGPR; /// VGPRResult[Lane] = use_op SGPR; /// }; /// Restore Execution Mask; ///; /// There is additional complexity to try for compare values to identify the; /// unique values used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:130,perform,perform,130,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,2,['perform'],"['perform', 'performs']"
Performance,/// Legalize the gather prefetch (scalar + vector addressing mode) when the; /// offset vector is an unpacked 32-bit scalable vector. The other cases (Offset; /// != nxv2i32) do not need legalization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:117,scalab,scalable,117,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['scalab'],['scalable']
Performance,"/// LexTokenInternal - This implements a simple C family lexer. It is an; /// extremely performance critical piece of code. This assumes that the buffer; /// has a null character at the end of the file. This returns a preprocessing; /// token, not a normal token, as such, it is an internal interface. It assumes; /// that the Flags of result have been cleared before calling this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:88,perform,performance,88,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['perform'],['performance']
Performance,"/// LibCallSimplifier - This class implements a collection of optimizations; /// that replace well formed calls to library functions with a more optimal; /// form. For example, replacing 'printf(""Hello!"")' with 'puts(""Hello!"")'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h:62,optimiz,optimizations,62,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SimplifyLibCalls.h,1,['optimiz'],['optimizations']
Performance,"/// Lightweight storage for a collection of types.; /// Differently from std::tuple, no instantiation of objects of stored types is performed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/TypeTraits.hxx:132,perform,performed,132,core/foundation/inc/ROOT/TypeTraits.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/TypeTraits.hxx,1,['perform'],['performed']
Performance,/// Limit the number of loaded ASTs. It is used to limit the memory usage; /// of the CrossTranslationUnitContext. The ASTUnitStorage has the; /// information whether the AST to load is actually loaded or returned from; /// cache. This information is needed to maintain the counter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:24,load,loaded,24,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,4,"['cache', 'load']","['cache', 'load', 'loaded']"
Performance,/// Linker Optimization Hint Type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h:11,Optimiz,Optimization,11,interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCLinkerOptimizationHint.h,1,['Optimiz'],['Optimization']
Performance,"/// List of callbacks for globals being tracked by this analysis. Note that; /// these objects are quite large, but we only anticipate having one per; /// global tracked by this analysis. There are numerous optimizations we; /// could perform to the memory utilization here if this becomes a problem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h:207,optimiz,optimizations,207,interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/GlobalsModRef.h,2,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,/// List of dynamic shared object files to be loaded as pass plugins.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:46,load,loaded,46,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,1,['load'],['loaded']
Performance,/// List of global values which are required to be present in the object file;; /// bitcast to i8*. This is used for forcing visibility of symbols which may; /// otherwise be optimized out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:175,optimiz,optimized,175,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['optimiz'],['optimized']
Performance,/// List of instructions ordered by load/store offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:36,load,load,36,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['load'],['load']
Performance,/// List of instructions which this instruction could be control dependent; /// on. Allowing such nodes to be scheduled below this one could introduce; /// a runtime fault which didn't exist in the original program.; /// ex: this is a load or udiv following a readonly call which inf loops,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:235,load,load,235,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['load'],['load']
Performance,/// List of virtual calls made by this function using (respectively); /// llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics that do; /// not have all constant integer arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:123,load,load,123,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['load'],['load']
Performance,/// List of virtual calls made by this function using (respectively); /// llvm.assume(llvm.type.test) or llvm.type.checked.load intrinsics with; /// all constant integer arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:123,load,load,123,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['load'],['load']
Performance,"/// Liveness information for this Candidate. Tracks from the end of the; /// block containing this Candidate to the beginning of its sequence.; ///; /// Optional. Can be used to fine-tune the cost model, or fine-tune legality; /// decisions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:183,tune,tune,183,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,2,['tune'],['tune']
Performance,"/// Liveness information restricted to this Candidate's instruction sequence.; ///; /// Optional. Can be used to fine-tune the cost model, or fine-tune legality; /// decisions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:118,tune,tune,118,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,2,['tune'],['tune']
Performance,/// Load & Store {; // VE doesn't have i1 sign extending load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,2,"['Load', 'load']","['Load', 'load']"
Performance,/// Load (or add) an immediate into a register.; ///; /// @param ImmValue The immediate to load.; /// @param DstReg The register that will hold the immediate.; /// @param SrcReg A register to add to the immediate or Mips::NoRegister; /// for a simple initialization.; /// @param Is32BitImm Is ImmValue 32-bit or 64-bit?; /// @param IsAddress True if the immediate represents an address. False if it; /// is an integer.; /// @param IDLoc Location of the immediate in the source file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,2,"['Load', 'load']","['Load', 'load']"
Performance,"/// Load Compiled API notes for current module.; ///; /// \param Buffers Array of compiled API notes.; ///; /// \returns true if API notes were successfully loaded, \c false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,2,"['Load', 'load']","['Load', 'loaded']"
Performance,/// Load DIEs of input compilation unit. \returns true if input DIEs; /// successfully loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:4,Load,Load,4,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,2,"['Load', 'load']","['Load', 'loaded']"
Performance,/// Load a (possibly unaligned) pointer from a given address and; /// offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:4,Load,Load,4,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,1,['Load'],['Load']
Performance,/// Load a (possibly unaligned) source location from a given address; /// and offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp:4,Load,Load,4,interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/NestedNameSpecifier.cpp,1,['Load'],['Load']
Performance,"/// Load a (real) dynamic library and make its symbols available through a; /// new JITDylib with the same name.; ///; /// If the given *executor* path contains a valid platform dynamic library; /// then that library will be loaded, and a new bare JITDylib whose name is; /// the given path will be created to make the library's symbols available to; /// JIT'd code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h:4,Load,Load,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,2,"['Load', 'load']","['Load', 'loaded']"
Performance,/// Load a 32-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 32-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:4,Load,Load,4,interpreter/llvm-project/clang/lib/Headers/immintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h,2,"['Load', 'load']","['Load', 'load']"
Performance,/// Load a 64-bit value from memory and swap its bytes.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the MOVBE instruction.; ///; /// \param __P; /// A pointer to the 64-bit value to load.; /// \returns The byte-swapped value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h:4,Load,Load,4,interpreter/llvm-project/clang/lib/Headers/immintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/immintrin.h,2,"['Load', 'load']","['Load', 'load']"
Performance,"/// Load a SavedModel, find the given inputs and outputs, and setup storage; /// for input tensors. The user is responsible for correctly dimensioning the; /// input tensors and setting their values before calling evaluate().; /// To initialize:; /// - construct the object; /// - initialize the input tensors using initInput. Indices must correspond to; /// indices in the InputNames used at construction.; /// To use:; /// - set input values by using getInput to get each input tensor, and then; /// setting internal scalars, for all dimensions (tensors are row-major:; /// https://github.com/tensorflow/tensorflow/blob/r1.5/tensorflow/c/c_api.h#L205); /// - call evaluate. The input tensors' values are not consumed after this, and; /// may still be read.; /// - use the outputs in the output vector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h:4,Load,Load,4,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,1,['Load'],['Load']
Performance,/// Load a matrix with \p Shape starting at \p Ptr and using \p Stride between; /// vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['Load'],['Load']
Performance,/// Load a member function from an object and a member function; /// pointer. Apply the this-adjustment and set 'This' to the; /// adjusted value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Load,Load,4,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,1,['Load'],['Load']
Performance,"/// Load a pointer with type \p PtrTy stored at address \p Ptr.; /// Note that \p PtrTy is the type of the loaded pointer, not the addresses; /// it is loaded from.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:4,Load,Load,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,3,"['Load', 'load']","['Load', 'loaded']"
Performance,"/// Load a selector from disk, registering its ID if it exists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['Load'],['Load']
Performance,/// Load a set of name remappings from a text file.; ///; /// See the documentation at the top of the file for an explanation of; /// the expected format.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SymbolRemappingReader.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/ProfileData/SymbolRemappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SymbolRemappingReader.cpp,1,['Load'],['Load']
Performance,/// Load a value from memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,1,['Load'],['Load']
Performance,"/// Load a vtable from This, an object of polymorphic type RD, or from one of; /// its virtual bases if it does not have its own vtable. Returns the vtable; /// and the class from which the vtable was loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Load,Load,4,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,2,"['Load', 'load']","['Load', 'loaded']"
Performance,/// Load all external visible decls in the given DeclContext.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['Load'],['Load']
Performance,"/// Load all known, top-level system modules.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['Load'],['Load']
Performance,/// Load all of the module maps within the immediate subdirectories; /// of the given search directory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['Load'],['Load']
Performance,/// Load an input into a writer context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['Load'],['Load']
Performance,/// Load and verify that a PCH file is usable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,1,['Load'],['Load']
Performance,/// Load any externally-stored vtable uses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Load'],['Load']
Performance,/// Load any lazily-loaded specializations from the external source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,6,"['Load', 'load']","['Load', 'loaded']"
Performance,/// Load bitcode modules to link into our module from the options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenAction.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenAction.h,1,['Load'],['Load']
Performance,"/// Load each IR file and dump certain information based on active flags.; ///; /// The main point here is to provide lit-testable coverage for the LTOModule; /// functionality that's exposed by the C API. Moreover, this provides testing; /// coverage for modules that have been created in their own contexts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,1,['Load'],['Load']
Performance,"/// Load everything, including Sema.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['Load'],['Load']
Performance,/// Load from an Objective-C property reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:4,Load,Load,4,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,1,['Load'],['Load']
Performance,"/// Load internal wrapping key from __intkey, __enkey_lo and __enkey_hi. __ctl; /// will assigned to EAX, whch specifies the KeySource and whether backing up; /// the key is permitted. The 256-bit encryption key is loaded from the two; /// explicit operands (__enkey_lo and __enkey_hi). The 128-bit integrity key is; /// loaded from the implicit operand XMM0 which assigned by __intkey.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> LOADIWKEY </c> instructions.; ///; /// \code{.operation}; /// IF CPL > 0 // LOADKWKEY only allowed at ring 0 (supervisor mode); /// GP (0); /// FI; /// IF “LOADIWKEY exiting” VM execution control set; /// VMexit; /// FI; /// IF __ctl[4:1] > 1 // Reserved KeySource encoding used; /// GP (0); /// FI; /// IF __ctl[31:5] != 0 // Reserved bit in __ctl is set; /// GP (0); /// FI; /// IF __ctl[0] AND (CPUID.19H.ECX[0] == 0) // NoBackup is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 1) AND (CPUID.19H.ECX[1] == 0) // KeySource of 1 is not supported on this part; /// GP (0); /// FI; /// IF (__ctl[4:1] == 0) // KeySource of 0.; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0]:; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // KeySource of 1. See RDSEED definition for details of randomness; /// IF HW_NRND_GEN.ready == 1 // Full-entropy random data from RDSEED was received; /// IWKey.Encryption Key[127:0] := __enkey_hi[127:0] XOR HW_NRND_GEN.data[127:0]; /// IWKey.Encryption Key[255:128] := __enkey_lo[127:0] XOR HW_NRND_GEN.data[255:128]; /// IWKey.Encryption Key[255:0] := __enkey_hi[127:0]:__enkey_lo[127:0] XOR HW_NRND_GEN.data[255:0]; /// IWKey.IntegrityKey[127:0] := __intkey[127:0] XOR HW_NRND_GEN.data[383:256]; /// IWKey.NoBackup := __ctl[0]; /// IWKey.KeySource := __ctl[4:1]; /// ZF := 0; /// ELSE // Random data was not returned from RDS",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h:4,Load,Load,4,interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/keylockerintrin.h,6,"['LOAD', 'Load', 'load']","['LOADIWKEY', 'LOADKWKEY', 'Load', 'loaded']"
Performance,"/// Load object with live-in variable values. \p mlocs contains the live-in; /// values in each machine location, while \p vlocs the live-in variable; /// values. This method picks variable locations for the live-in variables,; /// creates DBG_VALUEs and puts them in #Transfers, then prepares the other; /// object fields to track variable locations as we step through the block.; /// FIXME: could just examine mloctracker instead of passing in \p mlocs?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['Load'],['Load']
Performance,/// Load of global gamed gegisters are always calls to intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:4,Load,Load,4,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['Load'],['Load']
Performance,/// Load options and the preprocessor state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['Load'],['Load']
Performance,/// Load profiles specified by BaseFilename and TestFilename.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['Load'],['Load']
Performance,/// Load queue size.; ///; /// A value of zero for this field means that the load queue is unbounded.; /// Processor models can declare the size of a load queue via tablegen (see; /// the definition of tablegen class LoadQueue in; /// llvm/Target/TargetSchedule.td).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:4,Load,Load,4,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,7,"['Load', 'load', 'queue']","['Load', 'LoadQueue', 'load', 'queue']"
Performance,/// Load queue size.; ///; /// A value of zero for this field means that the store queue is unbounded.; /// Processor models can declare the size of a store queue via tablegen (see; /// the definition of tablegen class StoreQueue in; /// llvm/Target/TargetSchedule.td).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:4,Load,Load,4,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,4,"['Load', 'queue']","['Load', 'queue']"
Performance,"/// Load samples from a text file.; ///; /// See the documentation at the top of the file for an explanation of; /// the expected format.; ///; /// \returns true if the file was loaded successfully, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SampleProfReader.cpp,2,"['Load', 'load']","['Load', 'loaded']"
Performance,"/// Load shared libs necessary for graphics. These libraries are only; /// loaded when gROOT->IsBatch() is kFALSE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:4,Load,Load,4,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,2,"['Load', 'load']","['Load', 'loaded']"
Performance,/// Load stack guard from the frame and check if it has changed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['Load'],['Load']
Performance,"/// Load the API notes associated with the given buffer, whether it is; /// the binary or source form of API notes.; ///; /// \returns the API notes reader for this file, or null if there is; /// a failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,1,['Load'],['Load']
Performance,"/// Load the API notes associated with the given file, whether it is; /// the binary or source form of API notes.; ///; /// \returns the API notes reader for this file, or null if there is; /// a failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,1,['Load'],['Load']
Performance,"/// Load the API notes for the current module.; ///; /// \param M The current module.; /// \param LookInModule Whether to look inside the module itself.; /// \param SearchPaths The paths in which we should search for API notes; /// for the current module.; ///; /// \returns true if API notes were successfully loaded, \c false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,2,"['Load', 'load']","['Load', 'loaded']"
Performance,"/// Load the AST file and validate its contents against the given; /// Preprocessor.; ///; /// \param PP the preprocessor associated with the context in which this; /// precompiled header will be loaded.; ///; /// \param Context the AST context that this precompiled header will be; /// loaded into, if any.; ///; /// \param PCHContainerRdr the PCHContainerOperations to use for loading and; /// creating modules.; ///; /// \param Extensions the list of module file extensions that can be loaded; /// from the AST files.; ///; /// \param isysroot If non-NULL, the system include path specified by the; /// user. This is only used with relocatable PCH files. If non-NULL,; /// a relocatable PCH file will use the default path ""/"".; ///; /// \param DisableValidationKind If set, the AST reader will suppress most; /// of its regular consistency checking, allowing the use of precompiled; /// headers and module files that cannot be determined to be compatible.; ///; /// \param AllowASTWithCompilerErrors If true, the AST reader will accept an; /// AST file the was created out of an AST with compiler errors,; /// otherwise it will reject it.; ///; /// \param AllowConfigurationMismatch If true, the AST reader will not check; /// for configuration differences between the AST file and the invocation.; ///; /// \param ValidateSystemInputs If true, the AST reader will validate; /// system input files in addition to user input files. This is only; /// meaningful if \p DisableValidation is false.; ///; /// \param UseGlobalIndex If true, the AST reader will try to load and use; /// the global module index.; ///; /// \param ReadTimer If non-null, a timer used to track the time spent; /// deserializing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,6,"['Load', 'load']","['Load', 'load', 'loaded', 'loading']"
Performance,"/// Load the AST file designated by the given file name.; ///; /// \param FileName The name of the AST file to load.; ///; /// \param Type The kind of AST being loaded, e.g., PCH, module, main file,; /// or preamble.; ///; /// \param ImportLoc the location where the module file will be considered as; /// imported from. For non-module AST types it should be invalid.; ///; /// \param ClientLoadCapabilities The set of client load-failure; /// capabilities, represented as a bitset of the enumerators of; /// LoadFailureCapabilities.; ///; /// \param LoadedModuleFile The optional out-parameter refers to the new; /// loaded modules. In case the module specified by FileName is already; /// loaded, the module file pointer referred by NewLoadedModuleFile wouldn't; /// change. Otherwise if the AST file get loaded successfully,; /// NewLoadedModuleFile would refer to the address of the new loaded top level; /// module. The state of NewLoadedModuleFile is unspecified if the AST file; /// isn't loaded successfully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,11,"['Load', 'load']","['Load', 'LoadFailureCapabilities', 'LoadedModuleFile', 'load', 'load-failure', 'loaded']"
Performance,"/// Load the AST from a source-file, which is supposed to be located inside the; /// YAML formatted invocation list file under the filesystem path specified by; /// \p InvocationList. The invocation list should contain absolute paths.; /// \p SourceFilePath is the absolute path of the source file that contains the; /// function definition the analysis is looking for. The Index is built by the; /// \p clang-extdef-mapping tool, which is also supposed to be generating; /// absolute paths.; ///; /// Proper diagnostic emission requires absolute paths, so even if a future; /// change introduces the handling of relative paths, this must be taken into; /// consideration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp:4,Load,Load,4,interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CrossTU/CrossTranslationUnit.cpp,1,['Load'],['Load']
Performance,"/// Load the AST, but do not restore Sema state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['Load'],['Load']
Performance,"/// Load the ASTUnit by its identifier found in the index file. If the; /// identifier is suffixed with '.ast' it is considered a dump. Otherwise; /// it is treated as source-file, and on-demand parsed. Relative paths are; /// prefixed with CTUDir.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['Load'],['Load']
Performance,/// Load the VTT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:4,Load,Load,4,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['Load'],['Load']
Performance,"/// Load the combined index from disk, compute the imports, and emit; /// the import file lists for each module to disk.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,1,['Load'],['Load']
Performance,"/// Load the combined index from disk, then compute and generate; /// individual index files suitable for ThinLTO distributed backend builds; /// on the files mentioned on the command line (these must match the index; /// content).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,1,['Load'],['Load']
Performance,"/// Load the combined index from disk, then load every file referenced by",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,2,"['Load', 'load']","['Load', 'load']"
Performance,"/// Load the combined index from disk, then load every file referenced by; /// the index and add them to the generator, finally perform the promotion; /// on the files mentioned on the command line (these must match the index; /// content).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,3,"['Load', 'load', 'perform']","['Load', 'load', 'perform']"
Performance,"/// Load the combined index from disk, then load every file referenced by; /// the index and add them to the generator, then performs the promotion and; /// cross module importing on the files mentioned on the command line; /// (these must match the index content).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,3,"['Load', 'load', 'perform']","['Load', 'load', 'performs']"
Performance,/// Load the contents of the given module file into the builder.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp:4,Load,Load,4,interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/GlobalModuleIndex.cpp,1,['Load'],['Load']
Performance,/// Load the contents of the global method pool for a given; /// selector if necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,3,['Load'],['Load']
Performance,/// Load the contents of the global method pool for a given; /// selector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,3,['Load'],['Load']
Performance,/// Load the coverage mapping data. Return nullptr if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,1,['Load'],['Load']
Performance,"/// Load the coverage mapping from the given object files and profile. If; /// \p Arches is non-empty, it must specify an architecture for each object.; /// Ignores non-instrumented object files unless all are not instrumented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h:4,Load,Load,4,interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,1,['Load'],['Load']
Performance,/// Load the coverage mapping using the given readers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h:4,Load,Load,4,interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,1,['Load'],['Load']
Performance,/// Load the current object file symbols into CurrentObjectAddresses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,1,['Load'],['Load']
Performance,/// Load the declarations within this lexical storage from an; /// external source.; /// \return \c true if any declarations were added.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:4,Load,Load,4,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,1,['Load'],['Load']
Performance,/// Load the dynamic library at the given path and return a handle to it.; /// If LibraryPath is null this function will return the global handle for; /// the target process.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h:4,Load,Load,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutorProcessControl.h,1,['Load'],['Load']
Performance,"/// Load the features of the given VirtReg (allocated or not) at column Pos,; /// but if that can't be evicted, return false instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['Load'],['Load']
Performance,/// Load the given API notes file for the given header directory.; ///; /// \param HeaderDir The directory at which we; ///; /// \returns true if an error occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/APINotes/APINotesManager.h,1,['Load'],['Load']
Performance,/// Load the given object binary in memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h:4,Load,Load,4,interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/BinaryHolder.h,2,['Load'],['Load']
Performance,"/// Load the global decl attachments, using the index built for lazy loading.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,2,"['Load', 'load']","['Load', 'loading']"
Performance,"/// Load the input files, create the combined index, and write it out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,1,['Load'],['Load']
Performance,/// Load the interesting main binary symbols' addresses into; /// MainBinarySymbolAddresses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,1,['Load'],['Load']
Performance,/// Load the list of plugins requested in the \c FrontendOptions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,1,['Load'],['Load']
Performance,/// Load the returned value from the stack into virtual registers in \p VRegs.; /// It uses the frame index \p FI and the start offset from \p DemoteReg.; /// The loaded data size will be determined from \p RetTy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h:4,Load,Load,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CallLowering.h,2,"['Load', 'load']","['Load', 'loaded']"
Performance,"/// Load the set of namespaces that are known to the external source,; /// which will be used during typo correction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,3,['Load'],['Load']
Performance,"/// Load the set of used but not defined functions or variables with; /// internal linkage, or used but not defined inline functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/MultiplexExternalSemaSource.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Sema/MultiplexExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/MultiplexExternalSemaSource.h,1,['Load'],['Load']
Performance,"/// Load the set of used but not defined functions or variables with; /// internal linkage, or used but not defined internal functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,1,['Load'],['Load']
Performance,/// Load the specified register of the given register class from the specified; /// stack frame index. The load instruction is to be added to the given; /// machine basic block before the specified machine instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:4,Load,Load,4,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,2,"['Load', 'load']","['Load', 'load']"
Performance,"/// Load the specified register of the given register class from the specified; /// stack frame index. The load instruction is to be added to the given; /// machine basic block before the specified machine instruction. If \p; /// DestReg is being directly reloaded as part of assigning a virtual; /// register, \p VReg is the register being assigned. This additional register; /// argument is needed for certain targets when invoked from RegAllocFast to; /// map the loaded physical register to its virtual register. A null register; /// can be passed elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Load,Load,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,3,"['Load', 'load']","['Load', 'load', 'loaded']"
Performance,"/// Load tile configuration from a 64-byte memory location specified by; /// ""mem_addr"". The tile configuration includes the tile type palette, the; /// number of bytes per row, and the number of rows. If the specified; /// palette_id is zero, that signifies the init state for both the tile; /// config and the tile data, and the tiles are zeroed. Any invalid; /// configurations will result in #GP fault.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> LDTILECFG </c> instruction.; ///; /// \param __config; /// A pointer to 512-bits configuration",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:4,Load,Load,4,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h,1,['Load'],['Load']
Performance,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"". This intrinsic provides a hint to the implementation; /// that the data will likely not be reused in the near future and the data; /// caching can be optimized accordingly.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADDT1 </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:4,Load,Load,4,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h,3,"['Load', 'load', 'optimiz']","['Load', 'loaded', 'optimized']"
Performance,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"" using the tile configuration previously configured; /// via ""_tile_loadconfig"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADD </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:4,Load,Load,4,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h,2,"['Load', 'load']","['Load', 'loaded']"
Performance,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"". This intrinsic provides a hint to the implementation; /// that the data will likely not be reused in the near future and the data; /// caching can be optimized accordingly.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADDT1 </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:4,Load,Load,4,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h,3,"['Load', 'load', 'optimiz']","['Load', 'loaded', 'optimized']"
Performance,"/// Load tile rows from memory specifieid by ""base"" address and ""stride"" into; /// destination tile ""dst"".; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TILELOADD </c> instruction.; ///; /// \param dst; /// A destination tile. Max size is 1024 Bytes.; /// \param base; /// A pointer to base address.; /// \param stride; /// The stride between the rows' data to be loaded in memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:4,Load,Load,4,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h,2,"['Load', 'load']","['Load', 'loaded']"
Performance,/// Load values for each location from array of ValueIDNums. Take current; /// bbnum just in case we read a value from a hitherto untouched register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Load,Load,4,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['Load'],['Load']
Performance,/// Load weak undeclared identifiers from the external source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Load'],['Load']
Performance,"/// Load, create, or return global module.; /// This function returns an existing global module index, if one; /// had already been loaded or created, or loads one if it; /// exists, or creates one if it doesn't exist.; /// Also, importantly, if the index doesn't cover all the modules; /// in the module map, it will be update to do so here, because; /// of its use in searching for needed module imports and; /// associated fixit messages.; /// \param TriggerLoc The location for what triggered the load.; /// \returns Returns null if load failed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h:4,Load,Load,4,interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleLoader.h,5,"['Load', 'load']","['Load', 'load', 'loaded', 'loads']"
Performance,/// Load/Store Interleaving instructions are not always beneficial.; /// Replace them by ZIP instructionand classical load/store.; /// Return true if the SIMD instruction is modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,2,"['Load', 'load']","['Load', 'load']"
Performance,"/// Load/Store Interleaving instructions are not always beneficial.; /// Replace them by ZIP instructions and classical load/store.; ///; /// For example:; /// st2 {v0.4s, v1.4s}, addr; ///; /// Is rewritten into:; /// zip1 v2.4s, v0.4s, v1.4s; /// zip2 v3.4s, v0.4s, v1.4s; /// stp q2, q3, addr; //; /// For example:; /// st4 {v0.4s, v1.4s, v2.4s, v3.4s}, addr; ///; /// Is rewritten into:; /// zip1 v4.4s, v0.4s, v2.4s; /// zip2 v5.4s, v0.4s, v2.4s; /// zip1 v6.4s, v1.4s, v3.4s; /// zip2 v7.4s, v1.4s, v3.4s; /// zip1 v8.4s, v4.4s, v6.4s; /// zip2 v9.4s, v4.4s, v6.4s; /// zip1 v10.4s, v5.4s, v7.4s; /// zip2 v11.4s, v5.4s, v7.4s; /// stp q8, q9, addr; /// stp q10, q11, addr+32; ///; /// Currently only instructions related to ST2 and ST4 are considered.; /// Other may be added later.; /// Return true if the SIMD instruction is modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,2,"['Load', 'load']","['Load', 'load']"
Performance,/// Load/store instruction that can be merged with a base address; /// update,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Load,Load,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Load'],['Load']
Performance,"/// LoadAddress - the address of the section in the target process's memory.; /// Used for situations in which JIT-ed code is being executed in the address; /// space of a separate process. If the code executes in the same address; /// space where it was JIT-ed, this just equals Address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:4,Load,LoadAddress,4,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,1,['Load'],['LoadAddress']
Performance,/// LoadCXXThis - Load the value of 'this'. This function is only valid while; /// generating code for an C++ member function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:4,Load,LoadCXXThis,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,2,['Load'],"['Load', 'LoadCXXThis']"
Performance,/// LoadCXXVTT - Load the VTT parameter to base constructors/destructors have; /// virtual bases.; // FIXME: Every place that calls LoadCXXVTT is something; // that needs to be abstracted properly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:4,Load,LoadCXXVTT,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,3,['Load'],"['Load', 'LoadCXXVTT']"
Performance,"/// LoadFromCommandLine - Create an ASTUnit from a vector of command line; /// arguments, which must specify exactly one source file.; ///; /// \param ArgBegin - The beginning of the argument vector.; ///; /// \param ArgEnd - The end of the argument vector.; ///; /// \param PCHContainerOps - The PCHContainerOperations to use for loading and; /// creating modules.; ///; /// \param Diags - The diagnostics engine to use for reporting errors; its; /// lifetime is expected to extend past that of the returned ASTUnit.; ///; /// \param ResourceFilesPath - The path to the compiler resource files.; ///; /// \param StorePreamblesInMemory - Whether to store PCH in memory. If false,; /// PCH are stored in temporary files.; ///; /// \param PreambleStoragePath - The path to a directory, in which to create; /// temporary PCH files. If empty, the default system temporary directory is; /// used. This parameter is ignored if \p StorePreamblesInMemory is true.; ///; /// \param ModuleFormat - If provided, uses the specific module format.; ///; /// \param ErrAST - If non-null and parsing failed without any AST to return; /// (e.g. because the PCH could not be loaded), this accepts the ASTUnit; /// mainly to allow the caller to see the diagnostics.; ///; /// \param VFS - A llvm::vfs::FileSystem to be used for all file accesses.; /// Note that preamble is saved to a temporary directory on a RealFileSystem,; /// so in order for it to be loaded correctly, VFS should have access to; /// it(i.e., be an overlay over RealFileSystem). RealFileSystem will be used; /// if \p VFS is nullptr.; ///; // FIXME: Move OnlyLocalDecls, UseBumpAllocator to setters on the ASTUnit, we; // shouldn't need to specify them at construction time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:4,Load,LoadFromCommandLine,4,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,4,"['Load', 'load']","['LoadFromCommandLine', 'loaded', 'loading']"
Performance,"/// LoadFromCompilerInvocation - Create an ASTUnit from a source file, via a; /// CompilerInvocation object.; ///; /// \param CI - The compiler invocation to use; it must have exactly one input; /// source file. The ASTUnit takes ownership of the CompilerInvocation object.; ///; /// \param PCHContainerOps - The PCHContainerOperations to use for loading and; /// creating modules.; ///; /// \param Diags - The diagnostics engine to use for reporting errors; its; /// lifetime is expected to extend past that of the returned ASTUnit.; //; // FIXME: Move OnlyLocalDecls, UseBumpAllocator to setters on the ASTUnit, we; // shouldn't need to specify them at construction time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:4,Load,LoadFromCompilerInvocation,4,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,2,"['Load', 'load']","['LoadFromCompilerInvocation', 'loading']"
Performance,/// LoadInst specialization to compute vector information.; ///; /// This function also acts as abort condition to the recursion.; ///; /// \param LI LoadInst to operate on; /// \param Result Result of the computation; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:4,Load,LoadInst,4,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,2,['Load'],['LoadInst']
Performance,"/// LoadIntFromMemory - Loads the integer stored in the LoadBytes bytes starting; /// from Src into IntVal, which is assumed to be wide enough and to hold zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:4,Load,LoadIntFromMemory,4,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,6,['Load'],"['LoadBytes', 'LoadIntFromMemory', 'Loads']"
Performance,/// LoadObjCSelf - Load the value of self. This function is only valid while; /// generating code for an Objective-C method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:4,Load,LoadObjCSelf,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,2,['Load'],"['Load', 'LoadObjCSelf']"
Performance,"/// Loading virtual member pointers using the virtual inheritance model; /// always results in an adjustment using the vbtable even if the index is; /// zero.; ///; /// This is usually OK because the first slot in the vbtable points; /// backwards to the top of the MDC. However, the MDC might be reusing a; /// vbptr from an nv-base. In this case, the first slot in the vbtable; /// points to the start of the nv-base which introduced the vbptr and *not*; /// the MDC. Modify the NonVirtualBaseAdjustment to account for this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:4,Load,Loading,4,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['Load'],['Loading']
Performance,/// Loads 256 bits of integer data from a 32-byte aligned memory; /// location pointed to by \a __p into elements of a 256-bit integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVDQA </c> instruction.; ///; /// \param __p; /// A 32-byte aligned pointer to a 256-bit integer vector containing integer; /// values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Load'],['Loads']
Performance,/// Loads 256 bits of integer data from an unaligned memory location; /// pointed to by \a __p into a 256-bit integer vector. This intrinsic may; /// perform better than \c _mm256_loadu_si256 when the data crosses a cache; /// line boundary.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VLDDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 256-bit integer vector containing integer values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,3,"['Load', 'cache', 'perform']","['Loads', 'cache', 'perform']"
Performance,/// Loads 256 bits of integer data from an unaligned memory location; /// pointed to by \a __p into a 256-bit integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 256-bit integer vector containing integer values.; /// \returns A 256-bit integer vector containing the moved values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Load'],['Loads']
Performance,/// Loads 4 double-precision floating point values from an unaligned; /// memory location pointed to by \a __p into a vector of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVUPD </c> instruction.; ///; /// \param __p; /// A pointer to a memory location containing double-precision floating; /// point values.; /// \returns A 256-bit vector of [4 x double] containing the moved values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Load'],['Loads']
Performance,/// Loads 8 64-bit integer elements from memory starting at location \a base_addr; /// at packed 32-bit integer indices stored in the lower half of \a vindex; /// scaled by \a scale and stores them in dst using writemask \a mask (elements; /// are copied from \a src when the corresponding mask bit is not set).; ///; /// This intrinsic corresponds to the <c> VPGATHERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,1,['Load'],['Loads']
Performance,/// Loads 8 64-bit integer elements from memory starting at location \a base_addr; /// at packed 32-bit integer indices stored in the lower half of \a vindex; /// scaled by \a scale and stores them in dst.; ///; /// This intrinsic corresponds to the <c> VPGATHERDQ </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,1,['Load'],['Loads']
Performance,/// Loads 8 double-precision (64-bit) floating-point elements from memory; /// starting at location \a base_addr at packed 32-bit integer indices stored in; /// the lower half of \a vindex scaled by \a scale into dst using writemask; /// \a mask (elements are copied from \a src when the corresponding mask bit is; /// not set).; ///; /// This intrinsic corresponds to the <c> VGATHERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// IF mask[j]; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ELSE; /// dst[i+63:i] := src[i+63:i]; /// FI; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,1,['Load'],['Loads']
Performance,/// Loads 8 double-precision (64-bit) floating-point elements stored at memory; /// locations starting at location \a base_addr at packed 32-bit integer indices; /// stored in the lower half of \a vindex scaled by \a scale them in dst.; ///; /// This intrinsic corresponds to the <c> VGATHERDPD </c> instructions.; ///; /// \code{.operation}; /// FOR j := 0 to 7; /// i := j*64; /// m := j*32; /// addr := base_addr + SignExtend64(vindex[m+31:m]) * ZeroExtend64(scale) * 8; /// dst[i+63:i] := MEM[addr+63:addr]; /// ENDFOR; /// dst[MAX:512] := 0; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx512fintrin.h,1,['Load'],['Loads']
Performance,/// Loads 8 single-precision floating point values from a 32-byte aligned; /// memory location pointed to by \a __p into a vector of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVAPS </c> instruction.; ///; /// \param __p; /// A 32-byte aligned pointer to a memory location containing float values.; /// \returns A 256-bit vector of [8 x float] containing the moved values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Load'],['Loads']
Performance,/// Loads 8 single-precision floating point values from an unaligned; /// memory location pointed to by \a __p into a vector of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VMOVUPS </c> instruction.; ///; /// \param __p; /// A pointer to a memory location containing single-precision floating; /// point values.; /// \returns A 256-bit vector of [8 x float] containing the moved values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Load'],['Loads']
Performance,/// Loads ASTUnits from AST-dumps or source-files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:4,Load,Loads,4,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['Load'],['Loads']
Performance,"/// Loads a C++ Module with a given name by synthesizing an Import decl.; /// This routine checks if there is a modulemap in the current directory; /// and loads it.; ///; /// This is useful when we start up the interpreter and programatically,; /// later generate a modulemap.; ///; ///\returns true if the module was loaded.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:4,Load,Loads,4,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,3,"['Load', 'load']","['Loads', 'loaded', 'loads']"
Performance,"/// Loads a C++ Module with a given name by synthesizing an Import decl.; /// This routine checks if there is a modulemap in the current directory; /// and loads it.; ///; ///\returns true if the module was loaded or already visible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:4,Load,Loads,4,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,3,"['Load', 'load']","['Loads', 'loaded', 'loads']"
Performance,/// Loads a JSON compilation database from a data buffer.; ///; /// Returns NULL and sets ErrorMessage if the database could not be loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:4,Load,Loads,4,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,2,"['Load', 'load']","['Loads', 'loaded']"
Performance,/// Loads a JSON compilation database from the specified file.; ///; /// Returns NULL and sets ErrorMessage if the database could not be; /// loaded from the given file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h:4,Load,Loads,4,interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/JSONCompilationDatabase.h,2,"['Load', 'load']","['Loads', 'loaded']"
Performance,"/// Loads a compilation database from a build directory.; ///; /// Looks at the specified 'BuildDirectory' and creates a compilation database; /// that allows to query compile commands for source files in the; /// corresponding source tree.; ///; /// Returns NULL and sets ErrorMessage if we were not able to build up a; /// compilation database for the build directory.; ///; /// FIXME: Currently only supports JSON compilation databases, which; /// are named 'compile_commands.json' in the given directory. Extend this; /// for other build types (like ninja build files).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:4,Load,Loads,4,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,1,['Load'],['Loads']
Performance,/// Loads a compilation database from a build directory.; ///; /// \see CompilationDatabase::loadFromDirectory().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h:4,Load,Loads,4,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabasePluginRegistry.h,2,"['Load', 'load']","['Loads', 'loadFromDirectory']"
Performance,/// Loads a memory sequence containing the specified memory address into; /// all data cache levels. The cache-coherency state is set to exclusive.; /// Data can be read from and written to the cache line without additional; /// delay.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,4,"['Load', 'cache']","['Loads', 'cache', 'cache-coherency']"
Performance,/// Loads a memory sequence containing the specified memory address into; /// the L1 data cache and sets the cache-coherency to modified. This; /// provides a hint to the processor that the cache line will be modified.; /// It is intended for use when the cache line will be written to shortly; /// after the prefetch is performed.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHW instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchwintrin.h,6,"['Load', 'cache', 'perform']","['Loads', 'cache', 'cache-coherency', 'performed']"
Performance,/// Loads a scalar double-precision floating point value from the; /// specified address pointed to by \a __a and broadcasts it to the elements; /// of a [4 x double] vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTSD </c> instruction.; ///; /// \param __a; /// The double-precision floating point value to be broadcast.; /// \returns A 256-bit vector of [4 x double] whose 64-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Load'],['Loads']
Performance,/// Loads a scalar single-precision floating point value from the; /// specified address pointed to by \a __a and broadcasts it to the elements; /// of a [8 x float] vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTSS </c> instruction.; ///; /// \param __a; /// The single-precision floating point value to be broadcast.; /// \returns A 256-bit vector of [8 x float] whose 32-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Load'],['Loads']
Performance,"/// Loads a sub-matrix with shape \p ResultShape from a \p R x \p C matrix,; /// starting at \p MatrixPtr[I][J].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:4,Load,Loads,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['Load'],['Loads']
Performance,"/// Loads all the offload entries information from the host IR; /// metadata read from the file passed in as the HostFilePath argument. This; /// function is only meant to be used with device code generation.; ///; /// \param HostFilePath The path to the host IR file,; /// used to load in offload metadata for the device, allowing host and device; /// to maintain the same metadata mapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:4,Load,Loads,4,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,2,"['Load', 'load']","['Loads', 'load']"
Performance,/// Loads all the offload entries information from the host IR; /// metadata.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:4,Load,Loads,4,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['Load'],['Loads']
Performance,"/// Loads all the offload entries information from the host IR; /// metadata. This function is only meant to be used with device code; /// generation.; ///; /// \param M Module to load Metadata info from. Module passed maybe; /// loaded from bitcode file, i.e, different from OpenMPIRBuilder::M module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:4,Load,Loads,4,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,3,"['Load', 'load']","['Loads', 'load', 'loaded']"
Performance,/// Loads an AST from a pch-dump.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:4,Load,Loads,4,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['Load'],['Loads']
Performance,/// Loads an AST from a source-file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:4,Load,Loads,4,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['Load'],['Loads']
Performance,/// Loads an ASTUnit for a function.; ///; /// \param FunctionName USR name of the function.; /// \param CrossTUDir Path to the directory used to store CTU related files.; /// \param IndexName Name of the file inside \p CrossTUDir which maps; /// function USR names to file paths. These files contain the corresponding; /// AST-dumps.; /// \param DisplayCTUProgress Display a message about loading new ASTs.; ///; /// \return An Expected instance which contains the ASTUnit pointer or the; /// error occurred during the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:4,Load,Loads,4,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,3,"['Load', 'load']","['Loads', 'load', 'loading']"
Performance,/// Loads an instruction sequence containing the specified memory address into; /// all but the first-level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT1 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,2,"['Load', 'cache']","['Loads', 'cache']"
Performance,/// Loads an instruction sequence containing the specified memory address into; /// all level cache.; ///; /// Note that the effect of this intrinsic is dependent on the processor; /// implementation.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c PREFETCHIT0 instruction.; ///; /// \param __P; /// A pointer specifying the memory address to be prefetched.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/prfchiintrin.h,2,"['Load', 'cache']","['Loads', 'cache']"
Performance,/// Loads are not emitted to the program immediately. We bunch them up and; /// then emit token factor nodes when possible. This allows us to get simple; /// disambiguation between loads without worrying about alias analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:4,Load,Loads,4,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,2,"['Load', 'load']","['Loads', 'loads']"
Performance,"/// Loads are not normal binary operators: their result type is not; /// determined by their operands, and they produce a value AND a token chain.; ///; /// This function will set the MOLoad flag on MMOFlags, but you can set it if; /// you want. The MOStore flag must not be set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:4,Load,Loads,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['Load'],['Loads']
Performance,/// Loads comment ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h:4,Load,Loads,4,interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,2,['Load'],['Loads']
Performance,/// Loads comments ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:4,Load,Loads,4,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['Load'],['Loads']
Performance,"/// Loads data from an unaligned memory location to elements in a 128-bit; /// vector.; ///; /// If the address of the data is not 16-byte aligned, the instruction may; /// read two adjacent aligned blocks of memory to retrieve the requested; /// data.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VLDDQU </c> instruction.; ///; /// \param __p; /// A pointer to a 128-bit integer vector containing integer values.; /// \returns A 128-bit vector containing the moved values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/pmmintrin.h,1,['Load'],['Loads']
Performance,"/// Loads from reversed memory addresses, e.g. load(A[i+1]), load(A[i]).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Load,Loads,4,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,3,"['Load', 'load']","['Loads', 'load']"
Performance,"/// Loads header and footer without decompressing or deserializing them. This can be used to asynchronously open; /// a file in the background. The method is idempotent and it is called as a first step in `Attach()`.; /// Pages sources may or may not make use of splitting loading and processing meta-data.; /// Therefore, `LoadStructure()` may do nothing and defer loading the meta-data to `Attach()`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:4,Load,Loads,4,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,4,"['Load', 'load']","['LoadStructure', 'Loads', 'loading']"
Performance,/// Loads the 256-bit integer vector from memory \a __V using a non-temporal; /// memory hint and returns the vector. \a __V must be aligned on a 32-byte; /// boundary.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c VMOVNTDQA instruction.; ///; /// \param __V; /// A pointer to the 32-byte aligned memory containing the vector to load.; /// \returns A 256-bit integer vector loaded from memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avx2intrin.h,3,"['Load', 'load']","['Loads', 'load', 'loaded']"
Performance,/// Loads the AST based on the identifier found in the index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:4,Load,Loads,4,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,1,['Load'],['Loads']
Performance,/// Loads the data from a 128-bit vector of [2 x double] from the; /// specified address pointed to by \a __a and broadcasts it to 128-bit; /// elements in a 256-bit vector of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTF128 </c> instruction.; ///; /// \param __a; /// The 128-bit vector of [2 x double] to be broadcast.; /// \returns A 256-bit vector of [4 x double] whose 128-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Load'],['Loads']
Performance,/// Loads the data from a 128-bit vector of [4 x float] from the; /// specified address pointed to by \a __a and broadcasts it to 128-bit; /// elements in a 256-bit vector of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VBROADCASTF128 </c> instruction.; ///; /// \param __a; /// The 128-bit vector of [4 x float] to be broadcast.; /// \returns A 256-bit vector of [8 x float] whose 128-bit elements are set; /// equal to the broadcast value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Load'],['Loads']
Performance,/// Loads the dylib with the given name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericDylibManager.h:4,Load,Loads,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericDylibManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCGenericDylibManager.h,1,['Load'],['Loads']
Performance,/// Loads the incoming C++ this pointer as it was passed by the caller.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,1,['Load'],['Loads']
Performance,/// Loads the instrumentation map from |Filename|. This auto-deduces the type of; /// the instrumentation map.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h:4,Load,Loads,4,interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/InstrumentationMap.h,1,['Load'],['Loads']
Performance,"/// Loads the plugin that implements this class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RVirtualCanvasPainter.hxx:4,Load,Loads,4,graf2d/gpadv7/inc/ROOT/RVirtualCanvasPainter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RVirtualCanvasPainter.hxx,1,['Load'],['Loads']
Performance,/// Loads two 128-bit floating-point vectors of [2 x double] from; /// unaligned memory locations and constructs a 256-bit floating-point vector; /// of [4 x double] by concatenating the two 128-bit vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing two consecutive; /// double-precision floating-point values. These values are to be copied to; /// bits[255:128] of the result. The address of the memory location does not; /// have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing two consecutive; /// double-precision floating-point values. These values are to be copied to; /// bits[127:0] of the result. The address of the memory location does not; /// have to be aligned.; /// \returns A 256-bit floating-point vector of [4 x double] containing the; /// concatenated result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,2,"['Load', 'load']","['Loads', 'load']"
Performance,/// Loads two 128-bit integer vectors from unaligned memory locations and; /// constructs a 256-bit integer vector by concatenating the two 128-bit; /// vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to load instructions followed by the; /// <c> VINSERTF128 </c> instruction.; ///; /// \param __addr_hi; /// A pointer to a 128-bit memory location containing a 128-bit integer; /// vector. This vector is to be copied to bits[255:128] of the result. The; /// address of the memory location does not have to be aligned.; /// \param __addr_lo; /// A pointer to a 128-bit memory location containing a 128-bit integer; /// vector. This vector is to be copied to bits[127:0] of the result. The; /// address of the memory location does not have to be aligned.; /// \returns A 256-bit integer vector containing the concatenated result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Load,Loads,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,2,"['Load', 'load']","['Loads', 'load']"
Performance,/// Loads unit line table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:4,Load,Loads,4,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,1,['Load'],['Loads']
Performance,"/// Local cache of what-value-is-in-what-LocIdx. Used to identify differences; /// between TransferTrackers view of variable locations and MLocTrackers. For; /// example, MLocTracker observes all clobbers, but TransferTracker lazily; /// does not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:10,cache,cache,10,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['cache'],['cache']
Performance,"/// Location of a PHI instruction that is also a debug-info variable value,; /// for the duration of register allocation. Loaded by the PHI-elimination; /// pass, and emitted as DBG_PHI instructions during VirtRegRewriter, with; /// maintenance applied by intermediate passes that edit registers (such as; /// coalescing and the allocator passes).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:122,Load,Loaded,122,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['Load'],['Loaded']
Performance,/// Location pairs for which an assumption based result is currently stored.; /// Used to remove all potentially incorrect results from the cache if an; /// assumption is disproven.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:140,cache,cache,140,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,1,['cache'],['cache']
Performance,/// Locking and signaling for accessing the Tasks queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h:50,queue,queue,50,interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,1,['queue'],['queue']
Performance,/// Log perf jitdump events for each object (see; /// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/tools/perf/Documentation/jitdump-specification.txt).; /// Currently has support for dumping code load records and unwind info records.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.h:223,load,load,223,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Debugging/PerfSupportPlugin.h,1,['load'],['load']
Performance,"/// Look for and transform the sequence; /// lea (reg1, reg2), reg3; /// sub reg3, reg4; /// to; /// sub reg1, reg4; /// sub reg2, reg4; /// It can also optimize the sequence lea/add similarly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:153,optimiz,optimize,153,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,1,['optimiz'],['optimize']
Performance,/// Look for calls that look like they could be replaced with a load or store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOpcodes.cpp:64,load,load,64,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOpcodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceOpcodes.cpp,1,['load'],['load']
Performance,"/// Look for interesting constants used within the given function.; /// Promote them into global variables, load these global variables within; /// the related function, so that the number of inserted load is minimal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp:108,load,load,108,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp,2,['load'],['load']
Performance,"/// Look for opportunities to duplicate return instructions to the predecessor; /// to enable tail call optimizations. The case it is currently looking for is:; /// @code; /// bb0:; /// %tmp0 = tail call i32 @f0(); /// br label %return; /// bb1:; /// %tmp1 = tail call i32 @f1(); /// br label %return; /// bb2:; /// %tmp2 = tail call i32 @f2(); /// br label %return; /// return:; /// %retval = phi i32 [ %tmp0, %bb0 ], [ %tmp1, %bb1 ], [ %tmp2, %bb2 ]; /// ret i32 %retval; /// @endcode; ///; /// =>; ///; /// @code; /// bb0:; /// %tmp0 = tail call i32 @f0(); /// ret i32 %tmp0; /// bb1:; /// %tmp1 = tail call i32 @f1(); /// ret i32 %tmp1; /// bb2:; /// %tmp2 = tail call i32 @f2(); /// ret i32 %tmp2; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:104,optimiz,optimizations,104,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['optimiz'],['optimizations']
Performance,"/// Look for sequence of load / op / store where op is one of 'or', 'xor', and; /// 'and' of immediates. If 'op' is only touching some of the loaded bits, try; /// narrowing the load and store if it would end up being a win for performance; /// or code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:25,load,load,25,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,"['load', 'perform']","['load', 'loaded', 'performance']"
Performance,"/// Look through the loop-carried and loop-independent dependences in; /// this loop and find store->load dependences.; ///; /// Note that no candidate is returned if LAA has failed to analyze the loop; /// (e.g. if it's not bottom-tested, contains volatile memops, etc.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:101,load,load,101,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['load'],['load']
Performance,"/// Look up the completed type for a self pointer in the TypeCache and; /// create a copy of it with the ObjectPointer and Artificial flags; /// set. If the type is not cached, a new one is created. This should; /// never happen though, since creating a type for the implicit self; /// argument implies that we already parsed the interface definition; /// and the ivar declarations in the implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h:169,cache,cached,169,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.h,1,['cache'],['cached']
Performance,"/// Look up the given member of the given non-type-dependent; /// expression. This can return in one of two ways:; /// * If it returns a sentinel null-but-valid result, the caller will; /// assume that lookup was performed and the results written into; /// the provided structure. It will take over from there.; /// * Otherwise, the returned expression will be produced in place of; /// an ordinary member expression.; ///; /// The ObjCImpDecl bit is a gross hack that will need to be properly; /// fixed for ObjC++.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:213,perform,performed,213,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['perform'],['performed']
Performance,"/// Look up the node specified by ID in CSEMap. If it exists, return it. If; /// not, return the insertion token that will make insertion faster. Performs; /// additional processing for constant nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:146,Perform,Performs,146,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['Perform'],['Performs']
Performance,"/// Look up the specified framework name in our framework cache.; /// \returns The DirectoryEntry it is in if we know, null otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:58,cache,cache,58,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['cache'],['cache']
Performance,/// Look up the value to see if its value is already cached in a; /// register. It may be defined by instructions across blocks or defined; /// locally.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:53,cache,cached,53,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,1,['cache'],['cached']
Performance,"/// Looks up the GC strategy for a given function, returning null if the; /// function doesn't have a GC tag. The strategy is stored in the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:140,cache,cache,140,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['cache'],['cache']
Performance,"/// Looks up the modules that \p File corresponds to.; ///; /// If \p File represents a builtin header within Clang's builtin include; /// directory, this also loads all of the module maps to see if it will get; /// associated with a specific module (e.g. in /usr/include).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:160,load,loads,160,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['load'],['loads']
Performance,"/// Lookup, cache, and verify the specified directory (real or; /// virtual).; ///; /// This function is deprecated and will be removed at some point in the; /// future, new clients should use; /// \c getDirectoryRef.; ///; /// This returns a \c std::error_code if there was an error reading the; /// directory. If there is no error, the DirectoryEntry is guaranteed to be; /// non-NULL.; ///; /// \param CacheFailure If true and the file does not exist, we'll cache; /// the failure to find this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:12,cache,cache,12,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,3,"['Cache', 'cache']","['CacheFailure', 'cache']"
Performance,"/// Lookup, cache, and verify the specified directory (real or; /// virtual).; ///; /// This returns a \c std::error_code if there was an error reading the; /// directory. On success, returns the reference to the directory entry; /// together with the exact path that was used to access a file by a; /// particular call to getDirectoryRef.; ///; /// \param CacheFailure If true and the file does not exist, we'll cache; /// the failure to find this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:12,cache,cache,12,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,3,"['Cache', 'cache']","['CacheFailure', 'cache']"
Performance,"/// Lookup, cache, and verify the specified file (real or virtual). Return the; /// reference to the file entry together with the exact path that was used to; /// access a file by a particular call to getFileRef. If the underlying VFS is; /// a redirecting VFS that uses external file names, the returned FileEntryRef; /// will use the external name instead of the filename that was passed to this; /// method.; ///; /// This returns a \c std::error_code if there was an error loading the file,; /// or a \c FileEntryRef otherwise.; ///; /// \param OpenFile if true and the file exists, it will be opened.; ///; /// \param CacheFailure If true and the file does not exist, we'll cache; /// the failure to find this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:12,cache,cache,12,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,4,"['Cache', 'cache', 'load']","['CacheFailure', 'cache', 'loading']"
Performance,"/// Lookup, cache, and verify the specified file (real or; /// virtual).; ///; /// This function is deprecated and will be removed at some point in the; /// future, new clients should use; /// \c getFileRef.; ///; /// This returns a \c std::error_code if there was an error loading the file.; /// If there is no error, the FileEntry is guaranteed to be non-NULL.; ///; /// \param OpenFile if true and the file exists, it will be opened.; ///; /// \param CacheFailure If true and the file does not exist, we'll cache; /// the failure to find this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:12,cache,cache,12,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,4,"['Cache', 'cache', 'load']","['CacheFailure', 'cache', 'loading']"
Performance,"/// LookupFile - Lookup the specified file in this search path, returning it; /// if it exists or returning null if not.; ///; /// \param Filename The file to look up relative to the search paths.; ///; /// \param HS The header search instance to search with.; ///; /// \param IncludeLoc the source location of the #include or #import; /// directive.; ///; /// \param SearchPath If not NULL, will be set to the search path relative; /// to which the file was found.; ///; /// \param RelativePath If not NULL, will be set to the path relative to; /// SearchPath at which the file was found. This only differs from the; /// Filename for framework includes.; ///; /// \param RequestingModule The module in which the lookup was performed.; ///; /// \param SuggestedModule If non-null, and the file found is semantically; /// part of a known module, this will be set to the module that should; /// be imported instead of preprocessing/parsing the file found.; ///; /// \param [out] InUserSpecifiedSystemFramework If the file is found,; /// set to true if the file is located in a framework that has been; /// user-specified to be treated as a system framework.; ///; /// \param [out] IsFrameworkFound For a framework directory set to true if; /// specified '.framework' directory is found.; ///; /// \param [out] MappedName if this is a headermap which maps the filename to; /// a framework include (""Foo.h"" -> ""Foo/Foo.h""), set the new name to this; /// vector and point Filename to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/DirectoryLookup.h:724,perform,performed,724,interpreter/llvm-project/clang/include/clang/Lex/DirectoryLookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/DirectoryLookup.h,1,['perform'],['performed']
Performance,/// LookupNEONLdSt - Search the NEONLdStTable for information about a NEON; /// load or store pseudo instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:80,load,load,80,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,1,['load'],['load']
Performance,/// Loop optimization hint for loop and unroll pragmas.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/LoopHint.h:9,optimiz,optimization,9,interpreter/llvm-project/clang/include/clang/Parse/LoopHint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/LoopHint.h,1,['optimiz'],['optimization']
Performance,"/// Loop over all of the basic blocks, replacing address; /// calculations in load and store instructions, if it's already; /// been calculated by LEA. Also, remove redundant LEAs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:78,load,load,78,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['load'],['load']
Performance,"/// Loop over all of the basic blocks, replacing byte and word instructions by; /// equivalent 32 bit instructions where performance or code size can be; /// improved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:121,perform,performance,121,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['perform'],['performance']
Performance,"/// Loop over all of the linked values to compute type mappings. For example,; /// if we link ""extern Foo *x"" and ""Foo *x = NULL"", then we have two struct; /// types 'Foo' but one got renamed when the module was loaded into the same; /// LLVMContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:212,load,loaded,212,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['load'],['loaded']
Performance,/// LoopVersioning. It's only set up (non-null) if memchecks were; /// used.; ///; /// This is currently only used to add no-alias metadata based on the; /// memchecks. The actually versioning is performed manually.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:196,perform,performed,196,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['perform'],['performed']
Performance,"/// Lower a HOM_Epilog pseudo instruction into a helper call while; /// creating the helper on demand. Or emit a sequence of loads in place when not; /// using a helper call.; ///; /// 1. With a helper including ret; /// HOM_Epilog x30, x29, x19, x20, x21, x22 ; MBBI; /// ret ; NextMBBI; /// =>; /// b _OUTLINED_FUNCTION_EPILOG_TAIL_x30x29x19x20x21x22; /// ... ; NextMBBI; ///; /// 2. With a helper; /// HOM_Epilog x30, x29, x19, x20, x21, x22; /// =>; /// bl _OUTLINED_FUNCTION_EPILOG_x30x29x19x20x21x22; ///; /// 3. Without a helper; /// HOM_Epilog x30, x29, x19, x20, x21, x22; /// =>; /// ldp x29, x30, [sp, #32]; /// ldp x20, x19, [sp, #16]; /// ldp x22, x21, [sp], #48",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp:125,load,loads,125,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp,1,['load'],['loads']
Performance,"/// Lower a HOM_Epilog pseudo instruction into a helper call; /// or a sequence of homogeneous loads.; /// When a return follow, it can be optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp:95,load,loads,95,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp,2,"['load', 'optimiz']","['loads', 'optimized']"
Performance,"/// Lower a HOM_Prolog pseudo instruction into a helper call; /// or a sequence of homogeneous stores.; /// When a fp setup follows, it can be optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp:143,optimiz,optimized,143,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp,1,['optimiz'],['optimized']
Performance,/// Lower a deinterleave intrinsic to a target specific load intrinsic.; /// Return true on success. Currently only supports; /// llvm.experimental.vector.deinterleave2; ///; /// \p DI is the deinterleave intrinsic.; /// \p LI is the accompanying load instruction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:56,load,load,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],['load']
Performance,/// Lower a load instruction with shape information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:12,load,load,12,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['load'],['load']
Performance,"/// Lower a vector CTLZ using native supported vector CTLZ instruction.; //; // i8/i16 vector implemented using dword LZCNT vector instruction; // ( sub(trunc(lzcnt(zext32(x)))) ). In case zext32(x) is illegal,; // split the vector, perform operation on it's Lo a Hi part and; // concatenate the results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:233,perform,perform,233,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['perform']
Performance,"/// Lower all calls to ifuncs by replacing uses with indirect calls loaded out; /// of a global table initialized in a global constructor. This will introduce; /// one constructor function and adds it to llvm.global_ctors. The constructor; /// will call the resolver function once for each ifunc.; ///; /// Leaves any unhandled constant initializer uses as-is.; ///; /// If \p IFuncsToLower is empty, all ifuncs in the module will be lowered.; /// If \p IFuncsToLower is non-empty, only the selected ifuncs will be lowered.; ///; /// The processed ifuncs without remaining users will be removed from the; /// module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:68,load,loaded,68,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,1,['load'],['loaded']
Performance,"/// Lower an interleaved load into a ldN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %ld2 = { <4 x i32>, <4 x i32> } call llvm.aarch64.neon.ld2(%ptr); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:25,load,load,25,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,3,['load'],['load']
Performance,"/// Lower an interleaved load into a vldN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr, align 4; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %vld2 = { <4 x i32>, <4 x i32> } call llvm.arm.neon.vld2(%ptr, 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %vld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %vld2, i32 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:25,load,load,25,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,3,['load'],['load']
Performance,"/// Lower an interleaved load into a vlsegN intrinsic.; ///; /// E.g. Lower an interleaved load (Factor = 2):; /// %wide.vec = load <8 x i32>, <8 x i32>* %ptr; /// %v0 = shuffle %wide.vec, undef, <0, 2, 4, 6> ; Extract even elements; /// %v1 = shuffle %wide.vec, undef, <1, 3, 5, 7> ; Extract odd elements; ///; /// Into:; /// %ld2 = { <4 x i32>, <4 x i32> } call llvm.riscv.seg2.load.v4i32.p0.i64(; /// %ptr, i64 4); /// %vec0 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 0; /// %vec1 = extractelement { <4 x i32>, <4 x i32> } %ld2, i32 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:25,load,load,25,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,4,['load'],['load']
Performance,/// Lower an interleaved load to target specific intrinsics. Return; /// true on success.; ///; /// \p LI is the vector load instruction.; /// \p Shuffles is the shufflevector list to DE-interleave the loaded vector.; /// \p Indices is the corresponding indices for each shufflevector.; /// \p Factor is the interleave factor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:25,load,load,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,3,['load'],"['load', 'loaded']"
Performance,/// Lower interleaved load(s) into target specific; /// instructions/intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:22,load,load,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['load'],['load']
Performance,"/// Lower load instructions, if shape information is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:10,load,load,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['load'],['load']
Performance,"/// Lower the current thread's priority such that it does not affect; /// foreground tasks significantly. This is a good default for long-; /// running, latency-insensitive tasks to make sure cpu is not hogged; /// by this task.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:153,latency,latency-insensitive,153,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,1,['latency'],['latency-insensitive']
Performance,/// LowerCCCArguments - transform physical registers into virtual registers and; /// generate load operations for arguments places on the stack.; // FIXME: struct return stuff,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp:94,load,load,94,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430ISelLowering.cpp,1,['load'],['load']
Performance,/// LowerCCCArguments - transform physical registers into; /// virtual registers and generate load operations for; /// arguments places on the stack.; /// TODO: sret,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreISelLowering.cpp:94,load,load,94,interpreter/llvm-project/llvm/lib/Target/XCore/XCoreISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/XCore/XCoreISelLowering.cpp,1,['load'],['load']
Performance,/// LowerFormalArguments - transform physical registers into virtual; /// registers and generate load operations for arguments places on the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h:97,load,load,97,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.h,1,['load'],['load']
Performance,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:126,load,loads,126,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,2,"['load', 'perform']","['loads', 'performs']"
Performance,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.; ///; /// This pass requires `CollectorMetadataAnalysis`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:126,load,loads,126,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,2,"['load', 'perform']","['loads', 'performs']"
Performance,"/// LowerMatrixIntrinsics contains the methods used to lower matrix intrinsics.; ///; /// Currently, the lowering for each matrix intrinsic is done as follows:; /// 1. Propagate the shape information from intrinsics to connected; /// instructions.; /// 2. Lower instructions with shape information (assuming column-major layout).; /// The lowering works similarly using row-major layout.; /// 2.1. Get column vectors for each argument. If we already lowered the; /// definition of an argument, use the produced column vectors directly.; /// If not, split the operand vector containing an embedded matrix into; /// a set of column vectors,; /// 2.2. Lower the instruction in terms of column major operations, which; /// yields a set of column vectors containing result matrix. Note that we; /// lower all instructions that have shape information. Besides the; /// intrinsics, this includes stores for example.; /// 2.3. Update uses of the lowered instruction. If we have shape information; /// for a user, there is nothing to do, as we will look up the result; /// column matrix when lowering the user. For other uses, we embed the; /// result matrix in a flat vector and update the use.; /// 2.4. Cache the result column matrix for the instruction we lowered; /// 3. After we lowered all instructions in a function, remove the now; /// obsolete instructions.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:1197,Cache,Cache,1197,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['Cache'],['Cache']
Performance,/// Lowers llvm.matrix.column.major.load.; ///; /// The intrinsic loads a matrix from memory using a stride between columns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:36,load,load,36,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,2,['load'],"['load', 'loads']"
Performance,/// MAT_PCREL_ADDR = Materialize a PC Relative address. This can be done; /// either through an add like PADDI or through a PC Relative load like; /// PLD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:136,load,load,136,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['load'],['load']
Performance,/// MD5 hash of CUID. It is calculated when first used and cached by this; /// data member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:59,cache,cached,59,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['cache'],['cached']
Performance,/// MO_PCREL_OPT_FLAG - If this bit is set the operand is part of a; /// PC Relative linker optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h:92,optimiz,optimization,92,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPC.h,1,['optimiz'],['optimization']
Performance,"/// MO_TAGGED - With MO_PAGE, indicates that the page includes a memory tag; /// in bits 56-63.; /// On a FrameIndex operand, indicates that the underlying memory is tagged; /// with an unknown tag value (MTE); this needs to be lowered either to an; /// SP-relative load or store instruction (which do not check tags), or to; /// an LDG instruction to obtain the tag value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h:266,load,load,266,interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h,1,['load'],['load']
Performance,/// MRMSrcMem4VOp3 - This form is used for instructions that encode; /// operand 3 with VEX.VVVV and load from memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:101,load,load,101,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,1,['load'],['load']
Performance,/// MRMSrcReg4VOp3 - This form is used for instructions that encode; /// operand 3 with VEX.VVVV and do not load from memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:108,load,load,108,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,1,['load'],['load']
Performance,/// MachO specific deployment target version info.; // A Major version of 0 indicates that no version information was supplied; // and so the corresponding load command should not be emitted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h:156,load,load,156,interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,1,['load'],['load']
Performance,/// MachOBuilder load command wrapper type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h:17,load,load,17,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/MachOBuilder.h,1,['load'],['load']
Performance,"/// Machine model for scheduling, bundling, and heuristics.; ///; /// The machine model directly provides basic information about the; /// microarchitecture to the scheduler in the form of properties. It also; /// optionally refers to scheduler resource tables and itinerary; /// tables. Scheduler resource tables model the latency and cost for each; /// instruction type. Itinerary tables are an independent mechanism that; /// provides a detailed reservation table describing each cycle of instruction; /// execution. Subtargets may define any or all of the above categories of data; /// depending on the type of CPU and selected scheduler.; ///; /// The machine independent properties defined here are used by the scheduler as; /// an abstract machine model. A real micro-architecture has a number of; /// buffers, queues, and stages. Declaring that a given machine-independent; /// abstract property corresponds to a specific physical property across all; /// subtargets can't be done. Nonetheless, the abstract model is; /// useful. Futhermore, subtargets typically extend this model with processor; /// specific resources to model any hardware features that can be exploited by; /// scheduling heuristics and aren't sufficiently represented in the abstract.; ///; /// The abstract pipeline is built around the notion of an ""issue point"". This; /// is merely a reference point for counting machine cycles. The physical; /// machine will have pipeline stages that delay execution. The scheduler does; /// not model those delays because they are irrelevant as long as they are; /// consistent. Inaccuracies arise when instructions have different execution; /// delays relative to each other, in addition to their intrinsic latency. Those; /// special cases can be handled by TableGen constructs such as, ReadAdvance,; /// which reduces latency when reading data, and ReleaseAtCycles, which consumes; /// a processor resource when writing data for a number of abstract; /// cycles.; ///; /// TODO: O",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:324,latency,latency,324,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,2,"['latency', 'queue']","['latency', 'queues']"
Performance,/// MachineCSE - This pass performs global CSE on machine instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:27,perform,performs,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,/// MachineCopyPropagation - This pass performs copy propagation on; /// machine instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:39,perform,performs,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,/// MachineRegisterInfo used to perform tracking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:32,perform,perform,32,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['perform'],['perform']
Performance,/// MachineSinking - This pass performs sinking on machine instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:31,perform,performs,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,/// Main entry point to perform analysis and transformations on graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:24,perform,perform,24,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['perform'],['perform']
Performance,/// Maintain number of AST loads and check for reaching the load limit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h:27,load,loads,27,interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CrossTU/CrossTranslationUnit.h,2,['load'],"['load', 'loads']"
Performance,/// Make sure Results are legal and update the translation cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:59,cache,cache,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['cache'],['cache']
Performance,"/// Make sure that the normalization set for a RooAddPdf is always defined when; /// numerically integrating a RooProdPdf where the RooAddPdf is one of the; /// factors. Covers GitHub #11476 and JIRA issue ROOT-9436.; ///; /// Disabled for now because the fix to the bug that is covered by this unit; /// test caused a severe performance problem and was reverted. The performance; /// regression is covered by another unit test in this file, called; /// ""ProjectConditional"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx:326,perform,performance,326,roofit/roofitcore/test/testRooRealIntegral.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooRealIntegral.cxx,2,['perform'],['performance']
Performance,"/// Make sure the offsets are up to date; ///; /// If the offsets need to be updated, this function triggers a likelihood evaluation.; /// The likelihood will make sure the offset is set correctly in their shared_ptr; /// offsets object, that is also shared with possible other LikelihoodWrapper members; /// of MinuitFcnGrad and also the LikelihoodGradientWrapper member. Other necessary; /// synchronization steps are also performed from the Wrapper child classes (e.g.; /// sending the values to workers from MultiProcess::Jobs).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx:425,perform,performed,425,roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx,1,['perform'],['performed']
Performance,/// Manages allocations of JIT memory.; ///; /// Instances of this class may be accessed concurrently from multiple threads; /// and their implemetations should include any necessary synchronization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h:89,concurren,concurrently,89,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,1,['concurren'],['concurrently']
Performance,"/// Manages the lifetime of CallEvent objects.; ///; /// CallEventManager provides a way to create arbitrary CallEvents ""on the; /// stack"" as if they were value objects by keeping a cache of CallEvent-sized; /// memory blocks. The CallEvents created by CallEventManager are only valid; /// for the lifetime of the OwnedCallEvent that holds them; right now these; /// objects cannot be copied and ownership cannot be transferred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h:183,cache,cache,183,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h,1,['cache'],['cache']
Performance,/// Manages the set of modules loaded by an AST reader.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:31,load,loaded,31,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,"/// Many allocas are only used within a single basic block. If this is the; /// case, avoid traversing the CFG and inserting a lot of potentially useless; /// PHI nodes by just performing a single linear pass over the basic block; /// using the Alloca.; ///; /// If we cannot promote this alloca (because it is read before it is written),; /// return false. This is necessary in cases where, due to control flow, the; /// alloca is undefined only on some control flow paths. e.g. code like; /// this is correct in LLVM IR:; /// // A is an alloca with no stores so far; /// for (...) {; /// int t = *A;; /// if (!first_iteration); /// use(t);; /// *A = 42;; /// }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:177,perform,performing,177,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['perform'],['performing']
Performance,"/// Many checkers are essentially built into this one, so enabling them will; /// make MallocChecker perform additional modeling and reporting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:101,perform,perform,101,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['perform'],['perform']
Performance,/// Map a location to the set of basic blocks it dominates. This is a cache; /// for \ref LexicalScopes::getMachineBasicBlocks results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:70,cache,cache,70,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,1,['cache'],['cache']
Performance,/// Map from IR unit to a list of analysis results.; ///; /// Provides linear time removal of all analysis results for a IR unit and; /// the ultimate storage for a particular cached analysis result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:176,cache,cached,176,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['cached']
Performance,/// Map from an analysis ID and IR unit to a particular cached; /// analysis result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:56,cache,cached,56,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['cache'],['cached']
Performance,/// Map from filenames to cached entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:26,cache,cached,26,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cached']
Performance,/// Map from instruction numbers defined by DBG_PHIs to a record of what that; /// DBG_PHI read and where. Populated and edited during the machine value; /// location problem -- we use LLVMs SSA Updater to fix changes by; /// optimizations that destroy PHI instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:226,optimiz,optimizations,226,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['optimiz'],['optimizations']
Performance,/// Map from unique IDs to cached entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:27,cache,cached,27,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cached']
Performance,"/// Map representing for accessed memory offsets and sizes.; /// A key is Offset and a value is size.; /// If there is a load/store instruction something like,; /// p[offset] = v;; /// (offset, sizeof(v)) will be inserted to this map.; /// std::map is used because we want to iterate keys in ascending order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:121,load,load,121,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['load'],['load']
Performance,/// Map to cache containsIrreducibleCFG results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:11,cache,cache,11,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['cache'],['cache']
Performance,"/// MapIterator has just changed, reset the cached state to point to the; /// start of the new underlying iterator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:44,cache,cached,44,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,1,['cache'],['cached']
Performance,/// Mapping from FileID (i.e. vector index) to filename. Used to support; /// macro expansions within a function in which the macro and function are; /// defined in separate files.; ///; /// TODO: Uniquing filenames across all function records may be a performance; /// optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h:253,perform,performance,253,interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,/// Mapping from decls to cached bytecode functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h:26,cache,cached,26,interpreter/llvm-project/clang/lib/AST/Interp/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/Program.h,1,['cache'],['cached']
Performance,"/// Mapping of DBG_INSTR_REF instructions to their values, for those; /// DBG_INSTR_REFs that call resolveDbgPHIs. These variable references solve; /// a mini SSA problem caused by DBG_PHIs being cloned, this collection caches; /// the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:220,cache,caches,220,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['cache'],['caches']
Performance,"/// Maps a value to its latest collapsed shadow value it was converted to in; /// terms of domination tree. When ClDebugNonzeroLabels is on, this cache is; /// used at a post process where CFG blocks are split. So it does not cache; /// BasicBlock like CachedShadows, but uses domination between values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:146,cache,cache,146,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,3,"['Cache', 'cache']","['CachedShadows', 'cache']"
Performance,"/// Maps from a start to an end spelling location of transformations; /// performed by the preprocessor. These include:; /// 1. range from '#' to the last token in the line for PP directives,; /// 2. macro name and arguments for macro expansions.; /// Note that we record only top-level macro expansions, intermediate; /// expansions (e.g. inside macro arguments) are ignored.; ///; /// Used to find correct boundaries of macro calls and directives when; /// building mappings from spelled to expanded tokens.; ///; /// Logically, at each point of the preprocessor execution there is a stack of; /// macro expansions being processed and we could use it to recover the; /// location information we need. However, the public preprocessor API only; /// exposes the points when macro expansions start (when we push a macro onto; /// the stack) and not when they end (when we pop a macro from the stack).; /// To workaround this limitation, we rely on source location information; /// stored in this map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:74,perform,performed,74,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,1,['perform'],['performed']
Performance,"/// Maps instructions to their shape information. The shape information; /// describes the shape to be used while lowering. This matches the shape of; /// the result value of the instruction, with the only exceptions being store; /// instructions and the matrix_column_major_store intrinsics. For those, the; /// shape information indicates that those instructions should be lowered; /// using shape information as well. A ValueMap is used so that when; /// sub-passes like optimizeTransposes performs RAUW the map stays; /// up-to-date.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:474,optimiz,optimizeTransposes,474,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,2,"['optimiz', 'perform']","['optimizeTransposes', 'performs']"
Performance,/// Maps the lane to a cache index based on \p VF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:23,cache,cache,23,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['cache'],['cache']
Performance,/// Maps the load/store instructions to their index according to; /// program order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:13,load,load,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['load'],['load']
Performance,"/// Mark \p F cold. Based on this assumption, also optimize it for minimum size.; /// If \p UpdateEntryCount is true (set when this is a new split function and; /// module has profile data), set entry count to 0 to ensure treated as cold.; /// Return true if the function is changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:51,optimiz,optimize,51,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,1,['optimiz'],['optimize']
Performance,"/// Mark if the basket is currently in the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:43,cache,cache,43,tree/tree/inc/TBranchCacheInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h,1,['cache'],['cache']
Performance,"/// Mark if the basket should be vetoed in the next round.; /// This happens when the basket was loaded in the previous round; /// and was not used and is overlapping to the next round/cluster",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:97,load,loaded,97,tree/tree/inc/TBranchCacheInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h,1,['load'],['loaded']
Performance,/// Mark the MMO of a load as the last use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h:22,load,load,22,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h,1,['load'],['load']
Performance,/// Mark the MMO of a uniform load if there are no potentially clobbering stores; /// on any path from the start of an entry function to this load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h:30,load,load,30,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h,2,['load'],['load']
Performance,"/// Mark the matcher as fully-built and ensure any invariants expected by both; /// optimize() and emit(...) methods. Generally, both sequences of calls; /// are expected to lead to a sensible result:; ///; /// addMatcher(...)*; finalize(); optimize(); emit(...); and; /// addMatcher(...)*; finalize(); emit(...);; ///; /// or generally; ///; /// addMatcher(...)*; finalize(); { optimize()*; emit(...); }*; ///; /// Multiple calls to optimize() are expected to be handled gracefully, though; /// optimize() is not expected to be idempotent. Multiple calls to finalize(); /// aren't generally supported. emit(...) is expected to be non-mutating and; /// producing the exact same results upon repeated calls.; ///; /// addMatcher() calls after the finalize() call are not supported.; ///; /// finalize() and optimize() are both allowed to mutate the contained; /// matchers, so moving them out after finalize() is not supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:84,optimiz,optimize,84,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,6,['optimiz'],['optimize']
Performance,/// Mark the specified file as having a controlling macro.; ///; /// This is used by the multiple-include optimization to eliminate; /// no-op \#includes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:106,optimiz,optimization,106,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['optimiz'],['optimization']
Performance,"/// Marks that the current location is not supposed to be reachable.; /// In !NDEBUG builds, prints the message and location info to stderr.; /// In NDEBUG builds, if the platform does not support a builtin unreachable; /// then we call an internal LLVM runtime function. Otherwise the behavior is; /// controlled by the CMake flag; /// -DLLVM_UNREACHABLE_OPTIMIZE; /// * When ""ON"" (default) llvm_unreachable() becomes an optimizer hint; /// that the current location is not supposed to be reachable: the hint; /// turns such code path into undefined behavior. On compilers that don't; /// support such hints, prints a reduced message instead and aborts the; /// program.; /// * When ""OFF"", a builtin_trap is emitted instead of an; // optimizer hint or printing a reduced message.; ///; /// Use this instead of assert(0). It conveys intent more clearly, suppresses; /// diagnostics for unreachable code paths, and allows compilers to omit; /// unnecessary code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:422,optimiz,optimizer,422,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,2,['optimiz'],['optimizer']
Performance,"/// Marks the column as complete; must be done for all columns, even empty ones without associated pages,; /// before the cluster is given from the page storage to the cluster pool. Marking the available columns is; /// typically the last step of RPageSouce::LoadCluster().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx:259,Load,LoadCluster,259,tree/ntuple/v7/inc/ROOT/RCluster.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RCluster.hxx,1,['Load'],['LoadCluster']
Performance,/// Marks the end of an TSX (RTM) suspend load address tracking region. If this; /// intrinsic is used inside a suspend load address tracking region it will; /// end the suspend region and all following load addresses will be added to; /// the transaction read set. If it's used inside an active transaction but; /// not in a suspend region it will cause transaction abort. If it's used; /// outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XRESLDTRK instruction.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:42,load,load,42,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,3,['load'],['load']
Performance,"/// Marks the start of an TSX (RTM) suspend load address tracking region. If; /// this intrinsic is used inside a transactional region, subsequent loads; /// are not added to the read set of the transaction. If it's used inside a; /// suspend load address tracking region it will cause transaction abort.; /// If it's used outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XSUSLDTRK instruction.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:44,load,load,44,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,3,['load'],"['load', 'loads']"
Performance,"/// Marks the version of the SCEV predicate used. When rewriting a SCEV; /// expression we mark it with the version of the predicate. We use this to; /// figure out if the predicate has changed from the last rewrite of the; /// SCEV. If so, we need to perform a new rewrite.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:252,perform,perform,252,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['perform'],['perform']
Performance,"/// Match (and (load x), mask) -> zextload x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:16,load,load,16,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['load'],['load']
Performance,"/// Match a 128b store of zero and split it into two 64 bit stores, for; /// size/performance reasons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp:82,perform,performance,82,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,1,['perform'],['performance']
Performance,"/// Match a pattern where a wide type scalar value is loaded by several narrow; /// loads and combined by shifts and ors. Fold it into a single load or a load; /// and a BSWAP if the targets supports it.; ///; /// Assuming little endian target:; /// i8 *a = ...; /// i32 val = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24); /// =>; /// i32 val = *((i32)a); ///; /// i8 *a = ...; /// i32 val = (a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]; /// =>; /// i32 val = BSWAP(*((i32)a)); ///; /// TODO: This rule matches complex patterns with OR node roots and doesn't; /// interact well with the worklist mechanism. When a part of the pattern is; /// updated (e.g. one of the loads) its direct users are put into the worklist,; /// but the root node of the pattern which triggers the load combine is not; /// necessarily a direct user of the changed node. For example, once the address; /// of t28 load is reassociated load combine won't be triggered:; /// t25: i32 = add t4, Constant:i32<2>; /// t26: i64 = sign_extend t25; /// t27: i64 = add t2, t26; /// t28: i8,ch = load<LD1[%tmp9]> t0, t27, undef:i64; /// t29: i32 = zero_extend t28; /// t32: i32 = shl t29, Constant:i8<8>; /// t33: i32 = or t23, t32; /// As a possible fix visitLoad can check if the load can be a part of a load; /// combine pattern and add corresponding OR roots to the worklist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:54,load,loaded,54,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,11,['load'],"['load', 'loaded', 'loads']"
Performance,/// Match an fcmp against a special value that performs a test possible by; /// llvm.is.fpclass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:47,perform,performs,47,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['perform'],['performs']
Performance,/// Match expression trees of the form; ///; /// \code; /// sN *a = ...; /// sM val = a[0] | (a[1] << N) | (a[2] << 2N) | (a[3] << 3N) ...; /// \endcode; ///; /// And check if the tree can be replaced with a M-bit load + possibly a; /// bswap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:214,load,load,214,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['load'],['load']
Performance,"/// Match sext_inreg(load p), imm -> sextload p",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:21,load,load,21,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['load'],['load']
Performance,"/// Match the index vector of a scatter or gather node as the shuffle mask; /// which performs the rearrangement if possible. Will only match if; /// all lanes are touched, and thus replacing the scatter or gather with; /// a unit strided access and shuffle is legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:86,perform,performs,86,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['perform'],['performs']
Performance,/// Matches LoadInst.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h:12,Load,LoadInst,12,interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PatternMatch.h,1,['Load'],['LoadInst']
Performance,"/// Matches NamedDecl nodes that have any of the specified names.; ///; /// This matcher is only provided as a performance optimization of hasName.; /// \code; /// hasAnyName(a, b, c); /// \endcode; /// is equivalent to, but faster than; /// \code; /// anyOf(hasName(a), hasName(b), hasName(c)); /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h:111,perform,performance,111,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"/// Matches ObjC selectors whose name contains; /// a substring matched by the given RegExp.; /// matcher = objCMessageExpr(matchesSelector(""loadHTMLString\:baseURL?""));; /// matches the outer message expr in the code below, but NOT the message; /// invocation for self.bodyView.; /// \code; /// [self.bodyView loadHTMLString:html baseURL:NULL];; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h:141,load,loadHTMLString,141,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,2,['load'],['loadHTMLString']
Performance,"/// Matches all callsite metadata (or summary) to the nodes created for; /// allocation memprof MIB metadata, synthesizing new nodes to reflect any; /// inlining performed on those callsite instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:162,perform,performed,162,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['perform'],['performed']
Performance,"/// Matches declaration of the function, method, or block the statement; /// belongs to.; ///; /// Given:; /// \code; /// F& operator=(const F& o) {; /// std::copy_if(o.begin(), o.end(), begin(), [](V v) { return v > 0; });; /// return *this;; /// }; /// \endcode; /// returnStmt(forCallable(functionDecl(hasName(""operator="")))); /// matches 'return *this'; /// but does not match 'return v > 0'; ///; /// Given:; /// \code; /// -(void) foo {; /// int x = 1;; /// dispatch_sync(queue, ^{ int y = 2; });; /// }; /// \endcode; /// declStmt(forCallable(objcMethodDecl())); /// matches 'int x = 1'; /// but does not match 'int y = 2'.; /// whereas declStmt(forCallable(blockDecl())); /// matches 'int y = 2'; /// but does not match 'int x = 1'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h:478,queue,queue,478,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,1,['queue'],['queue']
Performance,"/// Matches when BaseName == Selector.getAsString(); ///; /// matcher = objCMessageExpr(hasSelector(""loadHTMLString:baseURL:""));; /// matches the outer message expr in the code below, but NOT the message; /// invocation for self.bodyView.; /// \code; /// [self.bodyView loadHTMLString:html baseURL:NULL];; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h:101,load,loadHTMLString,101,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,2,['load'],['loadHTMLString']
Performance,"/// Matches when the selector has the specified number of arguments; ///; /// matcher = objCMessageExpr(numSelectorArgs(0));; /// matches self.bodyView in the code below; ///; /// matcher = objCMessageExpr(numSelectorArgs(2));; /// matches the invocation of ""loadHTMLString:baseURL:"" but not that; /// of self.bodyView; /// \code; /// [self.bodyView loadHTMLString:html baseURL:NULL];; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h:259,load,loadHTMLString,259,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,2,['load'],['loadHTMLString']
Performance,"/// Matches when the selector is a Unary Selector; ///; /// matcher = objCMessageExpr(matchesSelector(hasUnarySelector());; /// matches self.bodyView in the code below, but NOT the outer message; /// invocation of ""loadHTMLString:baseURL:"".; /// \code; /// [self.bodyView loadHTMLString:html baseURL:NULL];; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h:215,load,loadHTMLString,215,interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/ASTMatchers.h,2,['load'],['loadHTMLString']
Performance,/// Materialize \p C into virtual-register \p Reg. The generic instructions; /// performing this materialization will be inserted into the entry block of; /// the function.; ///; /// \return true if the materialization succeeded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h:81,perform,performing,81,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,1,['perform'],['performing']
Performance,"/// May perform round-trip of command line arguments. By default, the round-trip; /// is enabled in assert builds. This can be overwritten at run-time via the; /// ""-round-trip-args"" and ""-no-round-trip-args"" command line flags, or via the; /// ForceRoundTrip parameter.; ///; /// During round-trip, the command line arguments are parsed into a dummy; /// CompilerInvocation, which is used to generate the command line arguments; /// again. The real CompilerInvocation is then created by parsing the generated; /// arguments, not the original ones. This (in combination with tests covering; /// argument behavior) ensures the generated command line is complete (doesn't; /// drop/mangle any arguments).; ///; /// Finally, we check the command line that was used to create the real; /// CompilerInvocation instance. By default, we compare it to the command line; /// the real CompilerInvocation generates. This checks whether the generator is; /// deterministic. If \p CheckAgainstOriginalInvocation is enabled, we instead; /// compare it to the original command line to verify the original command-line; /// was canonical and can round-trip exactly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:8,perform,perform,8,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['perform'],['perform']
Performance,/// Memory - This is the space that holds cached preds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h:42,cache,cached,42,interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h,1,['cache'],['cached']
Performance,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:182,Load,Load,182,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['Load'],['Load']
Performance,"/// Merge all adjacent intervals in the collection. For all pairs; /// of adjacient intervals, it performs [a, b) + [b, c) -> [a, c).; ///; /// Before performing the merge operation, the intervals are; /// sorted with \ref sort_predicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:98,perform,performs,98,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['perform'],"['performing', 'performs']"
Performance,"/// Merge chain From into chain Into, update the list of active chains,; /// adjacency information, and the corresponding cached values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:122,cache,cached,122,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,2,['cache'],['cached']
Performance,/// Merge consecutive store operations into a wide store.; /// This optimization uses wide integers or vectors when possible.; /// \return true if stores were merged.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:68,optimiz,optimization,68,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['optimiz'],['optimization']
Performance,"/// Merge the DIAssignID metadata from this instruction and those attached to; /// instructions in \p SourceInstructions. This process performs a RAUW on; /// the MetadataAsValue uses of the merged DIAssignID nodes. Not every; /// instruction in \p SourceInstructions needs to have DIAssignID; /// metadata. If none of them do then nothing happens. If this instruction; /// does not have a DIAssignID attachment but at least one in \p; /// SourceInstructions does then the merged one will be attached to; /// it. However, instructions without attachments in \p SourceInstructions; /// are not modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:135,perform,performs,135,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['perform'],['performs']
Performance,/// Merges partitions in order to ensure that no loads are duplicated.; ///; /// We can't duplicate loads because that could potentially reorder them.; /// LoopAccessAnalysis provides dependency information with the context that; /// the order of memory operation is preserved.; ///; /// Return if any partitions were merged.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:49,load,loads,49,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,2,['load'],['loads']
Performance,"/// Method called after fit has been performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsMCStudyModule.h:37,perform,performed,37,roofit/roofitcore/inc/RooAbsMCStudyModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsMCStudyModule.h,1,['perform'],['performed']
Performance,"/// Method called after generation of toy data sample and resetting of fit parameters to initial values and before; /// actual fit is performed. Any modifications to fit parameters will apply to next fit operation. Note that setConstant; /// flag of fit parameters are not explicitly reset by RooMCStudy, so any changes made to these flags here will persist",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsMCStudyModule.h:134,perform,performed,134,roofit/roofitcore/inc/RooAbsMCStudyModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsMCStudyModule.h,1,['perform'],['performed']
Performance,"/// Method called at the end of each RooMCStudy run. If a RooDataSet is returned, it must have a length equal to; /// the number of toy experiments performed and will merged with the fitpar dataset of RooMCStudy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsMCStudyModule.h:148,perform,performed,148,roofit/roofitcore/inc/RooAbsMCStudyModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsMCStudyModule.h,1,['perform'],['performed']
Performance,"/// Method called when default page content is prepared for use; /// By default no-cache header is provided",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpWSHandler.h:83,cache,cache,83,net/http/inc/THttpWSHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpWSHandler.h,1,['cache'],['cache']
Performance,"/// Method called when multi-threaded send operation is completed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpWSHandler.h:23,multi-thread,multi-threaded,23,net/http/inc/THttpWSHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpWSHandler.h,1,['multi-thread'],['multi-threaded']
Performance,/// Method for building the DAG expansion of ISD::[US]DIVFIX[SAT]. This; /// method accepts integers as its arguments.; /// Note: This method may fail if the division could not be performed; /// within the type. Clients must retry with a wider type if this happens.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:180,perform,performed,180,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['performed']
Performance,"/// Method generate extra suffix for all kinds of loaded code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpWSHandler.h:50,load,loaded,50,net/http/inc/THttpWSHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpWSHandler.h,1,['load'],['loaded']
Performance,"/// Method to directly load a value. If the value can be fetched directly,; /// the direct handler is called. Otherwise, a pointer is left on the stack; /// and the indirect handler is expected to operate on that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h:23,load,load,23,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.h,1,['load'],['load']
Performance,"/// Method to try and mark a result as invalid.; ///; /// When the outer analysis manager detects a change in some underlying; /// unit of the IR, it will call this method on all of the results cached.; ///; /// \p PA is a set of preserved analyses which can be used to avoid; /// invalidation because the pass which changed the underlying IR took care; /// to update or preserve the analysis result in some way.; ///; /// \p Inv is typically a \c AnalysisManager::Invalidator object that can be; /// used by a particular analysis result to discover if other analyses; /// results are also invalidated in the event that this result depends on; /// them. See the documentation in the \c AnalysisManager for more details.; ///; /// \returns true if the result is indeed invalid (the default).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:194,cache,cached,194,interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,1,['cache'],['cached']
Performance,"/// Methods to load and drop cluster group details (cluster IDs and page locations)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx:15,load,load,15,tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleDescriptor.hxx,1,['load'],['load']
Performance,"/// Methods with trivial inline returns are convenient points in the common; /// codegen pass pipeline where targets may insert passes. Methods with; /// out-of-line standard implementations are major CodeGen stages called by; /// addMachinePasses. Some targets may override major stages when inserting; /// passes is insufficient, but maintaining overriden stages is more work.; ///; /// addMachineSSAOptimization - Add standard passes that optimize machine; /// instructions in SSA form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:442,optimiz,optimize,442,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,1,['optimiz'],['optimize']
Performance,/// ModFilter - Filters based on the mod bits [bits 7-6] of the ModR/M byte.; /// Some instructions are classified based on whether they are 11 or anything; /// else. This filter performs that classification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86ModRMFilters.h:179,perform,performs,179,interpreter/llvm-project/llvm/utils/TableGen/X86ModRMFilters.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86ModRMFilters.h,1,['perform'],['performs']
Performance,/// Model the elimination of repeated loads that is expected to happen; /// whenever we simplify away the stores that would otherwise cause them to be; /// loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:38,load,loads,38,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,2,['load'],['loads']
Performance,/// ModelUnderTrainingRunner - training mode implementation. It uses TFLite; /// to dynamically load and evaluate a TF SavedModel; /// (https://www.tensorflow.org/guide/saved_model) converted to TFLite. see; /// lib/Analysis/models/saved-model-to-tflite.py. Runtime performance is; /// sacrificed for ease of use while training.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h:96,load,load,96,interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h,2,"['load', 'perform']","['load', 'performance']"
Performance,/// Modifies directive to perform literal match.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h:26,perform,perform,26,interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/FileCheck/FileCheck.h,1,['perform'],['perform']
Performance,"/// Modify anything using 'From' to use 'To' instead.; /// This can cause recursive merging of nodes in the DAG. Use the first; /// version if 'From' is known to have a single result, use the second; /// if you have two nodes with identical results (or if 'To' has a superset; /// of the results of 'From'), use the third otherwise.; ///; /// These methods all take an optional UpdateListener, which (if not null) is; /// informed about nodes that are deleted and modified due to recursive; /// changes in the dag.; ///; /// These functions only replace all existing uses. It's possible that as; /// these replacements are being performed, CSE may cause the From node; /// to be given new uses. These new uses of From are left in place, and; /// not automatically transferred to To.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:629,perform,performed,629,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['perform'],['performed']
Performance,/// Module contains suppressed export information. This also infers that the; /// address taken IAT table is also present in the load config.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:129,load,load,129,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,1,['load'],['load']
Performance,"/// Module loading cache that includes submodules, indexed by IdentifierInfo.; /// nullptr is stored for modules that are known to fail to load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:11,load,loading,11,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,3,"['cache', 'load']","['cache', 'load', 'loading']"
Performance,/// Module performs control flow and write integrity checks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:11,perform,performs,11,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,1,['perform'],['performs']
Performance,/// Module performs control flow integrity checks using system-supplied; /// support.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:11,perform,performs,11,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,1,['perform'],['performs']
Performance,/// Module supports read only delay load IAT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:36,load,load,36,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,1,['load'],['load']
Performance,"/// Most of the time transposes can be fused with matrix multiplies or can; /// be folded away via algebraic simplifications. This is the number of; /// transposes that we failed to make ""free"" via such optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:203,optimiz,optimizations,203,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['optimiz'],['optimizations']
Performance,"/// Mother class of TTypedPointerHolder. The instances; /// of this class can be put in a container. Upon destruction,; /// the correct deletion of the pointer is performed in the; /// derived class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx:163,perform,performed,163,tree/dataframe/inc/ROOT/RDataSource.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDataSource.hxx,1,['perform'],['performed']
Performance,"/// Move a zext or sext fed by a load into the same basic block as the load,; /// unless conditions are unfavorable. This allows SelectionDAG to fold the; /// extend into the load.; ///; /// E.g.,; /// \code; /// %ld = load i32* %addr; /// %add = add nuw i32 %ld, 4; /// %zext = zext i32 %add to i64; // \endcode; /// =>; /// \code; /// %ld = load i32* %addr; /// %zext = zext i32 %ld to i64; /// %add = add nuw i64 %zext, 4; /// \encode; /// Note that the promotion in %add to i64 is done in tryToPromoteExts(), which; /// allow us to match zext(load i32*) to i64.; ///; /// Also, try to promote the computations used to obtain a sign extended; /// value used into memory accesses.; /// E.g.,; /// \code; /// a = add nsw i32 b, 3; /// d = sext i32 a to i64; /// e = getelementptr ..., i64 d; /// \endcode; /// =>; /// \code; /// f = sext i32 b to i64; /// a = add nsw i64 f, 3; /// e = getelementptr ..., i64 a; /// \endcode; ///; /// \p Inst[in/out] the extension may be modified during the process if some; /// promotions apply.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:33,load,load,33,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,6,['load'],['load']
Performance,/// Move affected values in the cache for OV to be affected values for NV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:32,cache,cache,32,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['cache'],['cache']
Performance,"/// Move in the provide values in \p ValuesToLink from \p Src.; ///; /// - \p AddLazyFor is a call back that the IRMover will call when a global; /// value is referenced by one of the ValuesToLink (transitively) but was; /// not present in ValuesToLink. The GlobalValue and a ValueAdder callback; /// are passed as an argument, and the callback is expected to be called; /// if the GlobalValue needs to be added to the \p ValuesToLink and linked.; /// Pass nullptr if there's no work to be done in such cases.; /// - \p IsPerformingImport is true when this IR link is to perform ThinLTO; /// function importing from Src.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Linker/IRMover.h:571,perform,perform,571,interpreter/llvm-project/llvm/include/llvm/Linker/IRMover.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Linker/IRMover.h,1,['perform'],['perform']
Performance,"/// Move the call to free before a NULL test.; ///; /// Check if this free is accessed after its argument has been test; /// against NULL (property 0).; /// If yes, it is legal to move this call in its predecessor block.; ///; /// The move is performed only if the block containing the call to free; /// will be removed, i.e.:; /// 1. it has only one predecessor P, and P has two successors; /// 2. it contains the call, noops, and an unconditional branch; /// 3. its successor is the same as its predecessor's successor; ///; /// The profitability is out-of concern here and this function should; /// be called only if the caller knows this transformation would be; /// profitable (e.g., for code size).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:243,perform,performed,243,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['perform'],['performed']
Performance,"/// Move the given iterators to the next leaf type in depth first traversal.; ///; /// Performs a depth-first traversal of the type as specified by its arguments,; /// stopping at the next leaf node (which may be a legitimate scalar type or an; /// empty struct or array).; ///; /// @param SubTypes List of the partial components making up the type from; /// outermost to innermost non-empty aggregate. The element currently; /// represented is SubTypes.back()->getTypeAtIndex(Path.back() - 1).; ///; /// @param Path Set of extractvalue indices leading from the outermost type; /// (SubTypes[0]) to the leaf node currently represented.; ///; /// @returns true if a new type was found, false otherwise. Calling this; /// function again on a finished iterator will repeatedly return; /// false. SubTypes.back()->getTypeAtIndex(Path.back()) is either an empty; /// aggregate or a non-aggregate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:87,Perform,Performs,87,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,1,['Perform'],['Performs']
Performance,"/// Multi-threaded top-down builder that partitions primitives using a grid. Multiple instances; /// of a single-threaded builder are run in parallel on that partition, generating many small; /// trees. Finally, a top-level tree is built on these smaller trees to form the final BVH.; /// This builder is inspired by; /// ""Rapid Bounding Volume Hierarchy Generation using Mini Trees"", by P. Ganestam et al.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/mini_tree_builder.h:4,Multi-thread,Multi-threaded,4,geom/geom/inc/bvh/v2/mini_tree_builder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/mini_tree_builder.h,1,['Multi-thread'],['Multi-threaded']
Performance,"/// Multiple entries can have been instantiated from the ntuple model. This method will perform; /// a light check whether the entry comes from the ntuple's own model.; /// \return The number of uncompressed bytes written.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx:88,perform,perform,88,tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriter.hxx,1,['perform'],['perform']
Performance,/// MustSaveTOC - Indicates that the TOC save needs to be performed in the; /// prologue of the function. This is typically the case when there are; /// indirect calls in the function and it is more profitable to save the; /// TOC pointer in the prologue than in the block(s) containing the call(s).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h:58,perform,performed,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineFunctionInfo.h,1,['perform'],['performed']
Performance,"/// Mutates IR (typicaly a load instruction) to use a <4 x s32> as the initial; /// type of the operand `idx` and then to transform it to a `p8` via bitcasts; /// and inttoptr. In addition, handle vectors of p8. Returns the new type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:27,load,load,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['load'],['load']
Performance,/// Mutex-protected queue of Events.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp:20,queue,queue,20,interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,1,['queue'],['queue']
Performance,"/// NEONThumb2LoadStorePostEncoder - Post-process encoded NEON load/store; /// instructions, and rewrite them to their Thumb2 form if we are currently in; /// Thumb2 mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp:63,load,load,63,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMMCCodeEmitter.cpp,1,['load'],['load']
Performance,"/// Name lookup results in an ambiguity because multiple; /// entities that meet the lookup criteria were found in; /// subobjects of different types. For example:; /// @code; /// struct A { void f(int); }; /// struct B { void f(double); }; /// struct C : A, B { };; /// void test(C c) {; /// c.f(0); // error: A::f and B::f come from subobjects of different; /// // types. overload resolution is not performed.; /// }; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:401,perform,performed,401,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['perform'],['performed']
Performance,/// Name of the profile file to load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:32,load,load,32,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,1,['load'],['load']
Performance,/// Name of the profile remapping file to load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:42,load,load,42,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,1,['load'],['load']
Performance,"/// Named Registers are named metadata pointing to the register name; /// which will be read from/written to as an argument to the intrinsic; /// @llvm.read/write_register.; /// So far, only the name is being passed down, but other options such as; /// register type, allocation type or even optimization options could be; /// passed down via the metadata node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:292,optimiz,optimization,292,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['optimiz'],['optimization']
Performance,/// NarrowingKind - The kind of narrowing conversion being performed by a; /// standard conversion sequence according to C++11 [dcl.init.list]p7.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:59,perform,performed,59,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['perform'],['performed']
Performance,/// NeedLatency - True if the scheduler will make use of latency information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:57,latency,latency,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['latency'],['latency']
Performance,/// Newly created live range that has never been queued.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:49,queue,queued,49,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,1,['queue'],['queued']
Performance,"/// No constant term optimization is possible in code-generation mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFuncWrapper.h:21,optimiz,optimization,21,roofit/roofitcore/inc/RooFuncWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFuncWrapper.h,1,['optimiz'],['optimization']
Performance,/// NoSignedZerosFPMath - This flag is enabled when the; /// -enable-no-signed-zeros-fp-math is specified on the command line. This; /// specifies that optimizations are allowed to treat the sign of a zero; /// argument or result as insignificant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:152,optimiz,optimizations,152,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['optimiz'],['optimizations']
Performance,/// Normalises latency statistics for each edge and vertex by CycleFrequency;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h:15,latency,latency,15,interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-graph.h,1,['latency'],['latency']
Performance,"/// NotRewritable - The operands being written will be the leaves of the new; /// expression and must not be used as inner nodes (via NodesToRewrite) by; /// mistake. Inner nodes are always reassociable, and usually leaves are not; /// (if they were they would have been incorporated into the expression and so; /// would not be leaves), so most of the time there is no danger of this. But; /// in rare cases a leaf may become reassociable if an optimization kills uses; /// of it, or it may momentarily become reassociable during rewriting (below); /// due it being removed as an operand of one of its uses. Ensure that misuse; /// of leaf nodes as inner nodes cannot occur by remembering all of the future; /// leaves and refusing to reuse any of them as inner nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:446,optimiz,optimization,446,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['optimiz'],['optimization']
Performance,/// Note that the frontend token information for this identifier has; /// changed since it was loaded from an AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:95,load,loaded,95,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['load'],['loaded']
Performance,"/// Note that the given module file has been loaded.; ///; /// \returns false if the global module index has information about this; /// module file, and true otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h:45,load,loaded,45,interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,1,['load'],['loaded']
Performance,/// Note that this identifier has changed since it was loaded from; /// an AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:55,load,loaded,55,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['load'],['loaded']
Performance,"/// Note that turning off page checksums will also turn off the same page merging optimization (see tuning.md)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx:82,optimiz,optimization,82,tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleWriteOptions.hxx,1,['optimiz'],['optimization']
Performance,/// Note that we found and ignored a declaration while performing; /// lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:55,perform,performing,55,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['perform'],['performing']
Performance,/// Notifies this tracking that we are going to insert a new instruction \p; /// Inst to the basic block \p BB. It makes all necessary updates to internal; /// caches to keep them consistent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:160,cache,caches,160,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,1,['cache'],['caches']
Performance,/// Notifies this tracking that we are going to remove the instruction \p Inst; /// It makes all necessary updates to internal caches to keep them consistent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:127,cache,caches,127,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,1,['cache'],['caches']
Performance,/// Notifies this tracking that we are going to replace all uses of \p Inst.; /// It makes all necessary updates to internal caches to keep them consistent.; /// Should typically be called before a RAUW.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h:125,cache,caches,125,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionPrecedenceTracking.h,1,['cache'],['caches']
Performance,"/// Notify PhiValues that the cached information using V is no longer valid; ///; /// Whenever a phi has its operands modified the cached values for that phi; /// (and the phis that use that phi) become invalid. A user of PhiValues has; /// to notify it of this by calling invalidateValue on either the operand or; /// the phi, which will then clear the relevant cached information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:30,cache,cached,30,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,3,['cache'],['cached']
Performance,"/// Now that the operands for this expression tree are; /// linearized and optimized, emit them in-order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:75,optimiz,optimized,75,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['optimiz'],['optimized']
Performance,"/// NumNodesSolelyBlocking - This vector contains, for every node in the; /// Queue, the number of nodes that the node is the sole unscheduled; /// predecessor for. This is used as a tie-breaker heuristic for better; /// mobility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:78,Queue,Queue,78,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,2,['Queue'],['Queue']
Performance,/// Number of loads emitted to generate this matrix.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:14,load,loads,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['load'],['loads']
Performance,/// Number of modules loaded,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:22,load,loaded,22,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,"/// Number of times we hit the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/LookupHelper.h:31,cache,cache,31,interpreter/cling/include/cling/Interpreter/LookupHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/LookupHelper.h,1,['cache'],['cache']
Performance,"/// Number of times we missed the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/LookupHelper.h:34,cache,cache,34,interpreter/cling/include/cling/Interpreter/LookupHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/LookupHelper.h,1,['cache'],['cache']
Performance,"/// NumericLiteralParser - This performs strict semantic analysis of the content; /// of a ppnumber, classifying it as either integer, floating, or erroneous,; /// determines the radix of the value and can convert it to a useful value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h:32,perform,performs,32,interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/LiteralSupport.h,1,['perform'],['performs']
Performance,"/// OL_applyQueryPhase1 is an optionally re-startable loop for triggering; /// definition generation. It is called when a lookup is performed, and again; /// each time that LookupState::continueLookup is called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:132,perform,performed,132,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['perform'],['performed']
Performance,"/// ObjectKey is a used to capture keys in Object. Like Value but:; /// - only strings are allowed; /// - it's optimized for the string literal case (Owned == nullptr); /// Like Value, strings must be UTF-8. See isUTF8 documentation for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:111,optimiz,optimized,111,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['optimiz'],['optimized']
Performance,/// Observe that the given method cannot be a key function.; /// Checks the key-function cache for the method's class and clears it; /// if matches the given declaration.; ///; /// This is used in ABIs where out-of-line definitions marked; /// inline are not considered to be key functions.; ///; /// \param method should be the declaration from the class definition,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:89,cache,cache,89,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['cache'],['cache']
Performance,"/// Obtain the Load Address of a section by SectionRef.; ///; /// Calculate the address of the given section.; /// The section need not be present in the local address space. The addresses; /// need to be consistent with the addresses used to query the DIContext and; /// the output of this function should be deterministic, i.e. repeated calls; /// with the same Sec should give the same address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h:15,Load,Load,15,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DIContext.h,1,['Load'],['Load']
Performance,/// Offset - The byte offset in Val that is interesting for the load query.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:64,load,load,64,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['load'],['load']
Performance,/// Offsets to dependant clobber loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:33,load,loads,33,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['load'],['loads']
Performance,"/// On some platforms, an AtomicRMW that never actually modifies the value; /// (such as fetch_add of 0) can be turned into a fence followed by an; /// atomic load. This may sound useless, but it makes it possible for the; /// processor to keep the cacheline shared, dramatically improving; /// performance. And such idempotent RMWs are useful for implementing some; /// kinds of locks, see for example (justification + benchmarks):; /// http://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf; /// This method tries doing that transformation, returning the atomic load if; /// it succeeds, and nullptr otherwise.; /// If shouldExpandAtomicLoadInIR returns true on that load, it will undergo; /// another round of expansion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:159,load,load,159,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,5,"['cache', 'load', 'perform']","['cacheline', 'load', 'performance']"
Performance,/// On-demand loading of a single MDString. Requires the index above to be; /// populated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:14,load,loading,14,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,1,['load'],['loading']
Performance,/// On-demand loading of a single metadata. Requires the index above to be; /// populated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:14,load,loading,14,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,1,['load'],['loading']
Performance,"/// Once the RecordType has been expanded, the temporary incomplete TypeString; /// must be removed from the cache.; /// If a Recursive was swapped out by addIncomplete(), it will be replaced.; /// Returns true if the RecordType was defined recursively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:109,cache,cache,109,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,1,['cache'],['cache']
Performance,/// One instance of this struct is kept for every file loaded or used.; ///; /// This object owns the MemoryBuffer object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:55,load,loaded,55,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,"/// One per MachineBasicBlock, this is used to cache the result; /// if-conversion feasibility analysis. This includes results from; /// TargetInstrInfo::analyzeBranch() (i.e. TBB, FBB, and Cond), and its; /// classification, and common tail block of its successors (if it's a; /// diamond shape), its size, whether it's predicable, and whether any; /// instruction can clobber the 'would-be' predicate.; ///; /// IsDone - True if BB is not to be considered for ifcvt.; /// IsBeingAnalyzed - True if BB is currently being analyzed.; /// IsAnalyzed - True if BB has been analyzed (info is still valid).; /// IsEnqueued - True if BB has been enqueued to be ifcvt'ed.; /// IsBrAnalyzable - True if analyzeBranch() returns false.; /// HasFallThrough - True if BB may fallthrough to the following BB.; /// IsUnpredicable - True if BB is known to be unpredicable.; /// ClobbersPred - True if BB could modify predicates (e.g. has; /// cmp, call, etc.); /// NonPredSize - Number of non-predicated instructions.; /// ExtraCost - Extra cost for multi-cycle instructions.; /// ExtraCost2 - Some instructions are slower when predicated; /// BB - Corresponding MachineBasicBlock.; /// TrueBB / FalseBB- See analyzeBranch().; /// BrCond - Conditions for end of block conditional branches.; /// Predicate - Predicate used in the BB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:47,cache,cache,47,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['cache'],['cache']
Performance,"/// Only called on function definitions; if there is a MSVC #pragma optimize; /// in scope, consider changing the function's attributes based on the; /// optimization list passed to the pragma.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:68,optimiz,optimize,68,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['optimiz'],"['optimization', 'optimize']"
Performance,/// OpcodeOffset - This is a cache used to dispatch efficiently into isel; /// state machines that start with a OPC_SwitchOpcode node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:29,cache,cache,29,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,1,['cache'],['cache']
Performance,"/// Open a file with `name` for reading and writing. Fail (return an invalid; /// `RFilePtr`) if a file with this name already exists.; ///; /// \note: Synchronizes multi-threaded accesses through locks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:165,multi-thread,multi-threaded,165,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['multi-thread'],['multi-threaded']
Performance,"/// Open a file with `name` for reading and writing. If a file with this name; /// already exists, delete it and create a new one. Else simply create a new file.; ///; /// \note: Synchronizes multi-threaded accesses through locks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:192,multi-thread,multi-threaded,192,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['multi-thread'],['multi-threaded']
Performance,"/// Open an existing file with `name` for reading and writing. If a file with; /// that name does not exist, an invalid RFilePtr will be returned.; ///; /// \note: Synchronizes multi-threaded accesses through locks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:177,multi-thread,multi-threaded,177,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['multi-thread'],['multi-threaded']
Performance,"/// OpenACC 3.3, section 2.10:; /// In C and C++, the syntax of the cache directive is:; ///; /// #pragma acc cache ([readonly:]var-list) new-line",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:68,cache,cache,68,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,2,['cache'],['cache']
Performance,"/// OpenACC 3.3, section 2.16:; /// In this section and throughout the specification, the term wait-argument; /// means:; /// [ devnum : int-expr : ] [ queues : ] async-argument-list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:152,queue,queues,152,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['queue'],['queues']
Performance,"/// OpenCL C v2.0, s6.13.17 - Enqueue kernel function contains four different; /// overload formats specified in Table 6.13.17.1.; /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(void)); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// void (^block)(local void*, ...),; /// uint size0, ...); /// int enqueue_kernel(queue_t queue,; /// kernel_enqueue_flags_t flags,; /// const ndrange_t ndrange,; /// uint num_events_in_wait_list,; /// clk_event_t *event_wait_list,; /// clk_event_t *event_ret,; /// void (^block)(local void*, ...),; /// uint size0, ...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:162,queue,queue,162,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,4,['queue'],['queue']
Performance,/// OpenMP-specific information cache. Also Used for Attributor runs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:32,cache,cache,32,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['cache'],['cache']
Performance,"/// Operates at the function-scope. I.e., optimizations are applied local to; /// the functions themselves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp:42,optimiz,optimizations,42,interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,1,['optimiz'],['optimizations']
Performance,/// Optimization Remark Emitter used to emit diagnostic remarks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:4,Optimiz,Optimization,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,1,['Optimiz'],['Optimization']
Performance,/// Optimization mode of the pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h:4,Optimiz,Optimization,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/RegBankSelect.h,1,['Optimiz'],['Optimization']
Performance,/// Optimization remark emitter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:4,Optimiz,Optimization,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,1,['Optimiz'],['Optimization']
Performance,/// Optimization remark with an optional regular expression pattern.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h:4,Optimiz,Optimization,4,interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/CodeGenOptions.h,1,['Optimiz'],['Optimization']
Performance,/// Optimization remarks file path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:4,Optimiz,Optimization,4,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['Optimiz'],['Optimization']
Performance,/// Optimization remarks pass filter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:4,Optimiz,Optimization,4,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['Optimiz'],['Optimization']
Performance,"/// OptimizationGoals - Maintain a combined optimization goal for all; /// functions in a module: one of Tag_ABI_optimization_goals values,; /// -1 if uninitialized, 0 if conflicting goals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.h:4,Optimiz,OptimizationGoals,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMAsmPrinter.h,2,"['Optimiz', 'optimiz']","['OptimizationGoals', 'optimization']"
Performance,"/// OptimizationRemarkEmitter legacy analysis pass; ///; /// Note that this pass shouldn't generally be marked as preserved by other; /// passes. It's holding onto BFI, so if the pass does not preserve BFI, BFI; /// could be freed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:4,Optimiz,OptimizationRemarkEmitter,4,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,1,['Optimiz'],['OptimizationRemarkEmitter']
Performance,/// Optimizations after all the reg selections and spills are done.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:4,Optimiz,Optimizations,4,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['Optimiz'],['Optimizations']
Performance,/// Optimize (cond ? x : x) -> x,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['Optimiz'],['Optimize']
Performance,"/// Optimize (fcmp)&(fcmp) or (fcmp)|(fcmp).; /// NOTE: Unlike most of instcombine, this returns a Value which should; /// already be inserted into the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,1,['Optimiz'],['Optimize']
Performance,/// Optimize (x op x) -> x,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['Optimiz'],['Optimize']
Performance,"/// Optimize X86ISD::CMOV [LHS, RHS, CONDCODE (e.g. X86::COND_NE), CONDVAL]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Optimiz'],['Optimize']
Performance,/// Optimize \p Plan based on \p BestVF and \p BestUF. This may restrict the; /// resulting plan to \p BestVF and \p BestUF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,1,['Optimiz'],['Optimize']
Performance,"/// Optimize \param OldBase and \param OldOffset selecting the best addressing; /// mode. Returns a tuple consisting of an Opcode, an SDValue representing the; /// new Base and an SDValue representing the new offset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['Optimiz'],['Optimize']
Performance,"/// Optimize a CCR definition used according to the condition code \p CC into; /// a simpler CCR value, potentially returning a new \p CC and replacing uses; /// of chain values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['Optimiz'],['Optimize']
Performance,/// Optimize a select instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['Optimiz'],['Optimize']
Performance,"/// Optimize a series of operands to an 'add' instruction. This; /// optimizes based on identities. If it can be reduced to a single Value, it; /// is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,"['Optimiz', 'optimiz']","['Optimize', 'optimizes']"
Performance,"/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.; /// This optimizes based on identities. If it can be reduced to a single Value,; /// it is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,"['Optimiz', 'optimiz']","['Optimize', 'optimizes']"
Performance,"/// Optimize a series of operands to an 'xor' instruction. If it can be reduced; /// to a single Value, it is returned, otherwise the Ops list is mutated as; /// necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['Optimiz'],['Optimize']
Performance,/// Optimize a vector shift instruction and its operand if shifted out; /// bits are not used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Optimiz'],['Optimize']
Performance,"/// Optimize an EFLAGS definition used according to the condition code \p CC; /// into a simpler EFLAGS value, potentially returning a new \p CC and replacing; /// uses of chain values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Optimiz'],['Optimize']
Performance,"/// Optimize an individual call, optionally passing the; /// GetArgRCIdentityRoot if it has already been computed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['Optimiz'],['Optimize']
Performance,/// Optimize branch condition evaluation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Optimiz'],['Optimize']
Performance,"/// Optimize copy-like instructions to create; /// register coalescer friendly instruction.; /// The optimization tries to kill-off the \p MI by looking; /// through a chain of copies to find a source that has a compatible; /// register class.; /// If such a source is found, it replace \p MI by a generic COPY; /// operation.; /// \pre isUncoalescableCopy(*MI) is true.; /// \return True, when \p MI has been optimized. In that case, \p MI has; /// been removed from its parent.; /// All COPY instructions created, are inserted in \p LocalMIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,3,"['Optimiz', 'optimiz']","['Optimize', 'optimization', 'optimized']"
Performance,/// Optimize expensive TLS variables in the given function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,1,['Optimiz'],['Optimize']
Performance,/// Optimize expensive integer constants in the given function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,1,['Optimiz'],['Optimize']
Performance,/// Optimize fabs(X) compared with zero.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Optimiz'],['Optimize']
Performance,"/// Optimize for fast execution as much as possible without triggering; /// significant incremental compile time or code size growth.; ///; /// The key idea is that optimizations at this level should ""pay for; /// themselves"". So if an optimization increases compile time by 5% or; /// increases code size by 5% for a particular benchmark, that benchmark; /// should also be one which sees a 5% runtime improvement. If the compile; /// time or code size penalties happen on average across a diverse range of; /// LLVM users' benchmarks, then the improvements should as well.; ///; /// And no matter what, the compile time needs to not grow superlinearly; /// with the size of input to LLVM so that users can control the runtime of; /// the optimizer in this mode.; ///; /// This is expected to be a good default optimization level for the vast; /// majority of users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,5,"['Optimiz', 'optimiz']","['Optimize', 'optimization', 'optimizations', 'optimizer']"
Performance,"/// Optimize for fast execution as much as possible.; ///; /// This mode is significantly more aggressive in trading off compile time; /// and code size to get execution time improvements. The core idea is that; /// this mode should include any optimization that helps execution time on; /// balance across a diverse collection of benchmarks, even if it increases; /// code size or compile time for some benchmarks without corresponding; /// improvements to execution time.; ///; /// Despite being willing to trade more compile time off to get improved; /// execution time, this mode still tries to avoid superlinear growth in; /// order to make even significantly slower compile times at least scale; /// reasonably. This does not preclude very substantial constant factor; /// costs though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,2,"['Optimiz', 'optimiz']","['Optimize', 'optimization']"
Performance,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,4,"['Optimiz', 'optimiz']","['Optimize', 'optimization']"
Performance,/// Optimize globals that never have their address taken.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalOpt.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalOpt.h,1,['Optimiz'],['Optimize']
Performance,"/// Optimize memcpy intrinsics et al, e.g. constant len calls.; /// /p MaxLen if non-zero specifies the max length of a mem libcall to inline.; ///; /// For example (pre-indexed):; ///; /// $addr = G_PTR_ADD $base, $offset; /// [...]; /// $val = G_LOAD $addr; /// [...]; /// $whatever = COPY $addr; ///; /// -->; ///; /// $val, $addr = G_INDEXED_LOAD $base, $offset, 1 (IsPre); /// [...]; /// $whatever = COPY $addr; ///; /// or (post-indexed):; ///; /// G_STORE $val, $base; /// [...]; /// $addr = G_PTR_ADD $base, $offset; /// [...]; /// $whatever = COPY $addr; ///; /// -->; ///; /// $addr = G_INDEXED_STORE $val, $base, $offset; /// [...]; /// $whatever = COPY $addr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CombinerHelper.h,1,['Optimiz'],['Optimize']
Performance,/// Optimize merged modules using various IPO passes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOCodeGenerator.cpp,1,['Optimiz'],['Optimize']
Performance,"/// Optimize pointer differences into the same array into a size. Consider:; /// &A[10] - &A[0]: we should compile this to ""10"". LHS/RHS are the pointer; /// operands to the ptrtoint instructions for the LHS/RHS of the subtract.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['Optimiz'],['Optimize']
Performance,"/// Optimize quickly without destroying debuggability.; ///; /// This level is tuned to produce a result from the optimizer as quickly; /// as possible and to avoid destroying debuggability. This tends to result; /// in a very good development mode where the compiled code will be; /// immediately executed as part of testing. As a consequence, where; /// possible, we would like to produce efficient-to-execute code, but not; /// if it significantly slows down compilation or would prevent even basic; /// debugging of the resulting binary.; ///; /// As an example, complex loop transformations such as versioning,; /// vectorization, or fusion don't make sense here due to the degree to; /// which the executed code differs from the source code, and the compile; /// time cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,3,"['Optimiz', 'optimiz', 'tune']","['Optimize', 'optimizer', 'tuned']"
Performance,/// Optimize scalar/vector interactions in IR using target cost models.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/VectorCombine.h,1,['Optimiz'],['Optimize']
Performance,/// Optimize selects of i1 if one of the operands has a 'true' or 'false'; /// value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['Optimiz'],['Optimize']
Performance,"/// Optimize sext(a)+sext(b) to sext(a+b) when a+b can't sign overflow.; /// SeparateConstOffsetFromGEP distributes a sext to leaves before extracting; /// the constant offset. After extraction, it becomes desirable to reunion the; /// distributed sexts. For example,; ///; /// &a[sext(i +nsw (j +nsw 5)]; /// => distribute &a[sext(i) +nsw (sext(j) +nsw 5)]; /// => constant extraction &a[sext(i) + sext(j)] + 5; /// => reunion &a[sext(i +nsw j)] + 5",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,1,['Optimiz'],['Optimize']
Performance,"/// Optimize the GOT and Stub relocations if the edge target address is in range; /// 1. PCRel32GOTLoadRelaxable. For this edge kind, if the target is in range,; /// then replace GOT load with lea. (THIS IS UNIMPLEMENTED RIGHT NOW!); /// 2. BranchPCRel32ToPtrJumpStubRelaxable. For this edge kind, if the target is; /// in range, replace a indirect jump by plt stub with a direct jump to the; /// target",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/i386.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/i386.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/i386.h,2,"['Optimiz', 'load']","['Optimize', 'load']"
Performance,"/// Optimize the GOT and Stub relocations if the edge target address is in range; /// 1. PCRel32GOTLoadRelaxable. For this edge kind, if the target is in range,; /// then replace GOT load with lea; /// 2. BranchPCRel32ToPtrJumpStubRelaxable. For this edge kind, if the target is; /// in range, replace a indirect jump by plt stub with a direct jump to the; /// target",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/x86_64.h,2,"['Optimiz', 'load']","['Optimize', 'load']"
Performance,/// Optimize the special case where the operand of \p I is a constant integer; /// induction variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPRecipeBuilder.h,1,['Optimiz'],['Optimize']
Performance,/// Optimize this function for minimum size (-Oz).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['Optimiz'],['Optimize']
Performance,/// Optimize this function for size (-Os) or minimum size (-Oz).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['Optimiz'],['Optimize']
Performance,/// Optimize uses to point to their actual clobbering definitions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:4,Optimiz,Optimize,4,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['Optimiz'],['Optimize']
Performance,/// OptimizeBB - Remove dead PHI cycles and PHI cycles that can be replaced by; /// a single value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp:4,Optimiz,OptimizeBB,4,interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/OptimizePHIs.cpp,1,['Optimiz'],['OptimizeBB']
Performance,/// OptimizeConstants - Reorder constant pool for denser encoding.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:4,Optimiz,OptimizeConstants,4,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,1,['Optimiz'],['OptimizeConstants']
Performance,/// OptimizePHIs - This pass optimizes machine instruction PHIs; /// to take advantage of opportunities created during DAG legalization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:4,Optimiz,OptimizePHIs,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,2,"['Optimiz', 'optimiz']","['OptimizePHIs', 'optimizes']"
Performance,"/// OptimizeVFPBrcond - With -enable-unsafe-fp-math, it's legal to optimize some; /// f32 and even f64 comparisons to integer ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Optimiz,OptimizeVFPBrcond,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,"['Optimiz', 'optimiz']","['OptimizeVFPBrcond', 'optimize']"
Performance,"/// Optimized method to evaluate at the same time the function value and derivative at a point x.; /// Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; /// Derived class should implement this method if performances play an important role and if it is faster to; /// evaluate value and derivative at the same time",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h:4,Optimiz,Optimized,4,math/mathcore/inc/Math/IFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance,"/// Optimized method to evaluate at the same time the function value and derivative at a point x.; /// Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; /// Derived class should implement this method if performances play an important role and if it is faster to; /// evaluate value and derivative at the same time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h:4,Optimiz,Optimized,4,math/mathcore/inc/Math/IFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IFunction.h,2,"['Optimiz', 'perform']","['Optimized', 'performances']"
Performance,/// Optimizes the merged module. Returns true on success.; ///; /// Calls \a verifyMergedModuleOnce().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h:4,Optimiz,Optimizes,4,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,1,['Optimiz'],['Optimizes']
Performance,/// Optional TargetInstrInfo used to perform some complex tracking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:37,perform,perform,37,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['perform'],['perform']
Performance,/// Optional extension of isLoadFromStackSlot that returns the number of; /// bytes loaded from the stack. This must be implemented if a backend; /// supports partial stack slot spills/loads to further disambiguate; /// what the load does.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:84,load,loaded,84,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,3,['load'],"['load', 'loaded', 'loads']"
Performance,/// Optional extension of isStoreToStackSlot that returns the number of; /// bytes stored to the stack. This must be implemented if a backend; /// supports partial stack slot spills/loads to further disambiguate; /// what the store does.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:182,load,loads,182,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['load'],['loads']
Performance,"/// Optional list of allocation memprof metadata summaries. The correspondence; /// between the alloc memprof summary and the allocation callsites in the; /// function is implied by the order in the vector (and can be validated by; /// comparing the stack ids in the AllocInfo to those in the instruction; /// memprof metadata).; /// As a memory savings optimization, we only create these for the prevailing; /// copy of a symbol when creating the combined index during LTO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:354,optimiz,optimization,354,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['optimiz'],['optimization']
Performance,"/// Optional list of memprof callsite metadata summaries. The correspondence; /// between the callsite summary and the callsites in the function is implied; /// by the order in the vector (and can be validated by comparing the stack; /// ids in the CallsiteInfo to those in the instruction callsite metadata).; /// As a memory savings optimization, we only create these for the prevailing; /// copy of a symbol when creating the combined index during LTO.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:335,optimiz,optimization,335,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['optimiz'],['optimization']
Performance,"/// Optional owned invocation, just used to make the invocation used in; /// LoadFromCommandLine available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:77,Load,LoadFromCommandLine,77,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['Load'],['LoadFromCommandLine']
Performance,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when Attribute::OptimizeNone is set or when; /// optimization bisect is over the limit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:122,Optimiz,OptimizeNone,122,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,4,"['Optimiz', 'optimiz']","['OptimizeNone', 'optimization']"
Performance,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when optimization bisect is over the limit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:111,optimiz,optimization,111,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,3,['optimiz'],['optimization']
Performance,/// Order of operands to transfer; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:77,optimiz,optimizations,77,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['optimiz'],['optimizations']
Performance,"/// Our algorithm for walking (and trying to optimize) clobbers, all wrapped up; /// in one class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:45,optimiz,optimize,45,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['optimiz'],['optimize']
Performance,"/// Our current alias analysis API differentiates heavily between calls and; /// non-calls, and functions called on one usually assert on the other.; /// This class encapsulates the distinction to simplify other code that wants; /// ""Memory affecting instructions and related data"" to use as a key.; /// For example, this class is used as a densemap key in the use optimizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:365,optimiz,optimizer,365,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['optimiz'],['optimizer']
Performance,/// Output dependency latency of a pair of defs of the same register.; ///; /// This is typically one cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:22,latency,latency,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,1,['latency'],['latency']
Performance,/// Output the remark via the diagnostic handler and to the; /// optimization record file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:65,optimiz,optimization,65,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,1,['optimiz'],['optimization']
Performance,/// OverloadingResult - Capture the result of performing overload; /// resolution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h:46,perform,performing,46,interpreter/llvm-project/clang/include/clang/Sema/Overload.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Overload.h,1,['perform'],['performing']
Performance,/// Override to support customized stack guard loading.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:47,load,loading,47,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,3,['load'],['loading']
Performance,/// Overrides the optimization level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h:18,optimiz,optimization,18,interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,1,['optimiz'],['optimization']
Performance,"/// Owner of all mca::Instruction instances. Note that we use std::deque here; /// to have a better throughput, in comparison to std::vector or; /// llvm::SmallVector, as they usually pay a higher re-allocation cost when; /// there is a large number of instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/IncrementalSourceMgr.h:100,throughput,throughput,100,interpreter/llvm-project/llvm/include/llvm/MCA/IncrementalSourceMgr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/IncrementalSourceMgr.h,1,['throughput'],['throughput']
Performance,/// PD - Prefix code for packed double precision vector floating point; /// operations performed in the SSE registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:87,perform,performed,87,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,1,['perform'],['performed']
Performance,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:61,load,loaded,61,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,8,['load'],"['load', 'loaded', 'loads']"
Performance,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:282,perform,performance,282,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,2,"['load', 'perform']","['loading', 'performance']"
Performance,"/// PREFETCH - This corresponds to a prefetch intrinsic. The first operand; /// is the chain. The other operands are the address to prefetch,; /// read / write specifier, locality specifier and instruction / data cache; /// specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:213,cache,cache,213,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['cache'],['cache']
Performance,"/// Pad the latency between neighboring MFMA instructions with s_nops. The; /// percentage of wait states to fill with s_nops is specified by the command; /// line option '-amdgpu-mfma-padding-ratio'.; ///; /// For example, with '-amdgpu-mfma-padding-ratio=100':; ///; /// 2 pass MFMA instructions have a latency of 2 wait states. Therefore, a; /// 'S_NOP 1' will be added between sequential MFMA instructions.; ///; /// V_MFMA_F32_4X4X1F32; /// V_MFMA_F32_4X4X1F32; ///-->; /// V_MFMA_F32_4X4X1F32; /// S_NOP 1; /// V_MFMA_F32_4X4X1F32",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h:12,latency,latency,12,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h,2,['latency'],['latency']
Performance,"/// Pages that have been already sealed by a concurrent task. A vector commit can be issued if all; /// buffered pages have been sealed.; /// Note that each RSealedPage refers to the same buffer as `fBufferedPages[i].fBuf` for some value of `i`, and; /// thus owned by RPageZipItem",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx:45,concurren,concurrent,45,tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,1,['concurren'],['concurrent']
Performance,"/// Parallel decompression and unpacking of the pages in the given cluster. The unzipped pages are supposed; /// to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's; /// unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the; /// actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set; /// if implicit multi-threading is turned on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:251,optimiz,optimization,251,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,2,"['multi-thread', 'optimiz']","['multi-threading', 'optimization']"
Performance,/// Parameter that limit the performed exploration. See the constructor for; /// their meaning.; ///{,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:29,perform,performed,29,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['perform'],['performed']
Performance,"/// Parameters (see the expansion example below):; /// (the builder, %addr, %loaded, %new_val, ordering,; /// /* OUT */ %success, /* OUT */ %new_loaded)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:77,load,loaded,77,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,1,['load'],['loaded']
Performance,/// Parse \p C as a single digit integer and get matching \c CodeGenLevel.; ///; /// Returns std::nullopt if the input is not a valid optimization level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CodeGen.h:134,optimiz,optimization,134,interpreter/llvm-project/llvm/include/llvm/Support/CodeGen.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CodeGen.h,1,['optimiz'],['optimization']
Performance,/// Parse and perform semantic analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h:14,perform,perform,14,interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendOptions.h,1,['perform'],['perform']
Performance,"/// Parse metadata from the module; // FIXME: it only parses ""llvm.linker.options"" metadata at the moment; // FIXME: can't access metadata in lazily loaded modules",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOModule.h:149,load,loaded,149,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOModule.h,1,['load'],['loaded']
Performance,"/// Parse the given module map file, and record any modules we; /// encounter.; ///; /// \param File The file to be parsed.; ///; /// \param IsSystem Whether this module map file is in a system header; /// directory, and therefore should be considered a system module.; ///; /// \param HomeDir The directory in which relative paths within this module; /// map file will be resolved.; ///; /// \param ID The FileID of the file to process, if we've already entered it.; ///; /// \param Offset [inout] On input the offset at which to start parsing. On; /// output, the offset at which the module map terminated.; ///; /// \param ExternModuleLoc The location of the ""extern module"" declaration; /// that caused us to load this module map file, if any.; ///; /// \returns true if an error occurred, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:713,load,load,713,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['load'],['load']
Performance,"/// Parse the given string as a cache pruning policy. Defaults are taken from a; /// default constructed CachePruningPolicy object.; /// For example: ""prune_interval=30s:prune_after=24h:cache_size=50%""; /// which means a pruning interval of 30 seconds, expiration time of 24 hours; /// and maximum cache size of 50% of available disk space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:32,cache,cache,32,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,3,"['Cache', 'cache']","['CachePruningPolicy', 'cache']"
Performance,/// Parse the next token and pop it from the queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:45,queue,queue,45,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['queue'],['queue']
Performance,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:175,perform,performs,175,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['perform'],['performs']
Performance,/// Parses the command line options into the LinkOptions struct and performs; /// some sanity checking. Returns an error in case the latter fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:68,perform,performs,68,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,1,['perform'],['performs']
Performance,/// Parses the variable list for the `cache` construct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:38,cache,cache,38,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['cache'],['cache']
Performance,"/// Part of the global at a specific offset, which is only accessed through; /// loads and stores with the given type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:81,load,loads,81,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['load'],['loads']
Performance,"/// Partially unroll a loop.; ///; /// The CanonicalLoopInfo of the unrolled loop for use with chained; /// loop-associated directive can be requested using \p UnrolledCLI. Not; /// needing the CanonicalLoopInfo allows more efficient code generation by; /// deferring the actual unrolling to the LoopUnrollPass using loop metadata.; /// A loop-associated directive applied to the unrolled loop needs to know the; /// new trip count which means that if using a heuristically determined unroll; /// factor (\p Factor == 0), that factor must be computed immediately. We are; /// using the same logic as the LoopUnrollPass to derived the unroll factor,; /// but which assumes that some canonicalization has taken place (e.g.; /// Mem2Reg, LICM, GVN, Inlining, etc.). That is, the heuristic will perform; /// better when the unrolled loop's CanonicalLoopInfo is not needed.; ///; /// \param DL Debug location for instructions added by unrolling.; /// \param Loop The loop to unroll. The loop will be invalidated.; /// \param Factor The factor to unroll the loop by. A factor of 0; /// indicates that a heuristic should be used to determine; /// the unroll-factor.; /// \param UnrolledCLI If non-null, receives the CanonicalLoopInfo of the; /// partially unrolled loop. Otherwise, uses loop metadata; /// to defer unrolling to the LoopUnrollPass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:791,perform,perform,791,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['perform'],['perform']
Performance,/// Participating load instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:18,load,load,18,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['load'],['load']
Performance,/// Partition store/load instructions in the loop nest into reference groups.; /// Two or more memory accesses belong in the same reference group if they; /// share the same cache line.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:20,load,load,20,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,2,"['cache', 'load']","['cache', 'load']"
Performance,/// Pass embeds a copy of the module optimized with the provided pass pipeline; /// into a global variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/EmbedBitcodePass.h:37,optimiz,optimized,37,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/EmbedBitcodePass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/EmbedBitcodePass.h,1,['optimiz'],['optimized']
Performance,"/// Pass options to the driver and optimization passes.; ///; /// These options are not necessarily for debugging purpose (the function; /// name is misleading). This function should be called before; /// LTOCodeGenerator::compilexxx(), and; /// LTOCodeGenerator::writeMergedModules().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h:35,optimiz,optimization,35,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/LTOCodeGenerator.h,1,['optimiz'],['optimization']
Performance,/// Pass to forward loads in a loop around the backedge to subsequent; /// iterations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h:20,load,loads,20,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopLoadElimination.h,1,['load'],['loads']
Performance,/// Pass to perform interprocedural constant propagation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h:12,perform,perform,12,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/SCCP.h,1,['perform'],['perform']
Performance,/// Pass to perform split of global variables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalSplit.h:12,perform,perform,12,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalSplit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalSplit.h,1,['perform'],['perform']
Performance,/// Pass to replace calls to ifuncs with indirect calls. This could be used to; /// support ifunc on systems where the program loader does not natively support; /// it. Constant initializer uses of ifuncs are not handled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerIFunc.h:127,load,loader,127,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerIFunc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LowerIFunc.h,1,['load'],['loader']
Performance,"/// Path - The sequence of base classes, fields and array indices to follow to; /// walk from Base to the subobject. When performing GCC-style folding, there; /// may not be such a path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp:122,perform,performing,122,interpreter/llvm-project/clang/lib/AST/APValue.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/APValue.cpp,1,['perform'],['performing']
Performance,"/// Peel off the first \p PeelCount iterations of loop \p L.; ///; /// Note that this does not peel them off as a single straight-line block.; /// Rather, each iteration is peeled off separately, and needs to check the; /// exit condition.; /// For loops that dynamically execute \p PeelCount iterations or less; /// this provides a benefit, since the peeled off iterations, which account; /// for the bulk of dynamic execution, can be further simplified by scalar; /// optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:470,optimiz,optimizations,470,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,1,['optimiz'],['optimizations']
Performance,/// PeepholeOptimizer - This pass performs peephole optimizations -; /// like extension and comparison eliminations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:34,perform,performs,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,2,"['optimiz', 'perform']","['optimizations', 'performs']"
Performance,"/// Peform pruning using the supplied policy, returns true if pruning; /// occurred, i.e. if Policy.Interval was expired.; ///; /// Check whether cache pruning happens using the supplied policy, adds a; /// ThinLTO warning if cache_size_bytes or cache_size_files is too small for the; /// current link job. The warning recommends the user to consider adjusting; /// --thinlto-cache-policy.; ///; /// As a safeguard against data loss if the user specifies the wrong directory; /// as their cache directory, this function will ignore files not matching the; /// pattern ""llvmcache-*"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:146,cache,cache,146,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,3,['cache'],"['cache', 'cache-policy']"
Performance,/// Pending queues extend the ready queues with the same ID and the; /// PendingFlag set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:12,queue,queues,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,4,['queue'],['queues']
Performance,"/// PendingQueue - This contains all of the instructions whose operands have; /// been issued, but their results are not ready yet (due to the latency of; /// the operation). Once the operands become available, the instruction is; /// added to the AvailableQueue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:143,latency,latency,143,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,1,['latency'],['latency']
Performance,"/// PendingQueue - This contains all of the instructions whose operands have; /// been issued, but their results are not ready yet (due to the latency of; /// the operation). Once the operands becomes available, the instruction is; /// added to the AvailableQueue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:143,latency,latency,143,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['latency'],['latency']
Performance,"/// Perform ""replace all uses with"" operations. These work items need to be; /// performed as part of materialization, but we postpone them to happen after; /// materialization is done. The materializer called by ValueMapper is not; /// expected to delete constants, as ValueMapper is holding pointers to some; /// of them, but constant destruction may be indirectly triggered by RAUW.; /// Hence, the need to move this out of the materialization call chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,2,"['Perform', 'perform']","['Perform', 'performed']"
Performance,"/// Perform ABI-specific ""this"" argument adjustment required prior to; /// a call of a virtual function.; /// The ""VirtualCall"" argument is true iff the call itself is virtual.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,1,['Perform'],['Perform']
Performance,/// Perform Bitcast legalize action on G_EXTRACT_VECTOR_ELT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,1,['Perform'],['Perform']
Performance,/// Perform Bitcast legalize action on G_INSERT_VECTOR_ELT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,1,['Perform'],['Perform']
Performance,/// Perform CodeGen only: disable all other stages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['Perform'],['Perform']
Performance,/// Perform DFS through the structure/class data members trying to find; /// member(s) with user-defined 'default' mapper and generate implicit map; /// clauses for such members with the found 'default' mapper.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['Perform'],['Perform']
Performance,/// Perform IV widening during the pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/IndVarSimplify.h,1,['Perform'],['Perform']
Performance,/// Perform LICM and CSE on the newly generated gather sequences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['Perform'],['Perform']
Performance,"/// Perform ODR-like check for C/ObjC when merging tag types from modules.; /// Differently from C++, actually parse the body and reject / error out; /// in case of a structural mismatch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Perform'],['Perform']
Performance,/// Perform TruncInst pattern optimization on given function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombineInternal.h,2,"['Perform', 'optimiz']","['Perform', 'optimization']"
Performance,"/// Perform a G_EXTRACT_VECTOR_ELT in a different sized vector element. If this; /// is casting to a vector with a smaller element size, perform multiple element; /// extracts and merge the results. If this is coercing to a vector with larger; /// elements, index the bitcasted vector and extract the target element with bit; /// operations. This is intended to force the indexing in the native register; /// size for architectures that can dynamically index the register file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,"/// Perform a G_INSERT_VECTOR_ELT in a different sized vector element. If this; /// is increasing the element size, perform the indexing in the target element; /// type, and use bit operations to insert at the element position. This is; /// intended for architectures that can dynamically index the register file and; /// want to force indexing in the native register size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,"/// Perform a \ref moveBefore operation, while signalling that the caller; /// intends to preserve the original ordering of instructions. This implicitly; /// means that any adjacent debug-info should move with this instruction.; /// This method is currently a no-op placeholder, but it will become meaningful; /// when the ""RemoveDIs"" project is enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['Perform'],['Perform']
Performance,"/// Perform a atomicrmw expansion using a target-specific way. This is; /// expected to be called when masked atomicrmw and bit test atomicrmw don't; /// work, and the target supports another way to lower atomicrmw.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Perform'],['Perform']
Performance,"/// Perform a atomicrmw which the result is only used by comparison, using a; /// target-specific intrinsic. This represents the combined atomic and compare; /// intrinsic which will be lowered at a late stage by the backend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Perform'],['Perform']
Performance,/// Perform a base-to-derived member pointer cast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,/// Perform a bit test atomicrmw using a target-specific intrinsic. This; /// represents the combined bit test intrinsic which will be lowered at a late; /// stage by the backend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Perform'],['Perform']
Performance,"/// Perform a bitcast, derived-to-base, or base-to-derived member pointer; /// conversion.; ///; /// Bitcast conversions are always a no-op under Itanium.; ///; /// Obligatory offset/adjustment diagram:; /// <-- offset --> <-- adjustment -->; /// |--------------------------|----------------------|--------------------|; /// ^Derived address point ^Base address point ^Member address point; ///; /// So when converting a base member pointer to a derived member pointer,; /// we add the offset to the adjustment because the address point has; /// decreased; and conversely, when converting a derived MP to a base MP; /// we subtract the offset from the adjustment because the address point; /// has increased.; ///; /// The standard forbids (at compile time) conversion to and from; /// virtual bases, which is why we don't have to consider them here.; ///; /// The standard forbids (at run time) casting a derived MP to a base; /// MP when the derived MP does not point to a member of the base.; /// This is why -1 is a reasonable choice for null data member; /// pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['Perform'],['Perform']
Performance,/// Perform a call to 'operator new' or to `__builtin_operator_new'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,/// Perform a cast towards the class of the Decl (either up or down the; /// hierarchy).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,/// Perform a compound assignment of LVal <op>= RVal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,/// Perform a contextual implicit conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Perform'],['Perform']
Performance,"/// Perform a control flow join (lattice value meet) of the values in machine; /// locations at \p MBB. Follows the algorithm described in the file-comment,; /// reading live-outs of predecessors from \p OutLocs, the current live ins; /// from \p InLocs, and assigning the newly computed live ins back into; /// \p InLocs. \returns two bools -- the first indicates whether a change; /// was made, the second whether a lattice downgrade occurred. If the latter; /// is true, revisiting this block is necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['Perform'],['Perform']
Performance,/// Perform a conversion adding _Atomic to a type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,/// Perform a copy from the source into the destination.; ///; /// \param type - the type of the aggregate being copied; qualifiers are; /// ignored,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['Perform'],['Perform']
Performance,/// Perform a dependence check and return if @p FC0 and @p FC1 can be fused.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['Perform'],['Perform']
Performance,"/// Perform a dependency query based on pointer/pointeesize starting at the end; /// of StartBB.; ///; /// Add any clobber/def results to the results vector and keep track of which; /// blocks are visited in 'Visited'.; ///; /// This has special behavior for the first block queries (when SkipFirstBlock; /// is true). In this special case, it ignores the contents of the specified; /// block and starts returning dependence info for its predecessors.; ///; /// This function returns true on success, or false to indicate that it could; /// not compute dependence information for some reason. This should be treated; /// as a clobber dependence on the first instruction in the predecessor block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['Perform'],['Perform']
Performance,"/// Perform a derived-to-base cast, producing an lvalue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,"/// Perform a derived-to-base cast, producing an rvalue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,"/// Perform a derived-to-base cast, producing an xvalue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,/// Perform a derived-to-base member pointer cast.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,"/// Perform a derived-to-base, base-to-derived, or bitcast member; /// pointer conversion on a constant value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,1,['Perform'],['Perform']
Performance,"/// Perform a derived-to-base, base-to-derived, or bitcast member; /// pointer conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.h,1,['Perform'],['Perform']
Performance,"/// Perform a destructor or pseudo-destructor call on the given object, which; /// might in general not be a complete object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['Perform'],['Perform']
Performance,"/// Perform a full dependency query for the specified call, returning the set; /// of blocks that the value is potentially live across.; ///; /// The returned set of results will include a ""NonLocal"" result for all; /// blocks where the value is live across.; ///; /// This method assumes the instruction returns a ""NonLocal"" dependency; /// within its own block.; ///; /// This returns a reference to an internal data structure that may be; /// invalidated on the next non-local query or when an instruction is; /// removed. Clients must copy this data if they want it around longer than; /// that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['Perform'],['Perform']
Performance,"/// Perform a function reference conversion, see [dcl.init.ref]p4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,/// Perform a load to a temporary register,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.h,2,"['Perform', 'load']","['Perform', 'load']"
Performance,"/// Perform a load-linked operation on Addr, returning a ""Value *"" with the; /// corresponding pointee type. This may entail some non-trivial operations to; /// truncate or reconstruct types that will be illegal in the backend. See; /// ARMISelLowering for an example implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,"['Perform', 'load']","['Perform', 'load-linked']"
Performance,"/// Perform a local numbering on blocks so that instruction ordering can be; /// determined in constant time.; /// TODO: We currently just number in order. If we numbered by N, we could; /// allow at least N-1 sequences of insertBefore or insertAfter (and at least; /// log2(N) sequences of mixed before and after) without needing to invalidate; /// the numbering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['Perform'],['Perform']
Performance,"/// Perform a logical left shift of \p Count words by moving everything; /// \p Count words to the right in memory.; ///; /// While confusing, words are stored from least significant at Bits[0] to; /// most significant at Bits[NumWords-1]. A logical shift left, however,; /// moves the current least significant bit to a higher logical index, and; /// fills the previous least significant bits with 0. Thus, we actually; /// need to move the bytes of the memory to the right, not to the left.; /// Example:; /// Words = [0xBBBBAAAA, 0xDDDDFFFF, 0x00000000, 0xDDDD0000]; /// represents a BitVector where 0xBBBBAAAA contain the least significant; /// bits. So if we want to shift the BitVector left by 2 words, we need; /// to turn this into 0x00000000 0x00000000 0xBBBBAAAA 0xDDDDFFFF by using a; /// memmove which moves right, not left.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,1,['Perform'],['Perform']
Performance,/// Perform a logical right shift of \p Count words by moving those; /// words to the left in memory. See wordShl for more information.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/BitVector.h,1,['Perform'],['Perform']
Performance,/// Perform a masked atomicrmw using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,"['Perform', 'load']","['Perform', 'loaded']"
Performance,/// Perform a masked cmpxchg using a target-specific intrinsic. This; /// represents the core LL/SC loop which will be lowered at a late stage by; /// the backend. The target-specific intrinsic returns the loaded value and; /// is not responsible for masking and shifting the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,"['Perform', 'load']","['Perform', 'loaded']"
Performance,/// Perform a merge of all the stores in \p Stores into a single store.; /// Erases the old stores from the block when finished.; /// \returns true if merging was done. It may fail to perform a merge if; /// there are issues with materializing legal wide values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,/// Perform a null-check of the given receiver.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Perform'],['Perform']
Performance,/// Perform a purely local form of PRE that looks for diamond; /// control flow patterns and attempts to perform simple PRE at the join point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,"/// Perform a qualification conversion, producing a prvalue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,"/// Perform a qualification conversion, producing an lvalue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,"/// Perform a qualification conversion, producing an xvalue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,/// Perform a search starting at the given class.; ///; /// PrivateDepth is the index of the last (least derived) class; /// along the current path such that a notional public member of; /// the final class in the path would have access in that class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['Perform'],['Perform']
Performance,/// Perform a signed saturating addition of two constant ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,1,['Perform'],['Perform']
Performance,/// Perform a signed saturating left shift of this constant range by a; /// value in \p Other.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,1,['Perform'],['Perform']
Performance,/// Perform a signed saturating multiplication of two constant ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,1,['Perform'],['Perform']
Performance,/// Perform a signed saturating subtraction of two constant ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,1,['Perform'],['Perform']
Performance,"/// Perform a single iteration of the loop for checking if a qualification; /// conversion is valid.; ///; /// Specifically, check whether any change between the qualifiers of \p; /// FromType and \p ToType is permissible, given knowledge about whether every; /// outer layer is const-qualified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['Perform'],['Perform']
Performance,"/// Perform a store-conditional operation to Addr. Return the status of the; /// store. This should be 0 if the store succeeded, non-zero otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['Perform'],['Perform']
Performance,"/// Perform a trivial copy from Param, which is the parameter of a copy or move; /// constructor or assignment operator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,"/// Perform a unary negation (-X) on this fixed point type, taking into; /// account saturation if applicable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h,1,['Perform'],['Perform']
Performance,"/// Perform a user-defined conversion, either via a conversion; /// function or via a constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,"/// Perform a zero-allocation check.; ///; /// \param [in] Call The expression that allocates memory.; /// \param [in] IndexOfSizeArg Index of the argument that specifies the size; /// of the memory that needs to be allocated. E.g. for malloc, this would be; /// 0.; /// \param [in] RetVal Specifies the newly allocated pointer value;; /// if unspecified, the value of expression \p E is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['Perform'],['Perform']
Performance,/// Perform access-control checking on a previously-unresolved member; /// access which has now been resolved to a member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['Perform'],['Perform']
Performance,/// Perform addition/subtraction of a pointer and an integer or; /// subtraction of two pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Interp/ByteCodeExprGen.cpp,1,['Perform'],['Perform']
Performance,/// Perform address space cast of a constant expression of pointer type.; /// \param V is the LLVM constant to be casted to another address space.; /// \param SrcAddr is the language address space of \p V.; /// \param DestAddr is the targeted language address space.; /// \param DestTy is the destination LLVM pointer type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,1,['Perform'],['Perform']
Performance,/// Perform address space cast of an expression of pointer type.; /// \param V is the LLVM value to be casted to another address space.; /// \param SrcAddr is the language address space of \p V.; /// \param DestAddr is the targeted language address space.; /// \param DestTy is the destination LLVM pointer type.; /// \param IsNonNull is the flag indicating \p V is known to be non null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,1,['Perform'],['Perform']
Performance,"/// Perform adjustment on the parameter type of a function.; ///; /// This routine adjusts the given parameter type @p T to the actual; /// parameter type used by semantic analysis (C99 6.7.5.3p[7,8],; /// C++ [dcl.fct]p3). The adjusted parameter type is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['Perform'],['Perform']
Performance,"/// Perform all actions needed to make the code owned by this RuntimeDyld; /// instance executable:; ///; /// 1) Apply relocations.; /// 2) Register EH frames.; /// 3) Update memory permissions*.; ///; /// * Finalization is potentially recursive**, and the 3rd step will only be; /// applied by the outermost call to finalize. This allows different; /// RuntimeDyld instances to share a memory manager without the innermost; /// finalization locking the memory and causing relocation fixup errors in; /// outer instances.; ///; /// ** Recursive finalization occurs when one RuntimeDyld instances needs the; /// address of a symbol owned by some other instance in order to apply; /// relocations.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['Perform'],['Perform']
Performance,"/// Perform all the necessary updates, including new PHI-nodes insertion and the; /// requested uses update.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,1,['Perform'],['Perform']
Performance,"/// Perform all the necessary updates, including new PHI-nodes insertion and; /// the requested uses update.; ///; /// The function requires dominator tree DT, which is used for computing; /// locations for new phi-nodes insertions. If a nonnull pointer to a vector; /// InsertedPHIs is passed, all the new phi-nodes will be added to this; /// vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdaterBulk.h,1,['Perform'],['Perform']
Performance,/// Perform all the requested attribute inference actions according to the; /// attribute predicates stored before.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['Perform'],['Perform']
Performance,"/// Perform an ""extended"" implicit conversion as returned by; /// TryClassUnification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['Perform'],['Perform']
Performance,/// Perform an MD5 checksum of \p Identifier and return the lower 64 bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,1,['Perform'],['Perform']
Performance,/// Perform an action for an invocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Tooling.h,1,['Perform'],['Perform']
Performance,/// Perform an assignment of Val to LVal. Takes ownership of Val.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,/// Perform an implicit conversion sequence without narrowing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,/// Perform an implicit conversion sequence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,"/// Perform an lvalue-to-rvalue conversion on the given glvalue. This; /// can also be used for 'lvalue-to-lvalue' conversions for looking up the; /// glvalue referred to by an entity of reference type.; ///; /// \param Info - Information about the ongoing evaluation.; /// \param Conv - The expression for which we are performing the conversion.; /// Used for diagnostics.; /// \param Type - The type of the glvalue (before stripping cv-qualifiers in the; /// case of a non-class type).; /// \param LVal - The glvalue on which we are attempting to perform this action.; /// \param RVal - The produced value will be placed here.; /// \param WantObjectRepresentation - If true, we're looking for the object; /// representation rather than the value, and in particular,; /// there is no requirement that the result be fully initialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,3,"['Perform', 'perform']","['Perform', 'perform', 'performing']"
Performance,/// Perform an operation having the following signature:; /// i8* (i8**),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['Perform'],['Perform']
Performance,"/// Perform an operation having the following signature:; /// i8* (i8**, i8*)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['Perform'],['Perform']
Performance,"/// Perform an operation having the following signature:; /// void (i8**, i8**)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['Perform'],['Perform']
Performance,/// Perform an operation having the signature; /// i8* (i8*); /// where a null input causes a no-op and returns null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,2,['Perform'],['Perform']
Performance,/// Perform an optional yaml-mapping of an endian-aware type EndianType as some; /// other type MapType.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp,1,['Perform'],['Perform']
Performance,/// Perform an optional yaml-mapping of an endian-aware type EndianType. The; /// only purpose of this function is to avoid casting the Default value to the; /// endian type;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp,1,['Perform'],['Perform']
Performance,/// Perform an optional yaml-mapping of an endian-aware type as an; /// appropriately-sized hex value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp,1,['Perform'],['Perform']
Performance,/// Perform an unsigned saturating addition of two constant ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,1,['Perform'],['Perform']
Performance,/// Perform an unsigned saturating left shift of this constant range by a; /// value in \p Other.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,1,['Perform'],['Perform']
Performance,/// Perform an unsigned saturating multiplication of two constant ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,1,['Perform'],['Perform']
Performance,/// Perform an unsigned saturating subtraction of two constant ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ConstantRange.h,1,['Perform'],['Perform']
Performance,"/// Perform any debug-info specific maintenence for the given splice; /// activity. In the DPValue debug-info representation, debug-info is not; /// in instructions, and so it does not automatically move from one block; /// to another.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,1,['Perform'],['Perform']
Performance,"/// Perform any per-file post processing, deallocate per-file; /// objects, and run statistics and output file cleanup code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['Perform'],['Perform']
Performance,/// Perform any semantic analysis which needs to be delayed until all; /// pending class member declarations have been parsed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Perform'],['Perform']
Performance,/// Perform bitcode upgrades on llvm.dbg.* calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,1,['Perform'],['Perform']
Performance,/// Perform check on requires decl to ensure that target architecture; /// supports unified addressing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,2,['Perform'],['Perform']
Performance,"/// Perform checking of type validity; ///; /// C++11 [dcl.align]p1:; /// An alignment-specifier may be applied to a variable or to a class; /// data member, but it shall not be applied to a bit-field, a function; /// parameter, the formal parameter of a catch clause, or a variable; /// declared with the register storage class specifier. An; /// alignment-specifier may also be applied to the declaration of a class; /// or enumeration type.; /// CWG 2354:; /// CWG agreed to remove permission for alignas to be applied to; /// enumerations.; /// C11 6.7.5/2:; /// An alignment attribute shall not be specified in a declaration of; /// a typedef, or a bit-field, or a function, or a parameter, or an; /// object declared with the register storage-class specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['Perform'],['Perform']
Performance,"/// Perform clean-up operations. To be called at the end of each event loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:4,Perform,Perform,4,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['Perform'],['Perform']
Performance,"/// Perform clean-up operations. To be called at the end of each task execution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:4,Perform,Perform,4,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['Perform'],['Perform']
Performance,/// Perform cloning on the graph necessary to uniquely identify the allocation; /// behavior of an allocation based on its context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['Perform'],['Perform']
Performance,"/// Perform code completion at the given file, line, and; /// column within this translation unit.; ///; /// \param File The file in which code completion will occur.; ///; /// \param Line The line at which code completion will occur.; ///; /// \param Column The column at which code completion will occur.; ///; /// \param IncludeMacros Whether to include macros in the code-completion; /// results.; ///; /// \param IncludeCodePatterns Whether to include code patterns (such as a; /// for loop) in the code-completion results.; ///; /// \param IncludeBriefComments Whether to include brief documentation within; /// the set of code completions returned.; ///; /// \param Act If supplied, this argument is used to parse the input file,; /// allowing customized parsing by overriding SyntaxOnlyAction lifecycle; /// methods.; ///; /// FIXME: The Diag, LangOpts, SourceMgr, FileMgr, StoredDiagnostics, and; /// OwnedBuffers parameters are all disgusting hacks. They will go away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['Perform'],['Perform']
Performance,/// Perform code-completion in an expression context when we know what; /// type we're looking for.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['Perform'],['Perform']
Performance,/// Perform conversions on the LHS of a member access expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['Perform'],['Perform']
Performance,/// Perform deep analyzes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,1,['Perform'],['Perform']
Performance,/// Perform early cleanup and prepare the InstCombine worklist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,1,['Perform'],['Perform']
Performance,/// Perform element by element copying of arrays with type \a; /// OriginalType from \a SrcAddr to \a DestAddr using copying procedure; /// generated by \a CopyGen.; ///; /// \param DestAddr Address of the destination array.; /// \param SrcAddr Address of the source array.; /// \param OriginalType Type of destination and source arrays.; /// \param CopyGen Copying procedure that copies value of single array element; /// to another single array element.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['Perform'],['Perform']
Performance,/// Perform extra checks when loading PCM files for mutable file systems.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,2,"['Perform', 'load']","['Perform', 'loading']"
Performance,/// Perform folds that are common to any floating-point operation. This implies; /// transforms based on poison/undef/NaN because the operation itself makes no; /// difference to the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['Perform'],['Perform']
Performance,/// Perform generic multiplication of values held in multiple registers.; /// Generated instructions use only types NarrowTy and i1.; /// Destination can be same or two times size of the source.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,1,['Perform'],['Perform']
Performance,/// Perform in-place global value handling on the given Module for; /// exported local functions renamed and promoted for ThinLTO.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionImportUtils.h,1,['Perform'],['Perform']
Performance,"/// Perform index-based whole program devirtualization on the \p Summary; /// index. Any devirtualized targets used by a type test in another module; /// are added to the \p ExportedGUIDs set. For any local devirtualized targets; /// only used within the defining module, the information necessary for; /// locating the corresponding WPD resolution is recorded for the ValueInfo; /// in case it is exported by cross module importing (in which case the; /// devirtualized target name will need adjustment).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/WholeProgramDevirt.h,1,['Perform'],['Perform']
Performance,/// Perform initialization analysis of the init-capture and perform; /// any implicit conversions such as an lvalue-to-rvalue conversion if; /// not being used to initialize a reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,/// Perform initialization based on the user configured set of features.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/RISCV.cpp,1,['Perform'],['Perform']
Performance,"/// Perform initialization based on the user configured; /// set of features (e.g., +sse4).; ///; /// The list is guaranteed to have at most one entry per feature.; ///; /// The target may modify the features list, to change which options are; /// passed onwards to the backend.; /// FIXME: This part should be fixed so that we can change handleTargetFeatures; /// to merely a TargetInfo initialization routine.; ///; /// \return False on error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['Perform'],['Perform']
Performance,/// Perform initialization that occurs after the parser has been; /// initialized but before it parses anything.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Perform'],['Perform']
Performance,/// Perform initialization via a constructor taking a single; /// std::initializer_list argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,"/// Perform initialization via a constructor, taking arguments from; /// a single InitListExpr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,/// Perform initialization via a constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,"/// Perform instruction selection on a single basic block, for; /// instructions between \p Begin and \p End. \p HadTailCall will be set; /// to true if a call in the block was translated as a tail call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,1,['Perform'],['Perform']
Performance,/// Perform instruction selection on all basic blocks in the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGISel.h,1,['Perform'],['Perform']
Performance,"/// Perform layout for a single fragment, assuming that the previous; /// fragment has already been laid out correctly, and the parent section has; /// been initialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmLayout.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/MC/MCAsmLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmLayout.h,1,['Perform'],['Perform']
Performance,"/// Perform layout on the given record.; ///; /// This routine allows the external AST source to provide an specific; /// layout for a record, overriding the layout that would normally be; /// constructed. It is intended for clients who receive specific layout; /// details rather than source code (such as LLDB). The client is expected; /// to fill in the field offsets, base offsets, virtual base offsets, and; /// complete object size.; ///; /// \param Record The record whose layout is being requested.; ///; /// \param Size The final size of the record, in bits.; ///; /// \param Alignment The final alignment of the record, in bits.; ///; /// \param FieldOffsets The offset of each of the fields within the record,; /// expressed in bits. All of the fields must be provided with offsets.; ///; /// \param BaseOffsets The offset of each of the direct, non-virtual base; /// classes. If any bases are not given offsets, the bases will be laid; /// out according to the ABI.; ///; /// \param VirtualBaseOffsets The offset of each of the virtual base classes; /// (either direct or not). If any bases are not given offsets, the bases will be laid; /// out according to the ABI.; ///; /// \returns true if the record layout was provided, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,1,['Perform'],['Perform']
Performance,"/// Perform layout on the given record.; ///; /// This routine allows the external AST source to provide an specific; /// layout for a record, overriding the layout that would normally be; /// constructed. It is intended for clients who receive specific layout; /// details rather than source code (such as LLDB). The client is expected; /// to fill in the field offsets, base offsets, virtual base offsets, and; /// complete object size.; ///; /// \param Record The record whose layout is being requested.; ///; /// \param Size The final size of the record, in bits.; ///; /// \param Alignment The final alignment of the record, in bits.; ///; /// \param FieldOffsets The offset of each of the fields within the record,; /// expressed in bits. All of the fields must be provided with offsets.; ///; /// \param BaseOffsets The offset of each of the direct, non-virtual base; /// classes. If any bases are not given offsets, the bases will be laid; /// out according to the ABI.; ///; /// \param VirtualBaseOffsets The offset of each of the virtual base classes; /// (either direct or not). If any bases are not given offsets, the bases will; /// be laid out according to the ABI.; ///; /// \returns true if the record layout was provided, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/MultiplexExternalSemaSource.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/MultiplexExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/MultiplexExternalSemaSource.h,1,['Perform'],['Perform']
Performance,"/// Perform lazy initialization of nearest-point locator after the Kd-tree; /// BFS bulk load if necessary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h:4,Perform,Perform,4,math/mathcore/src/CDT/Triangulation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/CDT/Triangulation.h,2,"['Perform', 'load']","['Perform', 'load']"
Performance,/// Perform ldtilecfg instructions inserting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,1,['Perform'],['Perform']
Performance,/// Perform list-initialization without a constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['Perform'],['Perform']
Performance,"/// Perform lookup for a special member of the specified kind, and determine; /// whether it is trivial. If the triviality can be determined without the; /// lookup, skip it. This is intended for use when determining whether a; /// special member of a containing object is trivial, and thus does not ever; /// perform overload resolution for default constructors.; ///; /// If \p Selected is not \c NULL, \c *Selected will be filled in with the; /// member that was most likely to be intended to be trivial, if any.; ///; /// If \p ForCall is true, look at CXXRecord::HasTrivialSpecialMembersForCall to; /// determine whether the special member is trivial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,/// Perform lookup for an overloaded binary operator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['Perform'],['Perform']
Performance,"/// Perform marking for a reference to an arbitrary declaration. It; /// marks the declaration referenced, and performs odr-use checking for; /// functions and variables. This method should not be used when building a; /// normal expression which refers to a variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,"['Perform', 'perform']","['Perform', 'performs']"
Performance,"/// Perform matrix multiplication of two tiles containing complex elements and; /// accumulate the results into a packed single precision tile. Each dword; /// element in input tiles \a a and \a b is interpreted as a complex number; /// with FP16 real part and FP16 imaginary part.; /// Calculates the imaginary part of the result. For each possible combination; /// of (row of \a a, column of \a b), it performs a set of multiplication; /// and accumulations on all corresponding complex numbers (one from \a a; /// and one from \a b). The imaginary part of the \a a element is multiplied; /// with the real part of the corresponding \a b element, and the real part; /// of the \a a element is multiplied with the imaginary part of the; /// corresponding \a b elements. The two accumulated results are added, and; /// then accumulated into the corresponding row and column of \a dst.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _tile_cmmimfp16ps(__tile dst, __tile a, __tile b);; /// \endcode; ///; /// \code{.operation}; /// FOR m := 0 TO dst.rows - 1; ///	tmp := dst.row[m]; ///	FOR k := 0 TO (a.colsb / 4) - 1; ///		FOR n := 0 TO (dst.colsb / 4) - 1; ///			tmp.fp32[n] += FP32(a.row[m].fp16[2*k+0]) * FP32(b.row[k].fp16[2*n+1]); ///			tmp.fp32[n] += FP32(a.row[m].fp16[2*k+1]) * FP32(b.row[k].fp16[2*n+0]); ///		ENDFOR; ///	ENDFOR; ///	write_row_and_zero(dst, m, tmp, dst.colsb); /// ENDFOR; /// zero_upper_rows(dst, dst.rows); /// zero_tileconfig_start(); /// \endcode; ///; /// This intrinsic corresponds to the \c TCMMIMFP16PS instruction.; ///; /// \param dst; /// The destination tile. Max size is 1024 Bytes.; /// \param a; /// The 1st source tile. Max size is 1024 Bytes.; /// \param b; /// The 2nd source tile. Max size is 1024 Bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,2,"['Perform', 'perform']","['Perform', 'performs']"
Performance,"/// Perform matrix multiplication of two tiles containing complex elements and; /// accumulate the results into a packed single precision tile. Each dword; /// element in input tiles \a a and \a b is interpreted as a complex number; /// with FP16 real part and FP16 imaginary part.; /// Calculates the real part of the result. For each possible combination; /// of (row of \a a, column of \a b), it performs a set of multiplication; /// and accumulations on all corresponding complex numbers (one from \a a; /// and one from \a b). The real part of the \a a element is multiplied; /// with the real part of the corresponding \a b element, and the negated; /// imaginary part of the \a a element is multiplied with the imaginary; /// part of the corresponding \a b elements. The two accumulated results; /// are added, and then accumulated into the corresponding row and column; /// of \a dst.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// void _tile_cmmrlfp16ps(__tile dst, __tile a, __tile b);; /// \endcode; ///; /// \code{.operation}; /// FOR m := 0 TO dst.rows - 1; ///	tmp := dst.row[m]; ///	FOR k := 0 TO (a.colsb / 4) - 1; ///		FOR n := 0 TO (dst.colsb / 4) - 1; ///			tmp.fp32[n] += FP32(a.row[m].fp16[2*k+0]) * FP32(b.row[k].fp16[2*n+0]); ///			tmp.fp32[n] += FP32(-a.row[m].fp16[2*k+1]) * FP32(b.row[k].fp16[2*n+1]); ///		ENDFOR; ///	ENDFOR; ///	write_row_and_zero(dst, m, tmp, dst.colsb); /// ENDFOR; /// zero_upper_rows(dst, dst.rows); /// zero_tileconfig_start(); /// \endcode; ///; /// This intrinsic corresponds to the \c TCMMIMFP16PS instruction.; ///; /// \param dst; /// The destination tile. Max size is 1024 Bytes.; /// \param a; /// The 1st source tile. Max size is 1024 Bytes.; /// \param b; /// The 2nd source tile. Max size is 1024 Bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,2,"['Perform', 'perform']","['Perform', 'performs']"
Performance,/// Perform matrix multiplication of two tiles containing complex elements and; /// accumulate the results into a packed single precision tile. Each dword; /// element in input tiles src0 and src1 is interpreted as a complex number with; /// FP16 real part and FP16 imaginary part.; /// This function calculates the imaginary part of the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TCMMIMFP16PS </c> instruction.; ///; /// \param dst; /// The destination tile. Max size is 1024 Bytes.; /// \param src0; /// The 1st source tile. Max size is 1024 Bytes.; /// \param src1; /// The 2nd source tile. Max size is 1024 Bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,1,['Perform'],['Perform']
Performance,/// Perform matrix multiplication of two tiles containing complex elements and; /// accumulate the results into a packed single precision tile. Each dword; /// element in input tiles src0 and src1 is interpreted as a complex number with; /// FP16 real part and FP16 imaginary part.; /// This function calculates the real part of the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the <c> TCMMRLFP16PS </c> instruction.; ///; /// \param dst; /// The destination tile. Max size is 1024 Bytes.; /// \param src0; /// The 1st source tile. Max size is 1024 Bytes.; /// \param src1; /// The 2nd source tile. Max size is 1024 Bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxcomplexintrin.h,1,['Perform'],['Perform']
Performance,"/// Perform most of the PEI work here:; /// - saving/restoring of the callee-saved registers,; /// - stack frame creation and destruction.; /// Normally, this work is distributed among various functions, but doing it; /// in one place allows shrink-wrapping of the stack frame.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['Perform'],['Perform']
Performance,/// Perform name lookup for a possible result for typo correction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['Perform'],['Perform']
Performance,"/// Perform name lookup on the given name, classifying it based on; /// the results of name lookup and the following token.; ///; /// This routine is used by the parser to resolve identifiers and help direct; /// parsing. When the identifier cannot be found, this routine will attempt; /// to correct the typo and classify based on the resulting name.; ///; /// \param S The scope in which we're performing name lookup.; ///; /// \param SS The nested-name-specifier that precedes the name.; ///; /// \param Name The identifier. If typo correction finds an alternative name,; /// this pointer parameter will be updated accordingly.; ///; /// \param NameLoc The location of the identifier.; ///; /// \param NextToken The token following the identifier. Used to help; /// disambiguate the name.; ///; /// \param CCC The correction callback, if typo correction is desired.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['Perform', 'perform']","['Perform', 'performing']"
Performance,/// Perform necessary initialization to handle a subset of CSRs explicitly; /// via copies. This function is called at the beginning of instruction; /// selection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['Perform'],['Perform']
Performance,/// Perform one layout iteration and return true if any offsets; /// were adjusted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,1,['Perform'],['Perform']
Performance,/// Perform one layout iteration of the given section and return true; /// if any offsets were adjusted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,1,['Perform'],['Perform']
Performance,/// Perform only intra-procedural analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,1,['Perform'],['Perform']
Performance,/// Perform optimizations common to nodes that compute two values. LoOp and HiOp; /// give the opcodes for the two computations that are being performed. Return; /// true if a simplification was made.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,3,"['Perform', 'optimiz', 'perform']","['Perform', 'optimizations', 'performed']"
Performance,"/// Perform partial array destruction as if in an EH cleanup. Unlike; /// emitArrayDestroy, the element type here may still be an array type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['Perform'],['Perform']
Performance,"/// Perform partitioning with the context lock held, since the partition; /// function is allowed to access the globals to compute the partition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,1,['Perform'],['Perform']
Performance,/// Perform propagation of DLL attributes from a derived class to a; /// templated base class for MS compatibility.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Perform'],['Perform']
Performance,/// Perform qualified lookups on the queued set of typo correction; /// candidates and add the nested name specifier changes to each candidate if; /// a lookup succeeds (at which point the candidate will be returned to the; /// main pool of potential corrections).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h,2,"['Perform', 'queue']","['Perform', 'queued']"
Performance,"/// Perform qualified name lookup in the namespaces nominated by; /// using directives by the given context.; ///; /// C++98 [namespace.qual]p2:; /// Given X::m (where X is a user-declared namespace), or given \::m; /// (where X is the global namespace), let S be the set of all; /// declarations of m in X and in the transitive closure of all; /// namespaces nominated by using-directives in X and its used; /// namespaces, except that using-directives are ignored in any; /// namespace, including X, directly containing one or more; /// declarations of m. No namespace is searched more than once in; /// the lookup of a name. If S is the empty set, the program is; /// ill-formed. Otherwise, if S has exactly one member, or if the; /// context of the reference is a using-declaration; /// (namespace.udecl), S is the required set of declarations of; /// m. Otherwise if the use of m is not one that allows a unique; /// declaration to be chosen from S, the program is ill-formed.; ///; /// C++98 [namespace.qual]p5:; /// During the lookup of a qualified namespace member name, if the; /// lookup finds more than one declaration of the member, and if one; /// declaration introduces a class name or enumeration name and the; /// other declarations either introduce the same object, the same; /// enumerator or a set of functions, the non-type name hides the; /// class or enumeration name if and only if the declarations are; /// from the same namespace; otherwise (the declarations are from; /// different namespaces), the program is ill-formed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['Perform'],['Perform']
Performance,"/// Perform qualified name lookup into a given context.; ///; /// Qualified name lookup (C++ [basic.lookup.qual]) is used to find; /// names when the context of those names is explicit specified, e.g.,; /// ""std::vector"" or ""x->member"", or as part of unqualified name lookup.; ///; /// Different lookup criteria can find different names. For example, a; /// particular scope can have both a struct and a function of the same; /// name, and each can be found by certain lookup criteria. For more; /// information about lookup criteria, see the documentation for the; /// class LookupCriteria.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param LookupCtx The context in which qualified name lookup will; /// search. If the lookup criteria permits, name lookup may also search; /// in the parent contexts or (for C++ classes) base classes.; ///; /// \param InUnqualifiedLookup true if this is qualified name lookup that; /// occurs as part of unqualified name lookup.; ///; /// \returns true if lookup succeeded, false if it failed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['Perform'],['Perform']
Performance,/// Perform qualified name lookup into all base classes of the given; /// class.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param Class The context in which qualified name lookup will; /// search. Name lookup will search in all base classes merging the results.; ///; /// @returns True if any decls were found (but possibly ambiguous),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['Perform'],['Perform']
Performance,"/// Perform reference-marking and odr-use handling for a DeclRefExpr.; ///; /// Note, this may change the dependence of the DeclRefExpr, and so needs to be; /// handled with care if the DeclRefExpr is not newly-created.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Perform'],['Perform']
Performance,/// Perform reference-marking and odr-use handling for a FunctionParmPackExpr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Perform'],['Perform']
Performance,/// Perform reference-marking and odr-use handling for a MemberExpr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Perform'],['Perform']
Performance,/// Perform region splitting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.h,1,['Perform'],['Perform']
Performance,/// Perform register allocation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,1,['Perform'],['Perform']
Performance,/// Perform register allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,4,['Perform'],['Perform']
Performance,/// Perform relaxation on a single fragment - returns true if the fragment; /// changes as a result of relaxation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAssembler.h,1,['Perform'],['Perform']
Performance,"/// Perform replacing of registers based on the <old,new> vreg map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRVRegNamerUtils.h,1,['Perform'],['Perform']
Performance,"/// Perform same function as equivalently named function in DAGCombiner. Since; /// we expand some divisions here, we need to perform this before obscuring.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,/// Perform sanity checks on graph when requested.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['Perform'],['Perform']
Performance,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,2,"['Perform', 'optimiz']","['Perform', 'optimizations']"
Performance,/// Perform semantic analysis for a call to __builtin_complex.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Perform'],['Perform']
Performance,"/// Perform semantic analysis for the given dependent function; /// template specialization.; ///; /// The only possible way to get a dependent function template specialization; /// is with a friend declaration, like so:; ///; /// \code; /// template \<class T> void foo(T);; /// template \<class T> class A {; /// friend void foo<>(T);; /// };; /// \endcode; ///; /// There really isn't any useful analysis we can do here, so we; /// just store the information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Perform'],['Perform']
Performance,"/// Perform semantic analysis for the given function template; /// specialization.; ///; /// This routine performs all of the semantic analysis required for an; /// explicit function template specialization. On successful completion,; /// the function declaration \p FD will become a function template; /// specialization.; ///; /// \param FD the function declaration, which will be updated to become a; /// function template specialization.; ///; /// \param ExplicitTemplateArgs the explicitly-provided template arguments,; /// if any. Note that this may be valid info even when 0 arguments are; /// explicitly provided as in, e.g., \c void sort<>(char*, char*);; /// as it anyway contains info on the angle brackets locations.; ///; /// \param Previous the set of declarations that may be specialized by; /// this function specialization.; ///; /// \param QualifiedFriend whether this is a lookup for a qualified friend; /// declaration with no explicit template argument list that might be; /// befriending a function template specialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,"['Perform', 'perform']","['Perform', 'performs']"
Performance,"/// Perform semantic analysis for the given non-template member; /// specialization.; ///; /// This routine performs all of the semantic analysis required for an; /// explicit member function specialization. On successful completion,; /// the function declaration \p FD will become a member function; /// specialization.; ///; /// \param Member the member declaration, which will be updated to become a; /// specialization.; ///; /// \param Previous the set of declarations, one of which may be specialized; /// by this function specialization; the set will be modified to contain the; /// redeclared member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,2,"['Perform', 'perform']","['Perform', 'performs']"
Performance,"/// Perform semantic analysis for the variable declaration that; /// occurs within a C++ catch clause, returning the newly-created; /// variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Perform'],['Perform']
Performance,/// Perform semantic analysis of the given friend type declaration.; ///; /// \returns A friend declaration that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Perform'],['Perform']
Performance,"/// Perform semantic checking of a new function declaration.; ///; /// Performs semantic analysis of the new function declaration; /// NewFD. This routine performs all semantic checking that does not; /// require the actual declarator involved in the declaration, and is; /// used both for the declaration of functions as they are parsed; /// (called via ActOnDeclarator) and for the declaration of functions; /// that have been instantiated via C++ template instantiation (called; /// via InstantiateDecl).; ///; /// \param IsMemberSpecialization whether this new function declaration is; /// a member specialization (that replaces any definition provided by the; /// previous declaration).; ///; /// This sets NewFD->isInvalidDecl() to true if there was an error.; ///; /// \returns true if the function declaration is a redeclaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,3,"['Perform', 'perform']","['Perform', 'Performs', 'performs']"
Performance,"/// Perform semantic checking on a newly-created variable; /// declaration.; ///; /// This routine performs all of the type-checking required for a; /// variable declaration once it has been built. It is used both to; /// check variables after they have been parsed and their declarators; /// have been translated into a declaration, and to check variables; /// that have been instantiated from a template.; ///; /// Sets NewVD->isInvalidDecl() if an error was encountered.; ///; /// Returns true if the variable declaration is a redeclaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['Perform', 'perform']","['Perform', 'performs']"
Performance,"/// Perform semantic checks on a class definition that has been; /// completing, introducing implicitly-declared members, checking for; /// abstract types, etc.; ///; /// \param S The scope in which the class was parsed. Null if we didn't just; /// parse a class definition.; /// \param Record The completed class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Perform'],['Perform']
Performance,/// Perform semantic checks on a completed expression. This will either; /// be a full-expression or a default argument expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Perform'],['Perform']
Performance,"/// Perform several checks on the arguments of @llvm.get.active.lane.mask; /// intrinsic. E.g., check that the loop induction variable and the element; /// count are of the form we expect, and also perform overflow checks for; /// the new expressions that are created.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,/// Perform shallow but fast analyzes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/AnalyzerOptions.h,1,['Perform'],['Perform']
Performance,"/// Perform simple partial redundancy elimination of the VSETVLI instructions; /// we're about to insert by looking for cases where we can PRE from the; /// beginning of one block to the end of one of its predecessors. Specifically,; /// this is geared to catch the common case of a fixed length vsetvl in a single; /// block loop when it could execute once in the preheader instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['Perform'],['Perform']
Performance,/// Perform simple self-diagnostic and assert if there is anything obviously; /// wrong with the actions set up.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['Perform'],['Perform']
Performance,"/// Perform simplification of memcpy's. If we have memcpy A; /// which copies X to Y, and memcpy B which copies Y to Z, then we can rewrite; /// B to be a memcpy from X to Z (or potentially a memmove, depending on; /// circumstances). This allows later passes to remove the first memcpy; /// altogether.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['Perform'],['Perform']
Performance,"/// Perform some cleanup and simplifications on loops after unrolling. It is; /// useful to simplify the IV's in the new loop, as well as do a quick; /// simplify/dce pass of the instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,1,['Perform'],['Perform']
Performance,"/// Perform substitution on the base class specifiers of the; /// given class template specialization.; ///; /// Produces a diagnostic and returns true on error, returns false and; /// attaches the instantiated base classes to the class template; /// specialization if successful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['Perform'],['Perform']
Performance,"/// Perform substitution on the type T with a given set of template; /// arguments.; ///; /// This routine substitutes the given template arguments into the; /// type T and produces the instantiated type.; ///; /// \param T the type into which the template arguments will be; /// substituted. If this type is not dependent, it will be returned; /// immediately.; ///; /// \param Args the template arguments that will be; /// substituted for the top-level template parameters within T.; ///; /// \param Loc the location in the source code where this substitution; /// is being performed. It will typically be the location of the; /// declarator (if we're instantiating the type of some declaration); /// or the location of the type in the source code (if, e.g., we're; /// instantiating the type of a cast expression).; ///; /// \param Entity the name of the entity associated with a declaration; /// being instantiated (if any). May be empty to indicate that there; /// is no such entity (if, e.g., this is a type that occurs as part of; /// a cast expression) or that the entity has no name (e.g., an; /// unnamed function parameter).; ///; /// \param AllowDeducedTST Whether a DeducedTemplateSpecializationType is; /// acceptable as the top level type of the result.; ///; /// \returns If the instantiation succeeds, the instantiated; /// type. Otherwise, produces diagnostics and returns a NULL type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,2,"['Perform', 'perform']","['Perform', 'performed']"
Performance,/// Perform target specific adjustments to the latency of a schedule; /// dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,4,"['Perform', 'latency']","['Perform', 'latency']"
Performance,/// Perform target specific instruction verification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,1,['Perform'],['Perform']
Performance,/// Perform target-specific initialization; /// \param AuxTarget Target info to incorporate builtins from. May be nullptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Builtins.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Basic/Builtins.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Builtins.h,1,['Perform'],['Perform']
Performance,/// Perform target-specific instruction verification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['Perform'],['Perform']
Performance,"/// Perform template argument deduction from a function call; /// (C++ [temp.deduct.call]).; ///; /// \param FunctionTemplate the function template for which we are performing; /// template argument deduction.; ///; /// \param ExplicitTemplateArgs the explicit template arguments provided; /// for this call.; ///; /// \param Args the function call arguments; ///; /// \param Specialization if template argument deduction was successful,; /// this will be set to the function template specialization produced by; /// template argument deduction.; ///; /// \param Info the argument will be updated to provide additional information; /// about template argument deduction.; ///; /// \param CheckNonDependent A callback to invoke to check conversions for; /// non-dependent parameters, between deduction and substitution, per DR1391.; /// If this returns true, substitution will be skipped and we return; /// TDK_NonDependentConversionFailure. The callback is passed the parameter; /// types (after substituting explicit template arguments).; ///; /// \returns the result of template argument deduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,"['Perform', 'perform']","['Perform', 'performing']"
Performance,/// Perform template argument deduction per [temp.deduct.call] for a; /// single parameter / argument pair.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['Perform'],['Perform']
Performance,/// Perform template argument deduction to determine whether; /// the given template arguments match the given class template; /// partial specialization per C++ [temp.class.spec.match].,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['Perform'],['Perform']
Performance,/// Perform template argument deduction to determine whether; /// the given template arguments match the given variable template; /// partial specialization per C++ [temp.class.spec.match].,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['Perform'],['Perform']
Performance,/// Perform the CFG preparation; /// This step will remove every unconditionnal/dead jump instructions and make; /// sure all loops have an exit block,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,1,['Perform'],['Perform']
Performance,/// Perform the CFG structurization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600MachineCFGStructurizer.cpp,1,['Perform'],['Perform']
Performance,/// Perform the TLS Variable Hoist optimization for the given function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,2,"['Perform', 'optimiz']","['Perform', 'optimization']"
Performance,"/// Perform the action using Records, and write output to OS.; /// Returns true on error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Main.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/TableGen/Main.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Main.h,1,['Perform'],['Perform']
Performance,"/// Perform the actual initialization of the given entity based on; /// the computed initialization sequence.; ///; /// \param S the semantic analysis object.; ///; /// \param Entity the entity being initialized.; ///; /// \param Kind the kind of initialization being performed.; ///; /// \param Args the argument(s) provided for initialization, ownership of; /// which is transferred into the routine.; ///; /// \param ResultType if non-NULL, will be set to the type of the; /// initialized object, which is the type of the declaration in most; /// cases. However, when the initialized object is a variable of; /// incomplete array type and the initializer is an initializer; /// list, this type will be set to the completed array type.; ///; /// \returns an expression that performs the actual object initialization, if; /// the initialization is well-formed. Otherwise, emits diagnostics; /// and returns an invalid expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,3,"['Perform', 'perform']","['Perform', 'performed', 'performs']"
Performance,"/// Perform the actual mechanics of sinking an instruction from Blocks into; /// BBEnd, which is their only successor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNSink.cpp,1,['Perform'],['Perform']
Performance,/// Perform the actual replacement of the underlying instruction graph.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['Perform'],['Perform']
Performance,"/// Perform the adjustment from a value returned by a virtual function to; /// a value of the statically expected type, which may be a pointer or; /// reference to a base class of the returned type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,/// Perform the adjustments to the parameter and argument types; /// described in C++ [temp.deduct.call].; ///; /// \returns true if the caller should not attempt to perform any template; /// argument deduction based on this P/A pair because the argument is an; /// overloaded function set that could not be resolved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,/// Perform the constant hoisting optimization for the given function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,2,"['Perform', 'optimiz']","['Perform', 'optimization']"
Performance,/// Perform the conversions required for an expression used in a; /// context that ignores the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['Perform'],['Perform']
Performance,"/// Perform the dataflow calculation and calculate the lifetime for each of; /// the slots, based on the BEGIN/END vectors. Set the LifetimeLIVE_IN and; /// LifetimeLIVE_OUT maps that represent which stack slots are live coming; /// in and out blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['Perform'],['Perform']
Performance,"/// Perform the extraction, returning the new function and providing an; /// interface to see what was categorized as inputs and outputs.; ///; /// \param CEAC - Cache to speed up operations for the CodeExtractor when; /// hoisting, and extracting lifetime values and assumes.; /// \param Inputs [out] - filled with values marked as inputs to the; /// newly outlined function.; /// \param Outputs [out] - filled with values marked as outputs to the; /// newly outlined function.; /// \returns zero when called on a CodeExtractor instance where isEligible; /// returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,2,"['Cache', 'Perform']","['Cache', 'Perform']"
Performance,"/// Perform the extraction, returning the new function.; ///; /// Returns zero when called on a CodeExtractor instance where isEligible; /// returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,1,['Perform'],['Perform']
Performance,"/// Perform the given binary floating-point operation, in-place, on LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,/// Perform the given binary integer operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,"/// Perform the given integer operation, which is known to need at most BitWidth; /// bits, and check for overflow in the original type (if that type was not an; /// unsigned type).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,"/// Perform the initial placement of the regular constant pool entries.; /// To start with, we put them all at the end of the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['Perform'],['Perform']
Performance,"/// Perform the initialization of a potentially-movable value, which; /// is the result of return value.; ///; /// This routine implements C++20 [class.copy.elision]p3, which attempts to; /// treat returned lvalues as rvalues in certain cases (to prefer move; /// construction), then falls back to treating them as lvalues if that failed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['Perform'],['Perform']
Performance,"/// Perform the necessary checks and state adjustments at the end of the; /// function.; /// \p S Return statement, may be null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h,1,['Perform'],['Perform']
Performance,"/// Perform the operation on a different, but equivalently sized type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegacyLegalizerInfo.h,2,['Perform'],['Perform']
Performance,/// Perform the relevant checks on the loop and convert active lane masks if; /// possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVETailPredication.cpp,1,['Perform'],['Perform']
Performance,"/// Perform the scalar expression combine in the form of:; /// CSEL(c, 1, cc) + b => CSINC(b+c, b, cc); /// CSNEG(c, -1, cc) + b => CSINC(b+c, b, cc)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Perform'],['Perform']
Performance,/// Perform the shrink-wrapping analysis and update; /// the MachineFrameInfo attached to \p MF with the results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['Perform'],['Perform']
Performance,/// Perform the transformation for a candidate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['Perform'],['Perform']
Performance,/// Perform the unqualified lookups that might be needed to form a defaulted; /// comparison function for the given operator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Perform'],['Perform']
Performance,/// Perform tile register configure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastPreTileConfig.cpp,1,['Perform'],['Perform']
Performance,"/// Perform two related transforms whose purpose is to incrementally recognize; /// an explode_vector followed by scalar reduction as a vector reduction node.; /// This exists to recover from a deficiency in SLP which can't handle; /// forests with multiple roots sharing common nodes. In some cases, one; /// of the trees will be vectorized, and the other will remain (unprofitably); /// scalarized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:4,Perform,Perform,4,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Perform'],['Perform']
Performance,"/// Perform type checking and populate the dependency graph, but; /// don't generate code yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,1,['Perform'],['Perform']
Performance,"/// Perform unqualified name lookup starting from a given; /// scope.; ///; /// Unqualified name lookup (C++ [basic.lookup.unqual], C99 6.2.1) is; /// used to find names within the current scope. For example, 'x' in; /// @code; /// int x;; /// int f() {; /// return x; // unqualified name look finds 'x' in the global scope; /// }; /// @endcode; ///; /// Different lookup criteria can find different names. For example, a; /// particular scope can have both a struct and a function of the same; /// name, and each can be found by certain lookup criteria. For more; /// information about lookup criteria, see the documentation for the; /// class LookupCriteria.; ///; /// @param S The scope from which unqualified name lookup will; /// begin. If the lookup criteria permits, name lookup may also search; /// in the parent scopes.; ///; /// @param [in,out] R Specifies the lookup to perform (e.g., the name to; /// look up and the lookup kind), and is updated with the results of lookup; /// including zero or more declarations and possibly additional information; /// used to diagnose ambiguities.; ///; /// @returns \c true if lookup succeeded and false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,"['Perform', 'perform']","['Perform', 'perform']"
Performance,"/// Perform validation, don't disable it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h:4,Perform,Perform,4,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorOptions.h,1,['Perform'],['Perform']
Performance,"/// Perform various unary floating-point operations inspired by libm. For; /// FPOWI, the result is undefined if the integer operand doesn't fit into; /// sizeof(int).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Perform,Perform,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Perform'],['Perform']
Performance,/// Perform virtual dispatch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,"/// Perform zero-initialization on an object of non-union class type.; /// C++11 [dcl.init]p5:; /// To zero-initialize an object or reference of type T means:; /// [...]; /// -- if T is a (possibly cv-qualified) non-union class type,; /// each non-static data member and each base-class subobject is; /// zero-initialized",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:4,Perform,Perform,4,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['Perform'],['Perform']
Performance,/// PerformADDCombine - Target-specific dag combine xforms for ISD::ADD.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformADDCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,['Perform'],['PerformADDCombine']
Performance,"/// PerformADDCombineWithOperands - Try DAG combinations for an ADD with; /// operands N0 and N1. This is a helper for PerformADDCombine that is; /// called with the default operands, and if that fails, with commuted; /// operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformADDCombineWithOperands,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,4,['Perform'],"['PerformADDCombine', 'PerformADDCombineWithOperands']"
Performance,"/// PerformADDECombine - Target-specific dag combine transform from; /// ARMISD::ADDC, ARMISD::ADDE, and ISD::MUL_LOHI to MLAL or; /// ARMISD::ADDC, ARMISD::ADDE and ARMISD::UMLAL to ARMISD::UMAAL",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformADDECombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformADDECombine']
Performance,/// PerformBRCONDCombine - Target-specific DAG combining for ARMISD::BRCOND.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformBRCONDCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformBRCONDCombine']
Performance,/// PerformCMOVCombine - Target-specific DAG combining for ARMISD::CMOV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformCMOVCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformCMOVCombine']
Performance,/// PerformContextuallyConvertToBool - Perform a contextual conversion; /// of the expression From to bool (C++0x [conv]p3).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Perform,PerformContextuallyConvertToBool,4,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['Perform'],"['Perform', 'PerformContextuallyConvertToBool']"
Performance,/// PerformContextuallyConvertToObjCPointer - Perform a contextual; /// conversion of the expression From to an Objective-C pointer type.; /// Returns a valid but null ExprResult if no conversion sequence exists.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Perform,PerformContextuallyConvertToObjCPointer,4,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['Perform'],"['Perform', 'PerformContextuallyConvertToObjCPointer']"
Performance,"/// PerformExtendCombine - Target-specific DAG combining for ISD::SIGN_EXTEND,; /// ISD::ZERO_EXTEND, and ISD::ANY_EXTEND.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformExtendCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformExtendCombine']
Performance,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType by following the standard; /// conversion sequence SCS. Returns the converted; /// expression. Flavor is the context in which we're performing this; /// conversion, for use in error messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Perform,PerformImplicitConversion,4,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,3,"['Perform', 'perform']","['Perform', 'PerformImplicitConversion', 'performing']"
Performance,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType using the pre-computed implicit; /// conversion sequence ICS. Returns the converted; /// expression. Action is the kind of conversion we're performing,; /// used in the error message.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:4,Perform,PerformImplicitConversion,4,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,3,"['Perform', 'perform']","['Perform', 'PerformImplicitConversion', 'performing']"
Performance,"/// PerformImplicitConversion - Perform an implicit conversion of the; /// expression From to the type ToType. Returns the; /// converted expression. Flavor is the kind of conversion we're; /// performing, used in the error message. If @p AllowExplicit,; /// explicit user-defined conversions are permitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Perform,PerformImplicitConversion,4,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,3,"['Perform', 'perform']","['Perform', 'PerformImplicitConversion', 'performing']"
Performance,/// PerformInsertEltCombine - Target-specific dag combine xforms for; /// ISD::INSERT_VECTOR_ELT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformInsertEltCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformInsertEltCombine']
Performance,/// PerformIntrinsicCombine - ARM-specific DAG combining for intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformIntrinsicCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformIntrinsicCombine']
Performance,/// PerformMULCombine - Runs PTX-specific DAG combine patterns on MUL nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:4,Perform,PerformMULCombine,4,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['Perform'],['PerformMULCombine']
Performance,/// PerformMinMaxCombine - Target-specific DAG combining for creating truncating; /// saturates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformMinMaxCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformMinMaxCombine']
Performance,/// PerformORCombine - Target-specific dag combine xforms for ISD::OR,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformORCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformORCombine']
Performance,/// PerformObjectArgumentInitialization - Perform initialization of; /// the implicit object parameter for the given Method with the given; /// expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:4,Perform,PerformObjectArgumentInitialization,4,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['Perform'],"['Perform', 'PerformObjectArgumentInitialization']"
Performance,/// PerformSHLCombine - Runs PTX-specific DAG combine patterns on SHL nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:4,Perform,PerformSHLCombine,4,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['Perform'],['PerformSHLCombine']
Performance,/// PerformSTORECombine - Target-specific dag combine xforms for; /// ISD::STORE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformSTORECombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformSTORECombine']
Performance,/// PerformSUBCombine - Target-specific dag combine xforms for ISD::SUB.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformSUBCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformSUBCombine']
Performance,"/// PerformShiftCombine - Checks for immediate versions of vector shifts and; /// lowers them. As with the vector shift intrinsics, this is done during DAG; /// combining instead of DAG legalizing because the build_vectors for 64-bit; /// vector element shift counts are generally not legal, and it is hard to see; /// their values after they get legalized to loads from a constant pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformShiftCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,2,"['Perform', 'load']","['PerformShiftCombine', 'loads']"
Performance,"/// PerformVCVTCombine - VCVT (floating-point to fixed-point, Advanced SIMD); /// can replace combinations of VMUL and VCVT (floating-point to integer); /// when the VMUL has a constant operand that is a power of 2.; ///; /// Example (assume d17 = <float 8.000000e+00, float 8.000000e+00>):; /// vmul.f32 d16, d17, d16; /// vcvt.s32.f32 d16, d16; /// becomes:; /// vcvt.s32.f32 d16, d16, #3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformVCVTCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformVCVTCombine']
Performance,"/// PerformVDIVCombine - VCVT (fixed-point to floating-point, Advanced SIMD); /// can replace combinations of VCVT (integer to floating-point) and VDIV; /// when the VDIV has a constant operand that is a power of 2.; ///; /// Example (assume d17 = <float 8.000000e+00, float 8.000000e+00>):; /// vcvt.f32.s32 d16, d16; /// vdiv.f32 d16, d17, d16; /// becomes:; /// vcvt.f32.s32 d16, d16, #3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformVDIVCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformVDIVCombine']
Performance,/// PerformVDUPCombine - Target-specific dag combine xforms for ARMISD::VDUP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformVDUPCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformVDUPCombine']
Performance,/// PerformVDUPLANECombine - Target-specific dag combine xforms for; /// ARMISD::VDUPLANE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformVDUPLANECombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformVDUPLANECombine']
Performance,/// PerformVMOVDRRCombine - Target-specific dag combine xforms for; /// ARMISD::VMOVDRR. This is also used for BUILD_VECTORs with 2 operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformVMOVDRRCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformVMOVDRRCombine']
Performance,/// PerformVMOVRRDCombine - Target-specific dag combine xforms for; /// ARMISD::VMOVRRD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformVMOVRRDCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformVMOVRRDCombine']
Performance,"/// PerformVMULCombine; /// Distribute (A + B) * C to (A * C) + (B * C) to take advantage of the; /// special multiplier accumulator forwarding.; /// vmul d3, d0, d2; /// vmla d3, d1, d2; /// is faster than; /// vadd d3, d0, d1; /// vmul d3, d3, d2; // However, for (A + B) * (A + B),; // vadd d2, d0, d1; // vmul d3, d0, d2; // vmla d3, d1, d2; // is slower than; // vadd d2, d0, d1; // vmul d3, d2, d2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:4,Perform,PerformVMULCombine,4,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Perform'],['PerformVMULCombine']
Performance,/// Performs C++ zero-initialization procedure on the region of memory; /// represented by \p loc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h:4,Perform,Performs,4,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,1,['Perform'],['Performs']
Performance,/// Performs Loop Idiom Recognize Pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopIdiomRecognize.h,1,['Perform'],['Performs']
Performance,/// Performs Loop Inst Simplify Pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopInstSimplify.h,1,['Perform'],['Performs']
Performance,/// Performs Loop Invariant Code Motion Pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,1,['Perform'],['Performs']
Performance,/// Performs Loop Predication Pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPredication.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPredication.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPredication.h,1,['Perform'],['Performs']
Performance,/// Performs Loop Strength Reduce Pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopStrengthReduce.h,1,['Perform'],['Performs']
Performance,/// Performs LoopNest Invariant Code Motion Pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LICM.h,1,['Perform'],['Performs']
Performance,/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing one of the operands.; /// \param __Y; /// An unsigned 64-bit integer containing one of the operands.; /// \returns An unsigned 64-bit integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see _andn_u64,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,1,['Perform'],['Performs']
Performance,/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned integer containing one of the operands.; /// \param __Y; /// An unsigned integer containing one of the operands.; /// \returns An unsigned integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see _andn_u32,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,1,['Perform'],['Performs']
Performance,"/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned int _andn_u32(unsigned int __X, unsigned int __Y);; /// \endcode; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned integer containing one of the operands.; /// \param __Y; /// An unsigned integer containing one of the operands.; /// \returns An unsigned integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see __andn_u32",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,1,['Perform'],['Performs']
Performance,"/// Performs a bitwise AND of the second operand with the one's; /// complement of the first operand.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _andn_u64(unsigned long long __X,; /// unsigned long long __Y);; /// \endcode; ///; /// This intrinsic corresponds to the \c ANDN instruction.; ///; /// \param __X; /// An unsigned 64-bit integer containing one of the operands.; /// \param __Y; /// An unsigned 64-bit integer containing one of the operands.; /// \returns An unsigned 64-bit integer containing the bitwise AND of the second; /// operand with the one's complement of the first operand.; /// \see __andn_u64",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/bmiintrin.h,1,['Perform'],['Performs']
Performance,"/// Performs a bitwise AND of two 256-bit vectors of [4 x double], using; /// the one's complement of the values contained in the first source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDNPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing the left source operand. The; /// one's complement of this value is used in the bitwise AND.; /// \param __b; /// A 256-bit vector of [4 x double] containing the right source operand.; /// \returns A 256-bit vector of [4 x double] containing the bitwise AND of the; /// values of the second operand and the one's complement of the first; /// operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Perform'],['Performs']
Performance,"/// Performs a bitwise AND of two 256-bit vectors of [8 x float], using; /// the one's complement of the values contained in the first source operand.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDNPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing the left source operand. The; /// one's complement of this value is used in the bitwise AND.; /// \param __b; /// A 256-bit vector of [8 x float] containing the right source operand.; /// \returns A 256-bit vector of [8 x float] containing the bitwise AND of the; /// values of the second operand and the one's complement of the first; /// operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Perform'],['Performs']
Performance,/// Performs a bitwise AND of two 256-bit vectors of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VANDPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \returns A 256-bit vector of [8 x float] containing the bitwise AND of the; /// values between both operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Perform'],['Performs']
Performance,/// Performs a bitwise AND of two 64-bit integer vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PAND </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise AND of both; /// parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h,1,['Perform'],['Performs']
Performance,"/// Performs a bitwise NOT of the first 64-bit integer vector, and then; /// performs a bitwise AND of the intermediate result and the second 64-bit; /// integer vector.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PANDN </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector. The one's complement of this parameter is used; /// in the bitwise AND.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise AND of the second; /// parameter and the one's complement of the first parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h,2,"['Perform', 'perform']","['Performs', 'performs']"
Performance,/// Performs a bitwise OR of two 256-bit vectors of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VORPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \returns A 256-bit vector of [4 x double] containing the bitwise OR of the; /// values between both operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Perform'],['Performs']
Performance,/// Performs a bitwise OR of two 256-bit vectors of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VORPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \returns A 256-bit vector of [8 x float] containing the bitwise OR of the; /// values between both operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Perform'],['Performs']
Performance,/// Performs a bitwise OR of two 64-bit integer vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> POR </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise OR of both; /// parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h,1,['Perform'],['Performs']
Performance,/// Performs a bitwise XOR of two 256-bit vectors of [4 x double].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VXORPD </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [4 x double] containing one of the source operands.; /// \returns A 256-bit vector of [4 x double] containing the bitwise XOR of the; /// values between both operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Perform'],['Performs']
Performance,/// Performs a bitwise XOR of two 256-bit vectors of [8 x float].; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VXORPS </c> instruction.; ///; /// \param __a; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \param __b; /// A 256-bit vector of [8 x float] containing one of the source operands.; /// \returns A 256-bit vector of [8 x float] containing the bitwise XOR of the; /// values between both operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/avxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/avxintrin.h,1,['Perform'],['Performs']
Performance,/// Performs a bitwise exclusive OR of two 64-bit integer vectors.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> PXOR </c> instruction.; ///; /// \param __m1; /// A 64-bit integer vector.; /// \param __m2; /// A 64-bit integer vector.; /// \returns A 64-bit integer vector containing the bitwise exclusive OR of both; /// parameters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/mmintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/mmintrin.h,1,['Perform'],['Performs']
Performance,"/// Performs a check of floating point class property, defined by IEEE-754.; /// The first operand is the floating point value to check. The second operand; /// specifies the checked property and is a TargetConstant which specifies; /// test in the same way as intrinsic 'is_fpclass'.; /// Returns boolean value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Perform'],['Performs']
Performance,/// Performs a few simplifications for operators which are associative; /// or commutative.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,1,['Perform'],['Performs']
Performance,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,1,['Perform'],['Performs']
Performance,/// Performs a full or partial save of processor state to the memory at; /// \a __p. The exact state saved depends on the 64-bit mask \a __m and; /// processor control register \c XCR0.; ///; /// \code{.operation}; /// mask[62:0] := __m[62:0] AND XCR0[62:0]; /// FOR i := 0 TO 62; /// IF mask[i] == 1; /// CASE (i) OF; /// 0: save X87 FPU state; /// 1: save SSE state; /// DEFAULT: __p.Ext_Save_Area[i] := ProcessorState[i]; /// FI; /// ENDFOR; /// __p.Header.XSTATE_BV[62:0] := INIT_FUNCTION(mask[62:0]); /// \endcode; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c XSAVEC64 instruction.; ///; /// \param __p; /// Pointer to the save area; must be 64-byte aligned.; /// \param __m; /// A 64-bit mask indicating what state should be saved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/xsavecintrin.h,1,['Perform'],['Performs']
Performance,/// Performs a full virtual base adjustment. Used to dereference; /// pointers to members of virtual bases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['Perform'],['Performs']
Performance,"/// Performs a post-encoding step on a `LD` or `ST` instruction.; ///; /// The encoding of the LD/ST family of instructions is inconsistent w.r.t; /// the pointer register and the addressing mode.; ///; /// The permutations of the format are as followed:; /// ld Rd, X `1001 000d dddd 1100`; /// ld Rd, X+ `1001 000d dddd 1101`; /// ld Rd, -X `1001 000d dddd 1110`; ///; /// ld Rd, Y `1000 000d dddd 1000`; /// ld Rd, Y+ `1001 000d dddd 1001`; /// ld Rd, -Y `1001 000d dddd 1010`; ///; /// ld Rd, Z `1000 000d dddd 0000`; /// ld Rd, Z+ `1001 000d dddd 0001`; /// ld Rd, -Z `1001 000d dddd 0010`; /// ^; /// |; /// Note this one inconsistent bit - it is 1 sometimes and 0 at other times.; /// There is no logical pattern. Looking at a truth table, the following; /// formula can be derived to fit the pattern:; //; /// ```; /// inconsistent_bit = is_predec OR is_postinc OR is_reg_x; /// ```; //; /// We manually set this bit in this post encoder method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp:4,Perform,Performs,4,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRMCCodeEmitter.cpp,1,['Perform'],['Performs']
Performance,/// Performs a simple check to see if From type can be converted to To type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaFixItUtils.h:4,Perform,Performs,4,interpreter/llvm-project/clang/include/clang/Sema/SemaFixItUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaFixItUtils.h,1,['Perform'],['Performs']
Performance,"/// Performs a single round of AES decryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESDEC </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the decrypted value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,1,['Perform'],['Performs']
Performance,"/// Performs a single round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENC </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,1,['Perform'],['Performs']
Performance,"/// Performs a target specific test of a floating point value for things; /// like IsNaN, Infinity, ... Nullptr is returned if no implementation; /// exists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,1,['Perform'],['Performs']
Performance,/// Performs aggregate initialization.; /// \param N Number of reduction item in the common list.; /// \param PrivateAddr Address of the corresponding private item.; /// \param SharedAddr Address of the original shared variable.; /// \param DRD Declare reduction construct used for reduction item.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,1,['Perform'],['Performs']
Performance,/// Performs an action for every DeclContext that is identified as; /// corresponding (either by forced origin or by name lookup) to DC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTMerger.h:4,Perform,Performs,4,interpreter/llvm-project/clang/include/clang/AST/ExternalASTMerger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTMerger.h,1,['Perform'],['Performs']
Performance,"/// Performs an async lookup for the given symbols in each of the given; /// JITDylibs, calling the given handler once all lookups have completed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['Perform'],['Performs']
Performance,"/// Performs an imprecise lookup of a dependent name in this class.; ///; /// This function does not follow strict semantic rules and should be used; /// only when lookup rules can be relaxed, e.g. indexing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:4,Perform,Performs,4,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['Perform'],['Performs']
Performance,"/// Performs an intermediate calculation for deriving the next four SHA-1; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the derived SHA-1; /// elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h,1,['Perform'],['Performs']
Performance,"/// Performs an intermediate calculation for deriving the next four SHA-256; /// message elements using previous message elements from the 128-bit; /// vectors of [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG1 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message elements.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h,1,['Perform'],['Performs']
Performance,/// Performs basic CFG simplifications to assist other loop passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopSimplifyCFG.h,1,['Perform'],['Performs']
Performance,"/// Performs dataflow analysis and returns a mapping from basic block IDs to; /// dataflow analysis states that model the respective basic blocks. Indices of; /// the returned vector correspond to basic block IDs. Returns an error if the; /// dataflow analysis cannot be performed successfully. Otherwise, calls; /// `PostVisitCFG` on each CFG element with the final analysis results at that; /// program point.; ///; /// `MaxBlockVisits` caps the number of block visits during analysis. It doesn't; /// distinguish between repeat visits to the same block and visits to distinct; /// blocks. This parameter is a backstop to prevent infinite loops, in the case; /// of bugs in the lattice and/or transfer functions that prevent the analysis; /// from converging.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.h:4,Perform,Performs,4,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/TypeErasedDataflowAnalysis.h,2,"['Perform', 'perform']","['Performs', 'performed']"
Performance,"/// Performs dataflow analysis and returns a mapping from basic block IDs to; /// dataflow analysis states that model the respective basic blocks. The; /// returned vector, if any, will have the same size as the number of CFG; /// blocks, with indices corresponding to basic block IDs. Returns an error if; /// the dataflow analysis cannot be performed successfully. Otherwise, calls; /// `PostVisitCFG` on each CFG element with the final analysis results at that; /// program point.; ///; /// `MaxBlockVisits` caps the number of block visits during analysis. See; /// `runTypeErasedDataflowAnalysis` for a full description. The default value is; /// essentially arbitrary -- large enough to accommodate what seems like any; /// reasonable CFG, but still small enough to limit the cost of hitting the; /// limit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h:4,Perform,Performs,4,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,2,"['Perform', 'perform']","['Performs', 'performed']"
Performance,/// Performs final cleanup after expansion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['Perform'],['Performs']
Performance,/// Performs flags lookup by calling findSymbolInLogicalDylib and; /// returning the flags value for that symbol.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,2,['Perform'],['Performs']
Performance,"/// Performs four iterations of the inner loop of the SHA-1 message digest; /// algorithm using the starting SHA-1 state (A, B, C, D) from the 128-bit; /// vector of [4 x i32] in \a V1 and the next four 32-bit elements of the; /// message from the 128-bit vector of [4 x i32] in \a V2. Note that the; /// SHA-1 state variable E must have already been added to \a V2; /// (\c _mm_sha1nexte_epu32() can perform this step). Returns the updated; /// SHA-1 state (A, B, C, D) as a 128-bit vector of [4 x i32].; ///; /// The SHA-1 algorithm has an inner loop of 80 iterations, twenty each; /// with a different combining function and rounding constant. This; /// intrinsic performs four iterations using a combining function and; /// rounding constant selected by \a M[1:0].; ///; /// \headerfile <immintrin.h>; ///; /// \code; /// __m128i _mm_sha1rnds4_epu32(__m128i V1, __m128i V2, const int M);; /// \endcode; ///; /// This intrinsic corresponds to the \c SHA1RNDS4 instruction.; ///; /// \param V1; /// A 128-bit vector of [4 x i32] containing the initial SHA-1 state.; /// \param V2; /// A 128-bit vector of [4 x i32] containing the next four elements of; /// the message, plus SHA-1 state variable E.; /// \param M; /// An immediate value where bits [1:0] select among four possible; /// combining functions and rounding constants (not specified here).; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h,3,"['Perform', 'perform']","['Performs', 'perform', 'performs']"
Performance,/// Performs initialization of the private copy for the reduction item.; /// \param N Number of the reduction item.; /// \param PrivateAddr Address of the corresponding private item.; /// \param DefaultInit Default initialization sequence that should be; /// performed if no reduction specific initialization is found.; /// \param SharedAddr Address of the original shared variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.h,2,"['Perform', 'perform']","['Performs', 'performed']"
Performance,"/// Performs lookup by, for each symbol, first calling; /// findSymbolInLogicalDylib and if that fails calling; /// findSymbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITSymbol.h,2,['Perform'],['Performs']
Performance,"/// Performs matrix transposition on a 4x4 matrix \p InputVectors and; /// returns the transposed-vectors in \p TransposedVectors.; /// E.g.; /// InputVectors:; /// In-V0 = p1, p2, p3, p4; /// In-V1 = q1, q2, q3, q4; /// In-V2 = r1, r2, r3, r4; /// In-V3 = s1, s2, s3, s4; /// OutputVectors:; /// Out-V0 = p1, q1, r1, s1; /// Out-V1 = p2, q2, r2, s2; /// Out-V2 = p3, q3, r3, s3; /// Out-V3 = P4, q4, r4, s4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:4,Perform,Performs,4,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,1,['Perform'],['Performs']
Performance,"/// Performs name lookup for a name that was parsed in the; /// source code, and may contain a C++ scope specifier.; ///; /// This routine is a convenience routine meant to be called from; /// contexts that receive a name and an optional C++ scope specifier; /// (e.g., ""N::M::x""). It will then perform either qualified or; /// unqualified name lookup (with LookupQualifiedName or LookupName,; /// respectively) on the given name and return those results. It will; /// perform a special type of lookup for ""__super::"" scope specifier.; ///; /// @param S The scope from which unqualified name lookup will; /// begin.; ///; /// @param SS An optional C++ scope-specifier, e.g., ""::N::M"".; ///; /// @param EnteringContext Indicates whether we are going to enter the; /// context of the scope-specifier SS (if present).; ///; /// @returns True if any decls were found (but possibly ambiguous)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,3,"['Perform', 'perform']","['Performs', 'perform']"
Performance,"/// Performs operation and \returns its result or an error in case of failure,; /// such as if an overflow occurs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['Perform'],['Performs']
Performance,"/// Performs promotions, truncations and conversions of the given set.; ///; /// This function is optimized for each of the six cast cases:; /// - noop; /// - conversion; /// - truncation; /// - truncation-conversion; /// - promotion; /// - promotion-conversion; ///; /// NOTE: This function is NOT self-inverse for truncations, because of; /// the higher bits loss:; /// - castTo(castTo(OrigRangeOfInt, char), int) != OrigRangeOfInt.; /// - castTo(castTo(OrigRangeOfChar, int), char) == OrigRangeOfChar.; /// But it is self-inverse for all the rest casts.; ///; /// Complexity:; /// - Noop O(1);; /// - Truncation O(N^2);; /// - Another case O(N);; /// where N = size(What)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h:4,Perform,Performs,4,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/RangedConstraintManager.h,2,"['Perform', 'optimiz']","['Performs', 'optimized']"
Performance,"/// Performs qualified name lookup or special type of lookup for; /// ""__super::"" scope specifier.; ///; /// This routine is a convenience overload meant to be called from contexts; /// that need to perform a qualified name lookup with an optional C++ scope; /// specifier that might require special kind of lookup.; ///; /// \param R captures both the lookup criteria and any lookup results found.; ///; /// \param LookupCtx The context in which qualified name lookup will; /// search.; ///; /// \param SS An optional C++ scope-specifier.; ///; /// \returns true if lookup succeeded, false if it failed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,2,"['Perform', 'perform']","['Performs', 'perform']"
Performance,/// Performs target lowering for the AVR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.h,1,['Perform'],['Performs']
Performance,/// Performs template instantiation for all implicit template; /// instantiations we have seen until this point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['Perform'],['Performs']
Performance,"/// Performs the ""real"" scheduling. Done before vectorization is actually; /// performed in a basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:4,Perform,Performs,4,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,"['Perform', 'perform']","['Performs', 'performed']"
Performance,"/// Performs the Anderson-Darling 2-Sample Test.; /// The Anderson-Darling K-Sample Test algorithm is described and taken from; /// http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; /// and from; /// (1) Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918–924.; /// (2-samples variant implemented).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GoFTest.h:4,Perform,Performs,4,math/mathcore/inc/Math/GoFTest.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/GoFTest.h,1,['Perform'],['Performs']
Performance,"/// Performs the CFG manipulation part of versioning the loop including; /// the DominatorTree and LoopInfo updates.; ///; /// The loop that was used to construct the class will be the ""versioned"" loop; /// i.e. the loop that will receive control if all the memchecks pass.; ///; /// This allows the loop transform pass to operate on the same loop regardless; /// of whether versioning was necessary or not:; ///; /// for each loop L:; /// analyze L; /// if versioning is necessary version L; /// transform L",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopVersioning.h,1,['Perform'],['Performs']
Performance,"/// Performs the Request, passing response data to the Handler. Returns all; /// errors which occur during the request. Aborts if an error is returned by a; /// Handler method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,1,['Perform'],['Performs']
Performance,/// Performs the actual expansion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['Perform'],['Performs']
Performance,/// Performs the actual liveness calculation for the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp:4,Perform,Performs,4,interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackMapLivenessAnalysis.cpp,2,['Perform'],['Performs']
Performance,/// Performs the actual work of attaching the given base class; /// specifiers to a C++ class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Perform'],['Performs']
Performance,/// Performs the annotation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['Perform'],['Performs']
Performance,/// Performs the code-generation required to convert a return; /// address as stored by the system into the actual address of the; /// next instruction that will be executed.; ///; /// Used by __builtin_extract_return_addr().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,1,['Perform'],['Performs']
Performance,/// Performs the code-generation required to convert the address; /// of an instruction into a return address suitable for storage; /// by the system in a return slot.; ///; /// Used by __builtin_frob_return_addr().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,1,['Perform'],['Performs']
Performance,/// Performs the combined functionality of DecRef and StopTrackingHard.; ///; /// The models the effect that the called function decrements the reference; /// count of the argument and all typestate tracking on that argument; /// should cease.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h:4,Perform,Performs,4,interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,1,['Perform'],['Performs']
Performance,"/// Performs the final calculation for deriving the next four SHA-1 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA1MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h,1,['Perform'],['Performs']
Performance,"/// Performs the final calculation for deriving the next four SHA-256 message; /// elements using previous message elements from the 128-bit vectors of; /// [4 x i32] in \a __X and \a __Y, and returns the result.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256MSG2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing an intermediate result.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing previous message values.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-256; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h,1,['Perform'],['Performs']
Performance,"/// Performs the final round of AES decryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESDECLAST </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the decrypted value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,1,['Perform'],['Performs']
Performance,"/// Performs the final round of AES encryption using the Equivalent; /// Inverse Cipher, transforming the state value from the first source; /// operand using a 128-bit round key value contained in the second source; /// operand, and writes the result to the destination.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the <c> VAESENCLAST </c> instruction.; ///; /// \param __V; /// A 128-bit integer vector containing the state value.; /// \param __R; /// A 128-bit integer vector containing the round key value.; /// \returns A 128-bit integer vector containing the encrypted value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__wmmintrin_aes.h,1,['Perform'],['Performs']
Performance,"/// Performs the initial survey of the specified function, checking out whether; /// it uses any of its incoming arguments or whether any callers use the return; /// value. This fills in the LiveValues set and Uses map.; ///; /// We consider arguments of non-internal functions to be intrinsically alive as; /// well as arguments to functions which have their ""address taken"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:4,Perform,Performs,4,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['Perform'],['Performs']
Performance,/// Performs the operation associated with this visitor object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeVisitor.h:4,Perform,Performs,4,interpreter/llvm-project/clang/include/clang/AST/TypeVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TypeVisitor.h,1,['Perform'],['Performs']
Performance,/// Performs the set intersection between this set and \p RHS. Returns true if; /// changes were made.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['Perform'],['Performs']
Performance,/// Performs the set union between this set and \p RHS. Returns true if; /// changes were made.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:4,Perform,Performs,4,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['Perform'],['Performs']
Performance,/// Performs this pass,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:4,Perform,Performs,4,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['Perform'],['Performs']
Performance,"/// Performs two rounds of SHA-256 operation using the following inputs: a; /// starting SHA-256 state (C, D, G, H) from the 128-bit vector of; /// [4 x i32] in \a __X; a starting SHA-256 state (A, B, E, F) from the; /// 128-bit vector of [4 x i32] in \a __Y; and a pre-computed sum of the; /// next two message elements (unsigned 32-bit integers) and corresponding; /// rounding constants from the 128-bit vector of [4 x i32] in \a __Z.; /// Returns the updated SHA-256 state (A, B, E, F) as a 128-bit vector of; /// [4 x i32].; ///; /// The SHA-256 algorithm has a core loop of 64 iterations. This intrinsic; /// performs two of those iterations.; ///; /// \headerfile <immintrin.h>; ///; /// This intrinsic corresponds to the \c SHA256RNDS2 instruction.; ///; /// \param __X; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Y; /// A 128-bit vector of [4 x i32] containing part of the initial SHA-256; /// state.; /// \param __Z; /// A 128-bit vector of [4 x i32] containing additional input to the; /// SHA-256 operation.; /// \returns A 128-bit vector of [4 x i32] containing the updated SHA-1 state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h:4,Perform,Performs,4,interpreter/llvm-project/clang/lib/Headers/shaintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/shaintrin.h,2,"['Perform', 'perform']","['Performs', 'performs']"
Performance,"/// Perhaps branch folding, tail merging and other CFG optimizations on the; /// given function. Block placement changes the layout and may create new; /// tail merging opportunities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h:55,optimiz,optimizations,55,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.h,1,['optimiz'],['optimizations']
Performance,"/// Permanently loads the library at the given path and, on success, returns; /// a DynamicLibrarySearchGenerator that will search it for symbol definitions; /// in the library. On failure returns the reason the library failed to load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.h:16,load,loads,16,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.h,4,['load'],"['load', 'loads']"
Performance,"/// Permanently loads the library at the given path and, on success, returns; /// a DynamicLibrarySearchGenerator that will search it for symbol definitions; /// in the library. On failure returns the reason the library failed to load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:16,load,loads,16,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,2,['load'],"['load', 'loads']"
Performance,/// Pick the best candidate from the queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:37,queue,queue,37,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,"['cache', 'queue']","['cached', 'queue']"
Performance,/// Pick the best candidate from the top queue.; ///; /// TODO: getMaxPressureDelta results can be mostly cached for each SUnit during; /// DAG building. To adjust for the current scheduling location we need to; /// maintain the number of vreg uses remaining to be top-scheduled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:41,queue,queue,41,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,2,"['cache', 'queue']","['cached', 'queue']"
Performance,/// Pick the best candidate node from either the top or bottom queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:63,queue,queue,63,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['queue'],['queue']
Performance,"/// Please use getIRPGOFuncName for LLVM IR instrumentation. This function is; /// for front-end (Clang, etc) instrumentation.; /// Return the modified name for function \c F suitable to be; /// used the key for profile lookup. Variable \c InLTO indicates if this; /// is called in LTO optimization passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:286,optimiz,optimization,286,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,1,['optimiz'],['optimization']
Performance,"/// Plotting engine function for internal use; ///; /// Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; /// function that occur in the previously plotted dataset are projected via partial integration,; /// otherwise no projections are performed. Optionally, certain projections can be performed; /// by summing over the values present in a provided dataset ('projData'), to correctly; /// project out data dependents that are not properly described by the PDF (e.g. per-event errors).; ///; /// The functions value can be multiplied with an optional scale factor. The interpretation; /// of the scale factor is unique for generic real functions, for PDFs there are various interpretations; /// possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; ///; /// The default projection behaviour can be overridden by supplying an optional set of dependents; /// to project via RooFit command arguments.; //_____________________________________________________________________________; // coverity[PASS_BY_VALUE]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:280,perform,performed,280,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['perform'],['performed']
Performance,"/// Plugin instances can be added to the ObjectLinkingLayer to receive; /// callbacks when code is loaded or emitted, and when JITLink is being; /// configured.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h:99,load,loaded,99,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h,1,['load'],['loaded']
Performance,/// Pointer to the cached tokens for an exception-specification; /// that has not yet been parsed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:19,cache,cached,19,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,1,['cache'],['cached']
Performance,/// Pointer value of all participation load instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:39,load,load,39,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['load'],['load']
Performance,/// Policy for the pruneCache() function. A default constructed; /// CachePruningPolicy provides a reasonable default policy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:69,Cache,CachePruningPolicy,69,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,1,['Cache'],['CachePruningPolicy']
Performance,"/// Populate the edges of this node if necessary.; ///; /// The first time this is called it will populate the edges for this node; /// in the graph. It does this by scanning the underlying function, so once; /// this is done, any changes to that function must be explicitly reflected; /// in updates to the graph.; ///; /// \returns the populated \c EdgeSequence to simplify walking it.; ///; /// This will not update or re-scan anything if called repeatedly. Instead,; /// the edge sequence is cached and returned immediately on subsequent; /// calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:496,cache,cached,496,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['cache'],['cached']
Performance,"/// Populate the index above to enable lazily loading of metadata, and load; /// the named metadata as well as the transitively referenced global; /// Metadata.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:46,load,loading,46,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,2,['load'],"['load', 'loading']"
Performance,"/// Populated by LoadStructureImpl(), reset at the end of Attach()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx:17,Load,LoadStructureImpl,17,tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorageFile.hxx,1,['Load'],['LoadStructureImpl']
Performance,"/// Populates all the pages of the given cluster ids and columns; it is possible that some columns do not; /// contain any pages. The page source may load more columns than the minimal necessary set from `columns`.; /// To indicate which columns have been loaded, `LoadClusters()`` must mark them with `SetColumnAvailable()`.; /// That includes the ones from the `columns` that don't have pages; otherwise subsequent requests; /// for the cluster would assume an incomplete cluster and trigger loading again.; /// `LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs; /// concurrently to other methods of the page source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:150,load,load,150,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,6,"['Load', 'concurren', 'load']","['LoadClusters', 'concurrently', 'load', 'loaded', 'loading']"
Performance,/// Post- register allocation pass the combine load / store instructions to; /// form ldm / stm instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:47,load,load,47,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['load'],['load']
Performance,/// Post-process the DAG to create cluster edges between neighboring; /// loads or between neighboring stores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:74,load,loads,74,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['load'],['loads']
Performance,"/// Post-visit the Statement.; ///; /// The method will be called after the analyzer core processes the; /// statement. The notification is performed for every explored CFGElement,; /// which does not include the control flow statements such as IfStmt. The; /// callback can be specialized to be called with any subclass of Stmt.; ///; /// check::PostStmt<DeclStmt>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:140,perform,performed,140,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,1,['perform'],['performed']
Performance,/// PostRAScheduler - This pass performs post register allocation; /// scheduling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:32,perform,performs,32,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['perform'],['performs']
Performance,/// PostprocessISelDAG - Perform some late peephole optimizations; /// on the DAG representation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:25,Perform,Perform,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,2,"['Perform', 'optimiz']","['Perform', 'optimizations']"
Performance,"/// PragmaOptimizeHandler - ""\#pragma clang optimize on/off"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:44,optimiz,optimize,44,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,1,['optimiz'],['optimize']
Performance,/// Pre- register allocation pass that move load / stores from consecutive; /// locations close to make it more likely they will be combined later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:44,load,load,44,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['load'],['load']
Performance,"/// Pre-fixup passes.; ///; /// These passes are called on the graph after memory has been allocated,; /// content copied into working memory, and all nodes (including externals); /// have been assigned their final addresses, but before any fixups have been; /// applied.; ///; /// Notable use cases: Late link-time optimizations like GOT and stub; /// elimination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:316,optimiz,optimizations,316,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['optimiz'],['optimizations']
Performance,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:14,load,loads,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,6,['load'],"['load', 'loads']"
Performance,"/// Pre-visit the Statement.; ///; /// The method will be called before the analyzer core processes the; /// statement. The notification is performed for every explored CFGElement,; /// which does not include the control flow statements such as IfStmt. The; /// callback can be specialized to be called with any subclass of Stmt.; ///; /// See checkBranchCondition() callback for performing custom processing of; /// the branching statements.; ///; /// check::PreStmt<ReturnStmt>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp:140,perform,performed,140,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckerDocumentation.cpp,2,['perform'],"['performed', 'performing']"
Performance,/// Precomputed values of log2(x). Table size is small enough to fit in cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h:72,cache,cache,72,interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,1,['cache'],['cache']
Performance,/// PredIteratorCache - This class is an extremely trivial cache for; /// predecessor iterator queries. This is useful for code that repeatedly; /// wants the predecessor list for the same blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h:59,cache,cache,59,interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PredIteratorCache.h,1,['cache'],['cache']
Performance,/// Predicate for distinguishing instructions that are hazardous in a load delay; /// slot. Consider inline assembly as unsafe as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:70,load,load,70,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,1,['load'],['load']
Performance,/// Predicate for distingushing instructions that have load delay slots.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:55,load,load,55,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,1,['load'],['load']
Performance,/// Predicate to determine if an instruction can go in a load delay slot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:57,load,load,57,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,1,['load'],['load']
Performance,/// Predicate to determine if an instruction has a load delay slot.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:51,load,load,51,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,1,['load'],['load']
Performance,"/// Prepare a page range read for the column set in `clusterKey`. Specifically, pages referencing the; /// `kTypePageZero` locator are filled in `pageZeroMap`; otherwise, `perPageFunc` is called for each page. This is; /// commonly used as part of `LoadClusters()` in derived classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:249,Load,LoadClusters,249,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['Load'],['LoadClusters']
Performance,"/// Prepares for a scalar cast, performing all the necessary stages; /// except the final cast and returning the kind required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:32,perform,performing,32,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['perform'],['performing']
Performance,/// Prepares to perform scheduling in the given block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:16,perform,perform,16,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['perform'],['perform']
Performance,/// Preprocessor-based frontend action that also loads PCH files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendActions.h:49,load,loads,49,interpreter/llvm-project/clang/include/clang/Frontend/FrontendActions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendActions.h,1,['load'],['loads']
Performance,/// Print out the values currently in the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:42,cache,cache,42,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,1,['cache'],['cache']
Performance,/// Printer pass for the \c CacheCost results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:28,Cache,CacheCost,28,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['Cache'],['CacheCost']
Performance,"/// Process a variable in the computation graph. This is a separate non-inlined; /// function such that we can see in performance profiles how long this takes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx:118,perform,performance,118,roofit/roofitcore/src/RooFit/Evaluator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFit/Evaluator.cxx,1,['perform'],['performance']
Performance,"/// Produce a merge of values in \p VRegs to define \p DstReg. Perform a merge; /// from the least common multiple type, and convert as appropriate to \p; /// DstReg.; ///; /// \p VRegs should each have type \p GCDTy. This type should be greatest; /// common divisor type of \p DstReg, \p NarrowTy, and an undetermined source; /// type.; ///; /// \p NarrowTy is the desired result merge source type. If the source value; /// needs to be widened to evenly cover \p DstReg, inserts high bits; /// corresponding to the extension opcode \p PadStrategy.; ///; /// \p VRegs will be cleared, and the result \p NarrowTy register pieces; /// will replace it. Returns The complete LCMTy that \p VRegs will cover when; /// merged.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h:63,Perform,Perform,63,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,1,['Perform'],['Perform']
Performance,"/// Produce a unique identifier for this module by taking the MD5 sum of; /// the names of the module's strong external symbols that are not comdat; /// members.; ///; /// This identifier is normally guaranteed to be unique, or the program would; /// fail to link due to multiply defined symbols.; ///; /// If the module has no strong external symbols (such a module may still have a; /// semantic effect if it performs global initialization), we cannot produce a; /// unique identifier for this module, so we return the empty string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:411,perform,performs,411,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,1,['perform'],['performs']
Performance,/// Produce the expression describing the \p MI loading a value into; /// the physical register \p Reg. This hook should only be used with; /// \p MIs belonging to VReg-less functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:48,load,loading,48,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['load'],['loading']
Performance,/// Produces a container ordering for optimal multi-threaded processing. Returns; /// ordered indices to elements in the input array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h:46,multi-thread,multi-threaded,46,interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,1,['multi-thread'],['multi-threaded']
Performance,"/// Promote the operands to the wider of the types using zero-extension, and; /// then perform a umax operation with them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:87,perform,perform,87,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['perform'],['perform']
Performance,"/// Promote the operands to the wider of the types using zero-extension, and; /// then perform a umin operation with them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:87,perform,perform,87,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['perform'],['perform']
Performance,"/// Promote the operands to the wider of the types using zero-extension, and; /// then perform a umin operation with them. N-ary function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:87,perform,perform,87,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['perform'],['perform']
Performance,"/// Promotes a single user of the alloca to a vector form.; ///; /// \param Inst Instruction to be promoted.; /// \param DL Module Data Layout.; /// \param VectorTy Vectorized Type.; /// \param VecStoreSize Size of \p VectorTy in bytes.; /// \param ElementSize Size of \p VectorTy element type in bytes.; /// \param TransferInfo MemTransferInst info map.; /// \param GEPVectorIdx GEP -> VectorIdx cache.; /// \param CurVal Current value of the vector (e.g. last stored value); /// \param[out] DeferredLoads \p Inst is added to this vector if it can't; /// be promoted now. This happens when promoting requires \p; /// CurVal, but \p CurVal is nullptr.; /// \return the stored value if \p Inst would have written to the alloca, or; /// nullptr otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp:397,cache,cache,397,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPromoteAlloca.cpp,1,['cache'],['cache']
Performance,"/// Promotes interesting constant into global variables.; /// The motivating example is:; /// static const uint16_t TableA[32] = {; /// 41944, 40330, 38837, 37450, 36158, 34953, 33826, 32768,; /// 31776, 30841, 29960, 29128, 28340, 27595, 26887, 26215,; /// 25576, 24967, 24386, 23832, 23302, 22796, 22311, 21846,; /// 21400, 20972, 20561, 20165, 19785, 19419, 19066, 18725,; /// };; ///; /// uint8x16x4_t LoadStatic(void) {; /// uint8x16x4_t ret;; /// ret.val[0] = vld1q_u16(TableA + 0);; /// ret.val[1] = vld1q_u16(TableA + 8);; /// ret.val[2] = vld1q_u16(TableA + 16);; /// ret.val[3] = vld1q_u16(TableA + 24);; /// return ret;; /// }; ///; /// The constants in this example are folded into the uses. Thus, 4 different; /// constants are created.; ///; /// As their type is vector the cheapest way to create them is to load them; /// for the memory.; ///; /// Therefore the final assembly final has 4 different loads. With this pass; /// enabled, only one load is issued for the constants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp:406,Load,LoadStatic,406,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PromoteConstant.cpp,4,"['Load', 'load']","['LoadStatic', 'load', 'loads']"
Performance,/// Propagate variable values to blocks in the common case where there's; /// only one value assigned to the variable. This function has better; /// performance as it doesn't have to find the dominance frontier between; /// different assignments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:149,perform,performance,149,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['perform'],['performance']
Performance,"/// Propagates types, then perform type inference and do a second round of; /// propagation in the apply patterns only if any types were inferred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:27,perform,perform,27,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['perform'],['perform']
Performance,"/// Properties of the type that allow for optimizations of collections of that type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:42,optimiz,optimizations,42,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['optimiz'],['optimizations']
Performance,"/// Propgate synthetic entry counts on a callgraph \p CG.; ///; /// This performs a reverse post-order traversal of the callgraph SCC. For each; /// SCC, it first propagates the entry counts to the nodes within the SCC; /// through call edges and updates them in one shot. Then the entry counts are; /// propagated to nodes outside the SCC. This requires \p GraphTraits; /// to have a specialization for \p CallGraphType.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp:73,perform,performs,73,interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/SyntheticCountsUtils.cpp,1,['perform'],['performs']
Performance,"/// Protects the shared state between the main thread and the I/O thread, namely the work queue and the in-flight; /// clusters vector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:90,queue,queue,90,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,1,['queue'],['queue']
Performance,/// Provide a path to a directory where to store the cached files for; /// incremental build.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h:53,cache,cached,53,interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/legacy/ThinLTOCodeGenerator.h,1,['cache'],['cached']
Performance,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:353,load,load,353,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,4,['load'],"['load', 'loads']"
Performance,/// Provides access to the loaded XRay trace file header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h:27,load,loaded,27,interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/XRay/Trace.h,1,['load'],['loaded']
Performance,/// Provides an 'InsertHelper' that calls a user-provided callback after; /// performing the default insertion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:78,perform,performing,78,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['perform'],['performing']
Performance,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:507,concurren,concurrent,507,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,2,"['concurren', 'scalab']","['concurrent', 'scalable']"
Performance,/// Provides information about what library functions are available for; /// the current target.; ///; /// This both allows optimizations to handle them specially and frontends to; /// disable such optimizations through -fno-builtin etc.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:124,optimiz,optimizations,124,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,2,['optimiz'],['optimizations']
Performance,/// Prune the cache of files that haven't been accessed in a long time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp:14,cache,cache,14,interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp,1,['cache'],['cache']
Performance,/// Prune the module cache of modules that haven't been accessed in; /// a long time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:21,cache,cache,21,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['cache'],['cache']
Performance,"/// Pseudo value representing memory load performed to check an address.; ///; /// This load operation is solely used for its side-effects: if the address; /// is not mapped (or not readable), it triggers CPU exception, otherwise; /// execution proceeds and the value is not used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h:37,load,load,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,3,"['load', 'perform']","['load', 'performed']"
Performance,/// Public interface to the SanitizerBinaryMetadata module pass for emitting; /// metadata for binary analysis sanitizers.; //; /// The pass should be inserted after optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/SanitizerBinaryMetadata.h:166,optimiz,optimizations,166,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/SanitizerBinaryMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/SanitizerBinaryMetadata.h,1,['optimiz'],['optimizations']
Performance,"/// Push L to the bottom of the queue regardless of its weight. If L is; /// constant, it will not be folded with other constants in the queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:32,queue,queue,32,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,2,['queue'],['queue']
Performance,/// Queue - The queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:4,Queue,Queue,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,4,"['Queue', 'queue']","['Queue', 'queue']"
Performance,"/// Queue a cleanup to be pushed after finishing the current full-expression,; /// potentially with an active flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:4,Queue,Queue,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['Queue'],['Queue']
Performance,/// Queue a phi-node to be added to a basic-block for a specific Alloca.; ///; /// Returns true if there wasn't already a phi-node for that variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:4,Queue,Queue,4,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['Queue'],['Queue']
Performance,/// Queue of implicit template instantiations that cannot be performed; /// eagerly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Queue,Queue,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,"['Queue', 'perform']","['Queue', 'performed']"
Performance,/// Queue of pointer uses to analyze and potentially rewrite.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Queue,Queue,4,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['Queue'],['Queue']
Performance,/// Queue of tokens. This is required to queue up tokens while looking; /// for the end of a simple key. And for cases where a single character; /// can produce multiple tokens (e.g. BlockEnd).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:4,Queue,Queue,4,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,2,"['Queue', 'queue']","['Queue', 'queue']"
Performance,/// Queues an update to the topological ordering to accommodate an edge to; /// be added from SUnit \p X to SUnit \p Y.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:4,Queue,Queues,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['Queue'],['Queues']
Performance,"/// RAII class used to indicate that we are performing provisional; /// semantic analysis to determine the validity of a construct, so; /// typo-correction and diagnostics in the immediate context (not within; /// implicitly-instantiated templates) should be suppressed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:44,perform,performing,44,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,/// RAII object to indicate that codegen is copying the value representation; /// instead of the object representation. Useful when copying a struct or; /// class which has uninitialized members and we're only performing; /// lvalue-to-rvalue conversion on the object but not its members.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:210,perform,performing,210,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['perform'],['performing']
Performance,"/// READCYCLECOUNTER - This corresponds to the readcyclecounter intrinsic.; /// It produces a chain and one i64 value. The only operand is a chain.; /// If i64 is not legal, the result will be expanded into smaller values.; /// Still, it returns an i64, so targets should set legality for i64.; /// The result is the content of the architecture-specific cycle; /// counter-like register (or other high accuracy low latency clock source).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:415,latency,latency,415,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['latency'],['latency']
Performance,"/// RESULT = [US]ADDSAT(LHS, RHS) - Perform saturation addition on 2; /// integers with the same bit width (W). If the true value of LHS + RHS; /// exceeds the largest value that can be represented by W bits, the; /// resulting value is this maximum value. Otherwise, if this value is less; /// than the smallest value that can be represented by W bits, the; /// resulting value is this minimum value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:36,Perform,Perform,36,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Perform'],['Perform']
Performance,"/// RESULT = [US]DIVFIX(LHS, RHS, SCALE) - Perform fixed point division on; /// 2 integers with the same width and scale. SCALE represents the scale; /// of both operands as fixed point numbers. This SCALE parameter must be a; /// constant integer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:43,Perform,Perform,43,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Perform'],['Perform']
Performance,"/// RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication; /// on 2 integers with the same width and scale. SCALE represents the scale; /// of both operands as fixed point numbers. This SCALE parameter must be a; /// constant integer. A scale of zero is effectively performing; /// multiplication on 2 integers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:43,Perform,Perform,43,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,2,"['Perform', 'perform']","['Perform', 'performing']"
Performance,"/// RESULT = [US]SHLSAT(LHS, RHS) - Perform saturation left shift. The first; /// operand is the value to be shifted, and the second argument is the amount; /// to shift by. Both must be integers of the same bit width (W). If the true; /// value of LHS << RHS exceeds the largest value that can be represented by; /// W bits, the resulting value is this maximum value, Otherwise, if this; /// value is less than the smallest value that can be represented by W bits,; /// the resulting value is this minimum value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:36,Perform,Perform,36,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Perform'],['Perform']
Performance,"/// RESULT = [US]SUBSAT(LHS, RHS) - Perform saturation subtraction on 2; /// integers with the same bit width (W). If the true value of LHS - RHS; /// exceeds the largest value that can be represented by W bits, the; /// resulting value is this maximum value. Otherwise, if this value is less; /// than the smallest value that can be represented by W bits, the; /// resulting value is this minimum value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:36,Perform,Perform,36,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['Perform'],['Perform']
Performance,"/// RET instructions and also instructions that indirect calls/jumps from memory; /// combine a load and a branch within a single instruction. To mitigate these; /// instructions against LVI, they must be decomposed into separate load and; /// branch instructions, with an LFENCE in between. For more details, see:; /// - X86LoadValueInjectionRetHardening.cpp; /// - X86LoadValueInjectionIndirectThunks.cpp; /// - https://software.intel.com/security-software-guidance/insights/deep-dive-load-value-injection; ///; /// Returns `true` if a mitigation was applied or warning was emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:96,load,load,96,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,3,['load'],"['load', 'load-value-injection']"
Performance,/// Re-resolves the result kind of the lookup after a set of; /// removals has been performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:84,perform,performed,84,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['perform'],['performed']
Performance,"/// React on completion of multi-threaded send operation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowWSHandler.hxx:27,multi-thread,multi-threaded,27,gui/webdisplay/src/RWebWindowWSHandler.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowWSHandler.hxx,1,['multi-thread'],['multi-threaded']
Performance,/// Read a global index file for the given directory.; ///; /// \param Path The path to the specific module cache where the module files; /// for the intended configuration reside.; ///; /// \returns A pair containing the global module index (if it exists) and; /// the error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h:108,cache,cache,108,interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/GlobalModuleIndex.h,1,['cache'],['cache']
Performance,/// Read a preallocated preprocessed entity from the external source.; ///; /// \returns null if an error occurred that prevented the preprocessed; /// entity from being loaded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:170,load,loaded,170,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,2,['load'],['loaded']
Performance,/// Read all of the declarations lexically stored in a; /// declaration context.; ///; /// \param DC The declaration context whose declarations will be; /// read.; ///; /// \param IsKindWeWant A predicate indicating which declaration kinds; /// we are interested in.; ///; /// \param Decls Vector that will contain the declarations loaded; /// from the external source. The caller is responsible for merging; /// these declarations with any declarations already stored in the; /// declaration context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:332,load,loaded,332,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// Read the bitcode module and prepare for lazy deserialization of function; /// bodies. If ShouldLazyLoadMetadata is true, lazily load metadata as well.; /// If IsImporting is true, this module is being parsed for ThinLTO; /// importing into another module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:132,load,load,132,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,1,['load'],['load']
Performance,"/// Read the header of the specified bitcode buffer and prepare for lazy; /// deserialization of function bodies. If ShouldLazyLoadMetadata is true,; /// lazily load metadata as well. If IsImporting is true, this module is; /// being parsed for ThinLTO importing into another module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:161,load,load,161,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,1,['load'],['load']
Performance,"/// Read the packed and compressed bytes of a page into the memory buffer provided by `sealedPage`. The sealed page; /// can be used subsequently in a call to `RPageSink::CommitSealedPage`.; /// The `fSize` and `fNElements` member of the sealedPage parameters are always set. If `sealedPage.fBuffer` is; /// `nullptr`, no data will be copied but the returned size information can be used by the caller to allocate a large; /// enough buffer and call `LoadSealedPage` again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:451,Load,LoadSealedPage,451,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['Load'],['LoadSealedPage']
Performance,"/// Read the source location entry with index ID, which will always be; /// less than -1.; ///; /// \returns true if an error occurred that prevented the source-location; /// entry from being loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:192,load,loaded,192,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,"/// ReadOptionalMacroParameterListAndBody - This consumes all (i.e. the; /// entire line) of the macro's tokens and adds them to MacroInfo, and while; /// doing so performs certain validity checks including (but not limited to):; /// - # (stringization) is followed by a macro parameter; /// \param MacroNameTok - Token that represents the macro name; /// \param ImmediatelyAfterHeaderGuard - Macro follows an #ifdef header guard; ///; /// Either returns a pointer to a MacroInfo object OR emits a diagnostic and; /// returns a nullptr if an invalid sequence of tokens is encountered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:164,perform,performs,164,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['perform'],['performs']
Performance,"/// Reads 64-byte command pointed by \a __src, formats 64-byte enqueue store; /// data, and performs 64-byte enqueue store to memory pointed by \a __dst.; /// This intrinsics may only be used in User mode.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsics corresponds to the <c> ENQCMD </c> instruction.; ///; /// \param __dst; /// Pointer to the destination of the enqueue store.; /// \param __src; /// Pointer to 64-byte command data.; /// \returns If the command data is successfully written to \a __dst then 0 is; /// returned. Otherwise 1 is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h:92,perform,performs,92,interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h,1,['perform'],['performs']
Performance,"/// Reads 64-byte command pointed by \a __src, formats 64-byte enqueue store; /// data, and performs 64-byte enqueue store to memory pointed by \a __dst; /// This intrinsic may only be used in Privileged mode.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsics corresponds to the <c> ENQCMDS </c> instruction.; ///; /// \param __dst; /// Pointer to the destination of the enqueue store.; /// \param __src; /// Pointer to 64-byte command data.; /// \returns If the command data is successfully written to \a __dst then 0 is; /// returned. Otherwise 1 is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h:92,perform,performs,92,interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/enqcmdintrin.h,1,['perform'],['performs']
Performance,"/// Reads a given byte range from the file into the provided memory buffer.; /// If `nbytes > fMaxKeySize` it will perform chunked read from multiple blobs,; /// whose addresses are listed at the end of the first chunk.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx:115,perform,perform,115,tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RMiniFile.hxx,1,['perform'],['perform']
Performance,/// Reads the specified performance monitoring counter. Refer to your; /// processor's documentation to determine which performance counters are; /// supported.; ///; /// \headerfile <x86intrin.h>; ///; /// \code; /// unsigned long long _rdpmc(int A);; /// \endcode; ///; /// This intrinsic corresponds to the \c RDPMC instruction.; ///; /// \param A; /// The performance counter to read.; /// \returns The 64-bit value read from the performance counter.; /// \see __rdpmc,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h:24,perform,performance,24,interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/ia32intrin.h,4,['perform'],['performance']
Performance,"/// Real time spent preparing the multi-thread workload.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx:34,multi-thread,multi-thread,34,tree/readspeed/inc/ReadSpeed.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/inc/ReadSpeed.hxx,1,['multi-thread'],['multi-thread']
Performance,"/// Rebuild an Objective-C exception declaration.; ///; /// By default, performs semantic analysis to build the new declaration.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:72,perform,performs,72,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// Rebuild the operand to an Objective-C \@synchronized statement.; ///; /// By default, performs semantic analysis to build the new statement.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:90,perform,performs,90,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['perform'],['performs']
Performance,"/// RecedeCycle - This callback is invoked whenever the next bottom-up; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:162,latency,latency,162,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['latency'],['latency']
Performance,"/// Receives the preprocessor options.; ///; /// \param SuggestedPredefines Can be filled in with the set of predefines; /// that are suggested by the preprocessor options. Typically only used when; /// loading a precompiled header.; ///; /// \returns true to indicate the preprocessor options are invalid, or false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:203,load,loading,203,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loading']
Performance,/// Record code for \#pragma optimize options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:29,optimiz,optimize,29,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['optimiz'],['optimize']
Performance,"/// Record code for the identifier table.; ///; /// The identifier table is a simple blob that contains; /// NULL-terminated strings for all of the identifiers; /// referenced by the AST file. The IDENTIFIER_OFFSET table; /// contains the mapping from identifier IDs to the characters; /// in this blob. Note that the starting offsets of all of the; /// identifiers are odd, so that, when the identifier offset; /// table is loaded in, we can use the low bit to distinguish; /// between offsets (for unresolved identifier IDs) and; /// IdentifierInfo pointers (for already-resolved identifier; /// IDs).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:425,load,loaded,425,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['load'],['loaded']
Performance,"/// Record code for the remapping information used to relate; /// loaded modules to the various offsets and IDs(e.g., source location; /// offests, declaration and type IDs) that are used in that module to; /// refer to other modules.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:66,load,loaded,66,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['load'],['loaded']
Performance,"/// Records the cluster IDs requests by LoadClusters() calls",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_cluster.cxx:40,Load,LoadClusters,40,tree/ntuple/v7/test/ntuple_cluster.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_cluster.cxx,1,['Load'],['LoadClusters']
Performance,/// Recursive subtasks up to the given depth are added to the queue and; /// distributed among threads by ThreadPool; all subsequent calls are executed; /// on the same thread,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h:62,queue,queue,62,interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BalancedPartitioning.h,1,['queue'],['queue']
Performance,"/// Recursively perform cloning on the graph for the given Node and its; /// callers, in order to uniquely identify the allocation behavior of an; /// allocation given its context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:16,perform,perform,16,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['perform'],['perform']
Performance,"/// Recursively replaces NULL values within the given initializer list; /// with expressions that perform value-initialization of the; /// appropriate type, and finish off the InitListExpr formation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:98,perform,perform,98,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['perform'],['perform']
Performance,"/// Recursively traverse the CFG of the function, renaming loads and; /// stores to the allocas which we are promoting.; ///; /// IncomingVals indicates what value each Alloca contains on exit from the; /// predecessor block Pred.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:59,load,loads,59,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['load'],['loads']
Performance,"/// Recursively traverses the expression calculating the origin of the requested; /// byte of the given value. Returns std::nullopt if the provider can't be; /// calculated.; ///; /// For all the values except the root of the expression, we verify that the; /// value has exactly one use and if not then return std::nullopt. This way if; /// the origin of the byte is returned it's guaranteed that the values which; /// contribute to the byte are not used outside of this expression.; /// However, there is a special case when dealing with vector loads -- we allow; /// more than one use if the load is a vector type. Since the values that; /// contribute to the byte ultimately come from the ExtractVectorElements of the; /// Load, we don't care if the Load has uses other than ExtractVectorElements,; /// because those operations are independent from the pattern to be combined.; /// For vector loads, we simply care that the ByteProviders are adjacent; /// positions of the same vector, and their index matches the byte that is being; /// provided. This is captured by the \p VectorIndex algorithm. \p VectorIndex; /// is the index used in an ExtractVectorElement, and \p StartingIndex is the; /// byte position we are trying to provide for the LoadCombine. If these do; /// not match, then we can not combine the vector loads. \p Index uses the; /// byte position we are trying to provide for and is matched against the; /// shl and load size. The \p Index algorithm ensures the requested byte is; /// provided for by the pattern, and the pattern does not over provide bytes.; ///; ///; /// The supported LoadCombine pattern for vector loads is as follows; /// or; /// / \; /// or shl; /// / \ |; /// or shl zext; /// / \ | |; /// shl zext zext EVE*; /// | | | |; /// zext EVE* EVE* LOAD; /// | | |; /// EVE* LOAD LOAD; /// |; /// LOAD; ///; /// *ExtractVectorElement",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:547,load,loads,547,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,14,"['LOAD', 'Load', 'load']","['LOAD', 'Load', 'LoadCombine', 'load', 'loads']"
Performance,"/// Recursively walk the \p DIE tree and look for DIEs to keep. Store that; /// information in \p CU's DIEInfo.; ///; /// This function is the entry point of the DIE selection algorithm. It is; /// expected to walk the DIE tree in file order and (though the mediation of; /// its helper) call hasValidRelocation() on each DIE that might be a 'root; /// DIE' (See DwarfLinker class comment).; ///; /// While walking the dependencies of root DIEs, this function is also called,; /// but during these dependency walks the file order is not respected. The; /// TF_DependencyWalk flag tells us which kind of traversal we are currently; /// doing.; ///; /// The recursive algorithm is implemented iteratively as a work list because; /// very deep recursion could exhaust the stack for large projects. The work; /// list acts as a scheduler for different types of work that need to be; /// performed.; ///; /// The recursive nature of the algorithm is simulated by running the ""main""; /// algorithm (LookForDIEsToKeep) followed by either looking at more DIEs; /// (LookForChildDIEsToKeep, LookForRefDIEsToKeep, LookForParentDIEsToKeep) or; /// fixing up a computed property (UpdateChildIncompleteness,; /// UpdateRefIncompleteness).; ///; /// The return value indicates whether the DIE is incomplete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:883,perform,performed,883,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['perform'],['performed']
Performance,"/// Reduce the number of arguments in this call expression. This is used for; /// example during error recovery to drop extra arguments. There is no way; /// to perform the opposite because: 1.) We don't track how much storage; /// we have for the argument array 2.) This would potentially require growing; /// the argument array, something we cannot support since the arguments are; /// stored in a trailing array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:161,perform,perform,161,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['perform'],['perform']
Performance,"/// Reduce the number of loads when building a vector.; ///; /// Building a vector out of multiple loads can be converted to a load; /// of the vector type if the loads are consecutive. If the loads are; /// consecutive but in descending order, a shuffle is added at the end; /// to reorder the vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:25,load,loads,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,5,['load'],"['load', 'loads']"
Performance,/// Reduction type; // TODO: Will be extended when additional optimizations are added,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp:62,optimiz,optimizations,62,interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MicroMipsSizeReduction.cpp,1,['optimiz'],['optimizations']
Performance,"/// Reference to a CachedFileSystemEntry.; /// If the underlying entry is an opened file, this wrapper returns the file; /// contents and the scanned preprocessor directives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:19,Cache,CachedFileSystemEntry,19,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['Cache'],['CachedFileSystemEntry']
Performance,/// Reference to the semantic analysis that is performing; /// this template instantiation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h:47,perform,performing,47,interpreter/llvm-project/clang/include/clang/Sema/Template.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h,1,['perform'],['performing']
Performance,"/// Reference to the shuffle(s), consumer(s) of the (load) 'Inst'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:53,load,load,53,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,1,['load'],['load']
Performance,/// Reference to the wide-load instruction of an interleaved access; /// group.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp:26,load,load,26,interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InterleavedAccess.cpp,1,['load'],['load']
Performance,/// References the file which the contents were actually loaded from.; ///; /// Can be different from 'Entry' if we overridden the contents of one file; /// with the contents of another file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:57,load,loaded,57,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,/// Register a callback for a default optimizer pipeline extension point.; ///; /// This extension point allows adding optimization once at the start of the; /// pipeline. This does not apply to 'backend' compiles (LTO and ThinLTO; /// link-time pipelines).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,2,['optimiz'],"['optimization', 'optimizer']"
Performance,/// Register a callback for a default optimizer pipeline extension point.; ///; /// This extension point allows adding optimization right after passes that do; /// basic simplification of the input IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,2,['optimiz'],"['optimization', 'optimizer']"
Performance,/// Register a callback for a default optimizer pipeline extension point; ///; /// This extension point allows adding optimizations at the end of the full; /// LTO pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,2,['optimiz'],"['optimizations', 'optimizer']"
Performance,/// Register a callback for a default optimizer pipeline extension point; ///; /// This extension point allows adding optimizations at the start of the full; /// LTO pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,2,['optimiz'],"['optimizations', 'optimizer']"
Performance,/// Register a callback for a default optimizer pipeline extension point; ///; /// This extension point allows adding optimizations at the very end of the; /// function optimization pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,3,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,/// Register a callback for a default optimizer pipeline extension point; ///; /// This extension point allows adding optimizations before the function; /// optimization pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,3,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,/// Register a callback for a default optimizer pipeline extension; /// point; ///; /// This extension point allows adding CallGraphSCC passes at the end of the; /// main CallGraphSCC passes and before any function simplification passes run; /// by CGPassManager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,1,['optimiz'],['optimizer']
Performance,"/// Register a callback for a default optimizer pipeline extension; /// point; ///; /// This extension point allows adding late loop canonicalization and; /// simplification passes. This is the last point in the loop optimization; /// pipeline before loop deletion. Each pass added; /// here must be an instance of LoopPass.; /// This is the place to add passes that can remove loops, such as target-; /// specific loop idiom recognition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,2,['optimiz'],"['optimization', 'optimizer']"
Performance,/// Register a callback for a default optimizer pipeline extension; /// point; ///; /// This extension point allows adding loop passes to the end of the loop; /// optimizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,2,['optimiz'],['optimizer']
Performance,"/// Register a callback for a default optimizer pipeline extension; /// point; ///; /// This extension point allows adding optimization passes after most of the; /// main optimizations, but before the last cleanup-ish optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,4,['optimiz'],"['optimization', 'optimizations', 'optimizer']"
Performance,/// Register a callback for a default optimizer pipeline extension; /// point; ///; /// This extension point allows adding optimization passes before the; /// vectorizer and other highly target specific optimization passes are; /// executed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,3,['optimiz'],"['optimization', 'optimizer']"
Performance,/// Register a callback for a default optimizer pipeline extension; /// point; ///; /// This extension point allows adding passes that perform peephole; /// optimizations similar to the instruction combiner. These passes will be; /// inserted after each instance of the instruction combiner pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h:38,optimiz,optimizer,38,interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/PassBuilder.h,3,"['optimiz', 'perform']","['optimizations', 'optimizer', 'perform']"
Performance,/// Register a load and whether it is only read from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:15,load,load,15,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['load'],['load']
Performance,"/// Register any EH frame sections that have been loaded but not previously; /// registered with the memory manager. Note, RuntimeDyld is responsible; /// for identifying the EH frame and calling the memory manager with the; /// EH frame section data. However, the memory manager itself will handle; /// the actual target-specific EH frame registration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:50,load,loaded,50,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['load'],['loaded']
Performance,/// Register calling convention used for parameters transfer optimization,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h:61,optimiz,optimization,61,interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/CallingConv.h,1,['optimiz'],['optimization']
Performance,"/// Register the EH frames with the runtime so that c++ exceptions work.; ///; /// \p Addr parameter provides the local address of the EH frame section; /// data, while \p LoadAddr provides the address of the data in the target; /// address space. If the section has not been remapped (which will usually; /// be the case for local execution) these two values will be the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h:172,Load,LoadAddr,172,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyld.h,1,['Load'],['LoadAddr']
Performance,/// Register-promote counter loads and stores in loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:29,load,loads,29,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['load'],['loads']
Performance,"/// Registers a yield callback with the given context.; ///; /// The yield callback function may be called by LLVM to transfer control back; /// to the client that invoked the LLVM compilation. This can be used to yield; /// control of the thread, or perform periodic work needed by the client.; /// There is no guaranteed frequency at which callbacks must occur; in fact,; /// the client is not guaranteed to ever receive this callback. It is at the; /// sole discretion of LLVM to do so and only if it can guarantee that; /// suspending the thread won't block any forward progress in other LLVM; /// contexts in the same process.; ///; /// At a suspend point, the state of the current LLVM context is intentionally; /// undefined. No assumptions about it can or should be made. Only LLVM; /// context API calls that explicitly state that they can be used during a; /// yield callback are allowed to be used. Any other API calls into the; /// context are not supported until the yield callback function returns; /// control to LLVM. Other LLVM contexts are unaffected by this restriction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:251,perform,perform,251,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,1,['perform'],['perform']
Performance,"/// Registers an externally loaded library. The library will be unloaded; /// when the program terminates.; ///; /// It is safe to call this function multiple times for the same library,; /// though ownership is only taken if there was no error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:28,load,loaded,28,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['load'],['loaded']
Performance,/// RegularPartialArrayDestroy - a cleanup which performs a partial; /// array destroy where the end pointer is regularly determined and; /// does not need to be loaded from a local.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:49,perform,performs,49,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,2,"['load', 'perform']","['loaded', 'performs']"
Performance,/// Release ExitSU predecessors and setup scheduler queues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:52,queue,queues,52,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['queue'],['queues']
Performance,/// Release ExitSU predecessors and setup scheduler queues. Re-position; /// the Top RP tracker in case the region beginning has changed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:52,queue,queues,52,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,['queue'],['queues']
Performance,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:84,queue,queue,84,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,5,['queue'],['queue']
Performance,/// Release memory in caches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:22,cache,caches,22,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['cache'],['caches']
Performance,/// Release pending ready nodes in to the available queue. This makes them; /// visible to heuristics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:52,queue,queue,52,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['queue'],['queue']
Performance,"/// Remove MemoryAccess for a given instruction, if a MemoryAccess exists.; /// This should be called when an instruction (load/store) is deleted from; /// the program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:123,load,load,123,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,1,['load'],['load']
Performance,/// Remove a Function from the FnTree and queue it up for a second sweep of; /// analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:42,queue,queue,42,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['queue'],['queue']
Performance,"/// Remove a MemoryAccess from MemorySSA, including updating all; /// definitions and uses.; /// This should be called when a memory instruction that has a MemoryAccess; /// associated with it is erased from the program. For example, if a store or; /// load is simply erased (not replaced), removeMemoryAccess should be called; /// on the MemoryAccess for that store/load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:253,load,load,253,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,2,['load'],['load']
Performance,"/// Remove a value from the cache, e.g. because it will be erased.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h:28,cache,cache,28,interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DomConditionCache.h,1,['cache'],['cache']
Performance,"/// Remove all nodes from the list like clear(), but do not call; /// removeNodeFromList() or deleteNode().; ///; /// This should only be used immediately before freeing nodes in bulk to; /// avoid traversing the list and bringing all the nodes into cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:250,cache,cache,250,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,1,['cache'],['cache']
Performance,/// Remove an \@llvm.assume intrinsic from this function's cache if it has; /// been added to the cache earlier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:59,cache,cache,59,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,2,['cache'],['cache']
Performance,/// Remove every uses that can safely be removed.; ///; /// This will remove for example uses in llvm.assume.; /// This should be used when performing want to perform a tranformation but; /// some Droppable uses pervent it.; /// This function optionally takes a filter to only remove some droppable; /// uses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h:140,perform,performing,140,interpreter/llvm-project/llvm/include/llvm/IR/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h,2,['perform'],"['perform', 'performing']"
Performance,/// Remove information related to this value from the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:54,cache,cache,54,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,1,['cache'],['cache']
Performance,/// Remove stale types from the type cache when an inheritance model; /// gets assigned to a class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h:37,cache,cache,37,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTypes.h,1,['cache'],['cache']
Performance,/// Remove the real file \p Entry from the cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:43,cache,cache,43,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['cache'],['cache']
Performance,/// Remove unneeded Load instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp:20,Load,Load,20,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMISimplifyPatchable.cpp,1,['Load'],['Load']
Performance,"/// RemoveDeadStores - Scan through a basic block and look for loads followed; /// by stores. If they're both using the same stack slot, then the store is; /// definitely dead. This could obviously be much more aggressive (consider; /// pairs with instructions between them), but such extensions might have a; /// considerable compile time impact.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:63,load,loads,63,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,1,['load'],['loads']
Performance,"/// Reorder the reachable metadata.; ///; /// This is not just an optimization, but is mandatory for emitting MDString; /// correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h:66,optimiz,optimization,66,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h,2,['optimiz'],['optimization']
Performance,"/// Reparse the source files using the same command-line options that; /// were originally used to produce this translation unit.; ///; /// \param VFS - A llvm::vfs::FileSystem to be used for all file accesses.; /// Note that preamble is saved to a temporary directory on a RealFileSystem,; /// so in order for it to be loaded correctly, VFS should give an access to; /// this(i.e. be an overlay over RealFileSystem).; /// FileMgr->getVirtualFileSystem() will be used if \p VFS is nullptr.; ///; /// \returns True if a failure occurred that causes the ASTUnit not to; /// contain any translation-unit information, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:320,load,loaded,320,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['load'],['loaded']
Performance,"/// Replace \p MI by a sequence of legal instructions that can implement the; /// same operation. Note that this means \p MI may be deleted, so any iterator; /// steps should be performed before calling this function. \p Helper should; /// be initialized to the MachineFunction containing \p MI.; ///; /// Considered as an opaque blob, the legal code will use and define the same; /// registers as \p MI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h:178,perform,performed,178,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,1,['perform'],['performed']
Performance,/// Replace a MUX instruction MI with a pair A2_tfrt/A2_tfrf. This function; /// performs all necessary changes to complete the replacement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:81,perform,performs,81,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['perform'],['performs']
Performance,"/// Replace a splat of a scalar to a vector store by scalar stores of the scalar; /// value. The load store optimizer pass will merge them to store pair stores.; /// This has better performance than a splat of the scalar followed by a split; /// vector store. Even if the stores are not merged it is four stores vs a dup,; /// followed by an ext.b and two stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:97,load,load,97,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,3,"['load', 'optimiz', 'perform']","['load', 'optimizer', 'performance']"
Performance,"/// Replace a splat of zeros to a vector store by scalar stores of WZR/XZR. The; /// load store optimizer pass will merge them to store pair stores. This should; /// be better than a movi to create the vector zero followed by a vector store; /// if the zero constant is not re-used, since one instructions and one register; /// live range will be removed.; ///; /// For example, the final generated code should be:; ///; /// stp xzr, xzr, [x0]; ///; /// instead of:; ///; /// movi v0.2d, #0; /// str q0, [x0]; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:85,load,load,85,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,"['load', 'optimiz']","['load', 'optimizer']"
Performance,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:99,perform,performs,99,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,2,['perform'],"['performed', 'performs']"
Performance,/// Replace an ISD::EXTRACT_VECTOR_ELT of a load with a narrowed; /// load.; ///; /// \param EVE ISD::EXTRACT_VECTOR_ELT to be replaced.; /// \param InVecVT type of the input vector to EVE with bitcasts resolved.; /// \param EltNo index of the vector element to load.; /// \param OriginalLoad load that EVE came from to be replaced.; /// \returns EVE on success SDValue() on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,load,load,44,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,4,['load'],['load']
Performance,/// Replace interleaved load candidates. It does additional; /// analyses if this makes sense. Returns true on success and false; /// of nothing has been changed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:24,load,load,24,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['load'],['load']
Performance,"/// Replace the last token with an annotation token.; ///; /// Like AnnotateCachedTokens(), this routine replaces an; /// already-parsed (and resolved) token with an annotation; /// token. However, this routine only replaces the last token with; /// the annotation token; it does not affect any other cached; /// tokens. This function has no effect if backtracking is not; /// enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:301,cache,cached,301,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['cache'],['cached']
Performance,/// Replace the original chain operand of the call with; /// load's chain operand and move load below the call's chain operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:61,load,load,61,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['load'],['load']
Performance,/// Replace token in `CachedLexPos - 1` in CachedTokens by the tokens; /// in \p NewToks.; ///; /// Useful when a token needs to be split in smaller ones and CachedTokens; /// most recent token must to be updated to reflect that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:22,Cache,CachedLexPos,22,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,3,['Cache'],"['CachedLexPos', 'CachedTokens']"
Performance,"/// Replace with a (mostly) real path, or don't modify. Resolves symlinks; /// in the directory, using \a CachedDirs to avoid redundant lookups, but; /// leaves the filename as a possible symlink.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h:106,Cache,CachedDirs,106,interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,1,['Cache'],['CachedDirs']
Performance,/// ReplaceVectorLoad - Convert vector loads into multi-output scalar loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:39,load,loads,39,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,2,['load'],['loads']
Performance,/// Replaces the whitespace from \p SplitAfterLastLine on the last line; /// after the last line has been formatted by performing a reformatting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:119,perform,performing,119,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h,1,['perform'],['performing']
Performance,/// Replay inline advisor that uses optimization remarks from inlining of; /// previous build to guide current inlining. This is useful for inliner tuning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h:36,optimiz,optimization,36,interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h,1,['optimiz'],['optimization']
Performance,/// Report an ISel error as a missed optimization remark to the LLVMContext's; /// diagnostic stream. Set the FailedISel MachineFunction property.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h:37,optimiz,optimization,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,1,['optimiz'],['optimization']
Performance,/// Report an ISel warning as a missed optimization remark to the LLVMContext's; /// diagnostic stream.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h:39,optimiz,optimization,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Utils.h,1,['optimiz'],['optimization']
Performance,"/// Report details on loop fusion opportunities.; ///; /// This template function can be used to report both successful and missed; /// loop fusion opportunities, based on the RemarkKind. The RemarkKind should; /// be one of:; /// - OptimizationRemarkMissed to report when loop fusion is unsuccessful; /// given two valid fusion candidates.; /// - OptimizationRemark to report successful fusion of two fusion; /// candidates.; /// The remarks will be printed using the form:; /// <path/filename>:<line number>:<column number>: [<function name>]:; /// <Cand1 Preheader> and <Cand2 Preheader>: <Stat Description>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:233,Optimiz,OptimizationRemarkMissed,233,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,2,['Optimiz'],"['OptimizationRemark', 'OptimizationRemarkMissed']"
Performance,/// Reports a diagnostic message to indicate an invalid size request has been; /// done on a scalable vector. This function may not return.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h:93,scalab,scalable,93,interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,1,['scalab'],['scalable']
Performance,"/// Reports a vectorization failure: print \p DebugMsg for debugging; /// purposes along with the corresponding optimization remark \p RemarkName.; /// If \p I is passed, it is an instruction that prevents vectorization.; /// Otherwise, the loop \p TheLoop is used for the location of the remark.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:112,optimiz,optimization,112,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,1,['optimiz'],['optimization']
Performance,"/// Reports an informative message: print \p Msg for debugging purposes as well; /// as an optimization remark. Uses either \p I as location of the remark, or; /// otherwise \p TheLoop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h:91,optimiz,optimization,91,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorize.h,1,['optimiz'],['optimization']
Performance,/// Represent a sequence of multiply-accumulate operations with the aim to; /// perform the multiplications in parallel.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp:80,perform,perform,80,interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMParallelDSP.cpp,1,['perform'],['perform']
Performance,/// Represent the type of SchedCandidate found within a single queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:63,queue,queue,63,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,1,['queue'],['queue']
Performance,/// Represent the type of SchedCandidate found within a single queue.; /// pickNodeBidirectional depends on these listed by decreasing priority.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:63,queue,queue,63,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['queue'],['queue']
Performance,"/// Represents a C11 generic selection.; ///; /// A generic selection (C11 6.5.1.1) contains an unevaluated controlling; /// expression, followed by one or more generic associations. Each generic; /// association specifies a type name and an expression, or ""default"" and an; /// expression (in which case it is known as a default generic association).; /// The type and value of the generic selection are identical to those of its; /// result expression, which is defined as the expression in the generic; /// association with a type name that is compatible with the type of the; /// controlling expression, or the expression in the default generic association; /// if no types are compatible. For example:; ///; /// @code; /// _Generic(X, double: 1, float: 2, default: 3); /// @endcode; ///; /// The above expression evaluates to 1 if 1.0 is substituted for X, 2 if 1.0f; /// or 3 if ""hello"".; ///; /// As an extension, generic selections are allowed in C++, where the following; /// additional semantics apply:; ///; /// Any generic selection whose controlling expression is type-dependent or; /// which names a dependent type in its association list is result-dependent,; /// which means that the choice of result expression is dependent.; /// Result-dependent generic associations are both type- and value-dependent.; ///; /// We also allow an extended form in both C and C++ where the controlling; /// predicate for the selection expression is a type rather than an expression.; /// This type argument form does not perform any conversions for the; /// controlling type, which makes it suitable for use with qualified type; /// associations, which is not possible with the expression form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:1521,perform,perform,1521,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['perform'],['perform']
Performance,/// Represents a filesystem entry that has been stat-ed (and potentially read); /// and that's about to be inserted into the cache as `CachedFileSystemEntry`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:125,cache,cache,125,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,2,"['Cache', 'cache']","['CachedFileSystemEntry', 'cache']"
Performance,"/// Represents a hint about the context in which a cast is used.; ///; /// For zext/sext, the context of the cast is the operand, which must be a; /// load of some kind. For trunc, the context is of the cast is the single; /// user of the instruction, which must be a store of some kind.; ///; /// This enum allows the vectorizer to give getCastInstrCost an idea of the; /// type of cast it's dealing with, as not every cast is equal. For instance,; /// the zext of a load may be free, but the zext of an interleaving load can; //// be (very) expensive!; ///; /// See \c getCastContextHint to compute a CastContextHint from a cast; /// Instruction*. Callers can use it if they don't need to override the; /// context and just want it to be calculated from the instruction.; ///; /// FIXME: This handles the types of load/store that the vectorizer can; /// produce, which are the cases where the context instruction is most; /// likely to be incorrect. There are other situations where that can happen; /// too, which might be handled here but in the long run a more general; /// solution of costing multiple instructions at the same times may be better.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:151,load,load,151,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,4,['load'],['load']
Performance,"/// Represents a lazily-loaded vector of data.; ///; /// The lazily-loaded vector of data contains data that is partially loaded; /// from an external source and partially added by local translation. The; /// items loaded from the external source are loaded lazily, when needed for; /// iteration over the complete vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h:24,load,loaded,24,interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,5,['load'],['loaded']
Performance,"/// Represents a reference to a non-type template parameter pack that; /// has been substituted with a non-template argument pack.; ///; /// When a pack expansion in the source code contains multiple parameter packs; /// and those parameter packs correspond to different levels of template; /// parameter lists, this node is used to represent a non-type template; /// parameter pack from an outer level, which has already had its argument pack; /// substituted but that still lives within a pack expansion that itself; /// could not be instantiated. When actually performing a substitution into; /// that pack expansion (e.g., when all template parameters have corresponding; /// arguments), this type will be replaced with the appropriate underlying; /// expression at the current pack substitution index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:564,perform,performing,564,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['perform'],['performing']
Performance,"/// Represents a search that terminated after finding a clobber. This clobber; /// may or may not be present in the path of defs from LastNode..SearchStart,; /// since it may have been retrieved from cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:200,cache,cache,200,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['cache'],['cache']
Performance,"/// Represents a single basic block in a source-level CFG.; /// It consists of:; ///; /// (1) A set of statements/expressions (which may contain subexpressions).; /// (2) A ""terminator"" statement (not in the set of statements).; /// (3) A list of successors and predecessors.; ///; /// Terminator: The terminator represents the type of control-flow that occurs; /// at the end of the basic block. The terminator is a Stmt* referring to an; /// AST node that has control-flow: if-statements, breaks, loops, etc.; /// If the control-flow is conditional, the condition expression will appear; /// within the set of statements in the block (usually the last statement).; ///; /// Predecessors: the order in the set of predecessors is arbitrary.; ///; /// Successors: the order in the set of successors is NOT arbitrary. We; /// currently have the following orderings based on the terminator:; ///; /// Terminator | Successor Ordering; /// ------------------|------------------------------------; /// if | Then Block; Else Block; /// ? operator | LHS expression; RHS expression; /// logical and/or | expression that consumes the op, RHS; /// vbase inits | already handled by the most derived class; not yet; ///; /// But note that any of that may be NULL in case of optimized-out edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CFG.h:1261,optimiz,optimized-out,1261,interpreter/llvm-project/clang/include/clang/Analysis/CFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CFG.h,1,['optimiz'],['optimized-out']
Performance,/// Represents a type of copy/destroy operation that should be performed for an; /// entity that's captured by a block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h:63,perform,performed,63,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.h,1,['perform'],['performed']
Performance,"/// Represents any generic load, including sign/zero extending variants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h:27,load,load,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,1,['load'],['load']
Performance,"/// Represents any type of generic load or store.; /// G_LOAD, G_STORE, G_ZEXTLOAD, G_SEXTLOAD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h:35,load,load,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,1,['load'],['load']
Performance,/// Represents indexed loads. These are different enough from regular loads; /// that they get their own class. Including them in GAnyLoad would probably; /// make a footgun for someone.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h:23,load,loads,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GenericMachineInstrs.h,2,['load'],['loads']
Performance,"/// Represents the result of substituting a set of types for a template; /// type parameter pack.; ///; /// When a pack expansion in the source code contains multiple parameter packs; /// and those parameter packs correspond to different levels of template; /// parameter lists, this type node is used to represent a template type; /// parameter pack from an outer level, which has already had its argument pack; /// substituted but that still lives within a pack expansion that itself; /// could not be instantiated. When actually performing a substitution into; /// that pack expansion (e.g., when all template parameters have corresponding; /// arguments), this type will be replaced with the \c SubstTemplateTypeParmType; /// at the current pack substitution index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:532,perform,performing,532,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['perform'],['performing']
Performance,"/// Request to load a subset of the columns of a particular cluster.; /// Work items come in groups and are executed by the page source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:15,load,load,15,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,1,['load'],['load']
Performance,"/// Reserves buffer and LSUnit queue resources that are necessary to issue; /// this instruction.; ///; /// Returns true if instruction IR is ready to be issued to the underlying; /// pipelines. Note that this operation cannot fail; it assumes that a; /// previous call to method `isAvailable(IR)` returned `SC_AVAILABLE`.; ///; /// If IR is a memory operation, then the Scheduler queries the LS unit to; /// obtain a LS token. An LS token is used internally to track memory; /// dependencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:31,queue,queue,31,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['queue'],['queue']
Performance,/// Reset all state tracking for a newly encountered safepoint. Also; /// performs some consistency checking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h:74,perform,performs,74,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h,1,['perform'],['performs']
Performance,"/// Reset compile units data(results of liveness analysis, clonning); /// if current stage greater than Stage::Loaded. We need to reset data; /// as we are going to repeat stages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:111,Load,Loaded,111,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,1,['Load'],['Loaded']
Performance,"/// Reset the ID of what this MemoryUse was optimized to, causing it to; /// be rewalked by the walker if necessary.; /// This really should only be called by tests.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:44,optimiz,optimized,44,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['optimiz'],['optimized']
Performance,"/// Reset the iterator to point at \p I, keep cached state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:46,cache,cached,46,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['cache'],['cached']
Performance,"/// Reset the kMustCleanup bit of a TObjArray of TBranch objects (e.g. returned by TTree::GetListOfBranches).; ///; /// In some rare cases, all branches in a TTree can have their kMustCleanup bit set, which causes a large amount; /// of contention at teardown due to concurrent calls to RecursiveRemove (which needs to take the global lock).; /// This helper function checks the first branch of the array and if it has the kMustCleanup bit set, it resets; /// it for all branches in the array, recursively going through sub-branches and leaves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:267,concurren,concurrent,267,tree/tree/src/InternalTreeUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx,1,['concurren'],['concurrent']
Performance,/// Resolve a declaration ID into a declaration. Return 0 if it's not; /// been loaded yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:80,load,loaded,80,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,/// Resolve a path by calling realpath and cache its result. The returned; /// StringRef is interned in the given \p StringPool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h:43,cache,cache,43,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Classic/DWARFLinkerDeclContext.h,1,['cache'],['cache']
Performance,"/// Resolve linkage for prevailing symbols in the \p Index. Linkage changes; /// recorded in the index and the ThinLTO backends must apply the changes to; /// the module via thinLTOFinalizeInModule.; ///; /// This is done for correctness (if value exported, ensure we always; /// emit a copy), and compile-time optimization (allow drop of duplicates).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h:311,optimiz,optimization,311,interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/LTO.h,1,['optimiz'],['optimization']
Performance,"/// Resolve prevailing symbols. Record resolutions in the \p ResolvedODR map; /// for caching, and in the \p Index for application during the ThinLTO; /// backends. This is needed for correctness for exported symbols (ensure; /// at least one copy kept) and a compile-time optimization (to drop duplicate; /// copies when possible).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp:273,optimiz,optimization,273,interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/ThinLTOCodeGenerator.cpp,1,['optimiz'],['optimization']
Performance,/// Resolves and cache a resolved scheduling class for an SUnit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:17,cache,cache,17,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,2,['cache'],['cache']
Performance,/// Results from loading a RedeclarableDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:17,load,loading,17,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['load'],['loading']
Performance,"/// Retain the given block, with _Block_copy semantics.; /// call i8* \@objc_retainBlock(i8* %value); ///; /// \param mandatory - If false, emit the call with metadata; /// indicating that it's okay for the optimizer to eliminate this call; /// if it can prove that the block never escapes except down the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:207,optimiz,optimizer,207,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['optimiz'],['optimizer']
Performance,/// Retrieve a Module from the cache or lazily load it on demand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp:31,cache,cache,31,interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-link/llvm-link.cpp,4,"['cache', 'load']","['cache', 'load']"
Performance,/// Retrieve a file status with a cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:34,cache,cache,34,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,1,['cache'],['cache']
Performance,"/// Retrieve a module with the given name using lexical name lookup,; /// starting at the given context.; ///; /// \param Name The name of the module to look up.; ///; /// \param Context The module context, from which we will perform lexical; /// name lookup.; ///; /// \returns The named module, if known; otherwise, returns null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:226,perform,perform,226,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['perform'],['perform']
Performance,"/// Retrieve all the modules that contain the given header file. Note that; /// this does not implicitly load module maps, except for builtin headers,; /// and does not consult the external source. (Those checks are the; /// responsibility of \ref HeaderSearch.); ///; /// Typically, \ref findModuleForHeader should be used instead, as it picks; /// the preferred module for the header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:105,load,load,105,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['load'],['load']
Performance,/// Retrieve an iterator into the set of all identifiers; /// in all loaded AST files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:69,load,loaded,69,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,"/// Retrieve the ""injected"" template arguments that correspond to the; /// template parameters of this template.; ///; /// Although the C++ standard has no notion of the ""injected"" template; /// arguments for a template, the notion is convenient when; /// we need to perform substitutions inside the definition of a template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h:267,perform,perform,267,interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,1,['perform'],['perform']
Performance,"/// Retrieve the C type corresponding to type tag TypeExpr.; ///; /// \param TypeExpr Expression that specifies a type tag.; ///; /// \param MagicValues Registered magic values.; ///; /// \param FoundWrongKind Set to true if a type tag was found, but of a wrong; /// kind.; ///; /// \param TypeInfo Information about the corresponding C type.; ///; /// \param isConstantEvaluated whether the evalaution should be performed in; /// constant context.; ///; /// \returns true if the corresponding C type was found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:413,perform,performed,413,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['perform'],['performed']
Performance,/// Retrieve the allocator used to cache global code completions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:35,cache,cache,35,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['cache'],['cache']
Performance,"/// Retrieve the canonical name for a given directory.; ///; /// This is a very expensive operation, despite its results being cached,; /// and should only be used when the physical layout of the file system is; /// required, which is (almost) never.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:127,cache,cached,127,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['cache'],['cached']
Performance,"/// Retrieve the canonical name for a given file.; ///; /// This is a very expensive operation, despite its results being cached,; /// and should only be used when the physical layout of the file system is; /// required, which is (almost) never.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:122,cache,cached,122,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['cache'],['cached']
Performance,"/// Retrieve the global declaration ID associated with this; /// declaration, which specifies where this Decl was loaded from.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:114,load,loaded,114,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['load'],['loaded']
Performance,/// Retrieve the kind of bridge being performed as a string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:38,perform,performed,38,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,1,['perform'],['performed']
Performance,/// Retrieve the loaded preprocessed entity at the given index.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:17,load,loaded,17,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,2,['load'],['loaded']
Performance,"/// Retrieve the module import location and name for the given ID, if; /// in fact it was loaded from a module (rather than, say, a precompiled; /// header).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:90,load,loaded,90,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,/// Retrieve the module loader associated with the preprocessor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:24,load,loader,24,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['load'],['loader']
Performance,/// Retrieve the module loader associated with this preprocessor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:24,load,loader,24,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['load'],['loader']
Performance,"/// Retrieve the module that owns the given header file, if any. Note that; /// this does not implicitly load module maps, except for builtin headers,; /// and does not consult the external source. (Those checks are the; /// responsibility of \ref HeaderSearch.); ///; /// \param File The header file that is likely to be included.; ///; /// \param AllowTextual If \c true and \p File is a textual header, return; /// its owning module. Otherwise, no KnownHeader will be returned if the; /// file is only known as a textual header.; ///; /// \returns The module KnownHeader, which provides the module that owns the; /// given header file. The KnownHeader is default constructed to indicate; /// that no module owns this header file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:105,load,load,105,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,1,['load'],['load']
Performance,"/// Retrieve the name of the (to-be-)cached module file that should; /// be used to load a module with the given name.; ///; /// \param ModuleName The module whose module file name will be returned.; ///; /// \param ModuleMapPath A path that when combined with \c ModuleName; /// uniquely identifies this module. See Module::ModuleMap.; ///; /// \param CachePath A path to the module cache.; ///; /// \returns The name of the module file that corresponds to this module,; /// or an empty string if this module does not correspond to any module file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:37,cache,cached,37,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,4,"['Cache', 'cache', 'load']","['CachePath', 'cache', 'cached', 'load']"
Performance,"/// Retrieve the name of the (to-be-)cached module file that should; /// be used to load a module with the given name.; ///; /// \param ModuleName The module whose module file name will be returned.; ///; /// \param ModuleMapPath A path that when combined with \c ModuleName; /// uniquely identifies this module. See Module::ModuleMap.; ///; /// \returns The name of the module file that corresponds to this module,; /// or an empty string if this module does not correspond to any module file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:37,cache,cached,37,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,2,"['cache', 'load']","['cached', 'load']"
Performance,"/// Retrieve the name of the cached module file that should be used; /// to load the given module.; ///; /// \param Module The module whose module file name will be returned.; ///; /// \returns The name of the module file that corresponds to this module,; /// or an empty string if this module does not correspond to any module file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:29,cache,cached,29,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,2,"['cache', 'load']","['cached', 'load']"
Performance,"/// Retrieve the name of the original source file name directly from; /// the AST file, without actually loading the AST file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:105,load,loading,105,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loading']
Performance,"/// Retrieve the name of the original source file name; /// directly from the AST file, without actually loading the AST; /// file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:105,load,loading,105,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['load'],['loading']
Performance,"/// Retrieve the name of the prebuilt module file that should be used; /// to load a module with the given name.; ///; /// \param ModuleName The module whose module file name will be returned.; ///; /// \param FileMapOnly If true, then only look in the explicit module name; // to file name map and skip the directory search.; ///; /// \returns The name of the module file that corresponds to this module,; /// or an empty string if this module does not correspond to any module file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:78,load,load,78,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['load'],['load']
Performance,"/// Retrieve the name of the prebuilt module file that should be used; /// to load the given module.; ///; /// \param Module The module whose module file name will be returned.; ///; /// \returns The name of the module file that corresponds to this module,; /// or an empty string if this module does not correspond to any module file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:78,load,load,78,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['load'],['load']
Performance,"/// Retrieve the parser's current scope.; ///; /// This routine must only be used when it is certain that semantic analysis; /// and the parser are in precisely the same context, which is not the case; /// when, e.g., we are performing any kind of template instantiation.; /// Therefore, the only safe places to use this scope are in the parser; /// itself and in routines directly invoked from the parser and *never* from; /// template substitution or instantiation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:225,perform,performing,225,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performing']
Performance,/// Retrieve the path to the module cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:36,cache,cache,36,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['cache'],['cache']
Performance,/// Retrieve the variable that might be used for the named return; /// value optimization.; ///; /// The optimization itself can only be performed if the variable is; /// also marked as an NRVO object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h:77,optimiz,optimization,77,interpreter/llvm-project/clang/include/clang/AST/Stmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Stmt.h,3,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"/// Retrieve whether this initialization allows the use of explicit; /// conversion functions when binding a reference. If the reference is the; /// first parameter in a copy or move constructor, such conversions are; /// permitted even though we are performing copy-initialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h:251,perform,performing,251,interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Initialization.h,1,['perform'],['performing']
Performance,"/// Retrieves a ToolChain for a particular \p Target triple.; ///; /// Will cache ToolChains for the life of the driver object, and create them; /// on-demand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h:76,cache,cache,76,interpreter/llvm-project/clang/include/clang/Driver/Driver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Driver.h,1,['cache'],['cache']
Performance,"/// Return 'true' if this vector operation is ""horizontal""; /// and return the operands for the horizontal operation in LHS and RHS. A; /// horizontal operation performs the binary operation on successive elements; /// of its first operand, then on successive elements of its second operand,; /// returning the resulting values in a vector. For example, if; /// A = < float a0, float a1, float a2, float a3 >; /// and; /// B = < float b0, float b1, float b2, float b3 >; /// then the result of doing a horizontal operation on A and B is; /// A horizontal-op B = < a0 op a1, a2 op a3, b0 op b1, b2 op b3 >.; /// In short, LHS and RHS are inspected to see if LHS op RHS is of the form; /// A horizontal-op B, for some already available A and B, and if so then LHS is; /// set to A, RHS to B, and the routine returns 'true'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:161,perform,performs,161,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['perform'],['performs']
Performance,/// Return True if instruction \p I is an optimizable truncate whose operand; /// is an induction variable. Such a truncate will be removed by adding a new; /// induction variable with the destination type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,optimiz,optimizable,42,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['optimiz'],['optimizable']
Performance,/// Return a MachineMemOperand object describing the memory; /// reference performed by operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:75,perform,performed,75,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['perform'],['performed']
Performance,"/// Return a StringRef to the source buffer data for the; /// specified FileID, returning std::nullopt if it's not yet loaded.; ///; /// \param FID The file ID whose contents will be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:119,load,loaded,119,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,"/// Return a StringRef to the source buffer data, only if it has already; /// been loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:83,load,loaded,83,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,"/// Return a base defining value for the 'Index' element of the given vector; /// instruction 'I'. If Index is null, returns a BDV for the entire vector; /// 'I'. As an optimization, this method will try to determine when the; /// element is known to already be a base pointer. If this can be established,; /// the second value in the returned pair will be true. Note that either a; /// vector or a pointer typed value can be returned. For the former, the; /// vector returned is a BDV (and possibly a base) of the entire vector 'I'.; /// If the later, the return pointer is a BDV (or possibly a base) for the; /// particular element in 'I'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:169,optimiz,optimization,169,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['optimiz'],['optimization']
Performance,"/// Return a cached TypeString encoding for the ID. If there isn't one, or we; /// are recursively expanding a type (IncompleteCount != 0) and the cached; /// encoding is Recursive, return an empty StringRef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:13,cache,cached,13,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,2,['cache'],['cached']
Performance,/// Return a cached module load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h:13,cache,cached,13,interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/ModuleMap.h,2,"['cache', 'load']","['cached', 'load']"
Performance,"/// Return a copy of the specified basic block, but without; /// embedding the block into a particular function. The block returned is an; /// exact copy of the specified basic block, without any remapping having been; /// performed. Because of this, this is only suitable for applications where; /// the basic block will be inserted into the same function that it was cloned; /// from (loop unrolling would use this, for example).; ///; /// Also, note that this function makes a direct copy of the basic block, and; /// can thus produce illegal LLVM code. In particular, it will copy any PHI; /// nodes from the original block, even though there are no predecessors for the; /// newly cloned block (thus, phi nodes will have to be updated). Also, this; /// block will branch to the old successors of the original block: these; /// successors will have to have any PHI nodes updated to account for the new; /// incoming edges.; ///; /// The correlation between instructions in the source and result basic blocks; /// is recorded in the VMap map.; ///; /// If you have a particular suffix you'd like to use to add to any cloned; /// names, specify it as the optional third parameter.; ///; /// If you would like the basic block to be auto-inserted into the end of a; /// function, you can specify it as the optional fourth parameter.; ///; /// If you would like to collect additional information about the cloned; /// function, you can specify a ClonedCodeInfo object with the optional fifth; /// parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h:223,perform,performed,223,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Cloning.h,1,['perform'],['performed']
Performance,"/// Return a likelihood interval. A global fit to the likelihood is performed and; /// the interval is constructed using the profile likelihood ratio function of the POI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProfileLikelihoodCalculator.h:68,perform,performed,68,roofit/roostats/inc/RooStats/ProfileLikelihoodCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProfileLikelihoodCalculator.h,1,['perform'],['performed']
Performance,/// Return a node that can be scheduled in this cycle. Requirements:; /// (1) Ready: latency has been satisfied; /// (2) No Hazards: resources are available; /// (3) No Interferences: may unschedule to break register interferences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:85,latency,latency,85,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['latency'],['latency']
Performance,/// Return a pass that optimizes the code-size of x86 call sequences. This is; /// done by replacing esp-relative movs with pushes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:23,optimiz,optimizes,23,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h,1,['optimiz'],['optimizes']
Performance,/// Return a pass that reduces the size of vector constant pool loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:64,load,loads,64,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h,1,['load'],['loads']
Performance,"/// Return a pointer to the value of the current entry.; /// Return a nullptr and print an error if no entry has been loaded yet.; /// The returned address is guaranteed to stay constant while a given TTree is being read from a given file,; /// unless the branch addresses are manipulated directly (e.g. through TTree::SetBranchAddress()).; /// The address might also change when the underlying TTree/TFile is switched, e.g. when a TChain switches files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderValue.h:118,load,loaded,118,tree/treeplayer/inc/TTreeReaderValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderValue.h,1,['load'],['loaded']
Performance,/// Return a range of dbg.assign intrinsics for which \p Inst performs the; /// assignment they encode.; /// Iterators invalidated by deleting an intrinsic contained in this range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h:62,perform,performs,62,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h,1,['perform'],['performs']
Performance,/// Return a range of instructions (typically just one) that perform the; /// assignment that \p DAI encodes.; /// Iterators invalidated by adding or removing DIAssignID metadata to/from any; /// instruction (including by deleting or cloning instructions).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h:61,perform,perform,61,interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugInfo.h,1,['perform'],['perform']
Performance,"/// Return a reference to the value of the current entry.; /// Equivalent to dereferencing the pointer returned by Get(). Behavior is undefined if no entry has been loaded yet.; /// Most likely a crash will occur.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderValue.h:165,load,loaded,165,tree/treeplayer/inc/TTreeReaderValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderValue.h,1,['load'],['loaded']
Performance,/// Return a string representing the human readable name for the specified; /// function declaration or file name. Used by SourceLocExpr and; /// PredefinedExpr to cache evaluated results.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:164,cache,cache,164,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['cache'],['cache']
Performance,"/// Return a vector shuffle operation which; /// performs the same shuffe in terms of order or result bytes, but on a type; /// whose vector element type is narrower than the original shuffle type.; /// e.g. <v4i32> <0, 1, 0, 1> -> v8i16 <0, 1, 2, 3, 0, 1, 2, 3>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:49,perform,performs,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['perform'],['performs']
Performance,"/// Return a vector splice intrinsic if using scalable vectors, otherwise; /// return a shufflevector. If the immediate is positive, a vector is; /// extracted from concat(V1, V2), starting at Imm. If the immediate; /// is negative, we extract -Imm elements from V1 and the remaining; /// elements from V2. Imm is a signed integer in the range; /// -VL <= Imm < VL (where VL is the runtime vector length of the; /// source/result vector)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:46,scalab,scalable,46,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['scalab'],['scalable']
Performance,"/// Return an AST address space which can be used opportunistically; /// for constant global memory. It must be possible to convert pointers into; /// this address space to LangAS::Default. If no such address space exists,; /// this may return std::nullopt, and such optimizations will be disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:267,optimiz,optimizations,267,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['optimiz'],['optimizations']
Performance,/// Return an ElementCount instance to represent the (possibly scalable); /// number of elements in the vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:63,scalab,scalable,63,interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,1,['scalab'],['scalable']
Performance,/// Return an OptimizeCall object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:14,Optimiz,OptimizeCall,14,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,1,['Optimiz'],['OptimizeCall']
Performance,"/// Return an iterator pointing to the first set bit AT, OR AFTER, \p Index.; /// If no such set bit exists, return end(). This is like std::lower_bound.; /// This has worst-case logarithmic performance (roughly O(log(gaps between; /// contiguous ranges))).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:191,perform,performance,191,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,1,['perform'],['performance']
Performance,/// Return an iterator range to explore the cached context around \p PP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:44,cache,cached,44,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['cache'],['cached']
Performance,/// Return an iterator to explore the cached context around \p PP.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:38,cache,cached,38,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['cache'],['cached']
Performance,"/// Return base name for caches, i.e. the name of the cached function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedReal.h:25,cache,caches,25,roofit/roofitcore/inc/RooCachedReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedReal.h,2,['cache'],"['cached', 'caches']"
Performance,/// Return bit mask that contains all register classes that are projected into; /// RC by SubRegIdx. The result is cached in SuperRegMasks data-member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp:115,cache,cached,115,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,1,['cache'],['cached']
Performance,/// Return bitmask containing all allocatable register classes with registers; /// aligned at AlignNumBits. The result is cached in; /// AllocatableAndAlignedRegClassMasks data-member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp:122,cache,cached,122,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNRewritePartialRegUses.cpp,1,['cache'],['cached']
Performance,/// Return false if a sub-class wants to keep one of the loads/stores; /// after the SSA construction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h:57,load,loads,57,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SSAUpdater.h,1,['load'],['loads']
Performance,"/// Return how the indexed load should be treated: either it is legal, needs; /// to be promoted to a larger size, needs to be expanded to some other code; /// sequence, or the target has a custom expander for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:27,load,load,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],['load']
Performance,"/// Return how this load with extension should be treated: either it is legal,; /// needs to be promoted to a larger size, needs to be expanded to some other; /// code sequence, or the target has a custom expander for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:20,load,load,20,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,/// Return if a code hotness metric should be included in optimization; /// diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:58,optimiz,optimization,58,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,1,['optimiz'],['optimization']
Performance,"/// Return information related to the DWARF DIE we're looking for when; /// performing a lookup by name.; ///; /// \param HashDataOffset an offset into the hash data table; /// \returns <DieOffset, DieTag>; /// DieOffset is the offset into the .debug_info section for the DIE; /// related to the input hash data offset.; /// DieTag is the tag of the DIE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h:76,perform,performing,76,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFAcceleratorTable.h,1,['perform'],['performing']
Performance,"/// Return metadata containing the entry \p Count for a function, a boolean; /// \Synthetic indicating whether the counts were synthetized, and the; /// GUIDs stored in \p Imports that need to be imported for sample PGO, to; /// enable the same inlines as the profiled optimized binary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/MDBuilder.h:269,optimiz,optimized,269,interpreter/llvm-project/llvm/include/llvm/IR/MDBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/MDBuilder.h,1,['optimiz'],['optimized']
Performance,"/// Return pointer to the used objective function for fitting.; /// If using an external function (e.g. given in SetFCN), return the cached pointer,; /// otherwise use the one stored as shared ptr and managed by the Fitter class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h:133,cache,cached,133,math/mathcore/inc/Fit/Fitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/Fitter.h,1,['cache'],['cached']
Performance,/// Return pointers that are possibly written to on the path from a; /// forwarding store to a load.; ///; /// These pointers need to be alias-checked against the forwarding candidates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:95,load,load,95,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['load'],['load']
Performance,"/// Return size of cache",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h:19,cache,cache,19,roofit/roofitcore/inc/RooCacheManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCacheManager.h,1,['cache'],['cache']
Performance,"/// Return the FileID for a SourceLocation with a high offset.; ///; /// This function knows that the SourceLocation is in a loaded buffer, not a; /// local one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:125,load,loaded,125,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['load'],['loaded']
Performance,"/// Return the FileID for a SourceLocation with a low offset.; ///; /// This function knows that the SourceLocation is in a local buffer, not a; /// loaded one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:149,load,loaded,149,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['load'],['loaded']
Performance,"/// Return the MemoryAccess associated with the optimized use, or nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:48,optimiz,optimized,48,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['optimiz'],['optimized']
Performance,"/// Return the VPValues stored by this interleave group. If it is a load; /// interleave group, return an empty ArrayRef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:68,load,load,68,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['load'],['load']
Performance,"/// Return the addressing mode for this load or store:; /// unindexed, pre-inc, pre-dec, post-inc, or post-dec.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:40,load,load,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,3,['load'],['load']
Performance,/// Return the alignment of the access that is being performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:53,perform,performed,53,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['perform'],['performed']
Performance,"/// Return the base name for cache objects, in this case the name of the cached p.d.f",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedPdf.h:29,cache,cache,29,roofit/roofitcore/inc/RooCachedPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCachedPdf.h,2,['cache'],"['cache', 'cached']"
Performance,"/// Return the basic size of this type if it is a primitive type. These are; /// fixed by LLVM and are not target-dependent.; /// This will return zero if the type does not have a size or is not a; /// primitive type.; ///; /// If this is a scalable vector type, the scalable property will be set and; /// the runtime size will be a positive integer multiple of the base size.; ///; /// Note that this may not reflect the size of memory allocated for an; /// instance of the type or the number of bytes that are written when an; /// instance of the type is stored to memory. The DataLayout class provides; /// additional query functions to provide this information.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Type.h:241,scalab,scalable,241,interpreter/llvm-project/llvm/include/llvm/IR/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Type.h,2,['scalab'],['scalable']
Performance,"/// Return the buffer, only if it has been loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:43,load,loaded,43,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,/// Return the builtin name for the __builtin___clear_cache intrinsic; /// Default is to invoke the clear cache library call,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:106,cache,cache,106,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['cache'],['cache']
Performance,"/// Return the cache associatvity for the given level of cache.; /// Level is zero-based, so a value of zero means the first level of; /// cache.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:15,cache,cache,15,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,3,['cache'],['cache']
Performance,/// Return the cache entry for comparing the given file IDs; /// for isBeforeInTranslationUnit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:15,cache,cache,15,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,2,['cache'],['cache']
Performance,"/// Return the cache size in bytes for the given level of cache.; /// Level is zero-based, so a value of zero means the first level of; /// cache.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:15,cache,cache,15,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,3,['cache'],['cache']
Performance,/// Return the cached assumptions for a function if it has already been; /// scanned. Otherwise return nullptr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h:15,cache,cached,15,interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AssumptionCache.h,1,['cache'],['cached']
Performance,"/// Return the cached comparison category information for the; /// specified 'Kind'. If no cache entry is present the comparison category; /// type is looked up. If lookup fails nullptr is returned. Otherwise, a; /// new cache entry is created and returned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h:15,cache,cached,15,interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h,3,['cache'],"['cache', 'cached']"
Performance,"/// Return the comparison category information as specified by; /// `getCategoryForType(Ty)`. If the information is not already cached,; /// the declaration is looked up and a cache entry is created.; /// NOTE: Lookup is expected to succeed. Use lookupInfo if failure is; /// possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h:128,cache,cached,128,interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ComparisonCategories.h,2,['cache'],"['cache', 'cached']"
Performance,/// Return the cost of full scalarization of gather / scatter operation.; ///; /// Opcode - Load or Store instruction.; /// SrcVTy - The type of the data vector that should be gathered or scattered.; /// VariableMask - The mask is non-constant at compile time.; /// Alignment - Alignment for one element.; /// AddressSpace - pointer[s] address space.; ///; /// FIXME: Add TargetCostKind support.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:92,Load,Load,92,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['Load'],['Load']
Performance,"/// Return the cost of the scaling factor used in the addressing; /// mode represented by AM for this target, for a load/store; /// of the specified type.; /// If the AM is supported, the return value must be >= 0.; /// If the AM is not supported, it returns a negative value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h:116,load,load,116,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h,2,['load'],['load']
Performance,"/// Return the cost of the scaling factor used in the addressing; /// mode represented by AM for this target, for a load/store; /// of the specified type.; /// If the AM is supported, the return value must be >= 0.; /// If the AM is not supported, it returns a negative value.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:116,load,load,116,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,/// Return the costs for our two available strategies for lowering a; /// div/rem operation which requires speculating at least one lane.; /// First result is for scalarization (will be invalid for scalable; /// vectors); second is for the safe-divisor strategy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:198,scalab,scalable,198,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['scalab'],['scalable']
Performance,"/// Return the current execution domain and bit mask of; /// possible domains for instruction.; ///; /// Some micro-architectures have multiple execution domains, and multiple; /// opcodes that perform the same operation in different domains. For; /// example, the x86 architecture provides the por, orps, and orpd; /// instructions that all do the same thing. There is a latency penalty if a; /// register is written in one domain and read in another.; ///; /// This function returns a pair (domain, mask) containing the execution; /// domain of MI, and a bit mask of possible domains. The setExecutionDomain; /// function can be used to change the opcode to one of the domains in the; /// bit mask. Instructions whose execution domain can't be changed should; /// return a 0 mask.; ///; /// The execution domain numbers don't have any special meaning except domain; /// 0 is used for instructions that are not associated with any interesting; /// execution domain.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:194,perform,perform,194,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,"['latency', 'perform']","['latency', 'perform']"
Performance,/// Return the current stored value. Returns \a None if there is a concurrent; /// \a loadOrGenerate() in flight.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h:67,concurren,concurrent,67,interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/LazyAtomicPointer.h,2,"['concurren', 'load']","['concurrent', 'loadOrGenerate']"
Performance,"/// Return the current virtual root of the Selection DAG, flushing any; /// PendingLoad items. This must be done before emitting a store or any other; /// memory node that may need to be ordered after any prior load instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:211,load,load,211,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,1,['load'],['load']
Performance,/// Return the default expected latency for a def based on it's opcode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:32,latency,latency,32,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['latency'],['latency']
Performance,/// Return the default expected latency for a def based on its opcode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:32,latency,latency,32,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['latency'],['latency']
Performance,/// Return the default p2align value for a load or store with the given opcode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h:43,load,load,43,interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyMCTargetDesc.h,1,['load'],['load']
Performance,/// Return the destination virtual register of the last instruction; /// that loads from object Entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:78,load,loads,78,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,1,['load'],['loads']
Performance,"/// Return the documentation comment attached to a given declaration,; /// without looking into cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:96,cache,cache,96,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['cache'],['cache']
Performance,/// Return the expected code size delta if the conversion into a; /// conditional compare is performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp:93,perform,performed,93,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,1,['perform'],['performed']
Performance,/// Return the immediate offset of the base register in a load/store \p LdSt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:58,load,load,58,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,/// Return the internal information cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:36,cache,cache,36,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['cache'],['cache']
Performance,"/// Return the list of temporaries nodes in the queue, these need to be; /// loaded before we can flush the queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:48,queue,queue,48,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,3,"['load', 'queue']","['loaded', 'queue']"
Performance,/// Return the load address of this section with an offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h:15,load,load,15,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/RuntimeDyldImpl.h,1,['load'],['load']
Performance,"/// Return the load opcode for a given load size. If load size >= 8,; /// neon opcode will be returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:15,load,load,15,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,3,['load'],['load']
Performance,"/// Return the maximal number of alias checks on memory operands. For; /// instructions with more than one memory operands, the alias check on a; /// single MachineInstr pair has quadratic overhead and results in; /// unacceptable performance in the worst case. The limit here is to clamp; /// that maximal checks performed. Usually, that's the product of memory; /// operand numbers from that pair of MachineInstr to be checked. For; /// instance, with two MachineInstrs with 4 and 5 memory operands; /// correspondingly, a total of 20 checks are required. With this limit set to; /// 16, their alias check is skipped. We choose to limit the product instead; /// of the individual instruction as targets may have special MachineInstrs; /// with a considerably high number of memory operands, such as `ldm` in ARM.; /// Setting this limit per MachineInstr would result in either too high; /// overhead or too rigid restriction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:231,perform,performance,231,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,['perform'],"['performance', 'performed']"
Performance,"/// Return the minimum hotness value a diagnostic would need in order; /// to be included in optimization diagnostics.; ///; /// Three possible return values:; /// 0 - threshold is disabled. Everything will be printed out.; /// positive int - threshold is set.; /// UINT64_MAX - threshold is not yet set, and needs to be synced from; /// profile summary. Note that in case of missing profile; /// summary, threshold will be kept at ""MAX"", effectively; /// suppresses all remarks output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h:93,optimiz,optimization,93,interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LLVMContext.h,1,['optimiz'],['optimization']
Performance,"/// Return the number of bits overwritten by a store of the specified value; /// type.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:120,scalab,scalable,120,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,4,['scalab'],['scalable']
Performance,"/// Return the number of bytes overwritten by a store of the specified value; /// type.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:121,scalab,scalable,121,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,4,['scalab'],['scalable']
Performance,"/// Return the number of currently available slot.; ///; /// The method is safe to call concurrently to other TThreadedObject methods.; /// Note that slots could be available but contain no data (i.e. a nullptr) if; /// they have not been used yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:88,concurren,concurrently,88,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['concurren'],['concurrently']
Performance,/// Return the number of cycles to add to (or subtract from) the static; /// itinerary based on the def opcode and alignment. The caller will ensure that; /// adjusted latency is at least one cycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:168,latency,latency,168,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['latency'],['latency']
Performance,/// Return the number of instructions that dominate the current; /// instruction and load the function address from object Entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp:85,load,load,85,interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsOptimizePICCall.cpp,1,['load'],['load']
Performance,"/// Return the opcode (SEXT/ZEXT/ANYEXT) that should be performed while; /// widening a constant of type SmallTy which targets can override.; /// For eg, the DAG does (SmallTy.isByteSized() ? G_SEXT : G_ZEXT) which; /// will be the default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:56,perform,performed,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['perform'],['performed']
Performance,/// Return the runtime function for optimized setting properties.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h:36,optimiz,optimized,36,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,1,['optimiz'],['optimized']
Performance,"/// Return the set of vectors that a matrix value is lowered to.; ///; /// If we lowered \p MatrixVal, just return the cache result matrix. Otherwise; /// split the flat vector \p MatrixVal containing a matrix with shape \p SI; /// into vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:119,cache,cache,119,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['cache'],['cache']
Performance,/// Return the size of the specified fixed width value type in bits. The; /// function will assert if the type is scalable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:114,scalab,scalable,114,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,2,['scalab'],['scalable']
Performance,"/// Return the size of the specified value type in bits.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:90,scalab,scalable,90,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,2,['scalab'],['scalable']
Performance,/// Return the target cache line size in bytes at a given level.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:22,cache,cache,22,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,1,['cache'],['cache']
Performance,"/// Return the target cache line size in bytes. By default, return; /// the line size for the bottom-most level of cache. This provides; /// a more convenient interface for the common case where all cache; /// levels have the same line size. Return zero if there is no; /// cache model.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h:22,cache,cache,22,interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSubtargetInfo.h,4,['cache'],['cache']
Performance,"/// Return the total stage latency of the given class. The latency is; /// the maximum completion time for any stage in the itinerary. If no stages; /// exist, it defaults to one cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h:27,latency,latency,27,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrItineraries.h,2,['latency'],['latency']
Performance,/// Return the type of the mask type suitable for masking the provided; /// vector type. This is simply an i1 element type vector of the same; /// (possibly scalable) length.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:157,scalab,scalable,157,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['scalab'],['scalable']
Performance,"/// Return the unique reference to a scalable vector type of the specified; /// element type and scalable number of elements.; /// For RISC-V, number of fields is also provided when it fetching for; /// tuple type.; ///; /// \pre \p EltTy must be a built-in type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:37,scalab,scalable,37,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,2,['scalab'],['scalable']
Performance,"/// Return the value that a load from C with offset Offset would produce if it; /// is constant and determinable. If this is not determinable, return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:28,load,load,28,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,1,['load'],['load']
Performance,"/// Return the value that a load from C would produce if it is constant and; /// determinable. If this is not determinable, return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h:28,load,load,28,interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ConstantFolding.h,1,['load'],['load']
Performance,"/// Return the value that would be computed by a load from P after the stores; /// reflected by 'memory' have been performed. If we can't decide, return null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:49,load,load,49,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,2,"['load', 'perform']","['load', 'performed']"
Performance,"/// Return true for all instructions that only update; /// the first 32 or 64-bits of the destination register and leave the rest; /// unmodified. This can be used to avoid folding loads if the instructions; /// only update part of the destination register, and the non-updated part is; /// not needed. e.g. cvtss2sd, sqrtss. Unfolding the load from these; /// instructions breaks the partial register dependency and it can improve; /// performance. e.g.:; ///; /// movss (%rdi), %xmm0; /// cvtss2sd %xmm0, %xmm0; ///; /// Instead of; /// cvtss2sd (%rdi), %xmm0; ///; /// FIXME: This should be turned into a TSFlags.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:181,load,loads,181,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,3,"['load', 'perform']","['load', 'loads', 'performance']"
Performance,"/// Return true for instructions that can be folded as memory operands; /// in other instructions. The most common use for this is instructions that; /// are simple loads from memory that don't modify the loaded value in any; /// way, but it can also be used for instructions that can be expressed as; /// constant-pool loads, such as V_SETALLONES on x86, to allow them to be; /// folded when it is beneficial. This should only be set on instructions; /// that return a value in their only virtual register definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h:165,load,loads,165,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,3,['load'],"['loaded', 'loads']"
Performance,"/// Return true for instructions that can be folded as; /// memory operands in other instructions. The most common use for this; /// is instructions that are simple loads from memory that don't modify; /// the loaded value in any way, but it can also be used for instructions; /// that can be expressed as constant-pool loads, such as V_SETALLONES; /// on x86, to allow them to be folded when it is beneficial.; /// This should only be set on instructions that return a value in their; /// only virtual register definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:165,load,loads,165,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,3,['load'],"['loaded', 'loads']"
Performance,/// Return true for loads/stores that can be combined to a double/multi; /// operation without increasing the requirements for alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:20,load,loads,20,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['load'],['loads']
Performance,/// Return true if 'MI' is a load or a store that may be fold it's address; /// operand into the load / store addressing mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:29,load,load,29,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,2,['load'],['load']
Performance,/// Return true if 'Use' is a load or a store that uses N as its base pointer; /// and that N may be folded in the load / store addressing mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:30,load,load,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['load'],['load']
Performance,"/// Return true if MI is likely to be usable as a memory operation by the; /// implicit null check optimization.; ///; /// This is a ""best effort"" heuristic, and should not be relied upon for; /// correctness. This returning true does not guarantee that the implicit null; /// check optimization is legal over MI, and this returning false does not; /// guarantee MI cannot possibly be used to do a null check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:99,optimiz,optimization,99,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,2,['optimiz'],['optimization']
Performance,"/// Return true if \p Load and \p Ext can form an ExtLoad.; /// For example, in AArch64; /// %L = load i8, i8* %ptr; /// %E = zext i8 %L to i32; /// can be lowered into one load instruction; /// ldrb w0, [x0]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:22,Load,Load,22,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,3,"['Load', 'load']","['Load', 'load']"
Performance,"/// Return true if \p MA represents the live on entry value; ///; /// Loads and stores from pointer arguments and other global values may be; /// defined by memory operations that do not occur in the current function, so; /// they may be live on entry to the function. MemorySSA represents such; /// memory state by the live on entry definition, which is guaranteed to occur; /// before any other memory access in the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:70,Load,Loads,70,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['Load'],['Loads']
Performance,/// Return true if \p MI is a load or store of \p NumBytes bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:30,load,load,30,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['load'],['load']
Performance,"/// Return true if a .align directive should use ""optimized nops"" to fill; /// instead of 0s.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSection.h:50,optimiz,optimized,50,interpreter/llvm-project/llvm/include/llvm/MC/MCSection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSection.h,1,['optimiz'],['optimized']
Performance,/// Return true if a load or store of the type should be lowered with a bitcast; /// to a different type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:21,load,load,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['load'],['load']
Performance,/// Return true if a stride load store of the given result type and; /// alignment is legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:28,load,load,28,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,1,['load'],['load']
Performance,"/// Return true if a truncation from FromTy to ToTy is permitted when deciding; /// whether a call is in tail position. Typically this means that both results; /// would be assigned to the same register or stack slot, but it could mean; /// the target performs adequate checks of its own before proceeding with the; /// tail call. Targets must return false when FromTy <= ToTy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:252,perform,performs,252,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['performs']
Performance,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:107,load,loads,107,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['load'],['loads']
Performance,"/// Return true if all the baskets that are marked loaded are also; /// mark as used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:51,load,loaded,51,tree/tree/inc/TBranchCacheInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h,1,['load'],['loaded']
Performance,"/// Return true if all uses of any loads from GV will trap if the loaded value; /// is null. Note that this also permits comparisons of the loaded value; /// against null, as a special case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:35,load,loads,35,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,3,['load'],"['loaded', 'loads']"
Performance,"/// Return true if both \p LHS and \p RHS are in the local source; /// location address space or the loaded one.; ///; /// If it's true and \p RelativeOffset is non-null, it will be set to the; /// offset of \p RHS relative to \p LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:101,load,loaded,101,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,"/// Return true if branch divergence exists.; ///; /// Branch divergence has a significantly negative impact on GPU performance; /// when threads in the same wavefront take different paths due to conditional; /// branches.; ///; /// If \p F is passed, provides a context function. If \p F is known to only; /// execute in a single threaded environment, the target may choose to skip; /// uniformity analysis and assume all values are uniform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:116,perform,performance,116,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['perform'],['performance']
Performance,"/// Return true if call address is a load and it can be; /// moved below CALLSEQ_START and the chains leading up to the call.; /// Return the CALLSEQ_START by reference as a second output.; /// In the case of a tail call, there isn't a callseq node between the call; /// chain and the load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:37,load,load,37,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['load'],['load']
Performance,"/// Return true if folding a vector load into ExtVal (a sign, zero, or any; /// extend node) is profitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:36,load,load,36,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],['load']
Performance,"/// Return true if get the base operand, byte offset of an instruction and; /// the memory width. Width is the size of memory that is being; /// loaded/stored (e.g. 1, 2, 4, 8).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h:145,load,loaded,145,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.h,1,['load'],['loaded']
Performance,"/// Return true if integer divide is usually cheaper than a sequence of; /// several shifts, adds, and multiplies for this target.; /// The definition of ""cheaper"" may depend on whether we're optimizing; /// for speed or for size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:192,optimiz,optimizing,192,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['optimiz'],['optimizing']
Performance,/// Return true if it has an unscaled load/store offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:38,load,load,38,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,/// Return true if it is beneficial to convert a load of a constant to; /// just the constant itself.; /// On some targets it might be more efficient to use a combination of; /// arithmetic instructions to materialize the constant instead of loading it; /// from a constant pool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:49,load,load,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],"['load', 'loading']"
Performance,"/// Return true if it is beneficial to expand an @llvm.powi.* intrinsic.; /// If not optimizing for size, expanding @llvm.powi.* intrinsics is always; /// considered beneficial.; /// If optimizing for size, expansion is only considered beneficial for upto; /// 5 multiplies and a divide (if the exponent is negative).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:85,optimiz,optimizing,85,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['optimiz'],['optimizing']
Performance,"/// Return true if it is desirable to convert a computation from 'From' to 'To'.; /// We don't want to convert from a legal to an illegal type or from a smaller; /// to a larger illegal type. i1 is always treated as a legal type because it is; /// a fundamental type in IR, and there are many specialized optimizations for; /// i1 types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:305,optimiz,optimizations,305,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['optimiz'],['optimizations']
Performance,"/// Return true if it is desirable to convert an integer computation from a; /// given bit width to a new bit width.; /// We don't want to convert from a legal or desirable type (like i8) to an; /// illegal type or from a smaller to a larger illegal type. A width of '1'; /// is always treated as a desirable type because i1 is a fundamental type in; /// IR, and there are many specialized optimizations for i1 types.; /// Common/desirable widths are equally treated as legal to convert to, in; /// order to open up more combining opportunities.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:390,optimiz,optimizations,390,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['optimiz'],['optimizations']
Performance,"/// Return true if it is possible to insert a select; /// instruction that chooses between TrueReg and FalseReg based on the; /// condition code in Cond.; ///; /// When successful, also return the latency in cycles from TrueReg,; /// FalseReg, and Cond to the destination register. In most cases, a select; /// instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1; ///; /// Some x86 implementations have 2-cycle cmov instructions.; ///; /// @param MBB Block where select instruction would be inserted.; /// @param Cond Condition returned by analyzeBranch.; /// @param DstReg Virtual dest register that the result should write to.; /// @param TrueReg Virtual register to select when Cond is true.; /// @param FalseReg Virtual register to select when Cond is false.; /// @param CondCycles Latency from Cond+Branch to select output.; /// @param TrueCycles Latency from TrueReg to select output.; /// @param FalseCycles Latency from FalseReg to select output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:197,latency,latency,197,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,4,"['Latency', 'latency']","['Latency', 'latency']"
Performance,/// Return true if it is profitable for dag combiner to transform a floating; /// point op of specified opcode to a equivalent op of an integer; /// type. e.g. f32 load -> i32 load can be profitable on ARM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:164,load,load,164,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],['load']
Performance,/// Return true if it is profitable to convert a select of FP constants into; /// a constant pool load whose address depends on the select condition. The; /// parameter may be used to differentiate a select with FP compare from; /// integer compare.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:98,load,load,98,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,/// Return true if it is profitable to reduce a load to a smaller type.; /// Example: (i16 (trunc (i32 (load x))) -> i16 load x,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:48,load,load,48,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,3,['load'],['load']
Performance,"/// Return true if it is valid to use the assumptions provided by an; /// assume intrinsic, I, at the point in the control-flow identified by the; /// context instruction, CxtI. By default, ephemeral values of the assumption; /// are treated as an invalid context, to prevent the assumption from being used; /// to optimize away its argument. If the caller can ensure that this won't; /// happen, it can call with AllowEphemerals set to true to get more valid; /// assumptions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:315,optimiz,optimize,315,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['optimiz'],['optimize']
Performance,"/// Return true if it is worth folding MI into an extended register. That is,; /// if it's safe to pull it into the addressing mode of a load or store as a; /// shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:137,load,load,137,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['load'],['load']
Performance,"/// Return true if it's profitable to predicate; /// instructions with accumulated instruction latency of ""NumCycles""; /// of the specified basic block, where the probability of the instructions; /// being executed is given by Probability, and Confidence is a measure; /// of our confidence that it will be properly predicted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:95,latency,latency,95,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,['latency'],['latency']
Performance,/// Return true if loads are next to each other and can be; /// merged. Check that both are nonvolatile and if LD is loading; /// 'Bytes' bytes from a location that is 'Dist' units away from the; /// location that the 'Base' load is loading from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:19,load,loads,19,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,4,['load'],"['load', 'loading', 'loads']"
Performance,"/// Return true if missed optimization remarks are enabled, override; /// to provide different implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticHandler.h:26,optimiz,optimization,26,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticHandler.h,1,['optimiz'],['optimization']
Performance,/// Return true if pairing the given load or store is hinted to be; /// unprofitable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:37,load,load,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,/// Return true if pairing the given load or store may be paired with another.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:37,load,load,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,"/// Return true if passed optimization remarks are enabled, override; /// to provide different implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticHandler.h:26,optimiz,optimization,26,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticHandler.h,1,['optimiz'],['optimization']
Performance,/// Return true if scalable vector with ScalarTy is legal for lowering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp:19,scalab,scalable,19,interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/GISel/RISCVCallLowering.cpp,1,['scalab'],['scalable']
Performance,"/// Return true if size-info optimization remark is enabled, false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:29,optimiz,optimization,29,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['optimiz'],['optimization']
Performance,"/// Return true if speculation of the given load must be suppressed to avoid; /// ordering or interfering with an active sanitizer. If not suppressed,; /// dereferenceability and alignment must be proven separately. Note: This; /// is only needed for raw reasoning; if you use the interface below; /// (isSafeToSpeculativelyExecute), this is handled internally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:44,load,load,44,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['load'],['load']
Performance,/// Return true if the Loader is stripping TBAA metadata.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h:23,Load,Loader,23,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.h,1,['Load'],['Loader']
Performance,"/// Return true if the Object is writable, in the sense that any location based; /// on this pointer that can be loaded can also be stored to without trapping.; /// Additionally, at the point Object is declared, stores can be introduced; /// without data races. At later points, this is only the case if the pointer; /// can not escape to a different thread.; ///; /// If ExplicitlyDereferenceableOnly is set to true, this property only holds; /// for the part of Object that is explicitly marked as dereferenceable, e.g.; /// using the dereferenceable(N) attribute. It does not necessarily hold for; /// parts that are only known to be dereferenceable due to the presence of; /// loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:113,load,loaded,113,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,['load'],"['loaded', 'loads']"
Performance,/// Return true if the SCEV is a scAddRecExpr or it contains; /// scAddRecExpr. The result will be cached in HasRecMap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:99,cache,cached,99,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['cache'],['cached']
Performance,"/// Return true if the addressing mode represented by AM is legal for this; /// target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:94,load,load,94,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,3,['load'],['load']
Performance,"/// Return true if the addressing mode represented by AM is legal for this; /// target, for a load/store of the specified type.; ///; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type. TODO: Handle; /// pre/postinc as well.; ///; /// If the address space cannot be determined, it will be -1.; ///; /// TODO: Remove default argument",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:94,load,load,94,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],['load']
Performance,"/// Return true if the addressing mode represented by AM is legal for; /// this target, for a load/store of the specified type.; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type.; /// If target returns true in LSRWithInstrQueries(), I may be valid.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:94,load,load,94,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,2,['load'],['load']
Performance,"/// Return true if the addressing mode represented; /// by AM is legal for this target, for a load/store of the specified type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:94,load,load,94,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,2,['load'],['load']
Performance,"/// Return true if the analyzed function is actually a default implementation; /// of the method that has to be overriden.; ///; /// These functions can have tracked parameters, but wouldn't call them; /// because they are not designed to perform any meaningful actions.; ///; /// There are a couple of flavors of such default implementations:; /// 1. Empty methods or methods with a single return statement; /// 2. Methods that have one block with a call to no return function; /// 3. Methods with only assertion-like operations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:239,perform,perform,239,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['perform'],['perform']
Performance,"/// Return true if the basket is currently in the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h:50,cache,cache,50,tree/tree/inc/TBranchCacheInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBranchCacheInfo.h,1,['cache'],['cache']
Performance,"/// Return true if the current class is trivial in the given state.; /// A class is trivial if and only if there is not any member relations stored; /// to it in State/ClassMembers.; /// An equivalence class with one member might seem as it does not hold any; /// meaningful information, i.e. that is a tautology. However, during the; /// removal of dead symbols we do not remove classes with one member for; /// resource and performance reasons. Consequently, a class with one member is; /// not necessarily trivial. It could happen that we have a class with two; /// members and then during the removal of dead symbols we remove one of its; /// members. In this case, the class is still non-trivial (it still has the; /// mappings in ClassMembers), even though it has only one member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:426,perform,performance,426,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['perform'],['performance']
Performance,"/// Return true if the currently cached values match up with; /// the specified LHS/RHS query.; ///; /// If not, we can't use the cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:33,cache,cached,33,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,2,['cache'],"['cache', 'cached']"
Performance,"/// Return true if the currently visible definition of this global (if any) is; /// exactly the definition we will see at runtime.; ///; /// Non-exact linkage types inhibits most non-inlining IPO, since a; /// differently optimized variant of the same function can have different; /// observable or undefined behavior than in the variant currently visible.; /// For instance, we could have started with; ///; /// void foo(int *v) {; /// int t = 5 / v[0];; /// (void) t;; /// }; ///; /// and ""refined"" it to; ///; /// void foo(int *v) { }; ///; /// However, we cannot infer readnone for `foo`, since that would justify; /// DSE'ing a store to `v[0]` across a call to `foo`, which can cause; /// undefined behavior if the linker replaces the actual call destination with; /// the unoptimized `foo`.; ///; /// Inlining is okay across non-exact linkage types as long as they're not; /// interposable (see \c isInterposable), since in such cases the currently; /// visible variant is *a* correct implementation of the original source; /// function; it just isn't the *only* correct implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:222,optimiz,optimized,222,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['optimiz'],['optimized']
Performance,/// Return true if the dependence from the store to the load has an; /// absolute distance of one.; /// E.g. A[i+1] = A[i] (or A[i-1] = A[i] for descending loop),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:56,load,load,56,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['load'],['load']
Performance,"/// Return true if the extension represented by \p I is free.; /// Unlikely the is[Z|FP]ExtFree family which is based on types,; /// this method can use the context provided by \p I to decide; /// whether or not \p I is free.; /// This method extends the behavior of the is[Z|FP]ExtFree family.; /// In other words, if is[Z|FP]Free returns true, then this method; /// returns true as well. The converse is not true.; /// The target can perform the adequate checks by overriding isExtFreeImpl.; /// \pre \p I must be a sign, zero, or fp extension.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:436,perform,perform,436,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['perform']
Performance,"/// Return true if the following transform is beneficial:; /// fold (conv (load x)) -> (load (conv*)x); /// On architectures that don't natively support some vector loads; /// efficiently, casting the load to a smaller vector of larger types and; /// loading is more efficient, however, this can be undone by optimizations in; /// dag combiner.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:75,load,load,75,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,6,"['load', 'optimiz']","['load', 'loading', 'loads', 'optimizations']"
Performance,"/// Return true if the given callsite is hot wrt to hot cutoff threshold.; ///; /// Functions that were inlined in the original binary will be represented; /// in the inline stack in the sample profile. If the profile shows that; /// the original inline decision was ""good"" (i.e., the callsite is executed; /// frequently), then we will recreate the inline decision and apply the; /// profile from the inlined callsite.; ///; /// To decide whether an inlined callsite is hot, we compare the callsite; /// sample count with the hot cutoff computed by ProfileSummaryInfo, it is; /// regarded as hot if the count is above the cutoff value.; ///; /// When ProfileAccurateForSymsInList is enabled and profile symbol list; /// is present, functions in the profile symbol list but without profile will; /// be regarded as cold and much less inlining will happen in CGSCC inlining; /// pass, so we tend to lower the hot criteria here to allow more early; /// inlining to happen for warm callsites and it is helpful for performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp:1011,perform,performance,1011,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,1,['perform'],['performance']
Performance,"/// Return true if the given instruction (assumed to be a memory access; /// instruction) has a volatile variant. If that's the case then we can avoid; /// addrspacecast to generic AS for volatile loads/stores. Default; /// implementation returns false, which prevents address space inference for; /// volatile loads/stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:197,load,loads,197,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,2,['load'],['loads']
Performance,/// Return true if the given load or store is a strided memory access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:29,load,load,29,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,"/// Return true if the given value is a source in the use-def chain, producing; /// a narrow 'TypeSize' value. These values will be zext to start the promotion; /// of the tree to i32. We guarantee that these won't populate the upper bits; /// of the register. ZExt on the loads will be free, and the same for call; /// return values because we only accept ones that guarantee a zeroext ret val.; /// Many arguments will have the zeroext attribute too, so those would be free; /// too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:273,load,loads,273,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,1,['load'],['loads']
Performance,"/// Return true if the given value is known to be non-zero when defined. For; /// vectors, return true if every demanded element is known to be non-zero when; /// defined. For pointers, if the context instruction and dominator tree are; /// specified, perform context-sensitive analysis and return true if the; /// pointer couldn't possibly be null at the specified instruction.; /// Supports values with integer or pointer type and vectors of integers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:252,perform,perform,252,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['perform'],['perform']
Performance,"/// Return true if the given value is known to be non-zero when defined. For; /// vectors, return true if every element is known to be non-zero when; /// defined. For pointers, if the context instruction and dominator tree are; /// specified, perform context-sensitive analysis and return true if the; /// pointer couldn't possibly be null at the specified instruction.; /// Supports values with integer or pointer type and vectors of integers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:243,perform,perform,243,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['perform'],['perform']
Performance,/// Return true if the identifier in its current state was loaded; /// from an AST file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:59,load,loaded,59,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['load'],['loaded']
Performance,"/// Return true if the indexed reference is 'consecutive' in loop \p L.; /// An indexed reference is 'consecutive' if the only coefficient that uses; /// the loop induction variable is the rightmost one, and the access stride is; /// smaller than the cache line size \p CLS. Provide a valid \p Stride value; /// if the indexed reference is 'consecutive'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:251,cache,cache,251,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,1,['cache'],['cache']
Performance,"/// Return true if the induction variable can underflow in the first iteration.; /// An example, is an initial unsigned value that is 0 and is decrement in the; /// first itertion of a do-while loop. In this case, we cannot generate a; /// hardware loop because the endloop instruction does not decrement the loop; /// counter if it is <= 1. We only need to perform this analysis if the; /// initial value is a register.; ///; /// This function assumes the initial value may underfow unless proven; /// otherwise. If the type is signed, then we don't care because signed; /// underflow is undefined. We attempt to prove the initial value is not; /// zero by perfoming a crude analysis of the loop counter. This function; /// checks if the initial value is used in any comparison prior to the loop; /// and, if so, assumes the comparison is a range check. This is inexact,; /// but will catch the simple cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:358,perform,perform,358,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['perform'],['perform']
Performance,"/// Return true if the instruction does not have any effects besides; /// calculating the result and does not have undefined behavior.; ///; /// This method never returns true for an instruction that returns true for; /// mayHaveSideEffects; however, this method also does some other checks in; /// addition. It checks for undefined behavior, like dividing by zero or; /// loading from an invalid pointer (but not for undefined results, like a; /// shift with a shift amount larger than the width of the result). It checks; /// for malloc and alloca because speculatively executing them might cause a; /// memory leak. It also returns false for instructions related to control; /// flow, specifically terminators and PHI nodes.; ///; /// If the CtxI is specified this method performs context-sensitive analysis; /// and returns true if it is safe to execute the instruction immediately; /// before the CtxI.; ///; /// If the CtxI is NOT specified this method only looks at the instruction; /// itself and its operands, so if this method returns true, it is safe to; /// move the instruction as long as the correct dominance relationships for; /// the operands and users hold.; ///; /// This method can return true for instructions that read memory;; /// for such instructions, moving them may change the resulting value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:373,load,loading,373,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,2,"['load', 'perform']","['loading', 'performs']"
Performance,"/// Return true if the instruction is as cheap as a move instruction.; ///; /// Targets for different archs need to override this, and different; /// micro-architectures can also be finely tuned inside.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:189,tune,tuned,189,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['tune'],['tuned']
Performance,"/// Return true if the instruction is marked ""cheap"" or the operand latency; /// between its def and a use is one or less.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:68,latency,latency,68,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['latency'],['latency']
Performance,/// Return true if the load is not executed on all paths in the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:23,load,load,23,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['load'],['load']
Performance,/// Return true if the macro directive was loaded from a PCH file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MacroInfo.h:43,load,loaded,43,interpreter/llvm-project/clang/include/clang/Lex/MacroInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MacroInfo.h,1,['load'],['loaded']
Performance,"/// Return true if the only users of this instruction are outside of; /// the loop. If this is true, we can sink the instruction to the exit; /// blocks of the loop.; ///; /// We also return true if the instruction could be folded away in lowering.; /// (e.g., a GEP can be folded into a load as an addressing mode in the loop).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:288,load,load,288,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['load'],['load']
Performance,/// Return true if the optimized regalloc pipeline is enabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:23,optimiz,optimized,23,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['optimiz'],['optimized']
Performance,"/// Return true if the provided MachineInstruction has cache prefetch hints. In; /// that case, the prefetch hints are stored, in order, in the Prefetches; /// vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp:55,cache,cache,55,interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InsertPrefetch.cpp,1,['cache'],['cache']
Performance,/// Return true if the provided declaration \a VD should be captured by; /// reference.; /// \param Level Relative level of nested OpenMP construct for that the check; /// is performed.; /// \param OpenMPCaptureLevel Capture level within an OpenMP construct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:175,perform,performed,175,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['perform'],['performed']
Performance,/// Return true if the specified indexed load is legal on this target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:41,load,load,41,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,4,['load'],['load']
Performance,/// Return true if the specified instruction is exactly identical to the; /// current one. This means that all operands match and any extra information; /// (e.g. load is volatile) agree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:163,load,load,163,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['load'],['load']
Performance,/// Return true if the specified load with extension is legal on this target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:33,load,load,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,/// Return true if the specified load with extension is legal or custom; /// on this target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:33,load,load,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,"/// Return true if the target has a unified operation to calculate division; /// and remainder. If so, the additional implicit multiplication and; /// subtraction required to calculate a remainder from division are free. This; /// can enable more aggressive transformations for division and remainder than; /// would typically be allowed using throughput or size cost models.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:344,throughput,throughput,344,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['throughput'],['throughput']
Performance,/// Return true if the target may be able emit the call instruction as a tail; /// call. This is used by optimization passes to determine if it's profitable; /// to duplicate return instructions to enable tailcall optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:105,optimiz,optimization,105,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['optimiz'],['optimization']
Performance,/// Return true if the target shall perform extract vector element and store; /// given that the vector is known to be splat of constant.; /// \p Index[out] gives the index of the vector element to be extracted when; /// this is true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:36,perform,perform,36,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['perform'],['perform']
Performance,"/// Return true if the target supplies and combines to a paired load; /// two loaded values of type LoadedType next to each other in memory.; /// RequiredAlignment gives the minimal alignment constraints that must be met; /// to be able to select this paired load.; ///; /// This information is *not* used to generate actual paired loads, but it is; /// used to generate a sequence of loads that is easier to combine into a; /// paired load.; /// For instance, something like this:; /// a = load i64* addr; /// b = trunc i64 a to i32; /// c = lshr i64 a, 32; /// d = trunc i64 c to i32; /// will be optimized into:; /// b = load i32* addr1; /// d = load i32* addr2; /// Where addr1 = addr2 +/- sizeof(i32).; ///; /// In other words, unless the target performs a post-isel load combining,; /// this information should not be provided because it will generate more; /// loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:64,load,load,64,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,14,"['Load', 'load', 'optimiz', 'perform']","['LoadedType', 'load', 'loaded', 'loads', 'optimized', 'performs']"
Performance,/// Return true if the target supports masked expand load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,load,load,53,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,/// Return true if the target supports masked load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:46,load,load,46,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,/// Return true if the target supports nontemporal load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:51,load,load,51,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['load'],['load']
Performance,/// Return true if the target supports swifterror attribute. It optimizes; /// loads and stores to reading and writing a specific register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:64,optimiz,optimizes,64,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,"['load', 'optimiz']","['loads', 'optimizes']"
Performance,/// Return true if the target wants to use the optimization that; /// turns ext(promotableInst1(...(promotableInstN(load)))) into; /// promotedInst1(...(promotedInstN(ext(load)))).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:47,optimiz,optimization,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,3,"['load', 'optimiz']","['load', 'optimization']"
Performance,/// Return true if the type is a scalable type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:33,scalab,scalable,33,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,2,['scalab'],['scalable']
Performance,"/// Return true if the underlying value is a store that is known to be; /// removable. This is different from dead stores as the removable store; /// can have an effect on live values, especially loads, but that effect; /// is propagated which allows us to remove the store in turn.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:196,load,loads,196,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['load'],['loads']
Performance,"/// Return true if there exists a point in the program at which both; /// A and B could be operands to the same instruction.; /// SCEV expressions are generally assumed to correspond to instructions; /// which could exists in IR. In general, this requires that there exists; /// a use point in the program where all operands dominate the use.; ///; /// Example:; /// loop {; /// if; /// loop { v1 = load @global1; }; /// else; /// loop { v2 = load @global2; }; /// }; /// No SCEV with operand V1, and v2 can exist in this program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:399,load,load,399,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,2,['load'],['load']
Performance,"/// Return true if this alloca is legal for promotion.; ///; /// This is true if there are only loads, stores, and lifetime markers; /// (transitively) using this alloca. This also enforces that there is only; /// ever one layer of bitcasts or GEPs between the alloca and the lifetime; /// markers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h:96,load,loads,96,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/PromoteMemToReg.h,1,['load'],['loads']
Performance,/// Return true if this atomic instruction loads from memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:43,load,loads,43,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['load'],['loads']
Performance,"/// Return true if this function can prove that V does not have undef bits; /// and is never poison. If V is an aggregate value or vector, check whether; /// all elements (except padding) are not undef or poison.; /// Note that this is different from canCreateUndefOrPoison because the; /// function assumes Op's operands are not poison/undef.; ///; /// If CtxI and DT are specified this method performs flow-sensitive analysis; /// and returns true if it is guaranteed to be never undef or poison; /// immediately before the CtxI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:395,perform,performs,395,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['perform'],['performs']
Performance,"/// Return true if this global's definition can be substituted with an; /// *arbitrary* definition at link time or load time. We cannot do any IPO or; /// inlining across interposable call edges, since the callee can be; /// replaced with something arbitrary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:115,load,load,115,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['load'],['load']
Performance,"/// Return true if this instruction authenticates a pointer (e.g. LDRAx/BRAx; /// from ARMv8.3, which perform loads/branches with authentication).; ///; /// An authenticated instruction may fail in an ABI-defined manner when; /// operating on an invalid signed pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h:102,perform,perform,102,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,2,"['load', 'perform']","['loads', 'perform']"
Performance,/// Return true if this instruction behaves like a memory fence: it can load; /// or store to memory location without being given a memory location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h:72,load,load,72,interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instruction.h,1,['load'],['load']
Performance,"/// Return true if this instruction behaves; /// the same way as the generic EXTRACT_SUBREG instructions.; /// E.g., on ARM,; /// rX, rY VMOVRRD dZ; /// is equivalent to two EXTRACT_SUBREG:; /// rX = EXTRACT_SUBREG dZ, ssub_0; /// rY = EXTRACT_SUBREG dZ, ssub_1; ///; /// Note that for the optimizers to be able to take advantage of; /// this property, TargetInstrInfo::getExtractSubregLikeInputs has to be; /// override accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:290,optimiz,optimizers,290,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,2,['optimiz'],['optimizers']
Performance,"/// Return true if this instruction behaves; /// the same way as the generic INSERT_SUBREG instructions.; /// E.g., on ARM,; /// dX = VSETLNi32 dY, rZ, Imm; /// is equivalent to a INSERT_SUBREG:; /// dX = INSERT_SUBREG dY, rZ, translateImmToSubIdx(Imm); ///; /// Note that for the optimizers to be able to take advantage of; /// this property, TargetInstrInfo::getInsertSubregLikeInputs has to be; /// override accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:281,optimiz,optimizers,281,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,2,['optimiz'],['optimizers']
Performance,"/// Return true if this instruction behaves; /// the same way as the generic REG_SEQUENCE instructions.; /// E.g., on ARM,; /// dX VMOVDRR rY, rZ; /// is equivalent to; /// dX = REG_SEQUENCE rY, ssub_0, rZ, ssub_1.; ///; /// Note that for the optimizers to be able to take advantage of; /// this property, TargetInstrInfo::getRegSequenceLikeInputs has to be; /// override accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:243,optimiz,optimizers,243,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,2,['optimiz'],['optimizers']
Performance,"/// Return true if this instruction has side; /// effects that are not modeled by other flags. This does not return true; /// for instructions whose effects are captured by:; ///; /// 1. Their operand list and implicit definition/use list. Register use/def; /// info is explicit for instructions.; /// 2. Memory accesses. Use mayLoad/mayStore.; /// 3. Calling, branching, returning: use isCall/isReturn/isBranch.; ///; /// Examples of side effects would be modifying 'invisible' machine state like; /// a control register, flushing a cache, modifying a register invisible to; /// LLVM, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h:534,cache,cache,534,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,1,['cache'],['cache']
Performance,/// Return true if this is NOT a pre/post inc/dec load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:50,load,load,50,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,3,['load'],['load']
Performance,"/// Return true if this is a calling convention that we'd like to change. The; /// idea here is that we don't want to mess with the convention if the user; /// explicitly requested something with performance implications like coldcc,; /// GHC, or anyregcc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:196,perform,performance,196,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['perform'],['performance']
Performance,/// Return true if this is a custom target type that has a scalable size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:59,scalab,scalable,59,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,1,['scalab'],['scalable']
Performance,"/// Return true if this is a floating-point store smaller than the V reg. On; /// cyclone, these require a vector shuffle before storing a pair.; /// Ideally we would call getMatchingPairOpcode() and have the machine model; /// tell us if it's profitable with no cpu knowledge here.; ///; /// FIXME: We plan to develop a decent Target abstraction for simple loads and; /// stores. Until then use a nasty switch similar to AArch64LoadStoreOptimizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp:358,load,loads,358,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StorePairSuppress.cpp,1,['load'],['loads']
Performance,/// Return true if this is a load from a volatile memory location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:29,load,load,29,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['load'],['load']
Performance,/// Return true if this is a load/store that can be potentially paired/merged.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:29,load,load,29,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,/// Return true if this is a pre/post inc/dec load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:46,load,load,46,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,3,['load'],['load']
Performance,/// Return true if this is a setcc instruction that performs a signed; /// comparison when used with integer operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,perform,performs,52,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['perform'],['performs']
Performance,/// Return true if this is a setcc instruction that performs an equality; /// comparison when used with floating point operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,perform,performs,52,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['perform'],['performs']
Performance,/// Return true if this is a setcc instruction that performs an equality; /// comparison when used with integer operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,perform,performs,52,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['perform'],['performs']
Performance,/// Return true if this is a setcc instruction that performs an unsigned; /// comparison when used with integer operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,perform,performs,52,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['perform'],['performs']
Performance,/// Return true if this is a target extension type with a scalable layout.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Type.h:58,scalab,scalable,58,interpreter/llvm-project/llvm/include/llvm/IR/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Type.h,1,['scalab'],['scalable']
Performance,"/// Return true if this is a vector constant that includes any undef or; /// poison elements. Since it is impossible to inspect a scalable vector; /// element- wise at compile time, this function returns true only if the; /// entire vector is undef or poison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constant.h:130,scalab,scalable,130,interpreter/llvm-project/llvm/include/llvm/IR/Constant.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constant.h,1,['scalab'],['scalable']
Performance,/// Return true if this is always a dereferenceable pointer. If the context; /// instruction is specified perform context-sensitive analysis and return true; /// if the pointer is dereferenceable at the specified instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:106,perform,perform,106,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,1,['perform'],['perform']
Performance,/// Return true if this is an operation on mask registers. Note that; /// this includes both arithmetic/logical ops and load/store (vlm/vsm).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:120,load,load,120,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['load'],['load']
Performance,"/// Return true if this load instruction never traps and points to a memory; /// location whose value doesn't change during the execution of this function.; ///; /// Examples include loading a value from the constant pool or from the; /// argument area of a function (if it does not change). If the instruction; /// does multiple loads, this returns true only if all of the loads are; /// dereferenceable and invariant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:24,load,load,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,4,['load'],"['load', 'loading', 'loads']"
Performance,/// Return true if this machine instruction loads from global offset table or; /// constant pool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:44,load,loads,44,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,2,['load'],['loads']
Performance,"/// Return true if this machine model includes an instruction-level; /// scheduling model.; ///; /// This is more detailed than the course grain IssueWidth and default; /// latency properties, but separate from the per-cycle itinerary data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h:173,latency,latency,173,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSchedule.h,1,['latency'],['latency']
Performance,/// Return true if this opcode has high latency to its result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:40,latency,latency,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['latency'],['latency']
Performance,"/// Return true if this operand (which must be a chain) reaches the; /// specified operand without crossing any side-effecting instructions.; /// In practice, this looks through token factors and non-volatile loads.; /// In order to remain efficient, this only; /// looks a couple of nodes in, it does not do an exhaustive search.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:209,load,loads,209,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['load'],['loads']
Performance,"/// Return true if this optimization remark is enabled by one of; /// of the LLVM command line flags (-pass-remarks, -pass-remarks-missed,; /// or -pass-remarks-analysis). Note that this only handles the LLVM; /// flags. We cannot access Clang flags from here (they are handled; /// in BackendConsumer::OptimizationRemarkHandler).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h:24,optimiz,optimization,24,interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DiagnosticInfo.h,2,"['Optimiz', 'optimiz']","['OptimizationRemarkHandler', 'optimization']"
Performance,/// Return true if this target allows an unrelaxable instruction to be; /// emitted into RelaxableFragment and then we can increase its size in a; /// tricky way for optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h:166,optimiz,optimization,166,interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmBackend.h,1,['optimiz'],['optimization']
Performance,/// Return true if we believe it is correct and profitable to reduce the; /// load node to a smaller type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:78,load,load,78,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['load'],['load']
Performance,/// Return true if we can load or store from a pointer to this type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h:26,load,load,26,interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DerivedTypes.h,1,['load'],['load']
Performance,"/// Return true if we can prove that the given load (which is assumed to be; /// within the specified loop) would access only dereferenceable memory, and; /// be properly aligned on every iteration of the specified loop regardless of; /// its placement within the loop. (i.e. does not require predication beyond; /// that required by the header itself and could be hoisted into the header; /// if desired.) This is more powerful than the variants above when the; /// address loaded from is analyzeable by SCEV.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:47,load,load,47,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,2,['load'],"['load', 'loaded']"
Performance,"/// Return true if we can vectorize this loop while folding its tail by; /// masking, and mark all respective loads/stores for masking.; /// This object's state is only modified iff this function returns true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:110,load,loads,110,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['load'],['loads']
Performance,/// Return true if we can vectorize this outer loop. The method performs; /// specific checks for outer loop vectorization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:64,perform,performs,64,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['perform'],['performs']
Performance,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:44,load,load,44,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,8,"['load', 'perform']","['load', 'performs']"
Performance,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:55,load,load,55,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,4,['load'],['load']
Performance,"/// Return true if we should legalize a load by widening an odd sized memory; /// access up to the alignment. Note this case when the memory access itself; /// changes, not the size of the result register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:40,load,load,40,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['load'],['load']
Performance,/// Return true if zero-extending the specific node Val to type VT2 is free; /// (either because it's implicitly zero-extended such as ARM ldrb / ldrh or; /// because it's folded such as X86 zero-extending loads).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:206,load,loads,206,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['loads']
Performance,/// Return true when a code sequence can improve loop throughput.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:54,throughput,throughput,54,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['throughput'],['throughput']
Performance,/// Return true when a code sequence can improve throughput. It; /// should be called only for instructions in loops.; /// \param Pattern - combiner pattern,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:49,throughput,throughput,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,3,['throughput'],['throughput']
Performance,"/// Return true, if an ext(load) can be formed from an extension in; /// \p MovedExts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:27,load,load,27,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['load'],['load']
Performance,/// Return true/false if the current object and the indexed reference \p Other; /// are/aren't in the same cache line of size \p CLS. Two references are in; /// the same chace line iff the distance between them in the innermost; /// dimension is less than the cache line size. Return std::nullopt if unsure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:107,cache,cache,107,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,2,['cache'],['cache']
Performance,"/// Return whether this is a plain node,; /// or one of the varieties of value-extending loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:89,load,loads,89,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['load'],['loads']
Performance,"/// Return; // True : if this conversion changes the volatile-ness of a gl-value.; // Qualification conversions on gl-values currently use CK_NoOp, but; // it's important to recognize volatile-changing conversions in; // clients code generation that normally eagerly peephole loads. Note; // that the query is answering for this specific node; Sema may; // produce multiple cast nodes for any particular conversion sequence.; // False : Otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:276,load,loads,276,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['load'],['loads']
Performance,/// Returns LSU_AVAILABLE if there are enough load/store queue entries to; /// accomodate instruction IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:46,load,load,46,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,2,"['load', 'queue']","['load', 'queue']"
Performance,"/// Returns MVT::getSizeInBits(getValueType(ResNo)).; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:86,scalab,scalable,86,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,2,['scalab'],['scalable']
Performance,/// Returns a DebugLoc for a new DILocation which is a clone of \p OrigDL; /// inlined at \p InlinedAt. \p IANodes is an inlined-at cache.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:132,cache,cache,132,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['cache'],['cache']
Performance,"/// Returns a REP MOVS instruction, possibly with a few load/stores to implement; /// a constant size memory copy. In some cases where we know REP MOVS is; /// inefficient we return an empty SDValue so the calling code can either; /// generate a load/store sequence or call the runtime memcpy function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp:56,load,load,56,interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SelectionDAGInfo.cpp,2,['load'],['load']
Performance,"/// Returns a StructLayout object, indicating the alignment of the; /// struct, its size, and the offsets of its fields.; ///; /// Note that this information is lazily cached.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:168,cache,cached,168,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,1,['cache'],['cached']
Performance,"/// Returns a SymbolizableModule or an error if loading debug info failed.; /// Only one attempt is made to load a module, and errors during loading are; /// only reported once. Subsequent calls to get module info for a module that; /// failed to load will return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h:48,load,loading,48,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,4,['load'],"['load', 'loading']"
Performance,"/// Returns a SymbolizableModule or an error if loading debug info failed.; /// Unlike the above, errors are reported each time, since they are more; /// likely to be transient.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h:48,load,loading,48,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Symbolize.h,1,['load'],['loading']
Performance,"/// Returns a cached copy of the page source descriptor. The returned pointer remains valid until the next call; /// to LoadEntry or to any of the views returned from the reader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx:14,cache,cached,14,tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleReader.hxx,2,"['Load', 'cache']","['LoadEntry', 'cached']"
Performance,"/// Returns a calculation for the total number of elements for a given \p VF.; /// For fixed width vectors this value is a constant, whereas for scalable; /// vectors it is an expression determined at runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:145,scalab,scalable,145,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['scalab'],['scalable']
Performance,"/// Returns a human-readable qualified name for this declaration, like; /// A::B::i, for i being member of namespace A::B.; ///; /// If the declaration is not a member of context which can be named (record,; /// namespace), it will return the same result as printName().; ///; /// Creating this name is expensive, so it should be called only when; /// performance doesn't matter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:352,perform,performance,352,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['perform'],['performance']
Performance,/// Returns a list of filenames of dynamic libraries that this archive has; /// imported. This class does not load these libraries by itself. User is; /// responsible for making sure these libraries are avaliable to the JITDylib.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h:110,load,load,110,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ExecutionUtils.h,1,['load'],['load']
Performance,/// Returns a node representing a splat of one value into all lanes; /// of the provided vector type. This is a utility which returns; /// either a BUILD_VECTOR or SPLAT_VECTOR depending on the; /// scalability of the desired vector type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:199,scalab,scalability,199,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['scalab'],['scalability']
Performance,/// Returns a pass that performs linker relaxation. Should be added to; /// PostAllocationPasses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/ELF_riscv.h:24,perform,performs,24,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/ELF_riscv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/ELF_riscv.h,1,['perform'],['performs']
Performance,/// Returns a reference to the loaded compilations database.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h:31,load,loaded,31,interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CommonOptionsParser.h,1,['load'],['loaded']
Performance,"/// Returns a true value if if this FPClassTest can be performed with an ordered; /// fcmp to 0, and a false value if it's an unordered fcmp to 0. Returns; /// std::nullopt if it cannot be performed as a compare with 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:55,perform,performed,55,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['perform'],['performed']
Performance,"/// Returns a unique call site identifier for a given debug location of a call; /// instruction. This is wrapper of two scenarios, the probe-based profile and; /// regular profile, to hide implementation details from the sample loader and; /// the context tracker.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:228,load,loader,228,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['load'],['loader']
Performance,"/// Returns an adjusted FMA opcode that must be used in FMA instruction that; /// performs the same computations as the given \p MI but which has the; /// operands \p SrcOpIdx1 and \p SrcOpIdx2 commuted.; /// It may return 0 if it is unsafe to commute the operands.; /// Note that a machine instruction (instead of its opcode) is passed as the; /// first parameter to make it possible to analyze the instruction's uses and; /// commute the first operand of FMA even when it seems unsafe when you look; /// at the opcode. For example, it is Ok to commute the first operand of; /// VFMADD*SD_Int, if ONLY the lowest 64-bit element of the result is used.; ///; /// The returned FMA opcode may differ from the opcode in the given \p MI.; /// For example, commuting the operands #1 and #3 in the following FMA; /// FMA213 #1, #2, #3; /// results into instruction with adjusted opcode:; /// FMA231 #3, #2, #1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:82,perform,performs,82,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,1,['perform'],['performs']
Performance,"/// Returns an existing instance of BFI if any, otherwise nullptr. By; /// ""existing"" we mean either cached result provided by FunctionAnalysisManger; /// or created by preceding call to 'getOrCreateBFI'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h:101,cache,cached,101,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h,1,['cache'],['cached']
Performance,"/// Returns an existing instance of BPI if any, otherwise nullptr. By; /// ""existing"" we mean either cached result provided by FunctionAnalysisManger; /// or created by preceding call to 'getOrCreateBPI'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h:101,cache,cached,101,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/JumpThreading.h,1,['cache'],['cached']
Performance,/// Returns an instance of the Make Compressible Optimization pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:49,Optimiz,Optimization,49,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,1,['Optimiz'],['Optimization']
Performance,/// Returns an instance of the Merge Base Offset Optimization pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:49,Optimiz,Optimization,49,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,1,['Optimiz'],['Optimization']
Performance,/// Returns an instance of the high cost ASIMD instruction replacement; /// optimization pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:76,optimiz,optimization,76,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,1,['optimiz'],['optimization']
Performance,/// Returns an instance of the load / store optimization pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:31,load,load,31,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,2,"['load', 'optimiz']","['load', 'optimization']"
Performance,"/// Returns an iterator range for the local preprocessing entities; /// of the local Preprocessor, if this is a parsed source file, or the loaded; /// preprocessing entities of the primary module if this is an AST file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:139,load,loaded,139,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['load'],['loaded']
Performance,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:424,optimiz,optimizing,424,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,5,['optimiz'],"['optimizations', 'optimizing']"
Performance,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:417,optimiz,optimizing,417,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,5,['optimiz'],"['optimizations', 'optimizing']"
Performance,/// Returns cached ODRHash of the function. This must have been previously; /// computed and stored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:12,cache,cached,12,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['cache'],['cached']
Performance,/// Returns couples of Load then Store to memory which look; /// like a memcpy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp:23,Load,Load,23,interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AvoidStoreForwardingBlocks.cpp,1,['Load'],['Load']
Performance,"/// Returns entry associated with the filename in the shared cache if there is; /// some. Otherwise, associates the given entry with the filename and returns; /// it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:61,cache,cache,61,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cache']
Performance,"/// Returns entry associated with the filename in the shared cache if there is; /// some. Otherwise, constructs new one with the given error code, associates; /// it with the filename and returns the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:61,cache,cache,61,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cache']
Performance,"/// Returns entry associated with the filename or nullptr if none is found.; ///; /// Returns entry from local cache if there is some. Otherwise, if the entry; /// is found in the shared cache, writes it through the local cache and; /// returns it. Otherwise returns nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:111,cache,cache,111,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,3,['cache'],['cache']
Performance,/// Returns entry associated with the unique ID in the shared cache or nullptr; /// if none is found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:62,cache,cache,62,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cache']
Performance,"/// Returns entry associated with the unique ID of the given tentative entry; /// if there is some in the shared cache. Otherwise, constructs new one,; /// associates it with the unique ID and returns the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:113,cache,cache,113,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['cache']
Performance,"/// Returns entry for the given filename.; ///; /// Attempts to use the local and shared caches first, then falls back to; /// using the underlying filesystem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:89,cache,caches,89,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['cache'],['caches']
Performance,/// Returns how the given (atomic) load should be cast by the IR-level; /// AtomicExpand pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:35,load,load,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,/// Returns how the given (atomic) load should be expanded by the; /// IR-level AtomicExpand pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:35,load,load,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,"/// Returns processing mode of WS handler; /// If sync mode is TRUE (default), all event processing and data sending performed in main thread; /// All send functions are blocking and must be performed from main thread; /// If sync mode is false, WS handler can be used from different threads and starts its own sending threads",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpWSHandler.h:117,perform,performed,117,net/http/inc/THttpWSHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/inc/THttpWSHandler.h,2,['perform'],['performed']
Performance,/// Returns the CSEConfig object to use for the current optimization level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:56,optimiz,optimization,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,1,['optimiz'],['optimization']
Performance,/// Returns the StackID that scalable vectors should be associated with.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:29,scalab,scalable,29,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,1,['scalab'],['scalable']
Performance,/// Returns the address of symbol relocation used against and a section index.; /// Used for futher relocations computation. Symbol's section load address is,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:142,load,load,142,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,1,['load'],['load']
Performance,"/// Returns the address of the requested section (or an error message; /// in the second element of the pair if the address cannot be found).; ///; /// if 'LocalAddress' is true, this returns the address of the section; /// within the linker's memory. If 'LocalAddress' is false it returns the; /// address within the target process (i.e. the load address).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h:343,load,load,343,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RuntimeDyldChecker.h,1,['load'],['load']
Performance,/// Returns the address of this pointer in this block.; ///; /// This can be different than the address queried for the non-local result; /// because of phi translation. This returns null if the address was not; /// available in a block (i.e. because phi translation failed) or if this is; /// a cached result and that address was deleted.; ///; /// The address is always null for a non-local 'call' dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:296,cache,cached,296,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['cache'],['cached']
Performance,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:741,optimiz,optimizations,741,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,2,['optimiz'],"['optimizations', 'optimize']"
Performance,"/// Returns the alloction type of the intersection of the contexts of two; /// nodes (based on their provided context id sets), optimized for the case; /// when Node1Ids is smaller than Node2Ids.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:128,optimiz,optimized,128,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['optimiz'],['optimized']
Performance,/// Returns the base register operator of a load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:44,load,load,44,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,"/// Returns the bin number corresponding to the value `x`.; ///; /// \note This `inline` function is implemented by calling the vectorized; /// function `RooAbsBinning::binNumbers()`. If you want to calculate; /// the bin indices for multiple values, use that one for better; /// performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsBinning.h:280,perform,performance,280,roofit/roofitcore/inc/RooAbsBinning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsBinning.h,1,['perform'],['performance']
Performance,/// Returns the cache key for a given debuginfod URL path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h:16,cache,cache,16,interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,1,['cache'],['cache']
Performance,"/// Returns the cached set of interesting SVals contained within a lazy; /// binding.; ///; /// The precise value of ""interesting"" is determined for the purposes of; /// RegionStore's internal analysis. It must always contain all regions and; /// symbols, but may omit constants and other kinds of SVal.; ///; /// In contrast to compound values, LazyCompoundVals are also added; /// to the 'interesting values' list in addition to the child interesting; /// values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:16,cache,cached,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['cache'],['cached']
Performance,/// Returns the first potential AsynchEH faulty instruction; /// currently it checks for loads/stores (which may dereference a null; /// pointer) and calls/invokes (which may propagate exceptions),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h:89,load,loads,89,interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,1,['load'],['loads']
Performance,"/// Returns the given cluster from the pool, which needs to contain at least the columns `physicalColumns`.; /// Executed at the end of GetCluster when all missing data pieces have been sent to the load queue.; /// Ideally, the function returns without blocking if the cluster is already in the pool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:198,load,load,198,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,2,"['load', 'queue']","['load', 'queue']"
Performance,/// Returns the immediate offset operator of a load/store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:47,load,load,47,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,1,['load'],['load']
Performance,/// Returns the kind of memory used to back the memory buffer for; /// this content cache. This is used for performance analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:84,cache,cache,84,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,4,"['cache', 'perform']","['cache', 'performance']"
Performance,/// Returns the latency value for the scheduling class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:16,latency,latency,16,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['latency'],['latency']
Performance,"/// Returns the latency value for this edge, which roughly means the; /// minimum number of cycles that must elapse between the predecessor and; /// the successor, given that they have this edge between them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:16,latency,latency,16,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['latency'],['latency']
Performance,"/// Returns the list of pointer-type variables on which this gadget performs; /// its operation. Typically, there's only one variable. This isn't a list; /// of all DeclRefExprs in the gadget's AST!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:68,perform,performs,68,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['perform'],['performs']
Performance,/// Returns the list of virtual calls made by this function using; /// llvm.type.checked.load intrinsics that do not have all constant integer; /// arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:89,load,load,89,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['load'],['load']
Performance,/// Returns the list of virtual calls made by this function using; /// llvm.type.checked.load intrinsics with all constant integer arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:89,load,load,89,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['load'],['load']
Performance,"/// Returns the maximum number of bits that may be overwritten by; /// storing the specified type; always a multiple of 8.; ///; /// If Ty is a scalable vector type, the scalable property will be set and; /// the runtime size will be a positive integer multiple of the base size.; ///; /// For example, returns 40 for i36 and 80 for x86_fp80.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:144,scalab,scalable,144,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,2,['scalab'],['scalable']
Performance,"/// Returns the maximum number of bytes that may be overwritten by; /// storing the specified type.; ///; /// If Ty is a scalable vector type, the scalable property will be set and; /// the runtime size will be a positive integer multiple of the base size.; ///; /// For example, returns 5 for i36 and 10 for x86_fp80.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:121,scalab,scalable,121,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,2,['scalab'],['scalable']
Performance,"/// Returns the memory access attribute for function F using AAR for AA results,; /// where SCCNodes is the current SCC.; ///; /// If ThisBody is true, this function may examine the function body and will; /// return a result pertaining to this copy of the function. If it is false, the; /// result will be based only on AA results for the function declaration; it; /// will be assumed that some other (perhaps less optimized) version of the; /// function may be selected at link time.; ///; /// The return value is split into two parts: Memory effects that always apply,; /// and additional memory effects that apply if any of the functions in the SCC; /// can access argmem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:416,optimiz,optimized,416,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['optimiz'],['optimized']
Performance,"/// Returns the more specialized function template according; /// to the rules of function template partial ordering (C++ [temp.func.order]).; ///; /// \param FT1 the first function template; ///; /// \param FT2 the second function template; ///; /// \param TPOC the context in which we are performing partial ordering of; /// function templates.; ///; /// \param NumCallArguments1 The number of arguments in the call to FT1, used; /// only when \c TPOC is \c TPOC_Call.; ///; /// \param NumCallArguments2 The number of arguments in the call to FT2, used; /// only when \c TPOC is \c TPOC_Call.; ///; /// \param Reversed If \c true, exactly one of FT1 and FT2 is an overload; /// candidate with a reversed parameter order. In this case, the corresponding; /// P/A pairs between FT1 and FT2 are reversed.; ///; /// \returns the more specialized function template. If neither; /// template is more specialized, returns NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:291,perform,performing,291,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['perform'],['performing']
Performance,/// Returns the most recent declaration of a declaration (which must be; /// of a redeclarable kind) that is either local or has already been loaded; /// merged into its redecl chain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:142,load,loaded,142,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['load'],['loaded']
Performance,/// Returns the name of the file that was used when the file was loaded from; /// the underlying file system.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:65,load,loaded,65,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['load'],['loaded']
Performance,"/// Returns the newly rewritten kernel block, or nullptr if this was; /// optimized away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h:74,optimiz,optimized,74,interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ModuloSchedule.h,1,['optimiz'],['optimized']
Performance,"/// Returns the number of instructions required to materialize the given; /// constant in a register, or 3 if a literal pool load is needed.; /// If ForCodesize is specified, an approximate cost in bytes is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:125,load,load,125,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,1,['load'],['load']
Performance,/// Returns the number of stored operands of this interleave group. Returns 0; /// for load interleave groups.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:87,load,load,87,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['load'],['load']
Performance,/// Returns the number of unique real file entries cached by the file manager.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:51,cache,cached,51,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['cache'],['cached']
Performance,"/// Returns the offset in bits between successive objects of the; /// specified type, including alignment padding; always a multiple of 8.; ///; /// If Ty is a scalable vector type, the scalable property will be set and; /// the runtime size will be a positive integer multiple of the base size.; ///; /// This is the amount that alloca reserves for this type. For example,; /// returns 96 or 128 for x86_fp80, depending on alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:160,scalab,scalable,160,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,2,['scalab'],['scalable']
Performance,"/// Returns the offset in bytes between successive objects of the; /// specified type, including alignment padding.; ///; /// If Ty is a scalable vector type, the scalable property will be set and; /// the runtime size will be a positive integer multiple of the base size.; ///; /// This is the amount that alloca reserves for this type. For example,; /// returns 12 or 16 for x86_fp80, depending on alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:137,scalab,scalable,137,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,2,['scalab'],['scalable']
Performance,/// Returns the offset in parts to which this frame offset can be; /// decomposed for the purpose of describing a frame offset.; /// For non-scalable offsets this is simply its byte size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:141,scalab,scalable,141,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['scalab'],['scalable']
Performance,"/// Returns the opcode of the would be new; /// instruction after load / store are unfolded from an instruction of the; /// specified opcode. It returns zero if the specified unfolding is not; /// possible. If LoadRegIndex is non-null, it is filled in with the operand; /// index of the operand which will hold the register holding the loaded; /// value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:66,load,load,66,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,3,"['Load', 'load']","['LoadRegIndex', 'load', 'loaded']"
Performance,"/// Returns the optimization level: None, Less, Default, or Aggressive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h:16,optimiz,optimization,16,interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,2,['optimiz'],['optimization']
Performance,/// Returns the ordering constraint of this load instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:44,load,load,44,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['load'],['load']
Performance,"/// Returns the parents of the given node (within the traversal scope).; ///; /// Note that this will lazily compute the parents of all nodes; /// and store them for later retrieval. Thus, the first call is O(n); /// in the number of AST nodes.; ///; /// Caveats and FIXMEs:; /// Calculating the parent map over all AST nodes will need to load the; /// full AST. This can be undesirable in the case where the full AST is; /// expensive to create (for example, when using precompiled header; /// preambles). Thus, there are good opportunities for optimization here.; /// One idea is to walk the given node downwards, looking for references; /// to declaration contexts - once a declaration context is found, compute; /// the parent map for the declaration context; if that can satisfy the; /// request, loading the whole AST can be avoided. Note that this is made; /// more complex by statements in templates having multiple parents - those; /// problems can be solved by building closure over the templated parts of; /// the AST, which also avoids touching large parts of the AST.; /// Additionally, we will want to add an interface to already give a hint; /// where to search for the parents, for example when looking at a statement; /// inside a certain function.; ///; /// 'NodeT' can be one of Decl, Stmt, Type, TypeLoc,; /// NestedNameSpecifier or NestedNameSpecifierLoc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ParentMapContext.h:339,load,load,339,interpreter/llvm-project/clang/include/clang/AST/ParentMapContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ParentMapContext.h,3,"['load', 'optimiz']","['load', 'loading', 'optimization']"
Performance,"/// Returns the preferred order for allocating registers from this register; /// class in MF. The raw order comes directly from the .td file and may; /// include reserved registers that are not allocatable.; /// Register allocators should also make sure to allocate; /// callee-saved registers only after all the volatiles are used. The; /// RegisterClassInfo class provides filtered allocation orders with; /// callee-saved registers moved to the end.; ///; /// The MachineFunction argument can be used to tune the allocatable; /// registers based on the characteristics of the function, subtarget, or; /// other criteria.; ///; /// By default, this method returns all registers in the class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:507,tune,tune,507,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['tune'],['tune']
Performance,"/// Returns the primary module associated with the manager, that is,; /// the first module loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:91,load,loaded,91,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,"/// Returns the primary module associated with the manager, that is,; /// the first module loaded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:91,load,loaded,91,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['load'],['loaded']
Performance,"/// Returns the requested cluster either from the pool or, in case of a cache miss, lets the I/O thread load; /// the cluster in the pool, blocks until done, and then returns it. Triggers along the way the background loading; /// of the following fWindowPost number of clusters. The returned cluster has at least all the pages of; /// `physicalColumns` and possibly pages of other columns, too. If implicit multi-threading is turned on, the; /// uncompressed pages of the returned cluster are already pushed into the page pool associated with the page source; /// upon return. The cluster remains valid until the next call to GetCluster().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:72,cache,cache,72,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,4,"['cache', 'load', 'multi-thread']","['cache', 'load', 'loading', 'multi-threading']"
Performance,/// Returns the scalable component of the stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h:16,scalab,scalable,16,interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TypeSize.h,1,['scalab'],['scalable']
Performance,"/// Returns the set of GUIDs that needs to be imported to the function for; /// sample PGO, to enable the same inlines as the profiled optimized binary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:135,optimiz,optimized,135,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['optimiz'],['optimized']
Performance,"/// Returns the size of the specified MVT in bits.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h:84,scalab,scalable,84,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineValueType.h,2,['scalab'],['scalable']
Performance,"/// Returns the size of the value in bits.; ///; /// If the value type is a scalable vector type, the scalable property will; /// be set and the runtime size will be a positive integer multiple of the; /// base size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:76,scalab,scalable,76,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,2,['scalab'],['scalable']
Performance,/// Returns the spelling of a string literal or identifier after performing; /// any processing needed to handle \c clang::Token::NeedsCleaning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:65,perform,performing,65,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,1,['perform'],['performing']
Performance,/// Returns the synchronization scope ID of this load instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:49,load,load,49,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['load'],['load']
Performance,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; /// It returns EVT::Other if the type should be determined using generic; /// target-independent logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:49,load,load,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:49,load,load,49,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,3,['load'],"['load', 'loaded']"
Performance,/// Returns the total number of entries in the load queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:47,load,load,47,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,2,"['load', 'queue']","['load', 'queue']"
Performance,/// Returns the total number of entries in the store queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:53,queue,queue,53,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['queue'],['queue']
Performance,"/// Returns the unscaled load/store for the scaled load/store opcode,; /// if there is a corresponding unscaled variant available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h:25,load,load,25,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.h,2,['load'],['load']
Performance,"/// Returns true by value, base pointer and offset pointer and addressing mode; /// by reference if the node's address can be legally represented as; /// pre-indexed load / store address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:166,load,load,166,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['load'],['load']
Performance,"/// Returns true by value, base pointer and offset pointer and addressing mode; /// by reference if this node can be combined with a load / store to form a; /// post-indexed load / store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:133,load,load,133,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,2,['load'],['load']
Performance,"/// Returns true by value, base pointer and offset pointer and addressing; /// mode by reference if this node can be combined with a load / store to; /// form a post-indexed load / store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:133,load,load,133,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,2,['load'],['load']
Performance,"/// Returns true by value, base pointer and; /// offset pointer and addressing mode by reference if the node's address; /// can be legally represented as pre-indexed load / store address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:166,load,load,166,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,1,['load'],['load']
Performance,"/// Returns true by value, base pointer and; /// offset pointer and addressing mode by reference if this node can be; /// combined with a load / store to form a post-indexed load / store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:138,load,load,138,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,2,['load'],['load']
Performance,/// Returns true for RVV scalable vector types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:25,scalab,scalable,25,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['scalab'],['scalable']
Performance,/// Returns true for SVE scalable vector types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:25,scalab,scalable,25,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['scalab'],['scalable']
Performance,/// Returns true for all scalable vector types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:25,scalab,scalable,25,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['scalab'],['scalable']
Performance,"/// Returns true if 'From' instruction is assumed to reach, 'To' instruction.; /// Users should provide two positions they are interested in, and the class; /// determines (and caches) reachability.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:177,cache,caches,177,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['cache'],['caches']
Performance,/// Returns true if A and B access sequential memory if they are loads or; /// stores or if they have identical opcodes otherwise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:65,load,loads,65,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,1,['load'],['loads']
Performance,"/// Returns true if IR has to be issued immediately, or if IR is a zero; /// latency instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h:77,latency,latency,77,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h,1,['latency'],['latency']
Performance,"/// Returns true if LLVM is compiled with support for multi-threading, and; /// false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:54,multi-thread,multi-threading,54,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,1,['multi-thread'],['multi-threading']
Performance,"/// Returns true if MI is a candidate for move elimination.; ///; /// A candidate for move elimination may be optimized out at register renaming; /// stage. Subtargets can specify the set of optimizable moves by; /// instantiating tablegen class `IsOptimizableRegisterMove` (see; /// llvm/Target/TargetInstrPredicate.td).; ///; /// SubtargetEmitter is responsible for processing all the definitions of class; /// IsOptimizableRegisterMove, and auto-generate an override for this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:110,optimiz,optimized,110,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,2,['optimiz'],"['optimizable', 'optimized']"
Performance,"/// Returns true if MI is a candidate for move elimination.; ///; /// Different subtargets may apply different constraints to optimizable; /// register moves. For example, on most X86 subtargets, a candidate for move; /// elimination cannot specify the same register for both source and; /// destination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h:126,optimiz,optimizable,126,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h,1,['optimiz'],['optimizable']
Performance,"/// Returns true if N is a predecessor of any node in Worklist. This; /// helper keeps Visited and Worklist sets externally to allow unions; /// searches to be performed in parallel, caching of results across; /// queries and incremental addition to Worklist. Stops early if N is; /// found but will resume. Remember to clear Visited and Worklists; /// if DAG changes. MaxSteps gives a maximum number of nodes to visit before; /// giving up. The TopologicalPrune flag signals that positive NodeIds are; /// topologically ordered (Operands have strictly smaller node id) and search; /// can be pruned leveraging this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:160,perform,performed,160,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['perform'],['performed']
Performance,"/// Returns true if Phi is a fixed-order recurrence. A fixed-order recurrence; /// is a non-reduction recurrence relation in which the value of the; /// recurrence in the current loop iteration equals a value defined in a; /// previous iteration (e.g. if the value is defined in the previous; /// iteration, we refer to it as first-order recurrence, if it is defined in; /// the iteration before the previous, we refer to it as second-order; /// recurrence and so on). Note that this function optimistically assumes that; /// uses of the recurrence can be re-ordered if necessary and users need to; /// check and perform the re-ordering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:613,perform,perform,613,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,1,['perform'],['perform']
Performance,/// Returns true if V is always a dereferenceable pointer with alignment; /// greater or equal than requested. If the context instruction is specified; /// performs context-sensitive analysis and returns true if the pointer is; /// dereferenceable at the specified instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:156,perform,performs,156,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,1,['perform'],['performs']
Performance,/// Returns true if V is always dereferenceable for Size byte with alignment; /// greater or equal than requested. If the context instruction is specified; /// performs context-sensitive analysis and returns true if the pointer is; /// dereferenceable at the specified instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:160,perform,performs,160,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,1,['perform'],['performs']
Performance,/// Returns true if \p Fn needs the queue pointer because of \p C.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp:36,queue,queue,36,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAttributor.cpp,1,['queue'],['queue']
Performance,/// Returns true if \p I is a memory instruction in an interleaved-group; /// of memory accesses that can be vectorized with wide vector loads/stores; /// and shuffles.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:137,load,loads,137,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['load'],['loads']
Performance,"/// Returns true if a homogeneous prolog or epilog code can be emitted; /// for the size optimization. If possible, a frame helper call is injected.; /// When Exit block is given, this check is for epilog.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:89,optimiz,optimization,89,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['optimiz'],['optimization']
Performance,"/// Returns true if a homogeneous prolog or epilog code can be emitted; /// for the size optimization. If so, HOM_Prolog/HOM_Epilog pseudo; /// instructions are emitted in place. When Exit block is given, this check is; /// for epilog.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.h:89,optimiz,optimization,89,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.h,1,['optimiz'],['optimization']
Performance,/// Returns true if all tasks in the given group have finished (nullptr means; /// all tasks regardless of their group). QueueLock must be locked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h:121,Queue,QueueLock,121,interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,1,['Queue'],['QueueLock']
Performance,"/// Returns true if at least one of the register writes performed by; /// \param Inst implicitly clears the upper portion of all super-registers.; ///; /// Example: on X86-64, a write to EAX implicitly clears the upper half of; /// RAX. Also (still on x86) an XMM write perfomed by an AVX 128-bit; /// instruction implicitly clears the upper portion of the correspondent; /// YMM register.; ///; /// This method also updates an APInt which is used as mask of register; /// writes. There is one bit for every explicit/implicit write performed by; /// the instruction. If a write implicitly clears its super-registers, then; /// the corresponding bit is set (vic. the corresponding bit is cleared).; ///; /// The first bits in the APint are related to explicit writes. The remaining; /// bits are related to implicit writes. The sequence of writes follows the; /// machine operand sequence. For implicit writes, the sequence is defined by; /// the MCInstrDesc.; ///; /// The assumption is that the bit-width of the APInt is correctly set by; /// the caller. The default implementation conservatively assumes that none of; /// the writes clears the upper portion of a super-register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h:56,perform,performed,56,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrAnalysis.h,2,['perform'],['performed']
