quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Safety,"// Exchange the two operands to this instruction. This instruction is safe to; // use on any binary instruction and does not modify the semantics of the; // instruction. If the instruction is order-dependent (SetLT f.e.), the opcode; // is changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:70,safe,safe,70,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,1,['safe'],['safe']
Safety,// Exclude CopyFromReg to avoid partial register stalls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:26,avoid,avoid,26,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Exclude INT64_MIN to avoid passing it to std::abs. We won't optimize it; // anyway as the shift of 63 won't fit in uimm5.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,avoid,avoid,24,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// ExecutedBlocks - We only handle non-looping, non-recursive code. As such,; // we can only evaluate any one basic block at most once. This set keeps; // track of what we have executed so we can detect recursive cases etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:196,detect,detect,196,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['detect'],['detect']
Safety,// Exit early to avoid confusion when processing members.; // We do the same for braced list initialization in; // `CheckStructUnionTypes`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:17,avoid,avoid,17,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['avoid'],['avoid']
Safety,"// Exit needs to be delayed to avoid bad drawable X ids - GUI; // will all be changed in future anyway",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSAViewer.cxx:31,avoid,avoid,31,graf3d/gl/src/TGLSAViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSAViewer.cxx,1,['avoid'],['avoid']
Safety,"// Expand CALL_BTI pseudo to:; // - a branch to the call target; // - a BTI instruction; // Mark the sequence as a bundle, to avoid passes moving other code in; // between.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp:126,avoid,avoid,126,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp,1,['avoid'],['avoid']
Safety,"// Expand CALL_RVMARKER pseudo to:; // - a branch to the call target, followed by; // - the special `mov x29, x29` marker, and; // - another branch, to the runtime function; // Mark the sequence as bundle, to avoid passes moving other code in between.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp:209,avoid,avoid,209,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp,1,['avoid'],['avoid']
Safety,"// Expand instructions like; // %result = shl i32 %n, %amount; // to a loop so that library calls are avoided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp:102,avoid,avoided,102,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.cpp,1,['avoid'],['avoided']
Safety,"// Expand is only ever created as a masked instruction. It is not safe to; // unfold a masked expand because we don't know if it came from an expand load; // intrinsic or folding a plain load. If it is from a expand load intrinsic,; // Unfolding to plain load would read more elements and could trigger a fault.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp:66,safe,safe,66,interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86FoldTablesEmitter.cpp,1,['safe'],['safe']
Safety,"// Expand the mov into a sequence of mov/add+lsl of the individual bytes. We; // want to avoid emitting any zero bytes, as they won't change the result, and; // also don't want any pointless shifts, so instead of immediately emitting; // the shift for a byte we keep track of how much we will need to shift and do; // it before the next nonzero byte.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp:89,avoid,avoid,89,interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMExpandPseudoInsts.cpp,1,['avoid'],['avoid']
Safety,"// Expand the unconditional branch first if necessary. If there is a; // conditional branch, this will end up changing the branch destination of; // it to be over the newly inserted indirect branch block, which may avoid; // the need to try expanding the conditional branch first, saving an extra; // jump.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:215,avoid,avoid,215,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,1,['avoid'],['avoid']
Safety,// Expand to an ORi instead of a LUi to avoid sign-extending into the; // upper 32 bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:40,avoid,avoid,40,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,2,['avoid'],['avoid']
Safety,"// Expand vector FTRUNC, FCEIL, FFLOOR, FROUND, VP_FCEIL, VP_FFLOOR, VP_FROUND; // VP_FROUNDEVEN, VP_FROUNDTOZERO, VP_FRINT and VP_FNEARBYINT by converting to; // the integer domain and back. Taking care to avoid converting values that are; // nan or already correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:207,avoid,avoid,207,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Experimental option that will only be fully functional when the cost-model; // and code-generator have been changed to avoid using scalable vector; // instructions that are not legal in streaming SVE mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:122,avoid,avoid,122,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['avoid'],['avoid']
Safety,"// Explanation on the ""FillWithNoInit"" mode:; //; // Assume we have the following definitions (Case#1):; // struct P { char x[6][6]; } xp = { .x[1] = ""bar"" };; // struct PP { struct P lp; } l = { .lp = xp, .lp.x[1][2] = 'f' };; //; // l.lp.x[1][0..1] should not be filled with implicit initializers because the; // ""base"" initializer ""xp"" will provide values for them; l.lp.x[1] will be ""baf"".; //; // But if we have (Case#2):; // struct PP l = { .lp = xp, .lp.x[1] = { [2] = 'f' } };; //; // l.lp.x[1][0..1] are implicitly initialized and do not use values from the; // ""base"" initializer; l.lp.x[1] will be ""\0\0f\0\0\0"".; //; // To distinguish Case#1 from Case#2, and also to avoid leaving many ""holes""; // in the InitListExpr, the ""holes"" in Case#1 are filled not with empty; // initializers but with special ""NoInitExpr"" place holders, which tells the; // CodeGen not to generate any initializers for these parts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:679,avoid,avoid,679,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['avoid'],['avoid']
Safety,"// Explicitly check for !ResNo to avoid use-after-free, because there are; // callers that use SDValue(N, 0) with a deleted N to indicate successful; // combines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:34,avoid,avoid,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['avoid'],['avoid']
Safety,"// Explicitly checking for zero avoids causing UB by passing a null pointer; // to memcpy. This comes up in practice with things like:; // std::vector<uint8_t> v;; // blake3_hasher_finalize(&hasher, v.data(), v.size());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:32,avoid,avoids,32,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['avoid'],['avoids']
Safety,"// Explicitly checking for zero avoids causing UB by passing a null pointer; // to memcpy. This comes up in practice with things like:; // std::vector<uint8_t> v;; // blake3_hasher_update(&hasher, v.data(), v.size());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:32,avoid,avoids,32,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['avoid'],['avoids']
Safety,// Explicitly sequence get-size and insert-value operations to avoid UB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:63,avoid,avoid,63,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,2,['avoid'],['avoid']
Safety,// Expressions must start from the same base. Here we detect at which; // point both expressions diverge from each other and see if we can; // detect if the memory referred to both expressions is contiguous and; // do not overlap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:54,detect,detect,54,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['detect'],['detect']
Safety,// Extend the lifetime of the callback. We delayed this until here; // to avoid allocations in the hot path (which is where no typo correction; // occurs). Note that CorrectionCandidateCallback is polymorphic and; // initially stack-allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:74,avoid,avoid,74,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['avoid'],['avoid']
Safety,"// Extend the switch condition and case constants using the target preferred; // extend unless the switch condition is a function argument with an extend; // attribute. In that case, we can avoid an unnecessary mask/extension by; // matching the argument extension instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:190,avoid,avoid,190,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"// Extending a range of a virtual register can be dangerous,; // since the scavenger will need to find a physical register; // for it. Avoid extending the range past a function call,; // and avoid overlapping it with another virtual register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:135,Avoid,Avoid,135,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,2,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,"// Extension format is correct, keep parsing the extensions.; // TODO: Save Type, Name, Major, Minor to avoid parsing them later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/RISCVISAInfo.cpp:104,avoid,avoid,104,interpreter/llvm-project/llvm/lib/Support/RISCVISAInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/RISCVISAInfo.cpp,1,['avoid'],['avoid']
Safety,// External Analysis can return a result higher/lower than the value; // represents. We need to detect overflow/underflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp:96,detect,detect,96,interpreter/llvm-project/llvm/lib/IR/Operator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Operator.cpp,2,['detect'],['detect']
Safety,"// Extra Credit: passing extra parameters is perfectly safe; // in many calling conventions, so only bail out if the ctor's; // calling convention is nonstandard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:55,safe,safe,55,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,1,['safe'],['safe']
Safety,// Extract the initializer for the individual array elements by pulling; // out the array filler from all the nested initializer lists. This avoids; // generating a nested loop for the initialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:141,avoid,avoids,141,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['avoid'],['avoids']
Safety,// Extract the resulting weights from the control flow; // All weights are increased by one to avoid propagation errors introduced by; // zero weights.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:95,avoid,avoid,95,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,1,['avoid'],['avoid']
Safety,"// Extract the type. This (for instance) replaces references to typedef; // members of the current instantiations with the definitions of those; // typedefs, avoiding triggering instantiation of the deduced type during; // deduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:158,avoid,avoiding,158,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['avoid'],['avoiding']
Safety,// ExtractedVals - Each new PHI we introduce is saved here so we don't; // introduce redundant PHIs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:85,redund,redundant,85,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['redund'],['redundant']
Safety,"// Extracting the lowest bit is a no-op, but it changes the type,; // so it must be kept as an operation to avoid errors related to; // type mismatches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:108,avoid,avoid,108,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Extracts are just reads of a subregister, so are free. Inserts are; // considered free because we don't want to have any cost for scalarizing; // operations, and we don't have to copy into a different register class.; // Dynamic indexing isn't free and is best avoided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:264,avoid,avoided,264,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,2,['avoid'],['avoided']
Safety,// FD is only needed to avoid race conditions. Close it right away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Path.cpp:24,avoid,avoid,24,interpreter/llvm-project/llvm/lib/Support/Path.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Path.cpp,2,['avoid'],['avoid']
Safety,// FIXME - need better way (e.g. Metadata) to avoid generating this global,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp:46,avoid,avoid,46,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAsmPrinter.cpp,1,['avoid'],['avoid']
Safety,"// FIXME : Cling has problems to detect these arguments.; /*; if(langOpts.CUDADeviceFlushDenormalsToZero); m_CuArgs.additionalPtxOpt.push_back(""-fcuda-flush-denormals-to-zero"");; if(langOpts.CUDADeviceApproxTranscendentals); m_CuArgs.additionalPtxOpt.push_back(""-fcuda-approx-transcendentals"");; if(langOpts.CUDAAllowVariadicFunctions); m_CuArgs.additionalPtxOpt.push_back(""-fcuda-allow-variadic-functions"");; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalCUDADeviceCompiler.cpp:33,detect,detect,33,interpreter/cling/lib/Interpreter/IncrementalCUDADeviceCompiler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalCUDADeviceCompiler.cpp,1,['detect'],['detect']
Safety,// FIXME The frontend should detect this case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:29,detect,detect,29,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,2,['detect'],['detect']
Safety,"// FIXME This causes a redundant load/store if the SSE-class value is already; // in memory, such as if it is on the callstack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:23,redund,redundant,23,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['redund'],['redundant']
Safety,"// FIXME-PERF: We could immediately lower out instructions if we can tell; // they are fully resolved, to avoid retesting on later passes.; // Relax the fragment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:106,avoid,avoid,106,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,1,['avoid'],['avoid']
Safety,"// FIXME. Make safe assumption assuming arbitrary statements cause capturing.; // Later, provide code to poke into statements for capture analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:15,safe,safe,15,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['safe'],['safe']
Safety,"// FIXME: ""A(f())"" deserves a vexing-parse warning, not just a; // redundant-parens warning, but we don't know whether the function; // chunk was syntactically valid as an expression here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:67,redund,redundant-parens,67,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['redund'],['redundant-parens']
Safety,// FIXME: A problematic debug_abbrev section is reported below in the form; // of a `note:`. We should propagate this error there (or elsewhere) to; // avoid losing the specific problem with the debug_abbrev section.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp:152,avoid,avoid,152,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFVerifier.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Actually abort assembly here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:19,abort,abort,19,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['abort'],['abort']
Safety,"// FIXME: Although all systems tested with (Linux, OS X), do not need this; // header file included. A user on ubuntu reported, undefined symbols; // for stderr, and fprintf, and the addition of this include fixed the; // issue for them. Given that LLVM's best practices include the goal; // of reducing the number of redundant header files included, the; // correct solution would be to find out why these symbols are not; // defined for the system in question, and fix the issue by finding out; // which LLVM header file, if any, would include these symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:318,redund,redundant,318,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['redund'],['redundant']
Safety,// FIXME: Are there other cases where we can avoid emitting an initializer?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:45,avoid,avoid,45,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: At this point the constant folding claims that the result; // of a bitwise shift is undefined. However, constant folding; // relies on the inaccurate type information that is stored in the; // bit size of APSInt objects, and if we reached this point, then; // the checker core.BitwiseShift already determined that the shift; // is valid (in a PreStmt callback, by querying the real type from; // the AST node).; // To avoid embarrassing false positives, let's just say that we; // don't know anything about the result of the shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:428,avoid,avoid,428,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Avoid copy here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp:10,Avoid,Avoid,10,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/ELFNixPlatform.cpp,1,['Avoid'],['Avoid']
Safety,// FIXME: Avoid quadratic complexity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:10,Avoid,Avoid,10,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,2,['Avoid'],['Avoid']
Safety,// FIXME: Avoid specializing for stride==1 instead of bailing out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10,Avoid,Avoid,10,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['Avoid'],['Avoid']
Safety,"// FIXME: Avoid std::string in ""Sel.getAsString()""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:10,Avoid,Avoid,10,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['Avoid'],['Avoid']
Safety,// FIXME: Avoid the allocation/copy if at all possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp:10,Avoid,Avoid,10,interpreter/llvm-project/clang/lib/AST/Stmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Stmt.cpp,1,['Avoid'],['Avoid']
Safety,// FIXME: Avoid the conversion through memory if possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:10,Avoid,Avoid,10,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['Avoid'],['Avoid']
Safety,// FIXME: Avoid the tentative parse when NextToken() can't begin a type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:10,Avoid,Avoid,10,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['Avoid'],['Avoid']
Safety,// FIXME: Avoid visiting the same operands multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp:10,Avoid,Avoid,10,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanSLP.cpp,1,['Avoid'],['Avoid']
Safety,// FIXME: Better recovery here?.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:17,recover,recovery,17,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['recover'],['recovery']
Safety,// FIXME: Can we avoid a linear search here? The table might be sorted by; // CPUKind so we could binary search?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp:17,avoid,avoid,17,interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/X86TargetParser.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Can we avoid manually doing this?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:17,avoid,avoid,17,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Can we detect when the user just wrote an include guard above?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:17,detect,detect,17,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['detect'],['detect']
Safety,"// FIXME: Causes rootcling to deadlock, debug and uncomment; // SafeDelete(fRootFolder);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:64,Safe,SafeDelete,64,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['Safe'],['SafeDelete']
Safety,"// FIXME: Causes segfault in rootcling, debug and uncomment; // fClasses->Delete(); SafeDelete(fClasses); // TClass'es must be deleted last",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:84,Safe,SafeDelete,84,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['Safe'],['SafeDelete']
Safety,// FIXME: Change CreateOverloadedBinOp to take an ArrayRef instead of an; // UnresolvedSet to avoid this copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:94,avoid,avoid,94,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Change the GVSummaryMapTy to hold ValueInfo instead of GUID; // so this map look up (and possibly others) can be avoided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:123,avoid,avoided,123,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['avoid'],['avoided']
Safety,// FIXME: Come up with a more type-safe way to model context-sensitivity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/AnalysisDeclContext.h:35,safe,safe,35,interpreter/llvm-project/clang/include/clang/Analysis/AnalysisDeclContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/AnalysisDeclContext.h,1,['safe'],['safe']
Safety,// FIXME: Conservatively refuse to convert an instruction which isn't in the; // same BB as the comparison. This is to allow the check below to avoid calls; // (and other explicit clobbers); instead we should really check for these; // more explicitly (in at least a few predecessors).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:144,avoid,avoid,144,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Consider destroying `MergedValue` immediately if `ValueModel::merge`; // returns false to avoid storing unneeded values in `DACtx`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:100,avoid,avoid,100,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Consider not skipping import if the module contains; // a non-prevailing def with interposable linkage. The prevailing copy; // can safely be imported (see shouldImportGlobal()).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:142,safe,safely,142,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['safe'],['safely']
Safety,// FIXME: Consider passing invalid template-ids on to callers; they may; // be able to recover better than we can.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:87,recover,recover,87,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recover']
Safety,"// FIXME: Current implementation of ClampedSubtract implicitly assumes that; // X is non-negative (in sense of a signed value). We need to re-implement; // this function in a way that it will correctly handle negative X as well.; // We use it twice: for X = 0 everything is fine, but for X = getEnd() we can; // end up with a negative X and produce wrong results. So currently we ensure; // that if getEnd() is negative then both ends of the safe range are zero.; // Note that this may pessimize elimination of unsigned range checks against; // negative values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:442,safe,safe,442,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['safe'],['safe']
Safety,"// FIXME: Currently -fsanitize=leak is silently ignored in the presence of; // -fsanitize=address. Perhaps it should print an error, or perhaps; // -f(-no)sanitize=leak should change whether leak detection is enabled by; // default in ASan?; // Parse -f(no-)?sanitize-recover flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:196,detect,detection,196,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,"['detect', 'recover']","['detection', 'recover']"
Safety,"// FIXME: Currently the calls which may access the thread id may; // be considered as not accessing the memory. But this is; // problematic for coroutines, since coroutines may resume in a; // different thread. So we disable the optimization here for the; // correctness. However, it may block many other correct; // optimizations. Revert this one when we detect the memory; // accessing kind more precisely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:356,detect,detect,356,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,4,['detect'],['detect']
Safety,// FIXME: Detect integer instructions properly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp:10,Detect,Detect,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,2,['Detect'],['Detect']
Safety,"// FIXME: Detect non-deduced exception specification mismatches?; //; // Careful about [temp.deduct.call] and [temp.deduct.conv], which allow; // top-level differences in noexcept-specifications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:10,Detect,Detect,10,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['Detect'],['Detect']
Safety,// FIXME: Diagnose redundant specifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:19,redund,redundant,19,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['redund'],['redundant']
Safety,"// FIXME: Don't compute this in advance, it makes every token larger, and is; // also not generally what we want (it is nicer for recovery etc. to lex 123br; // as a single token, then diagnose as an invalid number).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmMacro.h:130,recover,recovery,130,interpreter/llvm-project/llvm/include/llvm/MC/MCAsmMacro.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmMacro.h,1,['recover'],['recovery']
Safety,// FIXME: Either avoid relying on address space here or change the default; // address space for functions to avoid the explicit check.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:17,avoid,avoid,17,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// FIXME: Emit checks to determine it's _actually_ safe to fold and/or; // account for unsafe cases.; //; // Example:; // MI1--> %0 = ...; // %1 = ... %0; // MI0--> %2 = ... %0; // It's not safe to erase MI1. We currently handle this by not; // erasing %0 (even when it's dead).; //; // Example:; // MI1--> %0 = load volatile @a; // %1 = load volatile @a; // MI0--> %2 = ... %0; // It's not safe to sink %0's def past %1. We currently handle; // this by rejecting all loads.; //; // Example:; // MI1--> %0 = load @a; // %1 = store @a; // MI0--> %2 = ... %0; // It's not safe to sink %0's def past %1. We currently handle; // this by rejecting all loads.; //; // Example:; // G_CONDBR %cond, @BB1; // BB0:; // MI1--> %0 = load @a; // G_BR @BB1; // BB1:; // MI0--> %2 = ... %0; // It's not always safe to sink %0 across control flow. In this; // case it may introduce a memory fault. We currentl handle; // this by rejecting all loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp:51,safe,safe,51,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,6,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"// FIXME: Evaluate the efficiency of matchers. If using matchers results in a; // lot of duplicated work (e.g. string comparisons), consider providing APIs; // that avoid it through memoization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:165,avoid,avoid,165,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,2,['avoid'],['avoid']
Safety,// FIXME: Find a better way to avoid duplicated diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:31,avoid,avoid,31,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: For a specialization of a variable template, we don't; // distinguish between ""declaration and type implicitly instantiated""; // and ""implicit instantiation of definition requested"", so we have; // no direct way to avoid enqueueing the pending instantiation; // multiple times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:225,avoid,avoid,225,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: For error recovery, consider recognizing attribute syntax here; // and terminating / diagnosing a missing semicolon if we find anything; // else? (Can we leave that to the parser?)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:20,recover,recovery,20,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['recover'],['recovery']
Safety,"// FIXME: For non-dllimport functions, MSVC emits the same entry; // twice, for reasons I don't understand. I have to assume the linker; // ignores the redundant entry; there aren't any reasonable semantics; // to attach to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:152,redund,redundant,152,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['redund'],['redundant']
Safety,"// FIXME: For now we require the newer floating-point conversion operations; // (which are present only on P7 and A2 server models) when converting; // to single-precision float. Otherwise we have to generate a lot of; // fiddly code to avoid double rounding. If necessary, the fiddly code; // can be found in PPCTargetLowering::LowerINT_TO_FP().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:237,avoid,avoid,237,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: For now, avoid instructions with multiple defs, unless; // it's a dead implicit def.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:19,avoid,avoid,19,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: For resource conflicts in very long non-pipelined stages, we; // should probably skip ahead here to avoid useless scoreboard checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:110,avoid,avoid,110,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: For those things that are not safe we could generate; // expressions all the way down, and see if this comes out to a; // constant. For anything where that is true, and unsafe, we should; // have made a phi-of-ops (or value numbered it equivalent to something); // for the pieces already.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:40,safe,safe,40,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"// FIXME: Formatting here is pretty nasty because clang does not accept; // newlines from diagnostics. This forces us to emit multiple diagnostic; // remarks to simulate newlines. If and when clang does accept newlines, this; // formatting should be aggregated into one remark with newlines to avoid; // printing multiple diagnostic location and diag opts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp:294,avoid,avoid,294,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUAsmPrinter.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: GH63562; // Arrays allocate an APValue per element.; // We use the number of constexpr steps as a proxy for the maximum size; // of arrays to avoid exhausting the system resources, as initialization; // of each element is likely to take some number of steps anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:152,avoid,avoid,152,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['avoid'],['avoid']
Safety,// FIXME: HLSLSemantic is shared for Semantic and resource binding which is; // confusing. Need a better name to avoid misunderstanding. Issue; // https://github.com/llvm/llvm-project/issues/57882,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp:113,avoid,avoid,113,interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseHLSL.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: Handle aggregate types; // Since we don't have sub-dword scalar loads, avoid doing an extload by; // loading earlier than the argument address, and extracting the relevant; // bits.; // TODO: Update this for GFX12 which does have scalar sub-dword loads.; //; // Additionally widen any sub-dword load to i32 even if suitably aligned,; // so that CSE between different argument loads works easily.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp:81,avoid,avoid,81,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: I doubt that it is correct to resolve a dangling DbgValue as a; // FuncArgumentDbgValue (it would be hoisted to the function entry, and if; // we couldn't resolve it directly when examining the DbgValue intrinsic; // in the first place we should not be more successful here). Unless we; // have some test case that prove this to be correct we should avoid; // calling EmitFuncArgumentDbgValue here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:360,avoid,avoid,360,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: If the memcpy is volatile (isVol), lowering it to a plain libc; // memcpy is not guaranteed to be safe. libc memcpys aren't required to; // respect volatile, so they may do things like read or write memory; // beyond the given memory regions. But fixing this isn't easy, and most; // people don't care.; // Emit a library call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:108,safe,safe,108,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['safe'],['safe']
Safety,"// FIXME: If the memmove is volatile, lowering it to plain libc memmove may; // not be safe. See memcpy above for more details.; // Emit a library call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:87,safe,safe,87,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['safe'],['safe']
Safety,"// FIXME: If the type is wider than it needs to be, e.g. i8 but all values; // are <= 15, we could try to narrow the type.; // Avoid overflow, fitsInLegalInteger uses unsigned int for the width.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:127,Avoid,Avoid,127,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['Avoid'],['Avoid']
Safety,"// FIXME: If this depth limit is hit, then we may cache sub-optimal results; // for recursive queries. For this reason, this limit is chosen to be large; // enough to be very rarely hit, while still being small enough to avoid; // stack overflows.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:221,avoid,avoid,221,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: If this is a problem, recover from it by creating a multiplex; // source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:32,recover,recover,32,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,1,['recover'],['recover']
Safety,"// FIXME: If we ended up with a typo for a type name or; // Objective-C class name, we're in trouble because the parser; // is in the wrong place to recover. Suggest the typo; // correction, but don't make it a fix-it since we're not going; // to recover well anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:149,recover,recover,149,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['recover'],['recover']
Safety,"// FIXME: If we have no MR, we still need to unwrap the array to avoid; // destroying the whole array at once.; //; // For this case there is no universal solution as there is no way to; // directly create an array of temporary objects. There are some expressions; // however which can create temporary objects and have an array type.; //; // E.g.: std::initializer_list<S>{S(), S()};; //; // The expression above has a type of 'const struct S[2]' but it's a single; // 'std::initializer_list<>'. The destructors of the 2 temporary 'S()'; // objects will be called anyway, because they are 2 separate objects in 2; // separate clusters, i.e.: not an array.; //; // Now the 'std::initializer_list<>' is not an array either even though it; // has the type of an array. The point is, we only want to invoke the; // destructor for the initializer list once not twice or so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:65,avoid,avoid,65,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: Implement duplicate function detection.; // The check below will only work if the duplicate is in the open module.; // If F conflicted, there was already something named 'Name'. If it has a; // body, don't allow redefinition or reextern.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp:39,detect,detection,39,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/complete/toy.cpp,1,['detect'],['detection']
Safety,// FIXME: In the future it would be nice if we could avoid hardcoding these; // values. One idea is to define some structures representing these types; // that would allow the use of offsetof().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeIndexDiscovery.cpp:53,avoid,avoid,53,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeIndexDiscovery.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeIndexDiscovery.cpp,2,['avoid'],['avoid']
Safety,// FIXME: Insert UnreachableInst if !MS.Recover?; // This may invalidate some of the following checks and needs to be done; // at the very end.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:40,Recover,Recover,40,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['Recover'],['Recover']
Safety,"// FIXME: Instead of passing in the CallOperator->getTypeSourceInfo(); // we should get a prebuilt TrivialTypeSourceInfo from Context; // using FunctionTy & Loc and get its TypeLoc as a FunctionProtoTypeLoc; // then rewire the parameters accordingly, by hoisting up the InvokeParams; // loop below and then use its Params to set Invoke->setParams(...) below.; // This would avoid the 'const' qualifier of the calloperator from; // contaminating the type of the invoker, which is currently adjusted; // in SemaTemplateDeduction.cpp:DeduceTemplateArguments. Fixing the; // trailing return type of the invoker would require a visitor to rebuild; // the trailing return type and adjusting all back DeclRefExpr's to refer; // to the new static invoker parameters - not the call operator's.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:374,avoid,avoid,374,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Is there a better way to avoid quotes than using getName()?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:35,avoid,avoid,35,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: Is this actually dangerous as WritingAnLLVMPass.html claims? Seems; // that, short of multithreaded LLVM, it should be safe; all that is; // necessary is that a simple Module::iterator loop not be invalidated.; // Appending to the GlobalVariable list is safe in that sense.; //; // All of the output passes emit globals last. The ExecutionEngine; // explicitly supports adding globals to the module after; // initialization.; //; // Still, if it isn't deemed acceptable, then this transformation needs; // to be a ModulePass (which means it cannot be in the 'llc' pipeline; // (which uses a FunctionPassManager (which segfaults (not asserts) if; // provided a ModulePass))).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp:129,safe,safe,129,interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShadowStackGCLowering.cpp,2,['safe'],['safe']
Safety,// FIXME: It should be safe to return false for the STO_MIPS_MICROMIPS but; // we neglect to handle the adjustment to the LSB of the addend that; // it causes in applyFixup() and similar.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:23,safe,safe,23,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,1,['safe'],['safe']
Safety,"// FIXME: It would be good to recover by accepting the attributes,; // but attempting to do that now would cause serious; // madness in terms of diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:30,recover,recover,30,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Safety,// FIXME: It's not safe to lower a unary FNeg into a FMul by -1.0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:19,safe,safe,19,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['safe'],['safe']
Safety,// FIXME: Let the caller know if these fail to avoid duplicate diagnostics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:47,avoid,avoid,47,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: Liveness. A 2D BitVector, perhaps?; //; // BitVector Liveness;; //; // bool islive(int point, int root) =; // Liveness[point * SafePoints.size() + root]; //; // The bit vector is the more compact representation where >3.2% of roots; // are live per safe point (1.5% on 64-bit hosts).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:137,Safe,SafePoints,137,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,2,"['Safe', 'safe']","['SafePoints', 'safe']"
Safety,// FIXME: Make VBases lazily computed when needed to avoid storing them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:53,avoid,avoid,53,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: Make this the iterator's operator*() after the 4.0 release.; // operator*() had a different meaning in earlier releases, so we're; // temporarily not giving this iterator an operator*() to avoid a subtle; // semantics break.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GetElementPtrTypeIterator.h:199,avoid,avoid,199,interpreter/llvm-project/llvm/include/llvm/IR/GetElementPtrTypeIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GetElementPtrTypeIterator.h,1,['avoid'],['avoid']
Safety,// FIXME: Manually selecting to avoid dealing with the SReg_1 trick; // SelectionDAG uses for wave32 vs wave64.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,2,['avoid'],['avoid']
Safety,// FIXME: Many of these relocations should probably return false but this; // hasn't been confirmed to be safe yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:106,safe,safe,106,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,1,['safe'],['safe']
Safety,// FIXME: Maybe check for ODR violations.; // It's safe to stop now because this update record is always last.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:51,safe,safe,51,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['safe'],['safe']
Safety,// FIXME: Metadata Verifier only works with AMDHSA.; // This is an ugly workaround to avoid the verifier for other MD; // formats (e.g. amdpal),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Need to find a way to avoid use of getNullValue here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Pass should maintain scavenger to avoid scan through the block on; // every AGPR spill.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:44,avoid,avoid,44,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Perform error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:24,recover,recovery,24,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,2,['recover'],['recovery']
Safety,"// FIXME: Pre-increment to avoid failing tests.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp:27,avoid,avoid,27,interpreter/cling/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Probably shouldn't bother trying to fold if not an; // SGPR. PeepholeOptimizer can eliminate redundant VGPR->VGPR; // copies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:103,redund,redundant,103,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['redund'],['redundant']
Safety,"// FIXME: Re-enable assert once PR20057 is resolved.; // assert(i <= (HazardRec->getMaxLookAhead() + MaxObservedStall) &&; // ""permanent hazard"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:70,Hazard,HazardRec,70,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,"['Hazard', 'hazard']","['HazardRec', 'hazard']"
Safety,// FIXME: Recover by calling the found function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,Recover,Recover,10,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['Recover'],['Recover']
Safety,// FIXME: Recover from this by treating the declaration as a redeclaration; // of the primary template.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:10,Recover,Recover,10,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Recover'],['Recover']
Safety,"// FIXME: Redundant check, but even less readable when factored out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:10,Redund,Redundant,10,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['Redund'],['Redundant']
Safety,"// FIXME: Redundant storage which, beyond utilizing value of; // caughtResultStore for unwindException storage, may be alleviated; // altogether with a block rearrangement",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp:10,Redund,Redundant,10,interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/ExceptionDemo/ExceptionDemo.cpp,1,['Redund'],['Redundant']
Safety,"// FIXME: Remove this flag when it is no longer necessary to convert; // llvm.dbg.declare to avoid inaccurate debug info. Setting this to false; // increases variable availability at the cost of accuracy. Variables that; // cannot be promoted by mem2reg or SROA will be described as living in memory; // for their entire lifetime. However, passes like DSE and instcombine can; // delete stores to the alloca, leading to misleading and inaccurate debug; // information. This flag can be removed when those passes are fixed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Rewrite the Actions to avoid duplication of descriptions/names with; // rules.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp:33,avoid,avoid,33,interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/RefactoringActions.cpp,2,['avoid'],['avoid']
Safety,"// FIXME: Setting IsMultiVariableDeclStmt for the whole line is error-prone,; // because it does not take into account nested scopes like lambdas.; // In multi-variable declaration statements, attach */& to the variable; // independently of the style. However, avoid doing it if we are in a nested; // scope, e.g. lambda. We still need to special-case statements with; // initializers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:261,avoid,avoid,261,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Several methods should be pure virtual but aren't to avoid the; // partially-implemented subclass breaking.; /// Implements runtime-specific code generation functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h:63,avoid,avoid,63,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,1,['avoid'],['avoid']
Safety,// FIXME: Should have analysis or something rather than attribute to detect; // calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:69,detect,detect,69,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['detect'],['detect']
Safety,"// FIXME: Should perform GVN again after PRE does something. PRE can move; // computations into blocks where they become fully redundant. Note that; // we can't do this until PRE's critical edge splitting updates memdep.; // Actually, when this happens, we should just fully integrate PRE into GVN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:127,redund,redundant,127,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['redund'],['redundant']
Safety,"// FIXME: Should we move the logic that tries to recover from a missing tag; // (struct, union, enum) from Parser::ParseImplicitInt here, instead?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:49,recover,recover,49,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recover']
Safety,"// FIXME: Shouldn't we go to -1 here, or better just abort?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:53,abort,abort,53,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['abort'],['abort']
Safety,// FIXME: Support error recovery for the template-name case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:24,recover,recovery,24,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery']
Safety,"// FIXME: The big likely candidate here are PHI nodes. We could in theory; // handle PHI nodes, but it gets really, really hard. Insanely hard. Hard; // enough that it is probably better to change every other part of LLVM; // to avoid creating them. The issue is that once we have PHIs we won't; // know which original EFLAGS value we need to capture with our setCCs; // below. The end result will be computing a complete set of setCCs that; // we *might* want, computing them in every place where we copy *out* of; // EFLAGS and then doing SSA formation on all of them to insert necessary; // PHI nodes and consume those here. Then hoping that somehow we DCE the; // unnecessary ones. This DCE seems very unlikely to be successful and so; // we will almost certainly end up with a glut of dead setCC; // instructions. Until we have a motivating test case and fail to avoid; // it by changing other parts of LLVM's lowering, we refuse to handle; // this complex case here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:229,avoid,avoid,229,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,2,['avoid'],['avoid']
Safety,"// FIXME: The check below is redundant and incomplete. According to spec, if a; // convergent call is missing a token, then the caller is using uncontrolled; // convergence. If the callee has an entry intrinsic, then the callee is using; // controlled convergence, and the call cannot be inlined. A proper; // implemenation of this check requires a whole new analysis that identifies; // convergence in every function. For now, we skip that and just do this one; // cursory check. The underlying assumption is that in a compiler flow that; // fully implements convergence control tokens, there is no mixing of; // controlled and uncontrolled convergent operations in the whole program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:29,redund,redundant,29,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['redund'],['redundant']
Safety,"// FIXME: The check for extern ""C"" here is not justified by the standard; // wording, but we retain it from the pre-DR1113 model to avoid breaking; // code.; //; // C++11 [basic.link]p4:; // An unnamed namespace or a namespace declared directly or indirectly; // within an unnamed namespace has internal linkage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:132,avoid,avoid,132,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: The command line parser below is not thread-safe and shares a global; // state, so this call might crash or overwrite the options of another Clang; // instance in the same process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:54,safe,safe,54,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['safe'],['safe']
Safety,"// FIXME: The following early return was presumably added to safeguard the; // getTypeSizeInChars() call (which doesn't accept an incomplete type), but; // it seems that `ElemType` cannot be incomplete at this point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:61,safe,safeguard,61,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,1,['safe'],['safeguard']
Safety,// FIXME: The loop above only tries to split in halves. But if the input; // vector for example is <3 x i16> it wouldn't be able to detect a; // SplatBitSize of 16. No idea if that is a design flaw currently limiting; // optimizations. I guess that back in the days when this helper was created; // vectors normally was power-of-2 sized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:132,detect,detect,132,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['detect'],['detect']
Safety,"// FIXME: The other checks should be redundant with allStackObjectsAreDead,; // but currently hasNonSpillStackObjects is set only from source; // allocas. Stack temps produced from legalization are not counted currently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:37,redund,redundant,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['redund'],['redundant']
Safety,"// FIXME: The vectorizer is highly sensistive to the cost of these; // instructions, which suggests that it may be using the costs incorrectly.; // But, for now, just make them free to avoid performance regressions for; // vector targets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:185,avoid,avoid,185,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,1,['avoid'],['avoid']
Safety,// FIXME: These are taken from the heuristic-based cost visitor: we should; // eventually abstract these to the CallAnalyzer to avoid duplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:128,avoid,avoid,128,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['avoid'],['avoid']
Safety,// FIXME: These constants are taken from the heuristic-based cost visitor.; // These should be removed entirely in a later revision to avoid reliance on; // heuristics in the ML inliner.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:135,avoid,avoid,135,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: This approach for uniquing ADL results (and removing; // redundant candidates from the set) relies on pointer-equality,; // which means we need to key off the canonical decl. However,; // always going back to the canonical decl might not get us the; // right set of default arguments. What default arguments are; // we supposed to consider on ADL candidates, anyway?; // FIXME: Pass in the explicit template arguments?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:67,redund,redundant,67,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['redund'],['redundant']
Safety,// FIXME: This could eventually be replaced by an LLVM intrinsic to; // avoid this long IR sequence.; // (a + ib) / (c + id) = (e + if),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp:72,avoid,avoid,72,interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: This is a hack so that we can override the preamble file during; // crash-recovery testing, which is the only case where the preamble files; // are not necessarily cleaned up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:84,recover,recovery,84,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,1,['recover'],['recovery']
Safety,// FIXME: This is a temporary workaround for the case where clang-format; // sets BreakBeforeParameter to avoid bin packing and this creates a; // completely unnecessary line break after a template type that isn't; // line-wrapped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:106,avoid,avoid,106,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: This is horrible, we should use our own list or something to avoid; // this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp:71,avoid,avoid,71,interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/TokenRewriter.cpp,1,['avoid'],['avoid']
Safety,// FIXME: This is not complete. We basically treat @throw as; // an abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:68,abort,abort,68,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['abort'],['abort']
Safety,// FIXME: This is not quite correct recovery as we don't transform SS; // into the corresponding dependent form (and we don't diagnose missing; // 'template' keywords within SS as a result).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:36,recover,recovery,36,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recovery']
Safety,"// FIXME: This is technically correct but gives a different result to gas,; // but gas is incomplete there (it has a fixme noting it doesn't work with; // 64-bit addresses).; // FIXME: With -msym32 option, the address expansion for N64 should probably; // use the O32 / N32 case. It's safe to use the 64 address expansion as the; // symbol's value is considered sign extended.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:285,safe,safe,285,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['safe'],['safe']
Safety,"// FIXME: This may not be safe if the analysis allows undef elements. By; // moving 'Y' before the splat shuffle, we are implicitly assuming; // that it is not undef/poison at the splat index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:26,safe,safe,26,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['safe'],['safe']
Safety,"// FIXME: This should use the same heuristics as IfConversion to determine; // whether a select is better represented as a branch.; // If metadata tells us that the select condition is obviously predictable,; // then we want to replace the select with a branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:195,predict,predictable,195,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['predict'],['predictable']
Safety,"// FIXME: This transform is restricted from changing the select between; // scalars and vectors to avoid backend problems caused by creating; // potentially illegal operations. If a fix-up is added to handle that; // situation, we can remove this check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:99,avoid,avoid,99,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: This transform is restricted to vector types to avoid backend; // problems caused by creating potentially illegal operations. If a fix-up is; // added to handle that situation, we can remove this check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:58,avoid,avoid,58,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Turn these into classes so we can have some type safety when; // we go from local ID to global and vice-versa.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:59,safe,safety,59,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['safe'],['safety']
Safety,"// FIXME: Use lazy DTU and update SplitBlock to accept a DTU instead of a; // DT. Manually collect dominator tree updates, to avoid unnecessary work,; // as we adjust Check0 and Check1's branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:126,avoid,avoid,126,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: UseMemorySSA is set to false. Maybe we could do things like:; // bool UseMemorySSA = !(""canon-freeze"" || ""loop-predication"" ||; // ""guard-widening"");; // The risk is that it may become obsolete if we're not careful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:168,risk,risk,168,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,1,['risk'],['risk']
Safety,"// FIXME: We are managing our modules, so we do not want the base class; // ExecutionEngine to manage them as well. To avoid double destruction; // of the first (and only) module added in ExecutionEngine constructor; // we remove it from EE and will destruct it ourselves.; //; // It may make sense to move our module manager (based on SmallStPtr) back; // into EE if the JIT and Interpreter can live with it.; // If so, additional functions: addModule, removeModule, FindFunctionNamed,; // runStaticConstructorsDestructors could be moved back to EE as well.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp:119,avoid,avoid,119,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: We can safely allow undefs here. If Index was specified, we will; // check that the mask elt is defined at the required index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:17,safe,safely,17,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['safe'],['safely']
Safety,"// FIXME: We don't want this to happen. Rather, we should be able to; // detect all kinds of implicit accesses more cleanly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:73,detect,detect,73,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['detect'],['detect']
Safety,"// FIXME: We found a keyword. Suggest it, but don't provide a fix-it; // because we aren't able to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:99,recover,recover,99,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Safety,"// FIXME: We inherit EnableImplicitIMT from TBufferMerger tests (we are sharing the same executable) where we call; // EnableThreadSafety(). Here, we hit a race condition in TBranch::FlushBaskets. Once we get that fixed we probably; // should re-enable implicit MT.; //; // In general, we should probably have a way to conditionally enable/disable thread safety.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/test/TFileMergerTests.cxx:355,safe,safety,355,io/io/test/TFileMergerTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/test/TFileMergerTests.cxx,1,['safe'],['safety']
Safety,"// FIXME: We lack an extension to customize the mangling of the variants, e.g.,; // add a suffix. This means we would clash with the names of the variants; // (note that we do not create implicit base functions here). To avoid; // this clash we add a new trait to some of them that is always true; // (this is LLVM after all ;)). It will only influence the mangled name; // of the variants inside the inner region and avoid the clash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h:221,avoid,avoid,221,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,4,['avoid'],['avoid']
Safety,// FIXME: We may be able to use PPCallbacks to check for empty context; // comments as part of preprocessing and avoid this re-lexing hack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp:113,avoid,avoid,113,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/LocalizationChecker.cpp,1,['avoid'],['avoid']
Safety,// FIXME: We may be able to use the NumToSkip values to recover; // appropriate indentation levels.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp:56,recover,recover,56,interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DecoderEmitter.cpp,1,['recover'],['recover']
Safety,// FIXME: We probably need to make this out-of-line to avoid redundant; // generation of virtual functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h:55,avoid,avoid,55,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// FIXME: We really _ought_ to insert these value numbers into their; // parent's availability map. However, in doing so, we risk getting into; // ordering issues. If a block hasn't been processed yet, we would be; // marking a value as AVAIL-IN, which isn't what we intend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:125,risk,risk,125,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['risk'],['risk']
Safety,"// FIXME: We set the section explicitly to avoid a bug in ld64 224.1.; // Without it LLVM can merge the string with a non unnamed_addr one during; // LTO. Doing that changes the section it ends in, which surprises ld64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:43,avoid,avoid,43,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: We should add the pcm to the InMemoryModuleCache if it could be; // read again later, but we do not have the context here to determine if it; // is safe to change the result of InMemoryModuleCache::getPCMState().; // FIXME: This allows use of the VFS; we do not allow use of the; // VFS when actually loading a module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:158,safe,safe,158,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['safe'],['safe']
Safety,// FIXME: We should avoid this pattern of getting the ASTContext.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:20,avoid,avoid,20,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: We should probably indicate the identifier in question to avoid; // confusion for constructs like ""virtual int a(), b;""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:68,avoid,avoid,68,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: We should sink the escape vs. abort info into the caller nicely,; // possibly by just storing the PtrInfo in the AllocaSlices.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:40,abort,abort,40,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['abort'],['abort']
Safety,"// FIXME: We should track down all sets and potentially avoid them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.h:56,avoid,avoid,56,core/metacling/src/TClingClassInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingClassInfo.h,1,['avoid'],['avoid']
Safety,"// FIXME: We use the 'unsafe' accessor for the access specifier here,; // because Sema may not have set it yet. That's really just a misdesign; // in Sema. However, LLDB *will* have set the access specifier correctly,; // and adds declarations after the class is technically completed,; // so completeDefinition()'s overriding of the access specifiers doesn't; // work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp:22,unsafe,unsafe,22,interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclCXX.cpp,1,['unsafe'],['unsafe']
Safety,// FIXME: We're generating redundant loads and stores here!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:27,redund,redundant,27,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['redund'],['redundant']
Safety,"// FIXME: We've expanded Count where we hope to insert the counter setting; // intrinsic. But, in the case of the 'test and set' form, we may fallback to; // the just 'set' form and in which case the insertion block is most likely; // different. It means there will be instruction(s) in a block that possibly; // aren't needed. The isLoopEntryGuardedByCond is trying to avoid this issue,; // but it's doesn't appear to work in all cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:370,avoid,avoid,370,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,1,['avoid'],['avoid']
Safety,// FIXME: What if the index is integer literal 0? Should this be; // a safe gadget in this case?; // clang-format off,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:71,safe,safe,71,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['safe'],['safe']
Safety,// FIXME: What we're doing here is modifying the type-specifier that; // precedes the first Decl. In the future the DeclGroup should have; // a separate type-specifier that we can rewrite.; // NOTE: We need to avoid rewriting the DeclStmt if it is within; // the context of an ObjCForCollectionStmt. For example:; // NSArray *someArray;; // for (id <FooProtocol> index in someArray) ;; // This is because RewriteObjCForCollectionStmt() does textual rewriting; // and it depends on the original text locations/positions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:210,avoid,avoid,210,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['avoid'],['avoid']
Safety,"// FIXME: When Sema learns to form this AttributedType, avoid printing the; // attribute again in printFunctionProtoAfter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:56,avoid,avoid,56,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: Why are we trying to remove files that we have not created? For; // example we should only try to remove a temporary assembly file if; // ""clang -cc1"" succeed in writing it. Was this a workaround for when; // clang was writing directly to a .s file and sometimes leaving it behind; // during a failure?; // FIXME: If this is necessary, we can still try to split; // llvm::sys::fs::remove into a removeFile and a removeDir and avoid the; // duplicated stat from is_regular_file.; // Don't try to remove files which we don't have write access to (but may be; // able to remove), or non-regular files. Underlying tools may have; // intentionally not overwritten them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp:436,avoid,avoid,436,interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,1,['avoid'],['avoid']
Safety,// FIXME: Why not return false and abort parsing?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp:35,abort,abort,35,interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ModuleBuilder.cpp,1,['abort'],['abort']
Safety,"// FIXME: Would it make sense to try to ""forget"" the previous; // definition, as part of error recovery?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:95,recover,recovery,95,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recovery']
Safety,"// FIXME: arg->getIsOmitted() == ""false"" means we haven't implemented; // any way to detect whether the argument was omitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:85,detect,detect,85,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['detect'],['detect']
Safety,// FIXME: avoid copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,avoid,avoid,10,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,3,['avoid'],['avoid']
Safety,// FIXME: avoid re-calculating this every time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp:10,avoid,avoid,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,2,['avoid'],['avoid']
Safety,// FIXME: avoid the fake decl,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:10,avoid,avoid,10,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['avoid'],['avoid']
Safety,// FIXME: change the signature of join() to avoid copying here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h:44,avoid,avoid,44,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowAnalysis.h,1,['avoid'],['avoid']
Safety,// FIXME: check for mem op safety and legality of the types. Not all of; // SDAGisms map cleanly to GISel concepts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:27,safe,safety,27,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['safe'],['safety']
Safety,// FIXME: detect and handle SSE maskstore/maskload,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:10,detect,detect,10,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['detect'],['detect']
Safety,"// FIXME: diagnose the presence of template arguments now.; // If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:188,avoid,avoid,188,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: double memoization is redundant, with memoization both here and in; // BodyFarm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h:32,redund,redundant,32,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.h,1,['redund'],['redundant']
Safety,// FIXME: figure out how to safely handle things like; // int foo(int x) { return 1 << (x & 255); }; // int bar() { return foo(256); },MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:28,safe,safely,28,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['safe'],['safely']
Safety,// FIXME: have LockFileManager return an error_code so that we can; // avoid the mkdir when the directory already exists.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:71,avoid,avoid,71,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: in principle up to 64-bit could be made safe, but it would be very; // fragile at the moment: any support for multiple value returns would be; // liable to disallow tail calls involving i64 -> iN truncation in many cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:50,safe,safe,50,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['safe'],['safe']
Safety,"// FIXME: in the current implementation the granularity of affected range; // is an annotated line. However, this is not sufficient. Furthermore,; // redundant code introduced by replacements does not necessarily; // intercept with ranges of replacements that result in the redundancy.; // To determine if some redundant code is actually introduced by; // replacements(e.g. deletions), we need to come up with a more; // sophisticated way of computing affected ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:150,redund,redundant,150,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,3,['redund'],"['redundancy', 'redundant']"
Safety,"// FIXME: instead of isUse(), readsReg() would be a better fix here,; // For example, we can ignore modifications in reg with undef. However,; // it's not perfectly clear if skipping the internal read is safe in all; // other targets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:204,safe,safe,204,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['safe'],['safe']
Safety,"// FIXME: let user specify whether to treat this case as an error or ignore; // it as is currently done. This behavior is problematic in that it hides; // failures from bad ranges. Also, the behavior here differs from; // `flatten`. Here, we abort (without error), whereas flatten, if it hits an; // empty list, does not abort. As a result, `editList({A,B})` is not; // equivalent to `flatten(edit(A), edit(B))`. The former will abort if `A`; // produces a bad range, whereas the latter will simply ignore A.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp:242,abort,abort,242,interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/RewriteRule.cpp,3,['abort'],['abort']
Safety,// FIXME: need better way to detect AsmStreamer (upstream removed getKind()),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:29,detect,detect,29,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,2,['detect'],['detect']
Safety,// FIXME: need better way to detect if AsmStreamer (upstream removed; // getKind()),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp:29,detect,detect,29,interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/AsmParser/HexagonAsmParser.cpp,1,['detect'],['detect']
Safety,// FIXME: recover and fill decls in `TypeLoc`s.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,3,['recover'],['recover']
Safety,// FIXME: recover in order to allow the body to be parsed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['recover'],['recover']
Safety,// FIXME: recovery if we don't see another semi!; /*MissingOK=*/,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:10,recover,recovery,10,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['recover'],['recovery']
Safety,"// FIXME: remove the type-dependent bit from subexpressions, if the; // RecoveryExpr has a non-dependent type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:72,Recover,RecoveryExpr,72,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['Recover'],['RecoveryExpr']
Safety,"// FIXME: should we rerun resolveTargetShuffleInputsAndMask() now?; // Widen any subvector shuffle inputs we've collected.; // TODO: Remove this to avoid generating temporary nodes, we should only; // widen once combineX86ShuffleChain has found a match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:148,avoid,avoid,148,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: simplify-demanded-bits in DAGCombine will probably have; // changed the AND node to a 32-bit mask operation. We'll have to; // undo that as part of the transform here if we want to catch all; // the opportunities.; // Currently the NumberOfIgnoredLowBits argument helps to recover; // from these situations when matching bigger pattern (bitfield insert).; // For unsigned extracts, check for a shift right and mask",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:283,recover,recover,283,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['recover'],['recover']
Safety,// FIXME: these are redundant if CmpInst < BinaryOperator,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:20,redund,redundant,20,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['redund'],['redundant']
Safety,// FIXME: this involves duplicating earlier analysis in a lot of; // cases; we should avoid this when possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:86,avoid,avoid,86,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['avoid'],['avoid']
Safety,// FIXME: this is redundant with part of setFunctionDefinitionAttributes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:18,redund,redundant,18,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['redund'],['redundant']
Safety,// FIXME: this seems inherently un-qualifiers-safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:46,safe,safe,46,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['safe'],['safe']
Safety,// FIXME: to avoid complications with type merging we should; // emit the constant on the definition instead of the declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:13,avoid,avoid,13,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: true for safety, false may still be correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:19,safe,safety,19,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safety']
Safety,// FIXME: update join to detect backedges and simplify the flow condition; // accordingly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:25,detect,detect,25,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,1,['detect'],['detect']
Safety,// FIXME: use fast math flags instead of Options.UnsafeFPMath,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,Unsafe,UnsafeFPMath,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Unsafe'],['UnsafeFPMath']
Safety,// FIXME: use lazy evaluation of VN to avoid the fix-point computation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: v1f64 shouldn't be legal if we can avoid it, because it leads to; // silliness like this:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// FIXME: we could avoid an allocation here sometimes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:19,avoid,avoid,19,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,1,['avoid'],['avoid']
Safety,"// FIXME: we should be able to use private labels for sections that can't be; // dead-stripped (there's no issue with blocking atomization there), but `ld; // -r` sometimes drops the no_dead_strip attribute from sections so for safety; // we don't allow it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:228,safe,safety,228,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['safe'],['safety']
Safety,"// FIXME: when writing dwo, we need to avoid relocations. Probably; // the ""right"" solution is to treat globals the way func and data; // symbols are (with entries in .debug_addr).; // For now we hardcode the indices in the callsites. Global indices are not; // fixed, but in practice a few are fixed; for example, __stack_pointer is; // always index 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,1,['avoid'],['avoid']
Safety,"// FP instructions can allow unsafe algebra, thus vectorizable by; // non-IEEE-754 compliant SIMD units.; // This applies to floating-point math operations and calls, not memory; // operations, shuffles, or casts, as they don't change precision or; // semantics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:29,unsafe,unsafe,29,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['unsafe'],['unsafe']
Safety,"// Fail on dynamic allocas. At this point, getRegForValue has already; // checked its CSE maps, so if we're here trying to handle a dynamic; // alloca, we're not going to succeed. X86SelectAddress has a; // check for dynamic allocas, because it's called directly from; // various places, but targetMaterializeAlloca also needs a check; // in order to avoid recursion between getRegForValue,; // X86SelectAddrss, and targetMaterializeAlloca.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:351,avoid,avoid,351,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['avoid'],['avoid']
Safety,"// Failed to parse a proper sequence, abort now",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:38,abort,abort,38,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['abort'],['abort']
Safety,"// Failiing to insert means there is already an entry in SymbolMap,; // thus there are multiple functions that are mapped to the same; // stripped name. In this case of name conflicting, set the value; // to nullptr to avoid confusion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:219,avoid,avoid,219,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['avoid'],['avoid']
Safety,"// Fall through to create a dependent typename type, from which we can recover; // better.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:71,recover,recover,71,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Safety,"// Fallback unscaled operands are for aliases of LDR/STR that fall back; // to LDUR/STUR when the offset is not legal for the former but is for; // the latter. As such, in addition to checking for being a legal unscaled; // address, also check that it is not a legal scaled address. This avoids; // ambiguity in the matcher.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:288,avoid,avoids,288,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['avoid'],['avoids']
Safety,// False dest is safe if !BranchCond => GuardCond.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:17,safe,safe,17,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['safe'],['safe']
Safety,"// Fast memory allocation and translation between node id and node address.; // This is really the same idea as the one underlying the ""bump pointer; // allocator"", the difference being in the translation. A node id is; // composed of two components: the index of the block in which it was; // allocated, and the index within the block. With the default settings,; // where the number of nodes per block is 4096, the node id (minus 1) is:; //; // bit position: 11 0; // +----------------------------+--------------+; // | Index of the block |Index in block|; // +----------------------------+--------------+; //; // The actual node id is the above plus 1, to avoid creating a node id of 0.; //; // This method significantly improved the build time, compared to using maps; // (std::unordered_map or DenseMap) to translate between pointers and ids.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:659,avoid,avoid,659,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,1,['avoid'],['avoid']
Safety,"// Fast path the common cases so we can avoid the conservative computation; // below, which in common cases allocates ""large"" APSInt values, which are; // slow.; // If the element size is a power of 2, we can directly compute the additional; // number of addressing bits beyond those required for the element count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:40,avoid,avoid,40,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['avoid'],['avoid']
Safety,"// Fast path: Compute a conservative bound on the maximum number of; // bits per digit in this radix. If we can't possibly overflow a; // uint64 based on that bound then do the simple conversion to; // integer. This avoids the expensive overflow checking below, and; // handles the common cases that matter (small decimal integers and; // hex/octal values which don't overflow).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:216,avoid,avoids,216,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['avoid'],['avoids']
Safety,// Fast unsafe fdiv lowering:; // f32 rcp; // f32 fmul,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:8,unsafe,unsafe,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['unsafe'],['unsafe']
Safety,"// Fast-isel and the optimizer generally like scalar values better than; // FCAs, so we flatten them if this is safe to do for this argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:112,safe,safe,112,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,3,['safe'],['safe']
Safety,// Fast-path some expressions to avoid the overhead of going through the AST's; // constant evaluator,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:33,avoid,avoid,33,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,1,['avoid'],['avoid']
Safety,// FastRegisterAllocator spills virtual registers at basic; // block boundary. That leads to usages of xmm registers; // outside of check for %al. Pass physical registers to; // VASTART_SAVE_XMM_REGS to avoid unneccessary spilling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:203,avoid,avoid,203,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['avoid'],['avoid']
Safety,"// Fetch all the blocks in DLs scope. Because the range / block list also; // contain any subscopes, any instruction that DL dominates can be found in; // the block set.; //; // Cache the set of fetched blocks to avoid repeatedly recomputing the set in; // the LiveDebugValues pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp:213,avoid,avoid,213,interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LexicalScopes.cpp,1,['avoid'],['avoid']
Safety,"// Figure out the largest discriminator issued for each Location. When we; // issue new discriminators, we can thus avoid issuing discriminators; // belonging to instructions that don't have memops. This isn't a requirement; // for the goals of this pass, however, it avoids unnecessary ambiguity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp:116,avoid,avoid,116,interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DiscriminateMemOps.cpp,2,['avoid'],"['avoid', 'avoids']"
Safety,"// Figure out the underlying type if this a enum declaration. We need to do; // this early, because it's needed to detect if this is an incompatible; // redeclaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:115,detect,detect,115,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['detect'],['detect']
Safety,"// Figure out the underlying type if this a enum declaration. We need to do; // this early, because it's needed to detect if this is an incompatible; // redeclaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:115,detect,detect,115,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['detect'],['detect']
Safety,"// Figure out which symbols need to be internalized. This also needs to happen; // at -O0 because summary-based DCE is implemented using internalization, and; // we must apply DCE consistently with the full LTO module in order to avoid; // undefined references during the final link.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:230,avoid,avoid,230,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['avoid'],['avoid']
Safety,"// File is std::nullopt if it wasn't found.; // (We have some false negatives if PP recovered e.g. <foo> -> ""foo"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:84,recover,recovered,84,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,1,['recover'],['recovered']
Safety,"// FileID redundant, but clearer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:10,redund,redundant,10,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['redund'],['redundant']
Safety,"// Final bailout: if the mask is simple, we are better off using an extract; // and a simple narrow shuffle. Prefer extract+unpack(h/l)ps to vpermps; // because that avoids a constant load from memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:166,avoid,avoids,166,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// FinalReg now holds final stack pointer value, or zero if; // allocation would overflow. Compare against the current stack; // limit from the thread environment block. Note this limit is the; // lowest touched page on the stack, not the point at which the OS; // will cause an overflow exception, so this is just an optimization; // to avoid unnecessarily touching pages that are below the current; // SP but already committed to the stack by the OS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:338,avoid,avoid,338,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// Finally, if this interior node was full and a node is percolated up, split; // ourself and return that up the chain. Start by saving all our info to; // avoid having the split clobber it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp:156,avoid,avoid,156,interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/DeltaTree.cpp,1,['avoid'],['avoid']
Safety,"// Finally, initialize the set of available and recoverable sanitizers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:48,recover,recoverable,48,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['recover'],['recoverable']
Safety,"// Finally, we also need to check if the killing store overwrites the; // beginning of the dead store.; //; // |--dead--|; // |-- killing --|; //; // In this case we may want to move the destination address and trim the size; // of dead store to avoid generating stores to addresses which will definitely; // be overwritten killing store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:246,avoid,avoid,246,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['avoid'],['avoid']
Safety,"// Find a register matching \p RC from \p LiveUnits which is unused and; // available throughout the function. On failure, returns AMDGPU::NoRegister.; // TODO: Rewrite the loop here to iterate over MCRegUnits instead of; // MCRegisters. This should reduce the number of iterations and avoid redundant; // checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:286,avoid,avoid,286,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// Find a safe location to insert the copy, this may be the first terminator; // in the block (or end()).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:10,safe,safe,10,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,1,['safe'],['safe']
Safety,"// Find a scratch register that we can use at the start of the prologue to; // re-align the stack pointer. We avoid using callee-save registers since they; // may appear to be free when this is called from canUseAsPrologue (during; // shrink wrapping), but then no longer be free when this is called from; // emitPrologue.; //; // FIXME: This is a bit conservative, since in the above case we could use one; // of the callee-save registers as a scratch temp to re-align the stack pointer,; // but we would then have to make sure that we were in fact saving at least one; // callee-save register in the prologue, which is additional complexity that; // doesn't seem worth the benefit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:110,avoid,avoid,110,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// Find a scratch register that we can use in the prologue. We avoid using; // callee-save registers since they may appear to be free when this is called; // from canUseAsPrologue (during shrink wrapping), but then no longer be free; // when this is called from emitPrologue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:63,avoid,avoid,63,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// Find a setcc that is used by a zext.; // This doesn't have to be the only use, the transformation is safe; // regardless.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp:104,safe,safe,104,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupSetCC.cpp,1,['safe'],['safe']
Safety,// Find all safe points.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,1,['safe'],['safe']
Safety,"// Find all static and dynamic alloca instructions that must be moved to the; // unsafe stack, all return instructions and stack restore points.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:81,unsafe,unsafe,81,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['unsafe'],['unsafe']
Safety,"// Find all the potential call graph edges in this function. We track both; // actual call edges and indirect references to functions. The direct calls; // are trivially added, but to accumulate the latter we walk the instructions; // and add every operand which is a constant to the worklist to process; // afterward.; //; // Note that we consider *any* function with a definition to be a viable; // edge. Even if the function's definition is subject to replacement by; // some other module (say, a weak definition) there may still be; // optimizations which essentially speculate based on the definition and; // a way to check that the specific definition is in fact the one being; // used. For example, this could be done by moving the weak definition to; // a strong (internal) definition and making the weak definition be an; // alias. Then a test of the address of the weak function against the new; // strong definition's address would be an effective way to determine the; // safety of optimizing a direct call edge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:984,safe,safety,984,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['safe'],['safety']
Safety,"// Find allocas that are safe to promote, by looking at all instructions in; // the entry node",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:25,safe,safe,25,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,1,['safe'],['safe']
Safety,// Find an operand that's safely divisible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:26,safe,safely,26,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['safe'],['safely']
Safety,// Find bitcasts in the outlined region that have lifetime marker users; // outside that region. Replace the lifetime marker use with an; // outside region bitcast to avoid unnecessary alloca/reload instructions; // and extra lifetime markers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:167,avoid,avoid,167,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['avoid'],['avoid']
Safety,"// Find first non-alloca instruction and create insertion point. This is; // safe if block is well-formed: it always have terminator, otherwise; // we'll get and assertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp:77,safe,safe,77,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,1,['safe'],['safe']
Safety,"// Find loads whose uses only use some of the loaded value's bits. Add an ""and""; // just after the load if the target can fold this into one extload instruction,; // with the hope of eliminating some of the other later ""and"" instructions using; // the loaded value. ""and""s that are made trivially redundant by the insertion; // of the new ""and"" are removed by this function, while others (e.g. those whose; // path from the load goes through a phi) are left for isel to potentially; // remove.; //; // For example:; //; // b0:; // x = load i32; // ...; // b1:; // y = and x, 0xff; // z = use y; //; // becomes:; //; // b0:; // x = load i32; // x' = and x, 0xff; // ...; // b1:; // z = use x'; //; // whereas:; //; // b0:; // x1 = load i32; // ...; // b1:; // x2 = load i32; // ...; // b2:; // x = phi x1, x2; // y = and x, 0xff; //; // becomes (after a call to optimizeLoadExt for each load):; //; // b0:; // x1 = load i32; // x1' = and x1, 0xff; // ...; // b1:; // x2 = load i32; // x2' = and x2, 0xff; // ...; // b2:; // x = phi x1', x2'; // y = and x, 0xff",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:297,redund,redundant,297,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['redund'],['redundant']
Safety,// Find maximal number of parallel region CIs that are safe to merge.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:55,safe,safe,55,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['safe'],['safe']
Safety,"// Find mergable parallel regions within a basic block that are; // safe to merge, that is any in-between instructions can safely; // execute in parallel after merging.; // TODO: support merging across basic-blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:68,safe,safe,68,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,2,['safe'],"['safe', 'safely']"
Safety,// Find missing lines.; // TODO: Avoid meta instructions other than dbg_val.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp:33,Avoid,Avoid,33,interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCheckDebugify.cpp,1,['Avoid'],['Avoid']
Safety,// Find most common element to initialize vector with. This is to avoid; // unnecessary vinsert/valign for cases where the same value is present; // many times. Creates a histogram of the vector's elements to find the; // most common element n.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:66,avoid,avoid,66,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,1,['avoid'],['avoid']
Safety,// Find the end of the existing list.; // FIXME: It would be possible to preserve information from erase_if to; // avoid this rescan looking for the end of the list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclContextInternals.h:115,avoid,avoid,115,interpreter/llvm-project/clang/include/clang/AST/DeclContextInternals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclContextInternals.h,1,['avoid'],['avoid']
Safety,// Find the first point where all unsafe registers are dead.; // FIND: <safe instr> <-- end of first potential range; // SKIP: <unsafe def>; // SKIP: ... everything between ...; // SKIP: <unsafe use>,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:34,unsafe,unsafe,34,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,4,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,// Find the range of the node stack by walking down until we pass the; // root DFS number. Update the DFS numbers and low link numbers in the; // process to avoid re-walking this list where possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:157,avoid,avoid,157,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['avoid'],['avoid']
Safety,// Find the spelling location for the macro definition. We must use the; // spelling location here to avoid emitting a macro backtrace for the note.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:102,avoid,avoid,102,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,1,['avoid'],['avoid']
Safety,// Finds all roots without relaying on the set of roots already stored in the; // tree.; // We define roots to be some non-redundant set of the CFG nodes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:123,redund,redundant,123,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['redund'],['redundant']
Safety,// Finds compare instruction that corresponds to supported types of branching.; // Returns the instruction or nullptr on failures or detecting unsupported; // instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionOptimizer.cpp:133,detect,detecting,133,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionOptimizer.cpp,1,['detect'],['detecting']
Safety,// Finish the reduction.; // Need to add extra arguments and not vectorized possible reduction; // values.; // Try to avoid dependencies between the scalar remainders after; // reductions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:118,avoid,avoid,118,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// First check if it's safe to move it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp:23,safe,safe,23,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,1,['safe'],['safe']
Safety,"// First check if we're extending the result of a load which has a dest type; // smaller than 32 bits, then this zext is redundant. GPR32 is the smallest; // GPR register on AArch64 and all loads which are smaller automatically; // zero-extend the upper bits. E.g.; // %v(s8) = G_LOAD %p, :: (load 1); // %v2(s32) = G_ZEXT %v(s8)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:121,redund,redundant,121,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['redund'],['redundant']
Safety,"// First collect all the metadata to delete in a vector, then; // delete them all at once to avoid invalidating the iterator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['avoid'],['avoid']
Safety,"// First command MUST be M|m, it's safe to skip.; // Protect from access to [-1] for sure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:35,safe,safe,35,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['safe'],['safe']
Safety,// First compute NewVNInfo and the simple value mappings.; // Detect impossible conflicts early.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:62,Detect,Detect,62,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['Detect'],['Detect']
Safety,// First detect the path style in use by checking the first separator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:9,detect,detect,9,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['detect'],['detect']
Safety,"// First slide in the lo value, then the hi in above it. We use slide1down; // to avoid the register group overlap constraint of vslide1up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:82,avoid,avoid,82,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// First time we loop over proxies: cache the results to avoid future; // costly dynamic_casts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:57,avoid,avoid,57,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['avoid'],['avoid']
Safety,"// First try to find defining accvgpr_write to avoid temporary registers.; // In the case of copies of overlapping AGPRs, we conservatively do not; // reuse previous accvgpr_writes. Otherwise, we may incorrectly pick up; // an accvgpr_write used for this same copy due to implicit-defs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// First we need to recover the collection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:20,recover,recover,20,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['recover'],['recover']
Safety,"// First, as a sanity check, let's see if the parameter; // itself actually exists and if the model depends on it:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx:15,sanity check,sanity check,15,roofit/histfactory/src/HistFactoryNavigation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistFactoryNavigation.cxx,1,['sanity check'],['sanity check']
Safety,"// First, attempt to evaluate each operand.; // Avoid performing the look-up in the common case where the specified; // expression has no loop-variant portions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:48,Avoid,Avoid,48,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Avoid'],['Avoid']
Safety,"// First, check the function scope. We take the known information and we avoid; // work if the assumed information implies the current assumed information for; // this attribute. This is a valid for all but byval arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:73,avoid,avoid,73,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['avoid'],['avoid']
Safety,"// First, go through each memory operation and assign them to consecutive; // partitions (the order of partitions follows program order). Put those; // with unsafe dependences into ""cyclic"" partition otherwise put each store; // in its own ""non-cyclic"" partition (we'll merge these later).; //; // Note that a memory operation (e.g. Load2 below) at a program point that; // has an unsafe dependence (Store3->Load1) spanning over it must be; // included in the same cyclic partition as the dependent operations. This; // is to preserve the original program order after distribution. E.g.:; //; // NumUnsafeDependencesStartOrEnd NumUnsafeDependencesActive; // Load1 -. 1 0->1; // Load2 | /Unsafe/ 0 1; // Store3 -' -1 1->0; // Load4 0 0; //; // NumUnsafeDependencesActive > 0 indicates this situation and in this case; // we just keep assigning to the same cyclic partition until; // NumUnsafeDependencesActive reaches 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:157,unsafe,unsafe,157,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,3,"['Unsafe', 'unsafe']","['Unsafe', 'unsafe']"
Safety,"// First, if the main function is in the Safe module, we must add a stub to; // the Test module to call into it. Thus, we create a new function `main'; // which just calls the old one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:41,Safe,Safe,41,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['Safe'],['Safe']
Safety,"// First, if there are any DBG_VALUEs pointing at a spill slot that is; // written to, terminate that variable location. The value in memory; // will have changed. DbgEntityHistoryCalculator doesn't try to detect this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:206,detect,detect,206,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['detect'],['detect']
Safety,"// First, lex to the current token (which is the last token of the range that; // is definitely associated with the decl). Then, we process the first token; // separately from the rest based on conditions that hold specifically for; // that first token.; //; // We do not search for a terminator if none is required or we've already; // encountered it. Otherwise, if the original `EntityLast` location was in a; // macro expansion, we don't have visibility into the text, so we assume we've; // already terminated. However, we note this assumption with; // `TerminatedByMacro`, because we'll want to handle it somewhat differently; // for the terminators semicolon and comma. These terminators can be safely; // associated with the entity when they appear after the macro -- extra; // semicolons have no effect on the program and a well-formed program won't; // have multiple commas in a row, so we're guaranteed that there is only one.; //; // FIXME: This handling of macros is more conservative than necessary. When; // the end of the expansion coincides with the end of the node, we can still; // safely analyze the code. But, it is more complicated, because we need to; // start by lexing the spelling loc for the first token and then switch to the; // expansion loc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp:701,safe,safely,701,interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Transformer/SourceCode.cpp,2,['safe'],['safely']
Safety,"// First, we only consider nodes for reclamation of the following; // conditions apply:; //; // (1) 1 predecessor (that has one successor); // (2) 1 successor (that has one predecessor); //; // If a node has no successor it is on the ""frontier"", while a node; // with no predecessor is a root.; //; // After these prerequisites, we discard all ""filler"" nodes that; // are used only for intermediate processing, and are not essential; // for analyzer history:; //; // (a) PreStmtPurgeDeadSymbols; //; // We then discard all other nodes where *all* of the following conditions; // apply:; //; // (3) The ProgramPoint is for a PostStmt, but not a PostStore.; // (4) There is no 'tag' for the ProgramPoint.; // (5) The 'store' is the same as the predecessor.; // (6) The 'GDM' is the same as the predecessor.; // (7) The LocationContext is the same as the predecessor.; // (8) Expressions that are *not* lvalue expressions.; // (9) The PostStmt isn't for a non-consumed Stmt or Expr.; // (10) The successor is neither a CallExpr StmtPoint nor a CallEnter or; // PreImplicitCall (so that we would be able to find it when retrying a; // call with no inlining).; // FIXME: It may be safe to reclaim PreCall and PostCall nodes as well.; // Conditions 1 and 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp:1176,safe,safe,1176,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExplodedGraph.cpp,1,['safe'],['safe']
Safety,"// First, we split the edge to insert the checking block into a safe; // location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:64,safe,safe,64,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['safe'],['safe']
Safety,"// Fix call target; // Our index in the function is our place in the array + 1 to avoid index; // 0, because index 0 means the longjmp is not ours to handle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:82,avoid,avoid,82,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['avoid'],['avoid']
Safety,"// Fix up the instructions in the range, since we're going to modify the; // stack.; // Bugzilla ID: 46767; // TODO: Check if fixing up twice is safe so we can outline these.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:145,safe,safe,145,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['safe'],['safe']
Safety,"// Fixed-point types are tricky. In some cases, it isn't possible to; // represent a 1 or a -1 in the type at all. Piggyback off of; // EmitFixedPointBinOp to avoid having to reimplement saturation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:159,avoid,avoid,159,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['avoid'],['avoid']
Safety,// Fixup all the inputs of the new PHIs. Visit order needs to be; // deterministic and predictable because we're naming newly created; // instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:87,predict,predictable,87,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['predict'],['predictable']
Safety,"// Flag timeout condition",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:8,timeout,timeout,8,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['timeout'],['timeout']
Safety,"// Flags are intersected from the 2 source binops. But there are 2 exceptions:; // 1. If we changed an opcode, poison conditions might have changed.; // 2. If the shuffle had undef mask elements, the new binop might have undefs; // where the original code did not. But if we already made a safe constant,; // then there's no danger.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:290,safe,safe,290,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['safe'],['safe']
Safety,"// Flang always runs the preprocessor and has no notion of ""preprocessed; // fortran"". Here, TY_PP_Fortran is coerced to TY_Fortran to avoid treating; // them differently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp:135,avoid,avoid,135,interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChain.cpp,1,['avoid'],['avoid']
Safety,// Float comparison can be safely commuted for; // Ordered/Unordered/Equal/NotEqual tests,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:27,safe,safely,27,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safely']
Safety,"// Flush now or can drop the buffer when dup2 is called with Fd later.; // This seems only neccessary when piping stdout or stderr, but do it; // for ttys to avoid over complicated code for minimal benefit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp:158,avoid,avoid,158,interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/MetaProcessor/MetaProcessor.cpp,1,['avoid'],['avoid']
Safety,// Flush outs() when printing to errs(). This avoids interleaving output; // between the two.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp:46,avoid,avoids,46,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/llvm-dwarfdump.cpp,1,['avoid'],['avoids']
Safety,// Fold (zero_extend (fp_to_uint X)) to prevent forming fcvt+zexti32 during; // type legalization. This is safe because fp_to_uint produces poison if; // it overflows.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,safe,safe,107,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['safe'],['safe']
Safety,"// Fold AND(SRL(X,Y),1) -> SETCC(BT(X,Y), COND_B) iff Y is not a constant; // avoids slow variable shift (moving shift amount to ECX etc.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:78,avoid,avoids,78,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// Fold compare eq/ne with 0 from a compare result as the predicate to the; // intrinsic. The typical use is a wave vote function in the library, which; // will be fed from a user code condition compared with 0. Fold in the; // redundant compare.; // llvm.amdgcn.icmp([sz]ext ([if]cmp pred a, b), 0, ne); // -> llvm.amdgcn.[if]cmp(a, b, pred); //; // llvm.amdgcn.icmp([sz]ext ([if]cmp pred a, b), 0, eq); // -> llvm.amdgcn.[if]cmp(a, b, inv pred)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:228,redund,redundant,228,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['redund'],['redundant']
Safety,"// Fold loads into extends when possible.; // FIXME: We can have multiple redundant extend/trunc instructions; // following a load. The folding only picks up one. Extend this; // to check subsequent instructions for the same pattern and remove; // them. Thus ResultReg should be the def reg for the last redundant; // instruction in a chain, and all intervening instructions can be; // removed from parent. Change test/CodeGen/PowerPC/fast-isel-fold.ll; // to add ELF64-NOT: rldicl to the appropriate tests when this works.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:74,redund,redundant,74,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,2,['redund'],['redundant']
Safety,// Fold sign-extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT for MSA and fold; // constant splats into MipsISD::SHRA_DSP for DSPr2.; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to sign extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::SRA and ISD::SHL nodes.; // - Removes redundant sign extensions performed by an ISD::SRA and ISD::SHL; // sequence.; //; // See performDSPShiftCombine for more information about the transformation; // used for DSPr2.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:376,redund,redundant,376,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['redund'],['redundant']
Safety,// Fold zero extensions into MipsISD::VEXTRACT_[SZ]EXT_ELT; //; // Performs the following transformations:; // - Changes MipsISD::VEXTRACT_[SZ]EXT_ELT to zero extension if its; // sign/zero-extension is completely overwritten by the new one performed by; // the ISD::AND.; // - Removes redundant zero extensions performed by an ISD::AND.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:286,redund,redundant,286,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['redund'],['redundant']
Safety,// Folding select to and/or i1 isn't poison safe in general. impliesPoison; // checks whether folding it does not convert a well-defined value into; // poison.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:44,safe,safe,44,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['safe'],['safe']
Safety,"// Follow the chain of copies until we find a more suitable source, a phi; // or have to abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:89,abort,abort,89,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['abort'],['abort']
Safety,"// Follow the convention of emitting flags as a boolean value, but only; // emit if true to avoid unnecessary verbosity and test churn.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp:92,avoid,avoid,92,interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AsmWriter.cpp,1,['avoid'],['avoid']
Safety,"// For 'nodebug' functions, the associated DISubprogram is always null.; // Conservatively avoid propagating the callsite debug location to; // instructions inlined from a function whose DISubprogram is not null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:91,avoid,avoid,91,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['avoid'],['avoid']
Safety,"// For *signed* multiply, overflow is detected by checking:; // (hi != (lo >> bitwidth-1))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:38,detect,detected,38,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['detect'],['detected']
Safety,"// For 32-bit MSVC targets, raise the alignment of f80 values to 16 bytes.; // Raising the alignment is safe because Clang did not produce f80 values in; // the MSVC environment before this upgrade was added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:104,safe,safe,104,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['safe'],['safe']
Safety,"// For 32-bit values, we need to add an FP_ROUND node (if we made it; // here, we know that all inputs are extending loads so this is safe).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:134,safe,safe,134,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['safe'],['safe']
Safety,"// For @synchronized, call objc_sync_enter(sync.expr). The; // evaluation of the expression must occur before we enter the; // @synchronized. We can't avoid a temp here because we need the; // value to be preserved. If the backend ever does liveness; // correctly after setjmp, this will be unnecessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:151,avoid,avoid,151,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['avoid'],['avoid']
Safety,"// For AVX1 only, if we are extracting from a 256-bit and+not (which will; // eventually get combined/lowered into ANDNP) with a concatenated operand,; // split the 'and' into 128-bit ops to avoid the concatenate and extract.; // We let generic combining take over from there to simplify the; // insert/extract and 'not'.; // This pattern emerges during AVX1 legalization. We handle it before lowering; // to avoid complications like splitting constant vector loads.; // Capture the original wide type in the likely case that we need to bitcast; // back to this type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:191,avoid,avoid,191,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// For Falkor, we want to avoid having too many strided loads in a loop since; // that can exhaust the HW prefetcher resources. We adjust the unroller; // MaxCount preference below to attempt to ensure unrolling doesn't create too; // many strided loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:26,avoid,avoid,26,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['avoid'],['avoid']
Safety,"// For IEEE=false perform combine only when it's safe to assume that there are; // no NaN inputs. Most often MI is marked with nnan fast math flag.; // For IEEE=true consider NaN inputs. Only min(max(QNaN, 0.0), 1.0) evaluates; // to 0.0 requires dx10_clamp = true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp:49,safe,safe,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp,1,['safe'],['safe']
Safety,// For IEEE=false perform combine only when it's safe to assume that there are; // no NaN inputs. Most often MI is marked with nnan fast math flag.; // For IEEE=true consider NaN inputs. Requires dx10_clamp = true. Safe to fold; // when Val could be QNaN. If Val can also be SNaN third input should be 0.0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp:49,safe,safe,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp,2,"['Safe', 'safe']","['Safe', 'safe']"
Safety,"// For IEEE=false perform combine only when it's safe to assume that there are; // no NaN inputs. Most often MI is marked with nnan fast math flag.; // For IEEE=true consider NaN inputs. fmed3(NaN, K0, K1) is equivalent to; // min(min(NaN, K0), K1). Safe to fold for min(max(Val, K0), K1) since inner; // nodes(max/min) have same behavior when one input is NaN and other isn't.; // Don't consider max(min(SNaN, K1), K0) since there is no isKnownNeverQNaN,; // also post-legalizer inputs to min/max are fcanonicalized (never SNaN).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp:49,safe,safe,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegBankCombiner.cpp,2,"['Safe', 'safe']","['Safe', 'safe']"
Safety,"// For JITLink, we only need a custom memory manager to avoid freeing the; // memory segments; the default InProcessMemoryManager (which is mostly; // copied above) already does slab allocation to keep all segments; // together which is needed for exception handling support.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp:56,avoid,avoid,56,interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp,1,['avoid'],['avoid']
Safety,"// For LEA64_32r when BasePtr is 32-bits (X32) we can use full-size 64-bit; // register as source operand, semantic is the same and destination is; // 32-bits. It saves one byte per lea in code since 0x67 prefix is avoided.; // Don't change BasePtr since it is used later for stack adjustment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp:215,avoid,avoided,215,interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86RegisterInfo.cpp,1,['avoid'],['avoided']
Safety,// For MUBUF/MTBUF instructions this hazard only exists if the; // instruction is not using a register in the soffset field.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:37,hazard,hazard,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// For MachO, lower @llvm.global_dtors into @llvm.global_ctors with; // __cxa_atexit() calls to avoid emitting the deprecated __mod_term_func.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp:96,avoid,avoid,96,interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetPassConfig.cpp,1,['avoid'],['avoid']
Safety,"// For Mask3 with NegAcc, we need to create a new extractelement that; // avoids the negation above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:74,avoid,avoids,74,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['avoid'],['avoids']
Safety,"// For Medium and above, assume that the symbol is not within the 4GB range.; // Taking the address of locally-defined text would be OK, but that; // case isn't easy to detect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp:169,detect,detect,169,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZSubtarget.cpp,1,['detect'],['detect']
Safety,"// For O32 ABI, the following instruction sequence is emitted to initialize; // the global base register:; //; // 0. lui $2, %hi(_gp_disp); // 1. addiu $2, $2, %lo(_gp_disp); // 2. addu $globalbasereg, $2, $t9; //; // We emit only the last instruction here.; //; // GNU linker requires that the first two instructions appear at the beginning; // of a function and no instructions be inserted before or between them.; // The two instructions are emitted during lowering to MC layer in order to; // avoid any reordering.; //; // Register $2 (Mips::V0) is added to the list of live-in registers to ensure; // the value instruction 1 (addiu) defines is valid when instruction 2 (addu); // reads it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp:497,avoid,avoid,497,interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsMachineFunction.cpp,1,['avoid'],['avoid']
Safety,"// For OpenMP we work around some old system headers that have non-conforming; // `isinf(float)` and `isnan(float)` implementations that return an `int`. We do; // this by providing two versions of these functions, differing only in the; // return type. To avoid conflicting definitions we disable implicit base; // function generation. That means we will end up with two specializations, one; // per type, but only one has a base function defined by the system header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h:257,avoid,avoid,257,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_cmath.h,2,['avoid'],['avoid']
Safety,"// For PTEST(PG, PG), PTEST is redundant when PG is the result of an; // instruction that sets the flags as PTEST would. This is only valid when; // the condition is any.; // Fallthough to simply remove the PTEST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:31,redund,redundant,31,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['redund'],['redundant']
Safety,"// For PTEST(PG, PTEST_LIKE(PG, ...)), the PTEST is redundant since the; // flags are set based on the same mask 'PG', but PTEST_LIKE must operate; // on 8-bit predicates like the PTEST. Otherwise, for instructions like; // compare that also support 16/32/64-bit predicates, the implicit PTEST; // performed by the compare could consider fewer lanes for these element; // sizes.; //; // For example, consider; //; // ptrue p0.b ; P0=1111-1111-1111-1111; // index z0.s, #0, #1 ; Z0=<0,1,2,3>; // index z1.s, #1, #1 ; Z1=<1,2,3,4>; // cmphi p1.s, p0/z, z1.s, z0.s ; P1=0001-0001-0001-0001; // ; ^ last active; // ptest p0, p1.b ; P1=0001-0001-0001-0001; // ; ^ last active; //; // where the compare generates a canonical all active 32-bit predicate; // (equivalent to 'ptrue p1.s, all'). The implicit PTEST sets the last; // active flag, whereas the PTEST instruction with the same mask doesn't.; // For PTEST_ANY this doesn't apply as the flags in this case would be; // identical regardless of element size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:52,redund,redundant,52,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['redund'],['redundant']
Safety,"// For PTEST(PTRUE_ALL, WHILE), if the element size matches, the PTEST is; // redundant since WHILE performs an implicit PTEST with an all active; // mask. Must be an all active predicate of matching element size.; // For PTEST(PTRUE_ALL, PTEST_LIKE), the PTEST is redundant if the; // PTEST_LIKE instruction uses the same all active mask and the element; // size matches. If the PTEST has a condition of any then it is always; // redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:78,redund,redundant,78,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,3,['redund'],['redundant']
Safety,"// For VNI aggregation of each ParentVNI, collect dominated, i.e.,; // redundant VNIs to BackCopies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:71,redund,redundant,71,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['redund'],['redundant']
Safety,"// For Vector we take an extra short cut to avoid derefencing; // the iterator all the time and redefine the 'address' of the; // iterator as the iterator itself. This requires special handling; // in the looper (see TStreamerInfoAction) but is much faster.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollectionProxyInfo.h:44,avoid,avoid,44,core/cont/inc/TCollectionProxyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollectionProxyInfo.h,1,['avoid'],['avoid']
Safety,"// For Windows paths, only use the real path if it doesn't resolve; // a substitute drive, as those are used to avoid MAX_PATH issues.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:112,avoid,avoid,112,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['avoid'],['avoid']
Safety,"// For a block which requires predication, a address may be safe to access; // in the loop w/o predication if we can prove dereferenceability facts; // sufficient to ensure it'll never fault within the loop. For the moment,; // we restrict this to loads; stores are more complicated due to; // concurrency restrictions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:60,safe,safe,60,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['safe'],['safe']
Safety,"// For a normal instruction, we just move one to right before the; // branch, then replace all uses of the other with the first. Finally,; // we remove the now redundant second instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,redund,redundant,160,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['redund'],['redundant']
Safety,"// For a select that can be converted to branch,; // compute its cost as a branch (non-predicated cost).; //; // BranchCost = PredictedPathCost + MispredictCost; // PredictedPathCost = TrueOpCost * TrueProb + FalseOpCost * FalseProb; // MispredictCost = max(MispredictPenalty, CondCost) * MispredictRate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:126,Predict,PredictedPathCost,126,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,2,['Predict'],['PredictedPathCost']
Safety,"// For all vectors, but vXi8 we can just emit a sign_extend and a shift. This; // avoids a constant pool load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:82,avoid,avoids,82,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// For an SSE1-only target, lower a comparison of v4f32 to X86ISD::CMPP early; // to avoid scalarization via legalization because v4i32 is not a legal type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:85,avoid,avoid,85,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// For any type id used on a global's type metadata, create the type id; // summary resolution regardless of whether we can devirtualize, so that; // lower type tests knows the type id is not Unsat. If it was not used on; // a global's type metadata, the TypeIdMap entry set will be empty, and; // we don't want to create an entry (with the default Unknown type; // resolution), which can prevent detection of the Unsat.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:397,detect,detection,397,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['detect'],['detection']
Safety,"// For async functions / continuations, adjust the scope line of the; // clone to the line number of the suspend point. However, only; // adjust the scope line when the files are the same. This ensures; // line number and file name belong together. The scope line is; // associated with all pre-prologue instructions. This avoids a jump; // in the linetable from the function declaration to the suspend point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:323,avoid,avoids,323,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,1,['avoid'],['avoids']
Safety,"// For automatic generation of LDG (through SelectLoad[Vector], not the; // intrinsics), we may have an extending load like:; //; // i32,ch = load<LD1[%data1(addrspace=1)], zext from i8> t0, t7, undef:i64; //; // In this case, the matching logic above will select a load for the original; // memory type (in this case, i8) and our types will not match (the node needs; // to return an i32 in this case). Our LDG/LDU nodes do not support the; // concept of sign-/zero-extension, so emulate it here by adding an explicit; // CVT instruction. Ptxas should clean up any redundancies here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:566,redund,redundancies,566,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['redund'],['redundancies']
Safety,"// For better error recovery, eat all pushes inside the namespace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:20,recover,recovery,20,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,1,['recover'],['recovery']
Safety,// For better error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:20,recover,recovery,20,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recovery']
Safety,"// For bug reports that should be suppressed when all paths are post-dominated; // by a sink node, iterate through the reports in the equivalence class; // until we find one that isn't post-dominated (if one exists). We use a; // DFS traversal of the ExplodedGraph to find a non-sink node. We could write; // this as a recursive function, but we don't want to risk blowing out the; // stack for very long paths.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:360,risk,risk,360,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['risk'],['risk']
Safety,// For call safepoints insert dummy calls right after safepoint,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:12,safe,safepoints,12,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,2,['safe'],"['safepoint', 'safepoints']"
Safety,"// For calls that temporarily have to toggle streaming mode as part of the; // call-sequence, we need to be more careful when coalescing copy instructions; // so that we don't end up coalescing the NEON/FP result or argument register; // with a whole Z-register, such that after coalescing the register allocator; // will try to spill/reload the entire Z register.; //; // We do this by checking if the node has any defs/uses that are; // COALESCER_BARRIER pseudos. These are 'nops' in practice, but they exist to; // instruct the coalescer to avoid coalescing the copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp:544,avoid,avoid,544,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RegisterInfo.cpp,1,['avoid'],['avoid']
Safety,"// For cases such as (i4 bitcast (v4i1 setcc v4i64 v1, v2)); // sign-extend to a 256-bit operation to avoid truncation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:102,avoid,avoid,102,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// For cleanliness, we try to avoid emitting the return block for; // simple cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:30,avoid,avoid,30,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['avoid'],['avoid']
Safety,"// For comdat functions, an alias would need the same linkage as the original; // function and hidden visibility. There is no point in adding an alias with; // identical linkage an visibility to avoid introducing symbolic relocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:195,avoid,avoid,195,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['avoid'],['avoid']
Safety,// For cycle detection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:13,detect,detection,13,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,1,['detect'],['detection']
Safety,"// For delegate init calls in ARC, do an unsafe store of null into; // self. This represents the call taking direct ownership of that; // value. We have to do this after emitting the other call; // arguments because they might also reference self, but we don't; // have to worry about any of them modifying self because that would; // be an undefined read and write of an object in unordered; // expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:41,unsafe,unsafe,41,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['unsafe'],['unsafe']
Safety,"// For each of these checks we need to be careful if the sign flag is; // being used. It is only safe to use the sign flag in two conditions,; // either the sign bit in the shrunken mask is zero or the final test; // size is equal to the original compare size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:97,safe,safe,97,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,"// For each variant of a Read/Write in Trans, substitute the sequence of; // Read/Writes guarded by the variant. This is exponential in the number of; // variant Read/Writes, but in practice detection of mutually exclusive; // predicates should result in linear growth in the total number variants.; //; // This is one step in a breadth-first search of nested variants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp:191,detect,detection,191,interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.cpp,1,['detect'],['detection']
Safety,"// For edge predicates, we can just place the operand in the block before; // the terminator. For assume, we have to place it right before the assume; // to ensure we dominate all of our uses. Always insert right before the; // relevant instruction (terminator, assume), so that we insert in proper; // order in the case of multiple predicateinfo in the same block.; // The number of named values is used to detect if a new declaration was; // added. If so, that declaration is tracked so that it can be removed when; // the analysis is done. The corner case were a new declaration results in; // a name clash and the old name being renamed is not considered as that; // represents an invalid module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:408,detect,detect,408,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,1,['detect'],['detect']
Safety,"// For ehpad, we layout the least probable first as to avoid jumping back; // from least probable landingpads to more probable ones.; //; // FIXME: Using probability is probably (!) not the best way to achieve; // this. We should probably have a more principled approach to layout; // cleanup code.; //; // The goal is to get:; //; // +--------------------------+; // | V; // InnerLp -> InnerCleanup OuterLp -> OuterCleanup -> Resume; //; // Rather than:; //; // +-------------------------------------+; // V |; // OuterLp -> OuterCleanup -> Resume InnerLp -> InnerCleanup",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:55,avoid,avoid,55,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['avoid'],['avoid']
Safety,"// For entry functions we have to set up the stack pointer if we use it,; // whereas non-entry functions get this ""for free"". This means there is no; // intrinsic advantage to using S32 over S34 in cases where we do not have; // calls but do need a frame pointer (i.e. if we are requested to have one; // because frame pointer elimination is disabled). To keep things simple we; // only ever use S32 as the call ABI stack pointer, and so using it does not; // imply we need a separate frame pointer.; //; // Try to use s32 as the SP, but move it if it would interfere with input; // arguments. This won't work with calls though.; //; // FIXME: Move SP to avoid any possible inputs, or find a way to spill input; // registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:655,avoid,avoid,655,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// For equality, we can safely zext both parts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,safe,safely,24,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['safe'],['safely']
Safety,"// For every node on the dominator tree with spill, walk up on the dominator; // tree towards the Root node until it is reached. If there is other node; // containing spill in the middle of the path, the previous spill saw will; // be redundant and the node containing it will be removed. All the nodes on; // the path starting from the first node with non-redundant spill to the Root; // node will be added to the WorkSet, which will contain all the possible; // locations where spills may be hoisted to after the loop below is done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:235,redund,redundant,235,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,2,['redund'],['redundant']
Safety,"// For everything elese, we can just compute it, safe in the; // assumption that Sema won't let anything through that we can't; // safely compute the size of.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:49,safe,safe,49,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,2,['safe'],"['safe', 'safely']"
Safety,"// For extra ""safety"", allocate the buffers on the heap to avoid corrupting the stack should anything go wrong.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/test/ZipTest.cxx:14,safe,safety,14,core/zip/test/ZipTest.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/test/ZipTest.cxx,2,"['avoid', 'safe']","['avoid', 'safety']"
Safety,"// For fixed vectors, avoid scalarization if using SVE for them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h:22,avoid,avoid,22,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.h,1,['avoid'],['avoid']
Safety,"// For fully redundant case, we select two basic blocks MBB1 and MBB2; // as an optimization target if; // - both MBBs end with a conditional branch,; // - MBB1 is the only predecessor of MBB2, and; // - compare does not take a physical register as a operand in both MBBs.; // In this case, eligibleForCompareElimination sets MBBtoMoveCmp nullptr.; //; // As partially redundant case, we additionally handle if MBB2 has one; // additional predecessor, which has only one successor (MBB2).; // In this case, we move the compare instruction originally in MBB2 into; // MBBtoMoveCmp. This partially redundant case is typically appear by; // compiling a while loop; here, MBBtoMoveCmp is the loop preheader.; //; // Overview of CFG of related basic blocks; // Fully redundant case Partially redundant case; // -------- ---------------- --------; // | MBB1 | (w/ 2 succ) | MBBtoMoveCmp | | MBB1 | (w/ 2 succ); // -------- ---------------- --------; // | \ (w/ 1 succ) \ | \; // | \ \ | \; // | \ |; // -------- --------; // | MBB2 | (w/ 1 pred | MBB2 | (w/ 2 pred; // -------- and 2 succ) -------- and 2 succ); // | \ | \; // | \ | \; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:13,redund,redundant,13,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,5,['redund'],['redundant']
Safety,"// For hoisting, use the walker to determine safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:45,safe,safety,45,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safety']
Safety,"// For iOS 6, undo the translation to add -static for -mkernel/-fapple-kext.; // FIXME: It would be far better to avoid inserting those -static arguments,; // but we can't check the deployment target in the translation code until; // it is set here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:114,avoid,avoid,114,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['avoid'],['avoid']
Safety,"// For incorrect code, there might not be an ObjCInterfaceDecl. Do; // a null check to avoid a crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:87,avoid,avoid,87,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['avoid'],['avoid']
Safety,"// For inlined code, recover the original callsite and callee by finding the; // top-level inline frame. e.g. For frame stack ""main:1 @ foo:2 @ bar:3"", the; // top-level frame is ""main:1"", the callsite is ""1"" and the callee is ""foo"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:21,recover,recover,21,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['recover'],['recover']
Safety,"// For integer IVs, if we evaluated the limit in the narrower bitwidth to; // avoid the expensive expansion of the limit expression in the wider type,; // emit a truncate to narrow the IV to the ExitCount type. This is safe; // since we know (from the exit count bitwidth), that we can't self-wrap in; // the narrower type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:78,avoid,avoid,78,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,// For invoke safepooints insert dummy calls both in normal and; // exceptional destination blocks,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:14,safe,safepooints,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safepooints']
Safety,"// For local TFiles, TDavixFile, and TNetXNGFile, we want to open a new RRawFile to take advantage of the faster; // reading. We check the exact class name to avoid classes inheriting in ROOT (for example TMemFile) or in; // experiment frameworks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx:159,avoid,avoid,159,tree/ntuple/v7/src/RPageStorageFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageStorageFile.cxx,1,['avoid'],['avoid']
Safety,"// For method pool in the module, if it contains an entry for a selector,; // the entry should be complete, containing everything introduced by that; // module and all modules it imports. It's possible that the entry is out of; // date, so we need to pull in the new content here.; // It's possible that updateOutOfDateSelector can update SelectorIDs. To be; // safe, we copy all selectors out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:362,safe,safe,362,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['safe'],['safe']
Safety,"// For microMIPS if instruction is BEQ or BNE with one ZERO register, then; // instead of adding NOP replace this instruction with the corresponding; // compact branch instruction, i.e. BEQZC or BNEZC. Additionally; // PseudoReturn and PseudoIndirectBranch are expanded to JR_MM, so they can; // be replaced with JRC16_MM.; // For MIPSR6 attempt to produce the corresponding compact (no delay slot); // form of the CTI. For indirect jumps this will not require inserting a; // NOP and for branches will hopefully avoid requiring a NOP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp:513,avoid,avoid,513,interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp,1,['avoid'],['avoid']
Safety,"// For multiplication, the infinitely precise result has at most; // LHSWidth + RHSWidth significant bits; if OpWidth is sufficient; // that such a value can be exactly represented, then no double; // rounding can possibly occur; we can safely perform the operation; // in the destination format if it can represent both sources.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:237,safe,safely,237,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['safe'],['safely']
Safety,// For non-ConstantExpr we use getAggregateElement as a fast path to avoid; // calling getSplatValue in release builds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:69,avoid,avoid,69,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp,1,['avoid'],['avoid']
Safety,// For now avoid converting mutually-exclusive cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:11,avoid,avoid,11,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// For now the following line would lead to the (unwanted) instantiation; // of class template. This could/would need to be resurrected only if; // we re-introduce so sort of automatic instantiation. However this would; // have to include carefull look at the template parameter to avoid; // creating instance we can not really use (if the parameter are only forward; // declaration or do not have all the necessary interfaces).; // TClingClassInfo tci(fInterpreter, classname);; // if (1 || !tci.IsValid()) {",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:282,avoid,avoid,282,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avoid'],['avoid']
Safety,"// For now, no need to lock this routines as fRuntimeProperties is; // the only atomic set here and this is done at the end; // and there is no downside if the execution is done twice.; // Note SetRuntimeProperties is set to const as it is technically; // thread-safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:263,safe,safe,263,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['safe'],['safe']
Safety,"// For object files containing precompiled types, we need to extract the; // signature, through EndPrecompRecord. This is done here for performance; // reasons, to avoid re-parsing the Types stream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp:164,avoid,avoid,164,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/TypeStreamMerger.cpp,1,['avoid'],['avoid']
Safety,"// For outline two full draws (fill + wireframe) required.; // Do it this way to avoid costly GL state swaps on per drawable basis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx:81,avoid,avoid,81,graf3d/gl/src/TGLScene.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx,1,['avoid'],['avoid']
Safety,"// For preprocessor indent with tabs, State.Column will be 1 because of the; // hash. This causes second-level indents onward to have an extra space; // after the tabs. We avoid this misalignment by subtracting 1 from the; // column value passed to replaceWhitespace().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:172,avoid,avoid,172,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['avoid'],['avoid']
Safety,"// For recovery purposes, go ahead and implement the hiding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:7,recover,recovery,7,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['recover'],['recovery']
Safety,"// For regular files (as is the case for deepWriteArchive),; // FileOutputBuffer::create will return OnDiskBuffer.; // OnDiskBuffer uses a temporary file and then renames it. So in reality; // there is no inefficiency / duplicated in-memory buffers in this case. For; // now in-memory buffers can not be completely avoided since; // NewArchiveMember still requires them even though writeArchive does not; // write them on disk.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/Archive.cpp:315,avoid,avoided,315,interpreter/llvm-project/llvm/lib/ObjCopy/Archive.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/Archive.cpp,1,['avoid'],['avoided']
Safety,"// For safe erasing, replace the uses with dummy value first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:7,safe,safe,7,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['safe'],['safe']
Safety,"// For safety's sake, just ignore it if we don't have type source; // information. This should never happen for non-implicit methods,; // but...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:7,safe,safety,7,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['safe'],['safety']
Safety,"// For safety, ensure that the alignment of a pointer is enough for an; // MCSymbol. This also ensures we don't need padding between the name and; // symbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp:7,safe,safety,7,interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCSymbol.cpp,1,['safe'],['safety']
Safety,"// For scalable vectors it is safe to use LoVT.getVectorMinNumElements(); // (rather than having to use ElementCount), because EXTRACT_SUBVECTOR scales; // IDX with the runtime scaling factor of the result vector type. For; // fixed-width result vectors, that runtime scaling factor is 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:30,safe,safe,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['safe'],['safe']
Safety,"// For signed saturating operations, we need to be able to detect true integer; // division overflow; that is, when you have MIN / -EPS. However, this; // is undefined behavior and if we emit divisions that could take such; // values it may cause undesired behavior (arithmetic exceptions on x86, for; // example).; // Avoid this by requiring an extra bit so that we never get this case.; // FIXME: This is a bit unfortunate as it means that for an 8-bit 7-scale; // signed saturating division, we need to emit a whopping 32-bit division.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:59,detect,detect,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,"['Avoid', 'detect']","['Avoid', 'detect']"
Safety,"// For simplicity and speed, data dependency check can be; // avoided if read from memory doesn't exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:62,avoid,avoided,62,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,1,['avoid'],['avoided']
Safety,"// For simplicity, avoid cases containing PHI nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:19,avoid,avoid,19,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,1,['avoid'],['avoid']
Safety,"// For simplicity, we created a separate basic block for the edge. Merge; // it back into the predecessor if possible. This not only avoids; // unnecessary SimplifyCFG iterations, but also makes sure that we don't; // bypass the check for trivial cycles above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:133,avoid,avoids,133,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoids']
Safety,"// For sinking, we'd need to check all Defs below this use. The getClobbering; // call will look on the backedge of the loop, but will check aliasing with; // the instructions on the previous iteration.; // For example:; // for (i ... ); // load a[i] ( Use (LoE); // store a[i] ( 1 = Def (2), with 2 = Phi for the loop.; // i++;; // The load sees no clobbering inside the loop, as the backedge alias check; // does phi translation, and will check aliasing against store a[i-1].; // However sinking the load outside the loop, below the store is incorrect.; // For now, only sink if there are no Defs in the loop, and the existing ones; // precede the use and are in the same block.; // FIXME: Increase precision: Safe to sink if Use post dominates the Def;; // needs PostDominatorTreeAnalysis.; // FIXME: More precise: no Defs that alias this Use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:712,Safe,Safe,712,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['Safe'],['Safe']
Safety,// For stores we need to be careful whether it's safe to move them.; // Stores that are otherwise safe to move together may not appear safe; // to move over one another (i.e. isSafeToMoveBefore may return false).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:49,safe,safe,49,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,3,['safe'],['safe']
Safety,"// For strict DWARF mode, only generate attributes available to current; // DWARF version.; // Attribute 0 is used when emitting form-encoded values in blocks, which; // don't have attributes (only forms) so we cannot detect their DWARF; // version compatibility here and assume they are compatible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:218,detect,detect,218,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,1,['detect'],['detect']
Safety,"// For subtract, we don't need to sext the constant. We only put it in; // SafeWrap because SafeWrap.size() is used elsewhere.; // For cmp, we need to sign extend a constant appearing in either; // operand. For add, we should only sign extend the RHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:75,Safe,SafeWrap,75,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,2,['Safe'],['SafeWrap']
Safety,"// For the EK_LabelDifference32 entry, if using .set avoids a relocation,; /// emit a .set directive for each unique entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:53,avoid,avoids,53,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['avoid'],['avoids']
Safety,// For the bit field use a power-of-2 type with at least 8 bits to avoid; // creating unnecessary illegal types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:67,avoid,avoid,67,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['avoid'],['avoid']
Safety,"// For the case of equal or not equal, it is safe without comparison with 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:45,safe,safe,45,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['safe'],['safe']
Safety,"// For the case of floating point setcc, only unordered comparison; // or general comparison with -enable-no-nans-fp-math option reach; // here, so it is safe even if values are NaN. Only f128 doesn't; // safe since VE uses f64 result of f128 comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:154,safe,safe,154,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,2,['safe'],['safe']
Safety,"// For the case of integer setcc with cmov, all signed comparison with 0; // are safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:81,safe,safe,81,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['safe'],['safe']
Safety,"// For the case of integer setcc, only signed 64 bits comparison is safe.; // For unsigned, ""CMPU 0x80000000, 0"" has to be greater than 0, but it becomes; // less than 0 witout CMPU. For 32 bits, other half of 32 bits are; // uncoditional, so it is not safe too without CMPI..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:68,safe,safe,68,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,2,['safe'],['safe']
Safety,"// For the indices, use the same SEW to avoid an extra vsetvli",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:40,avoid,avoid,40,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// For the purpose of error recovery, we treat rvalue refs like lvalue refs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,recover,recovery,28,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recovery']
Safety,// For the purposes of these comparisons sign extending the type is; // equivalent to zero extending the add and displacing it by half the integer; // width. Provided we are careful and make sure our equations are valid over; // the whole range we can just adjust the input and avoid writing equations; // for sign extended inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:278,avoid,avoid,278,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// For the range reasoning, avoid computing SCEVs in the loop to avoid; // poisoning cache with sub-optimal results. For the must-execute case,; // this is a neccessary precondition for correctness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:28,avoid,avoid,28,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,2,['avoid'],['avoid']
Safety,"// For the sake of error recovery (if someone has moved the original header; // after creating the pre-processed output) fall back to obtaining the file; // ref for the input file, which must be present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp:25,recover,recovery,25,interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaModule.cpp,1,['recover'],['recovery']
Safety,"// For the users of the source value being used for compare instruction, if; // the number of signed predicate is greater than unsigned predicate, we; // prefer to use SIGN_EXTEND.; //; // With this optimization, we would be able to reduce some redundant sign or; // zero extension instruction, and eventually more machine CSE opportunities; // can be exposed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp:245,redund,redundant,245,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,1,['redund'],['redundant']
Safety,"// For thread-safe setting of SetOwner(kTRUE).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGlobal.cxx:14,safe,safe,14,core/meta/src/TGlobal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TGlobal.cxx,1,['safe'],['safe']
Safety,"// For thread-safety we need to go through TClass::GetCollectionProxy; // to get a thread local proxy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TContainerConverters.cxx:14,safe,safety,14,io/io/src/TContainerConverters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TContainerConverters.cxx,1,['safe'],['safety']
Safety,"// For thread-safety we need to go through TClass::GetStreamer; // to get a thread local proxy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TContainerConverters.cxx:14,safe,safety,14,io/io/src/TContainerConverters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TContainerConverters.cxx,1,['safe'],['safety']
Safety,"// For value unsafe context, combining this pragma with eval method; // setting is not recommended. See comment in function FixupInvocation#506.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:13,unsafe,unsafe,13,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,1,['unsafe'],['unsafe']
Safety,// For variadic dbg_values we will now insert an undef.; // FIXME: We can potentially recover these!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:86,recover,recover,86,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['recover'],['recover']
Safety,// For z13 we prefer LDE over LE to avoid partial register dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZShortenInst.cpp,1,['avoid'],['avoid']
Safety,// For z13 we prefer LDR over LER to avoid partial register dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:37,avoid,avoid,37,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,1,['avoid'],['avoid']
Safety,// Forbidden slot hazards are only defined for MIPSR6 but not microMIPSR6.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:18,hazard,hazards,18,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,1,['hazard'],['hazards']
Safety,"// Force '/tmp' under macosx, to avoid problems with lengths and symlinks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx:33,avoid,avoid,33,test/stressProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressProof.cxx,1,['avoid'],['avoid']
Safety,// Force const to avoid infinite recursion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:18,avoid,avoid,18,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['avoid'],['avoid']
Safety,"// Force the target node to be in the old SCC. This also enables us to take; // a very significant short-cut in the standard Tarjan walk to re-form SCCs; // below: whenever we build an edge that reaches the target node, we know; // that the target node eventually connects back to all other nodes in our; // walk. As a consequence, we can detect and handle participants in that; // cycle without walking all the edges that form this connection, and instead; // by relying on the fundamental guarantee coming into this operation (all; // nodes are reachable from the target due to previously forming an SCC).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:339,detect,detect,339,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['detect'],['detect']
Safety,"// Force very small components to zero to avoid rounding errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx:42,avoid,avoid,42,graf3d/gl/src/TGLBoundingBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx,1,['avoid'],['avoid']
Safety,"// Forget all contained loops too, to avoid dangling entries in the; // ValuesAtScopes map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:38,avoid,avoid,38,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,"// Form load groups.; // To avoid complications with moving code across basic blocks, only form; // groups that are contained within a single basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:28,avoid,avoid,28,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['avoid'],['avoid']
Safety,"// Form store groups.; // To avoid complications with moving code across basic blocks, only form; // groups that are contained within a single basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:29,avoid,avoid,29,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['avoid'],['avoid']
Safety,// Formally a fold expression expands to nested parenthesized expressions.; // Enforce this limit to avoid creating trees so deep we can't safely traverse; // them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:101,avoid,avoid,101,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,2,"['avoid', 'safe']","['avoid', 'safely']"
Safety,"// Formatting with 1 Column isn't really a column layout, so we don't need the; // special logic here. We can just avoid bin packing any of the parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp:115,avoid,avoid,115,interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,1,['avoid'],['avoid']
Safety,// Forward trivially copyable types to array_pod_sort. This avoids a large; // amount of code bloat for a minor performance hit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:60,avoid,avoids,60,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['avoid'],['avoids']
Safety,// Forward-declare ConstantInitBuilderBase and give it a; // PointerLikeTypeTraits specialization so that we can safely use it; // in a PointerUnion below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitFuture.h:113,safe,safely,113,interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitFuture.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitFuture.h,1,['safe'],['safely']
Safety,"// Forwards to dyn_cast_if_present to avoid breaking current users. This is; // deprecated and will be removed in a future patch, use; // cast_if_present instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h:38,avoid,avoid,38,interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Casting.h,1,['avoid'],['avoid']
Safety,"// Found PDF depending on arg; // If multiple PDFs depend on arg directGen is not safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:82,safe,safe,82,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['safe'],['safe']
Safety,"// Found a .crash file matching the driver pid. To avoid getting an older; // and misleading crash file, continue looking for the most recent.; // FIXME: the driver can dispatch multiple cc1 invocations, leading to; // multiple crashes poiting to the same parent process. Since the driver; // does not collect pid information for the dispatched invocation there's; // currently no way to distinguish among them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:51,avoid,avoid,51,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['avoid'],['avoid']
Safety,"// Found the previous store to same location and type. Make sure it is; // simple, to avoid introducing a spurious non-atomic write after an; // atomic write.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"// FramePointer is clobbered earlier than the use of NegSizeReg in; // prepareDynamicAlloca, save NegSizeReg in ActualNegSizeReg to avoid; // misuse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:132,avoid,avoid,132,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['avoid'],['avoid']
Safety,"// From experience, it's rather the members of the RooProduct that is; // still correct in these inconsistent cases. That's why we try to; // recover by setting the proxy in the _proxyList to be equal to the; // member proxy. But that might be wrong, so it's important to warn the; // user anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:142,recover,recover,142,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['recover'],['recover']
Safety,// From the first-implied list we have to finish building the final protocol; // list. If a protocol in the first-implied list was already implied via some; // inheritance path through some other protocols then it would be redundant to; // add it here and so we skip over it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:223,redund,redundant,223,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['redund'],['redundant']
Safety,// Function entry or an unreachable block. Bail to avoid confusing; // analysis below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['avoid'],['avoid']
Safety,// Function types are too different. Abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:37,Abort,Abort,37,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['Abort'],['Abort']
Safety,"// FunctionProtoType::ExtProtoInfo's ExceptionSpecDecl can point to the; // FunctionDecl that we are importing the FunctionProtoType for.; // To avoid an infinite recursion when importing, create the FunctionDecl; // with a simplified function type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:145,avoid,avoid,145,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['avoid'],['avoid']
Safety,"// Functions like isZIPMask return true when a ISD::VECTOR_SHUFFLE's mask; // represents the same logical operation as performed by a ZIP instruction. In; // isolation these functions do not mean the ISD::VECTOR_SHUFFLE is exactly; // equivalent to an AArch64 instruction. There's the extra component of; // ISD::VECTOR_SHUFFLE's value type to consider. Prior to SVE these functions; // only operated on 64/128bit vector types that have a direct mapping to a; // target register and so an exact mapping is implied.; // However, when using SVE for fixed length vectors, most legal vector types; // are actually sub-vectors of a larger SVE register. When mapping; // ISD::VECTOR_SHUFFLE to an SVE instruction care must be taken to consider; // how the mask's indices translate. Specifically, when the mapping requires; // an exact meaning for a specific vector index (e.g. Index X is the last; // vector element in the register) then such mappings are often only safe when; // the exact SVE register size is know. The main exception to this is when; // indices are logically relative to the first element of either; // ISD::VECTOR_SHUFFLE operand because these relative indices don't change; // when converting from fixed-length to scalable vector types (i.e. the start; // of a fixed length vector is always the start of a scalable vector).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:961,safe,safe,961,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['safe'],['safe']
Safety,"// Functions to print out the arguments and highlighting the difference.; /// PrintTypeNames - prints the typenames, bolding differences. Will detect; /// typenames that are the same and attempt to disambiguate them by using; /// canonical typenames.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp:143,detect,detect,143,interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTDiagnostic.cpp,1,['detect'],['detect']
Safety,"// Functions with auto return type may define a struct inside their body; // and the return type could refer to that struct.; // E.g.: auto foo() { struct X{}; return X(); }; // To avoid an infinite recursion when importing, create the FunctionDecl; // with a simplified return type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:181,avoid,avoid,181,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['avoid'],['avoid']
Safety,"// Funny Darwin hack: This flag tells the linker that no global symbols; // contain code that falls through to other global symbols (e.g. the obvious; // implementation of multiple entry points). If this doesn't occur, the; // linker can safely perform dead code stripping. Since LLVM never; // generates code that does this, it is always safe to set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp:238,safe,safely,238,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp,4,['safe'],"['safe', 'safely']"
Safety,"// GC poses two hazards to inlining, which only occur when the callee has GC:; // 1. If the caller has no GC, then the callee's GC must be propagated to the; // caller.; // 2. If the caller has a differing GC, it is invalid to inline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:16,hazard,hazards,16,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['hazard'],['hazards']
Safety,"// GCC emits the # directive for this directive on the line AFTER the; // directive and emits a bunch of spaces that aren't needed. This is because; // otherwise we will emit a line marker for THIS line, which requires an; // extra blank line after the directive to avoid making all following lines; // off by one. We can do better by simply incrementing NewLine here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp:266,avoid,avoid,266,interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrintPreprocessedOutput.cpp,1,['avoid'],['avoid']
Safety,"// GNU addr2line assumes the address is hexadecimal and allows a redundant; // ""0x"" or ""0X"" prefix; do the same for compatibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp:65,redund,redundant,65,interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-symbolizer/llvm-symbolizer.cpp,1,['redund'],['redundant']
Safety,// GNU warning -Wmissing-prototypes:; // Warn if a global function is defined without a previous; // prototype declaration. This warning is issued even if the; // definition itself provides a prototype. The aim is to detect; // global functions that fail to be declared in header files.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:217,detect,detect,217,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['detect'],['detect']
Safety,"// GNU/Hurd's triples should have been -hurd-gnu*, but were historically made; // -gnu* only, and we can not change this, so we have to detect that case as; // being the Hurd OS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:136,detect,detect,136,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['detect'],['detect']
Safety,"// GV's where the clang++ frontend (when ASan is used) notes that this is; // dynamically initialized, and thus needs ODR detection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLToken.h:122,detect,detection,122,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLToken.h,1,['detect'],['detection']
Safety,"// Garbage collector clear of held python member objects; this is a good time; // to safely remove this object from the memory regulator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx:85,safe,safely,85,bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,1,['safe'],['safely']
Safety,"// Gather all GOT equivalent globals in the module. We really need two; // passes over the globals: one to compute and another to avoid its emission; // in EmitGlobalVariable, otherwise we would not be able to handle cases; // where the got equivalent shows up before its use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:130,avoid,avoid,130,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['avoid'],['avoid']
Safety,// Gather dependences unless we accumulated MaxDependences; // dependences. In that case return as soon as we find the first; // unsafe dependence. This puts a limit on this quadratic; // algorithm.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:129,unsafe,unsafe,129,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['unsafe'],['unsafe']
Safety,"// Gather some discriminating data about the DeclContext we will be; // creating: File, line number and byte size. This shouldn't be necessary,; // because the ODR is just about names, but given that we do some; // approximations with overloaded functions and anonymous namespaces, use; // these additional data points to make the process safer.; //; // This is disabled for clang modules, because forward declarations of; // module-defined types do not have a file and line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp:339,safe,safer,339,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinkerDeclContext.cpp,1,['safe'],['safer']
Safety,"// Gaussian Multivariate distribution; // assume passed arrays are of correct dimensions; // use gsl_matrix_view to avoid copying the data and allocate the arrays; // covmat will return",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx:116,avoid,avoid,116,math/mathmore/src/GSLRndmEngines.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRndmEngines.cxx,1,['avoid'],['avoid']
Safety,"// General InstSimplify functions may refine the result, e.g. by returning; // a constant for a potentially poison value. To avoid this, implement only; // a few non-refining but profitable transforms here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:125,avoid,avoid,125,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['avoid'],['avoid']
Safety,"// Generally we try to report as many issues as possible at once, but in; // this case it's not clear what should we be comparing the size of the; // scalar with: the size of the whole vector or its lane. Instead of; // making an arbitrary choice and emitting not so helpful message, let's; // avoid the extra noise and stop here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:294,avoid,avoid,294,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['avoid'],['avoid']
Safety,// Generate a PIC-safe GOT reference.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:18,safe,safe,18,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,// Generate a diagnostic where an uncovered argument is detected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:56,detect,detected,56,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['detect'],['detected']
Safety,"// Generate a reference to the class pointer, which will be the receiver.; // Assumes that the method was introduced in the class that should be; // messaged (avoids pulling it out of the result type).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:159,avoid,avoids,159,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['avoid'],['avoids']
Safety,"// Generate a vector-predicated load if it is custom/legal on the target. To; // avoid possible recursion, only do this if the widened mask type is legal.; // FIXME: Not all targets may support EVL in VP_LOAD. These will have been; // removed from the IR by the ExpandVectorPredication pass but we're; // reintroducing them here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:81,avoid,avoid,81,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['avoid'],['avoid']
Safety,"// Generate a vector-predicated store if it is custom/legal on the target.; // To avoid possible recursion, only do this if the widened mask type is; // legal.; // FIXME: Not all targets may support EVL in VP_STORE. These will have been; // removed from the IR by the ExpandVectorPredication pass but we're; // reintroducing them here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:82,avoid,avoid,82,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['avoid'],['avoid']
Safety,"// Generate vtable assumptions if we're constructing a complete object; // with a vtable. We don't do this for base subobjects for two reasons:; // first, it's incorrect for classes with virtual bases, and second, we're; // about to overwrite the vptrs anyway.; // We also have to make sure if we can refer to vtable:; // - Otherwise we can refer to vtable if it's safe to speculatively emit.; // FIXME: If vtable is used by ctor/dtor, or if vtable is external and we are; // sure that definition of vtable is not hidden,; // then we are always safe to refer to it.; // FIXME: It looks like InstCombine is very inefficient on dealing with; // assumes. Make assumption loads require -fstrict-vtable-pointers temporarily.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:365,safe,safe,365,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,2,['safe'],['safe']
Safety,"// Generated files will use ""namespace PPC"". To avoid symbol clash,; // undefine PPC here. PPC may be predefined on some hosts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h:48,avoid,avoid,48,interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/MCTargetDesc/PPCPredicates.h,1,['avoid'],['avoid']
Safety,// Get a percentage rounded to two decimal digits. This avoids; // implementation-defined rounding inside printf.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BranchProbability.cpp:56,avoid,avoids,56,interpreter/llvm-project/llvm/lib/Support/BranchProbability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BranchProbability.cpp,1,['avoid'],['avoids']
Safety,// Get a percentage rounded to two decimal digits. This avoids; // implementation-defined rounding inside printing functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp:56,avoid,avoids,56,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVScope.cpp,2,['avoid'],['avoids']
Safety,// Get next segment and abort if it was not adjacent.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp:24,abort,abort,24,interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveInterval.cpp,1,['abort'],['abort']
Safety,"// Get prediction for all events",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:7,predict,prediction,7,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,2,['predict'],['prediction']
Safety,"// Get prediction from classifier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyAdaBoost.cxx:7,predict,prediction,7,tmva/pymva/src/MethodPyAdaBoost.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyAdaBoost.cxx,9,['predict'],['prediction']
Safety,// Get the InsertPos by FindNodeOrInsertPos() instead of calling; // InsertNode(FTInfo) directly to avoid the getASTContext() call in; // FunctionTemplateSpecializationInfo's Profile().; // We avoid getASTContext because a decl in the parent hierarchy may; // be initializing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:100,avoid,avoid,100,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,2,['avoid'],['avoid']
Safety,"// Get the annotation string, go through casts. Sema requires this to be a; // non-wide string literal, potentially casted, so the cast<> is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:141,safe,safe,141,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['safe'],['safe']
Safety,"// Get the header block, which contains the redundant range check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:44,redund,redundant,44,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,1,['redund'],['redundant']
Safety,// Get the instructions that need to be replaced. We emit at most two of; // these. Remember them in order to avoid complications coming from the need; // to traverse the block while potentially creating more blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:110,avoid,avoid,110,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['avoid'],['avoid']
Safety,// Get the matching pairs of div-rem instructions. We want this extra; // indirection to avoid dealing with having to RAUW the keys of the maps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:89,avoid,avoid,89,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,1,['avoid'],['avoid']
Safety,"// Get the maximum safe dependence distance in bits computed by LAA.; // It is computed by MaxVF * sizeOf(type) * 8, where type is taken from; // the memory accesses that is most restrictive (involved in the smallest; // dependence distance).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,safe,safe,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['safe'],['safe']
Safety,"// Get the set of nodes in the computation graph. Do the detour via; // RooArgList to avoid deduplication done after adding each element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitImplHelpers.cxx:86,avoid,avoid,86,roofit/roofitcore/src/RooFitImplHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitImplHelpers.cxx,1,['avoid'],['avoid']
Safety,// Get the value to be stored into a register. Use the zero register directly; // when possible to avoid an unnecessary copy and a wasted register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp:99,avoid,avoid,99,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FastISel.cpp,1,['avoid'],['avoid']
Safety,"// Get timeout settings (default none)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx:7,timeout,timeout,7,proof/proof/src/TDataSetManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManager.cxx,1,['timeout'],['timeout']
Safety,"// Get uses from the current function, excluding uses by called functions; // Two output variables to avoid walking the globals list twice",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp:102,avoid,avoid,102,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerModuleLDSPass.cpp,1,['avoid'],['avoid']
Safety,"// GetTarget() may replaced TripleName with a default triple.; // For safety, reconstruct the Triple object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp:70,safe,safety,70,interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mca/llvm-mca.cpp,1,['safe'],['safety']
Safety,"// Getting the branches here triggered the read of the first file of the chain if t is a chain.; // We check if a tree has been successfully read, otherwise we throw (see ROOT-9984) to avoid further; // operations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:185,avoid,avoid,185,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['avoid'],['avoid']
Safety,// Give it a chance to recover from unknown.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:23,recover,recover,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['recover'],['recover']
Safety,// Give non-deduced 'auto' types external linkage. We should only see them; // here in error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:93,recover,recovery,93,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['recover'],['recovery']
Safety,// Give source modifier matching some assistance before obscuring a foldable; // pattern.; // TODO: We can avoid the neg on the fract? The input sign to fract; // shouldn't matter?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:107,avoid,avoid,107,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['avoid'],['avoid']
Safety,// Give the external source a chance to provide a definition of the type.; // This is kept separate from completing the redeclaration chain so that; // external sources such as LLDB can avoid synthesizing a type definition; // unless it's actually needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:186,avoid,avoid,186,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['avoid'],['avoid']
Safety,"// Give the gen diagnostics more chances to succeed, by avoiding intentional; // crashes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:56,avoid,avoiding,56,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['avoid'],['avoiding']
Safety,"// Give up, we can't recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:21,recover,recover,21,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Safety,"// Given A-B, if A can be completely folded into the address and; // the index field with the index field unused, use -B as the index.; // This is a win if a has multiple parts that can be folded into; // the address. Also, this saves a mov if the base register has; // other uses, since it avoids a two-address sub instruction, however; // it costs an additional mov if the index register has other uses.; // Add an artificial use to this node so that we can keep track of; // it if it gets CSE'd with a different node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:291,avoid,avoids,291,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['avoid'],['avoids']
Safety,"// Given a 3D point, returns the; // a) the min radius R such that there is at least one leaf bounding box fully enclosed; // in the sphere of radius R around point + the smallest squared safety; // b) the set of leaf bounding boxes who partially lie within radius + margin",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:188,safe,safety,188,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"// Given a ABS node, detect the following pattern:; // (ABS (SUB (ZERO_EXTEND a), (ZERO_EXTEND b))).; // This is useful as it is the input into a SAD pattern.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:21,detect,detect,21,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,"// Given a ABS node, detect the following patterns:; // (ABS (SUB (EXTEND a), (EXTEND b))).; // (TRUNC (ABS (SUB (EXTEND a), (EXTEND b)))).; // Generates UABD/SABD instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:21,detect,detect,21,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['detect'],['detect']
Safety,"// Given a ISD::EXTRACT_VECTOR_ELT, which is a glorified bit sequence extract,; // recursively analyse all of it's users. and try to model themselves as; // bit sequence extractions. If all of them agree on the new, narrower element; // type, and all of them can be modelled as ISD::EXTRACT_VECTOR_ELT's of that; // new element type, do so now.; // This is mainly useful to recover from legalization that scalarized; // the vector as wide elements, but tries to rebuild it with narrower elements.; //; // Some more nodes could be modelled if that helps cover interesting patterns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:374,recover,recover,374,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['recover'],['recover']
Safety,"// Given a callee expression `Fn`, if the call is through a function pointer,; // try to find the declaration of the corresponding function pointer type,; // so that we can recover argument names from it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:173,recover,recover,173,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['recover'],['recover']
Safety,"// Given a preprocessing token kind, adjusts CurPtr to the end; // of the preprocessing directive word. Returns true, unless; // an unsupported token kind is passed in.; //; // We use look-ahead prepIsDirective() and prepEatPreprocessorDirective(); // to avoid adjusting CurPtr before we are sure that '#' is followed; // by a preprocessing directive. If it is not, then we fall back to; // tgtok::paste interpretation of '#'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h:255,avoid,avoid,255,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,1,['avoid'],['avoid']
Safety,"// Given a vecreduce_add node, detect the below pattern and convert it to the; // node sequence with UABDL, [S|U]ADB and UADDLP.; //; // i32 vecreduce_add(; // v16i32 abs(; // v16i32 sub(; // v16i32 [sign|zero]_extend(v16i8 a), v16i32 [sign|zero]_extend(v16i8 b)))); // =================>; // i32 vecreduce_add(; // v4i32 UADDLP(; // v8i16 add(; // v8i16 zext(; // v8i8 [S|U]ABD low8:v16i8 a, low8:v16i8 b; // v8i16 zext(; // v8i8 [S|U]ABD high8:v16i8 a, high8:v16i8 b",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:31,detect,detect,31,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['detect'],['detect']
Safety,"// Given a vector of operations that have been broken up to widen, see; // if we can collect them together into the next widest legal VT. This; // implementation is trap-safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:170,safe,safe,170,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['safe'],['safe']
Safety,"// Given some data, this returns an array-like view of it: an object that; // exposes a length property and allows numeric indexing. Note that unlike; // selectAll, this isn’t worried about “live” collections because the resulting; // array will only be used briefly while data is being bound. (It is possible to; // cause the data to change while iterating by using a key function, but please; // don’t; we’d rather avoid a gratuitous copy.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:417,avoid,avoid,417,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// Given something array like (or null), returns something that is strictly an; // array. This is used to ensure that array-like objects passed to d3.selectAll; // or selection.selectAll are converted into proper arrays when creating a; // selection; we don’t ever want to create a selection backed by a live; // HTMLCollection or NodeList. However, note that selection.selectAll will use a; // static NodeList as a group, since it safely derived from querySelectorAll.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:432,safe,safely,432,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['safe'],['safely']
Safety,"// Given the frontend rules for emitting AutoreleaseRV, RetainRV, and; // UnsafeClaimRV, it's probably safe to skip over even opaque function calls; // here since OptimizeInlinedAutoreleaseRVCall will confirm that they; // have the same RCIdentityRoot. However, what really matters is; // skipping instructions or intrinsics that the inliner could leave behind;; // be conservative for now and don't skip over opaque calls, which could; // potentially include other ARC calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:74,Unsafe,UnsafeClaimRV,74,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,2,"['Unsafe', 'safe']","['UnsafeClaimRV', 'safe']"
Safety,"// Given two predicated instructions, this function detects whether; // the predicates are complements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:52,detect,detects,52,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['detect'],['detects']
Safety,"// Given we're inlining this inside of safepoint poll insertion, this; // doesn't make any sense. Note that we do make any contained calls; // parseable after we inline a poll.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:39,safe,safepoint,39,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,"// Given whatever FP the runtime provided us in EntryFP, recover the true; // frame pointer of the parent function. We only need to do this in filters,; // since finally funclets recover the parent FP for us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:57,recover,recover,57,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,2,['recover'],['recover']
Safety,// Glibc versions greater than 2.35 automatically call rseq during; // initialization. Unmapping the region that glibc sets up for this causes; // segfaults in the program Unregister the rseq region so that we can safely; // unmap it later,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp:214,safe,safely,214,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/BenchmarkRunner.cpp,1,['safe'],['safely']
Safety,"// Global variables attached to symbols are memory locations.; // It would be better if this were unconditional, but malformed input that; // mixes non-fragments and fragments for the same variable is too expensive; // to detect in the verifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp:222,detect,detect,222,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfCompileUnit.cpp,1,['detect'],['detect']
Safety,"// Global variables which are vtables, and which we have enough information; // about to safely do dead virtual function elimination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalDCE.h:89,safe,safely,89,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalDCE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/GlobalDCE.h,1,['safe'],['safely']
Safety,// Globals for name and overview of program. Program name is not a string to; // avoid static ctor/dtor issues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:81,avoid,avoid,81,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['avoid'],['avoid']
Safety,"// Go through AND/OR conditions. Collect leaf ICMPs. We only care about; // those with one use, to avoid instruction duplication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:99,avoid,avoid,99,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['avoid'],['avoid']
Safety,// Go through all the basic blocks in the current loop and fix any streaming; // loads to avoid collisions with any other loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp:90,avoid,avoid,90,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FalkorHWPFFix.cpp,1,['avoid'],['avoid']
Safety,"// Go through all uses of this alloca and check whether all accesses to the; // allocated object are statically known to be memory safe and, hence, the; // object can be placed on the safe stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:131,safe,safe,131,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,2,['safe'],['safe']
Safety,"// Go through implicit defs of CSMI and MI, and clear the kill flags on; // their uses in all the instructions between CSMI and MI.; // We might have made some of the kill flags redundant, consider:; // subs ... implicit-def %nzcv <- CSMI; // csinc ... implicit killed %nzcv <- this kill flag isn't valid anymore; // subs ... implicit-def %nzcv <- MI, to be eliminated; // csinc ... implicit killed %nzcv; // Since we eliminated MI, and reused a register imp-def'd by CSMI; // (here %nzcv), that register, if it was killed before MI, should have; // that kill flag removed, because it's lifetime was extended.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:178,redund,redundant,178,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['redund'],['redundant']
Safety,"// Goes from Unknown to either Safe or Unsafe, but can't switch between them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:31,Safe,Safe,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,2,"['Safe', 'Unsafe']","['Safe', 'Unsafe']"
Safety,// Group decls are converted into single decls in the CFG so the cast below; // is safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp:83,safe,safe,83,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Transfer.cpp,1,['safe'],['safe']
Safety,"// Grow the table to cover all possible index values to avoid the range check.; // It will use the default result to fill in the table hole later, so make; // sure it exist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:56,avoid,avoid,56,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"// Guarantee that all emitted copies are stuck together,; // avoiding something bad.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp:61,avoid,avoiding,61,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelLowering.cpp,2,['avoid'],['avoiding']
Safety,"// Guarantee that all emitted copies are; // stuck together, avoiding something bad.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:61,avoid,avoiding,61,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoiding']
Safety,// Guard against 0-to-0 branch weights to avoid a division-by-zero crash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['avoid'],['avoid']
Safety,"// Guard intrinsics read all memory, but don't write any memory.; // Accordingly, don't update the generation but consume the last store (to; // avoid an incorrect DSE).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:145,avoid,avoid,145,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['avoid'],['avoid']
Safety,// Guard variable to avoid recursively redoing the process of passing; // decls to consumer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:21,avoid,avoid,21,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['avoid'],['avoid']
Safety,// HACK 2017-01-08: Work around an issue with libstdc++'s detection of; // ::gets. Sometimes it believes that glibc provides a ::gets in cases where; // it does not. The issue was fixed in libstdc++ 6.3 (2016-12-21) and later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:58,detect,detection,58,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['detect'],['detection']
Safety,"// HACK: This entire check is to handle two messages in the Cocoa frameworks:; // -[NSAssertionHandler; // handleFailureInMethod:object:file:lineNumber:description:]; // -[NSAssertionHandler; // handleFailureInFunction:file:lineNumber:description:]; // Eventually these should be annotated with __attribute__((noreturn)).; // Because ObjC messages use dynamic dispatch, it is not generally safe to; // assume certain methods can't return. In cases where it is definitely valid,; // see if you can mark the methods noreturn or analyzer_noreturn instead of; // adding more explicit checks to this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp:390,safe,safe,390,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NoReturnFunctionChecker.cpp,1,['safe'],['safe']
Safety,// HACK: This is a big hammer to avoid warning when there are defensive; // nil checks in -init and -copy methods. We should add more sophisticated; // logic here to suppress on common defensive idioms but still; // warn when there is a likely problem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:33,avoid,avoid,33,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['avoid'],['avoid']
Safety,"// HLSL doesn't support pointers, so it is unlikely to get more than one; // or two levels of indirection in the IR. Because of this, recursion is; // pretty safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXIRPasses/PointerTypeAnalysis.cpp:158,safe,safe,158,interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXIRPasses/PointerTypeAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DirectXIRPasses/PointerTypeAnalysis.cpp,1,['safe'],['safe']
Safety,// Hack: Avoid empty declarator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:9,Avoid,Avoid,9,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['Avoid'],['Avoid']
Safety,"// Half-precision return values can be returned like this:; //; // t11 f16 = fadd ...; // t12: i16 = bitcast t11; // t13: i32 = zero_extend t12; // t14: f32 = bitcast t13 <~~~~~~~ Arg; //; // to avoid code generation for bitcasts, we simply set Arg to the node; // that produces the f16 value, t11 in this case.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:195,avoid,avoid,195,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Handle 0 and -1 separately to avoid division by zero or overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:33,avoid,avoid,33,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['avoid'],['avoid']
Safety,// Handle 64-bit integer elements as a special case. Use a shuffle to get; // a one-element vector and avoid poor code for i64 in the backend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:103,avoid,avoid,103,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['avoid'],['avoid']
Safety,// Handle 64-bit integer elements as a special case. Use shuffles of; // one-element vectors to avoid poor code for i64 in the backend.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:96,avoid,avoid,96,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['avoid'],['avoid']
Safety,"// Handle C++ base classes. Non-virtual bases can treated a kind of; // field. Virtual bases are more complex and omitted, but avoid an; // incomplete view for NewStructPathTBAA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp:127,avoid,avoid,127,interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenTBAA.cpp,1,['avoid'],['avoid']
Safety,"// Handle a ""templated"" function together with its described; // template. This avoids need for a similar check at import of the; // described template.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:80,avoid,avoids,80,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['avoid'],['avoids']
Safety,"// Handle a case like bitcast v12i8 -> v3i32. Normally that would get widened; // to v16i8 -> v4i32, but for a target where v3i32 is legal but v12i8 is not,; // we end up here. Handling the case here with EXTRACT_SUBVECTOR avoids; // having to copy via memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:223,avoid,avoids,223,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['avoid'],['avoids']
Safety,"// Handle a corner case first when both range sets start from MIN.; // This helps to avoid complicated conditions below. Specifically, this; // particular check for `MIN` is not needed in the loop below every time; // when we do `Second->From() - One` operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:85,avoid,avoid,85,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['avoid'],['avoid']
Safety,// Handle a formal type change to avoid asserting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:34,avoid,avoid,34,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['avoid'],['avoid']
Safety,"// Handle a subsection with an unrecognized vendor-name by skipping; // over it to the next subsection. ADDENDA32 in the Arm ABI defines; // that vendor attribute sections must not affect compatibility, so; // this should always be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ELFAttributeParser.cpp:232,safe,safe,232,interpreter/llvm-project/llvm/lib/Support/ELFAttributeParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ELFAttributeParser.cpp,1,['safe'],['safe']
Safety,"// Handle a variety of cases where we are branching on something derived from; // a PHI node in the current block. If we can prove that any predecessors; // compute a predictable value based on a PHI node, thread those predecessors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:167,predict,predictable,167,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['predict'],['predictable']
Safety,"// Handle abort ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:10,abort,abort,10,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['abort'],['abort']
Safety,"// Handle abort() in msvcrt -- It has exit code as 3. abort(), aka; // unreachable, should be recognized as a crash. However, some binaries use; // exit code 3 on non-crash failure paths, so only do this if we expect a; // crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/not/not.cpp:10,abort,abort,10,interpreter/llvm-project/llvm/utils/not/not.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/not/not.cpp,2,['abort'],['abort']
Safety,"// Handle any inlined musttail call sites. In order for a new call site to be; // musttail, the source of the clone and the inlined call site must have been; // musttail. Therefore it's safe to return without merging control into the; // phi below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:186,safe,safe,186,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['safe'],['safe']
Safety,// Handle any special-case instructions which we can safely infer register; // classes from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp:53,safe,safely,53,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,1,['safe'],['safely']
Safety,// Handle catch list. As a special case we check if everything is; // matched and avoid generating code for falling off the end if; // so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:82,avoid,avoid,82,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['avoid'],['avoid']
Safety,// Handle cold misses of user includes in the presence of many header; // maps. We avoid searching perhaps thousands of header maps by; // jumping directly to the correct one or jumping beyond all of them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:83,avoid,avoid,83,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['avoid'],['avoid']
Safety,// Handle constrained floating-point operations of vector.; // The predictor is `hasVSX` because altivec instruction has; // no exception but VSX vector instruction has.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:67,predict,predictor,67,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['predict'],['predictor']
Safety,// Handle destination record types that we can safely infer a register class; // from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp:47,safe,safely,47,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,1,['safe'],['safely']
Safety,"// Handle the case of recursive call from another task in a different group,; // in which case process tasks while waiting to keep the thread busy and avoid; // possible deadlock.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp:151,avoid,avoid,151,interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp,1,['avoid'],['avoid']
Safety,"// Handle the case where a copy is being spilled or filled but the source; // and destination register class don't match. For example:; //; // %0 = COPY %xzr; GPR64common:%0; //; // In this case we can still safely fold away the COPY and generate the; // following spill code:; //; // STRXui %xzr, %stack.0; //; // This also eliminates spilled cross register class COPYs (e.g. between x and; // d regs) of the same size. For example:; //; // %0 = COPY %1; GPR64:%0, FPR64:%1; //; // will be filled as; //; // LDRDui %0, fi<#0>; //; // instead of; //; // LDRXui %Temp, fi<#0>; // %0 = FMOV %Temp; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:208,safe,safely,208,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['safe'],['safely']
Safety,// Handle the in-lane shuffles by detecting if and when they repeat. Adjust; // later vector indices to start at multiples of LaneSize instead of Size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:34,detect,detecting,34,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detecting']
Safety,"// Handle the safe cases where the return value is 0 if the; // receiver is nil.; //; // FIXME: For now take the conservative approach that we only; // return null values if we *know* that the receiver is nil.; // This is because we can have surprises like:; //; // ... = [[NSScreens screens] objectAtIndex:0];; //; // What can happen is that [... screens] could return nil, but; // it most likely isn't nil. We should assume the semantics; // of this case unless we have *a lot* more knowledge.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:14,safe,safe,14,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,1,['safe'],['safe']
Safety,// Handle the undefined 15 CC value here for printing so we don't abort().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:66,abort,abort,66,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,1,['abort'],['abort']
Safety,// Handle the undefined value here for printing so we don't abort().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp:60,abort,abort,60,interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/MCTargetDesc/LanaiInstPrinter.cpp,2,['abort'],['abort']
Safety,"// Handle these nodes here to avoid having to write patterns for all; // combinations of input/output types. In all cases, the resulting; // instruction is the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:30,avoid,avoid,30,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,// Handle trivially true compares directly to avoid adding V UGE 0 constraints; // for all variables in the unsigned system.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp:46,avoid,avoid,46,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstraintElimination.cpp,1,['avoid'],['avoid']
Safety,"// Handle value-propagation when control flow merges on entry to a block. For; // any location without a PHI already placed, the location has the same value; // as its predecessors. If a PHI is placed, test to see whether it's now a; // redundant PHI that we can eliminate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:237,redund,redundant,237,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['redund'],['redundant']
Safety,// Handled by formatFromToken (1) or avoid severe penalty (0).; // Ensure that we start on the opening brace.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp:37,avoid,avoid,37,interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.cpp,1,['avoid'],['avoid']
Safety,"// Handling expressions which produce invariant results, but *haven't* yet; // been removed from the loop serves two important purposes.; // 1) Most importantly, it resolves a pass ordering cycle which would; // otherwise need us to iteration licm, loop-predication, and either; // loop-unswitch or loop-peeling to make progress on examples with lots of; // predicable range checks in a row. (Since, in the general case, we can't; // hoist the length checks until the dominating checks have been discharged; // as we can't prove doing so is safe.); // 2) As a nice side effect, this exposes the value of peeling or unswitching; // much more obviously in the IR. Otherwise, the cost modeling for other; // transforms would end up needing to duplicate all of this logic to model a; // check which becomes predictable based on a modeled peel or unswitch.; //; // The cost of doing so in the worst case is an extra fill from the stack in; // the loop to materialize the loop invariant test value instead of checking; // against the original IV which is presumable in a register inside the loop.; // Such cases are presumably rare, and hint at missing oppurtunities for; // other passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:541,safe,safe,541,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,2,"['predict', 'safe']","['predictable', 'safe']"
Safety,"// Handling llvm.lifetime intrinsics for a given %alloca:; // (1) collect all llvm.lifetime.xxx(%size, %value) describing the alloca.; // (2) if %size is constant, poison memory for llvm.lifetime.end (to detect; // invalid accesses) and unpoison it for llvm.lifetime.start (the memory; // could be poisoned by previous llvm.lifetime.end instruction, as the; // variable may go in and out of scope several times, e.g. in loops).; // (3) if we poisoned at least one %alloca in a function,; // unpoison the whole stack frame at function exit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:204,detect,detect,204,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['detect'],['detect']
Safety,// Has one cycle hazard on a VALU instruction partially writing dst with; // a shift of result bits feeding another VALU instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:17,hazard,hazard,17,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['hazard'],['hazard']
Safety,// Has one cycle hazard on transcendental instruction feeding a; // non transcendental VALU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:17,hazard,hazard,17,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['hazard'],['hazard']
Safety,"// Hash interface for generic data of type T; // Data should implement a \fn getHashCode and a \fn isEqual; // Currently getHashCode is non-virtual to avoid the overhead of calling vtable,; // i.e we explicitly calculate hash of derived class, assign to base class's; // HashCode. This also provides the flexibility for calculating the hash code; // incrementally(like rolling hash) during frame stack unwinding since unwinding; // only changes the leaf of frame stack. \fn isEqual is a virtual function,; // which will have perf overhead. In the future, if we redesign a better hash; // function, then we can just skip this or switch to non-virtual function(like; // just ignore comparison if hash conflicts probabilities is low)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h:151,avoid,avoid,151,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.h,1,['avoid'],['avoid']
Safety,"// Hash min/max (cmp + select) to allow for commuted operands.; // Min/max may also have non-canonical compare predicate (eg, the compare for; // smin may use 'sgt' rather than 'slt'), and non-canonical operands in the; // compare.; // TODO: We should also detect FP min/max.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:257,detect,detect,257,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['detect'],['detect']
Safety,// Hazard is observed - insert a wait on va_dst counter to ensure hazard is; // avoided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:3,Hazard,Hazard,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,3,"['Hazard', 'avoid', 'hazard']","['Hazard', 'avoided', 'hazard']"
Safety,// Hazards related to FP MLx instructions,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.h:3,Hazard,Hazards,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.h,1,['Hazard'],['Hazards']
Safety,// Hazards related to bank conflicts,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.h:3,Hazard,Hazards,3,interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.h,1,['Hazard'],['Hazards']
Safety,"// Header file cannot be found anywhere, warn user and abort operation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:55,abort,abort,55,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['abort'],['abort']
Safety,"// Helper for chaining together multiple imports. If an error is detected,; // subsequent imports will return default constructed nodes, so that failure; // can be detected with a single conditional branch after a sequence of; // imports.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:65,detect,detected,65,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['detect'],['detected']
Safety,// Helper functions for computeExitLimitFromCond to avoid exponential time; // complexity.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:52,avoid,avoid,52,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['avoid'],['avoid']
Safety,// Helper functions of redundant load elimination,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:23,redund,redundant,23,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,1,['redund'],['redundant']
Safety,// Helper method to pretty print region and avoid extra spacing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:44,avoid,avoid,44,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,1,['avoid'],['avoid']
Safety,// Helper to avoid truncating the length if size_t is 32-bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:13,avoid,avoid,13,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['avoid'],['avoid']
Safety,// Helper to check for the hazard where VMEM instructions that store more than; // 8 bytes can have there store data over written by the next instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:27,hazard,hazard,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,// Helper to clone Phi instructions into the destination block. We clone Phi; // greedily to avoid combinatorial explosion of Phi instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ModuloSchedule.cpp,1,['avoid'],['avoid']
Safety,"// Helper to detect PACKSSDW(BITCAST(PACKSSDW(X)),BITCAST(PACKSSDW(Y))); // patterns often used to compact vXi64 allsignbit patterns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,detect,detect,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,// Helper to detect if the operand is CUR_DIRECTION rounding mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,detect,detect,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,// Helper to detect unneeded and instructions on shift amounts. Called; // from PatFrags in tablegen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:13,detect,detect,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['detect'],['detect']
Safety,"// Helper to determine if the access is executed by the same thread as the; // given instruction, for now it is sufficient to avoid any potential; // threading effects as we cannot deal with them anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:126,avoid,avoid,126,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['avoid'],['avoid']
Safety,// Helper to merge the __kmpc_fork_call calls in MergableCIs. They are all; // contained in BB and only separated by instructions that can be; // redundantly executed in parallel. The block BB is split before the first; // call (in MergableCIs) and after the last so the entire region we merge; // into a single parallel region is contained in a single basic block; // without any other instructions. We use the OpenMPIRBuilder to outline; // that block and call the resulting function via __kmpc_fork_call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:146,redund,redundantly,146,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['redund'],['redundantly']
Safety,"// Here the block is not pending. It could be done or aborted or not yet being processed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:54,abort,aborted,54,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['abort'],['aborted']
Safety,// Here using VAArgOverflowSizeTLS as VAArgSizeTLS to avoid creation of; // a new class member i.e. it is the total size of all VarArgs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:54,avoid,avoid,54,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,2,['avoid'],['avoid']
Safety,"// Here we can test the type of VT and return false when the type does not; // match, but since it is done prior to that call in the current context; // we turned that into an assert to avoid redundant code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:186,avoid,avoid,186,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,4,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// Here we comply to ""PEP 587 – Python Initialization Configuration"" to avoid; // deprecation warnings at compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx:72,avoid,avoid,72,bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,1,['avoid'],['avoid']
Safety,"// Here we use the same DebugLoc as the scalar loop latch terminator instead; // of the corresponding compare because they may have ended up with; // different line numbers and we want to avoid awkward line stepping while; // debugging. Eg. if the compare has got a line number inside the loop.; // TODO: At the moment, CreateICmpEQ will simplify conditions with constant; // operands. Perform simplification directly on VPlan once the branch is; // modeled there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:188,avoid,avoid,188,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avoid'],['avoid']
Safety,"// Here, we have a memory allocation that should be avoided when this; // code needs to be optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooUnbinnedL.cxx:52,avoid,avoided,52,roofit/roofitcore/src/TestStatistics/RooUnbinnedL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/RooUnbinnedL.cxx,1,['avoid'],['avoided']
Safety,"// Hereinafter: don't change SectionNamesVector content to avoid vector; // reallocation - reallocation invalidates all the references, pointers, and; // iterators referring to the elements in the sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp:59,avoid,avoid,59,interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/IntelJITEvents/IntelJITEventListener.cpp,1,['avoid'],['avoid']
Safety,"// Heuristic: avoid entities like myclass<myType1, myType2::xyz>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:14,avoid,avoid,14,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['avoid'],['avoid']
Safety,"// Heuristics #2: If the expression doesn't not use a vr and the only use; // of the redundant computation are copies, do not cse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:85,redund,redundant,85,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['redund'],['redundant']
Safety,"// Histogram containing template prediction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:33,predict,prediction,33,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['predict'],['prediction']
Safety,// Hit and diagnosed an error in a lambda.; // FIXME: Tell the caller this happened so they can recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:96,recover,recover,96,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,1,['recover'],['recover']
Safety,"// Hoist MostEncompassingPTrue to the start of the basic block. It is always; // safe to do this, since ptrue intrinsic calls are guaranteed to have no; // predecessors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp:81,safe,safe,81,interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,1,['safe'],['safe']
Safety,// Hold tapi converted triple to avoid unecessary casts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/RecordsSlice.h:33,avoid,avoid,33,interpreter/llvm-project/llvm/include/llvm/TextAPI/RecordsSlice.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/RecordsSlice.h,1,['avoid'],['avoid']
Safety,// Holds most recent error string.; // *** Not thread safe ***,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lto/lto.cpp:54,safe,safe,54,interpreter/llvm-project/llvm/tools/lto/lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lto/lto.cpp,1,['safe'],['safe']
Safety,// Holds the initialization state of the LTO module.; // *** Not thread safe ***,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lto/lto.cpp:72,safe,safe,72,interpreter/llvm-project/llvm/tools/lto/lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lto/lto.cpp,1,['safe'],['safe']
Safety,// Honor TargetOptions flags that explicitly say unsafe math is okay.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:49,unsafe,unsafe,49,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['unsafe'],['unsafe']
Safety,"// Hook to the constructor. This is needed to avoid using the plugin manager; // which may create problems in multi-threaded environments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:46,avoid,avoid,46,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,2,['avoid'],['avoid']
Safety,"// How far into the Order we can iterate. This is 0 if the AllocationOrder is; // constructed with HardHints = true, Order.size() otherwise. While; // technically a size_t, it will participate in comparisons with the; // Iterator's Pos, which must be signed, so it's typed here as signed, too, to; // avoid warnings and under the assumption that the size of Order is; // relatively small.; // IterationLimit defines an invalid iterator position.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h:301,avoid,avoid,301,interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AllocationOrder.h,1,['avoid'],['avoid']
Safety,// How to transform the EVL parameter.; // Legal: keep the EVL parameter as it is.; // Discard: Ignore the EVL parameter where it is safe to do so.; // Convert: Fold the EVL into the mask parameter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:133,safe,safe,133,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['safe'],['safe']
Safety,"// However, a 32-bit floating point number has only 23 bits mantissa and; // it's not enough to hold all the significant bits of `lof` if val is; // negative. To avoid the loss of precision, We need to take the absolute; // value after truncating and flip the result back based on the original; // signedness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:162,avoid,avoid,162,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// However, if this submessage is the first entry in its parent; // submessage, Left.ParameterCount might be 1 in some cases.; // We deal with this case later by detecting an entry; // following a closing paren of this submessage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:162,detect,detecting,162,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['detect'],['detecting']
Safety,"// However, we can still recover without crashing.; // If either location is invalid, set it to std::nullopt to avoid; // letting users of RegionStack think that region has a valid start/end; // location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp:25,recover,recover,25,interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,2,"['avoid', 'recover']","['avoid', 'recover']"
Safety,"// Humm .. we are missing the collection Proxy; // for a proxied (custom) collection ... avoid; // an infinite recursion and take a wild guess",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:89,avoid,avoid,89,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['avoid'],['avoid']
Safety,// I = B + sext(Idx *nsw S) * ElementSize; // = B + (sext(Idx) * sext(S)) * ElementSize; // = B + (sext(Idx) * ElementSize) * sext(S); // Casting to IntegerType is safe because we skipped vector GEPs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:164,safe,safe,164,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['safe'],['safe']
Safety,// I must be safe to execute unconditionally.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,"// I think we can avoid cloning the model function; //fFitFunc = dynamic_cast<IModelFunction *>( func->Clone() );; //assert(fFitFunc);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitResult.cxx:18,avoid,avoid,18,math/mathcore/src/FitResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitResult.cxx,1,['avoid'],['avoid']
Safety,"// I think we can be more aggressive here and make this nuw / nsw if the; // addition that feeds into the icmp for the latch's terminating branch is nuw; // / nsw. In any case, a wrapping 2's complement addition is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:215,safe,safe,215,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['safe'],['safe']
Safety,"// IC, DC, AT, TLBI and Prediction invalidation instructions are aliases for; // the SYS instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:24,Predict,Prediction,24,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['Predict'],['Prediction']
Safety,"// IMPORTANT: this function must not throw, as it is used in exception-unsafe code (TFileMerger).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx:71,unsafe,unsafe,71,tree/ntuple/v7/src/RNTupleMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleMerger.cxx,1,['unsafe'],['unsafe']
Safety,"// ISD::FSHL and ISD::FSHR have defined overflow behavior but ISD::SHL and; // ISD::SRA/L nodes haven't. Insert an AND to be safe, it's usually optimized; // away during isel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:125,safe,safe,125,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['safe'],['safe']
Safety,"// ISel may introduce a new register on this step, so we need to add it to; // DT and correct its type avoiding fails on the next stage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:103,avoid,avoiding,103,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,1,['avoid'],['avoiding']
Safety,"// Idea: Implement buf.ReadBasic/Primitive to avoid the return value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:46,avoid,avoid,46,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,6,['avoid'],['avoid']
Safety,"// Idea: Implement buf.ReadBasic/Primitive to avoid the return value; // Idea: This code really belongs inside TBuffer[File]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:46,avoid,avoid,46,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['avoid'],['avoid']
Safety,"// Idea: We should calculate the CanIgnoreTObjectStreamer here and avoid calling the; // Streamer alltogether.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:67,avoid,avoid,67,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,3,['avoid'],['avoid']
Safety,"// Ideally, operations with undef should be folded before we get here, but we; // can't guarantee it. Bail out because optimizing undefs is a waste of time.; // Without this, we have to forward undef state to new register operands to; // avoid machine verifier errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:238,avoid,avoid,238,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// Ideally, we would avoid deserializing the streamer info records of the streamer fields that we just serialized.; // However, this happens only once at the end of writing and only when streamer fields are used, so the; // preference here is for code simplicity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx:21,avoid,avoid,21,tree/ntuple/v7/src/RNTupleDescriptor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleDescriptor.cxx,1,['avoid'],['avoid']
Safety,"// Identifier(Tok).empty() is redundant 1st time, but simplifies code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:30,redund,redundant,30,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['redund'],['redundant']
Safety,"// Identify S_ENDPGM instructions which may have to wait for outstanding VMEM; // stores. In this case it can be useful to send a message to explicitly; // release all VGPRs before the stores have completed, but it is only safe to; // do this if:; // * there are no outstanding scratch stores; // * we are not in Dynamic VGPR mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:223,safe,safe,223,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['safe'],['safe']
Safety,"// If !noundef is not present, then !range violation results in a poison; // value rather than immediate undefined behavior. In theory, transferring; // these annotations to SDAG is fine, but in practice there are key SDAG; // transforms that are known not to be poison-safe, such as folding logical; // and/or to bitwise and/or. For now, only transfer !range if !noundef is; // also present.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:270,safe,safe,270,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['safe'],['safe']
Safety,"// If 'errno' must be checked, it should be done as soon as possible, and; // before any other call to a system function (something in a system header).; // To avoid use of a long list of functions that may change 'errno'; // (which may be different with standard library versions) assume that any; // function can change it.; // A list of special functions can be used that are allowed here without; // generation of diagnostic. For now the only such case is 'errno' itself.; // Probably 'strerror'?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp:160,avoid,avoid,160,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ErrnoChecker.cpp,1,['avoid'],['avoid']
Safety,"// If 'unsafe math' or reassoc and nsz, fold lots of things.; // TODO: break out portions of the transformations below for which Unsafe is; // considered and which do not require both nsz and reassoc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:7,unsafe,unsafe,7,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['Unsafe', 'unsafe']","['Unsafe', 'unsafe']"
Safety,"// If (1) this is a sqrt libcall, (2) we can assume that NAN is not created; // (because NNAN or the operand arg must not be less than -0.0) and (2) we; // would not end up lowering to a libcall anyway (which could change the value; // of errno), then:; // (1) errno won't be set.; // (2) it is safe to convert this to an intrinsic call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:295,safe,safe,295,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['safe'],['safe']
Safety,"// If --gcc-install-dir= is specified, skip filesystem detection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:55,detect,detection,55,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['detect'],['detection']
Safety,// If --gcc-triple is specified use this instead of trying to; // auto-detect a triple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:71,detect,detect,71,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['detect'],['detect']
Safety,"// If -canonical-prefixes is set, GetExecutablePath will have resolved Path; // to the llvm driver binary, not clang. In this case, we need to use; // PrependArg which should be clang-*. Checking just CanonicalPrefixes is; // safe even in the normal case because PrependArg will be null so; // setPrependArg will be a no-op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:226,safe,safe,226,interpreter/llvm-project/clang/tools/driver/driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp,1,['safe'],['safe']
Safety,// If -fno-integrated-as is used add -Q to the darwin assembler driver to make; // sure it runs its system assembler not clang's integrated assembler.; // Applicable to darwin11+ and Xcode 4+. darwin<10 lacked integrated-as.; // FIXME: at run-time detect assembler capabilities or rely on version; // information forwarded by -target-assembler-version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:248,detect,detect,248,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['detect'],['detect']
Safety,"// If .set directive is supported, use it to reduce the number of; // relocations the assembler will generate for differences between; // local labels. This is only safe when the symbols are in the same; // section so we are restricting it to jumptable references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:165,safe,safe,165,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,1,['safe'],['safe']
Safety,"// If AVL is defined by a vsetvli with the same VLMAX, we can replace the; // AVL operand with the AVL of the defining vsetvli. We avoid general; // register AVLs to avoid extending live ranges without being sure we can; // kill the original source reg entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:131,avoid,avoid,131,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,2,['avoid'],['avoid']
Safety,"// If Cond is an icmp and all users of V except for BranchOrSelect is a; // branch, negate the icmp predicate and swap the branch targets and avoid; // inserting an Xor to negate Cond.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:142,avoid,avoid,142,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['avoid'],['avoid']
Safety,"// If ConvertRHS is false, we want to leave the caller's RHS untouched. Sadly,; // we can't avoid *all* modifications at the moment, so we need some somewhere; // to put the updated value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:92,avoid,avoid,92,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,"// If DefMI defines CPSR and it is not dead, it's obviously not safe; // to delete DefMI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:64,safe,safe,64,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['safe'],['safe']
Safety,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:62,redund,redundant,62,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['redund'],['redundant']
Safety,"// If E is a variable, then trace back through any aliases or redundant; // Phi nodes to find the canonical definition.; // The non-const version will simplify incomplete Phi nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:62,redund,redundant,62,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['redund'],['redundant']
Safety,// If EFLAGS are live and we don't have access to instructions that avoid; // clobbering EFLAGS we need to save and restore them. This in turn makes; // the EFLAGS no longer live.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:68,avoid,avoid,68,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['avoid'],['avoid']
Safety,"// If Exp is wildly out-of-scale, simply adding it to X.exponent will; // overflow; clamp it to a safe range before adding, but ensure that the range; // is large enough that the clamp does not change the result. The range we; // need to support is the difference between the largest possible exponent and; // the normalized exponent of half the smallest denormal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:98,safe,safe,98,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['safe'],['safe']
Safety,"// If ExtName is set (if the ""ExtName = Name"" syntax was used), overwrite; // Name with ExtName and clear ExtName. When only creating an import; // library and not linking, the internal name is irrelevant. This avoids; // cases where writeImportLibrary tries to transplant decoration from; // symbol decoration onto ExtName.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ToolDrivers/llvm-dlltool/DlltoolDriver.cpp:211,avoid,avoids,211,interpreter/llvm-project/llvm/lib/ToolDrivers/llvm-dlltool/DlltoolDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ToolDrivers/llvm-dlltool/DlltoolDriver.cpp,1,['avoid'],['avoids']
Safety,"// If F is internal and all of its uses are calls from a non-recursive; // functions, then none of its calls could in fact recurse without going; // through a function marked norecurse, and so we can mark this function too; // as norecurse. Note that the uses must actually be calls -- otherwise; // a pointer to this function could be returned from a norecurse function but; // this function could be recursively (indirectly) called. Note that this; // also detects if F is directly recursive as F is not yet marked as; // a norecurse function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:459,detect,detects,459,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['detect'],['detects']
Safety,"// If FastISel bails out, it could leave local value instructions behind; // that aren't used for anything. Detect and erase those.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp:108,Detect,Detect,108,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp,1,['Detect'],['Detect']
Safety,"// If FoldingReg has no non-debug use and it has no implicit def (it; // is not RLWINMO or RLWINM8o), it's safe to delete its def SrcMI.; // Otherwise keep it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:107,safe,safe,107,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['safe'],['safe']
Safety,"// If GEPI is not inbounds but UGEPI is inbounds, change UGEPI to not; // inbounds to avoid UB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"// If G_ICMP + G_BRCOND + G_BR were the only MIs in MBB, erase this MBB. It; // can be safely assumed, there are no breaks or phis directing into this; // MBB. However, we need to remove this MBB from the CFG graph. MBBs must be; // erased top-down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:87,safe,safely,87,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,1,['safe'],['safely']
Safety,"// If HazardRec is disabled, and each inst counts as one cycle, then; // advance CurCycle before ReleasePredecessors to avoid useless pushes to; // PendingQueue for schedulers that implement HasReadyFilter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:6,Hazard,HazardRec,6,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,2,"['Hazard', 'avoid']","['HazardRec', 'avoid']"
Safety,"// If I is freeze(undef), check its uses and fold it to a fixed constant.; // - or: pick -1; // - select's condition: if the true value is constant, choose it by making; // the condition true.; // - default: pick 0; //; // Note that this transform is intentionally done here rather than; // via an analysis in InstSimplify or at individual user sites. That is; // because we must produce the same value for all uses of the freeze -; // it's the reason ""freeze"" exists!; //; // TODO: This could use getBinopAbsorber() / getBinopIdentity() to avoid; // duplicating logic for binops at least.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:541,avoid,avoid,541,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['avoid'],['avoid']
Safety,"// If Idx is set, the operands at Idx and Idx+1 must be removed.; // We reuse the location to avoid expensive removeOperand calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:94,avoid,avoid,94,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['avoid'],['avoid']
Safety,"// If Left.ParameterCount is 0, then this submessage entry is not the; // first in its parent submessage, and we want to break before this entry.; // If Left.ParameterCount is greater than 0, then its parent submessage; // might contain 1 or more entries and we want to break before this entry; // if it contains at least 2 entries. We deal with this case later by; // detecting and breaking before the next entry in the parent submessage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:369,detect,detecting,369,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['detect'],['detecting']
Safety,"// If LogicNonShiftReg is the same to Shift1Base, and shift1 const is the same; // to MatchInfo.Shift2 const, CSEMIRBuilder will reuse the old shift1 when; // build shift2. So, if we erase MatchInfo.Shift2 at the end, actually we; // remove old shift1. And it will cause crash later. So erase it earlier to; // avoid the crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:311,avoid,avoid,311,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['avoid'],['avoid']
Safety,"// If M is the module we're parsing, it should be usable. This covers the; // private module fragment. The private module fragment is usable only if; // it is within the current module unit. And it must be the current; // parsing module unit if it is within the current module unit according; // to the grammar of the private module fragment. NOTE: This is covered by; // the following condition. The intention of the check is to avoid string; // comparison as much as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:430,avoid,avoid,430,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['avoid'],['avoid']
Safety,"// If MI only demands that VL has the same zeroness, we only need to set the; // AVL if the zeroness differs. This removes a vsetvli entirely if the types; // match or allows use of cheaper avl preserving variant if VLMAX doesn't; // change. If VLMAX might change, we couldn't use the 'vsetvli x0, x0, vtype""; // variant, so we avoid the transform to prevent extending live range of an; // avl register operand.; // TODO: We can probably relax this for immediates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:328,avoid,avoid,328,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['avoid'],['avoid']
Safety,"// If MI stores a value known at compile-time, and the value is within a range; // that avoids using constant-extenders, replace it with a store-immediate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:88,avoid,avoids,88,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['avoid'],['avoids']
Safety,"// If MI's uses have special allocation requirement, don't allow; // any use registers to be changed. Also assume all registers; // used in a call must not be changed (ABI).; // Inline Assembly register uses also cannot be safely changed.; // FIXME: The issue with predicated instruction is more complex. We are being; // conservatively here because the kill markers cannot be trusted after; // if-conversion:; // %r6 = LDR %sp, %reg0, 92, 14, %reg0; mem:LD4[FixedStack14]; // ...; // STR %r0, killed %r6, %reg0, 0, 0, %cpsr; mem:ST4[%395]; // %r6 = LDR %sp, %reg0, 100, 0, %cpsr; mem:LD4[FixedStack12]; // STR %r0, killed %r6, %reg0, 0, 14, %reg0; mem:ST4[%396](align=8); //; // The first R6 kill is not really a kill since it's killed by a predicated; // instruction which may not be executed. The second R6 def may or may not; // re-define R6 so it's not safe to change it since the last R6 use cannot be; // changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:223,safe,safely,223,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,2,['safe'],"['safe', 'safely']"
Safety,"// If MemorySSA has determined that one of EarlierInst or LaterInst does not; // read/write memory, then we can safely return true here.; // FIXME: We could be more aggressive when checking doesNotAccessMemory(),; // onlyReadsMemory(), mayReadFromMemory(), and mayWriteToMemory() in this pass; // by also checking the MemorySSA MemoryAccess on the instruction. Initial; // experiments suggest this isn't worthwhile, at least for C/C++ code compiled; // with the default optimization pipeline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:112,safe,safely,112,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['safe'],['safely']
Safety,"// If N has two operands, where one has an input chain equal to the other,; // the 'other' chain is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,redund,redundant,100,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['redund'],['redundant']
Safety,"// If NaN is negative zero, we need to create a new NaN to avoid converting; // NaN to -Inf.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:59,avoid,avoid,59,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['avoid'],['avoid']
Safety,"// If NewReg is dead and NewReg's most recent def is not before; // AntiDepReg's kill, it's safe to replace AntiDepReg with NewReg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:92,safe,safe,92,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,1,['safe'],['safe']
Safety,"// If NewReg is dead and NewReg's most recent def is not before; // Regs's kill, it's safe to replace Reg with NewReg. We; // must also check all aliases of NewReg, because we can't define a; // register when any sub or super is already live.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp:86,safe,safe,86,interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AggressiveAntiDepBreaker.cpp,1,['safe'],['safe']
Safety,"// If Node dominates Block, and it already contains a spill, the spill in; // Block will be redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:92,redund,redundant,92,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['redund'],['redundant']
Safety,"// If NumThreads is not specified, auto-detect a good default.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:40,detect,detect,40,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['detect'],['detect']
Safety,"// If OP in PTEST(PG, OP(PG, ...)) has a flag-setting variant change the; // opcode so the PTEST becomes redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:105,redund,redundant,105,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['redund'],['redundant']
Safety,"// If OtherDest *is* BB, then BB is a basic block with a single conditional; // branch in it, where one edge (OtherDest) goes back to itself but the other; // exits. We don't *know* that the program avoids the infinite loop; // (even though that seems likely). If we do this xform naively, we'll end up; // recursively unpeeling the loop. Since we know that (after the xform is; // done) that the block *is* infinite if reached, we just make it an obviously; // infinite loop with no cond branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:199,avoid,avoids,199,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoids']
Safety,// If PLT must be avoided then the call should be via GOTPCREL.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp:18,avoid,avoided,18,interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,1,['avoid'],['avoided']
Safety,"// If PredND is FrameSetup, we should not pre-scheduled the node,; // or else, when bottom up scheduling, ADJCALLSTACKDOWN and; // ADJCALLSTACKUP may hold CallResource too long and make other; // calls can't be scheduled. If there's no other available node; // to schedule, the schedular will try to rename the register by; // creating copy to avoid the conflict which will fail because; // CallResource is not a real physical register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:344,avoid,avoid,344,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avoid'],['avoid']
Safety,"// If PrevConditionValues or ConditionValues is empty, don't split to avoid; // unnecessary splits at scopes with no branch/selects. If; // PrevConditionValues and ConditionValues don't intersect at all, split.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:70,avoid,avoid,70,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['avoid'],['avoid']
Safety,"// If R0 is in the operand where zero is special for the new instruction,; // it is unsafe to transform if the constant operand isn't that operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:84,unsafe,unsafe,84,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['unsafe'],['unsafe']
Safety,"// If Reg is not live-in to MBB, it means it must be live-in to some; // other PreMBB successor, and we can avoid the interference by splitting; // the edge.; //; // If Reg *is* live-in to MBB, the interference is inevitable and a copy; // is likely to be left after coalescing. If we are looking at a loop; // exiting edge, split it so we won't insert code in the loop, otherwise; // don't bother.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:108,avoid,avoid,108,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,1,['avoid'],['avoid']
Safety,"// If RegImm.Reg is modified by this instruction, then we cannot optimize; // past this instruction. If the register is already compressed, then it may; // possible to optimize a large offset in the current instruction - this; // will have been detected by the preceeding call to; // getRegImmPairPreventingCompression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:245,detect,detected,245,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,1,['detect'],['detected']
Safety,"// If SADDSAT/SSUBSAT is legal, compare results to detect overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:51,detect,detect,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['detect'],['detect']
Safety,"// If SE->isKnownPredicate can't prove the condition,; // we try the brute-force approach of subtracting; // and testing the difference.; // By testing with SE->isKnownPredicate first, we avoid; // the possibility of overflow when the arguments are constants.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:188,avoid,avoid,188,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['avoid'],['avoid']
Safety,// If SrcReg has no non-debug use it's safe to delete its def SrcMI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:39,safe,safe,39,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['safe'],['safe']
Safety,"// If Start is an immediate and End is a register, the trip count; // will be ""reg - imm"". Hexagon's ""subtract immediate"" instruction; // is actually ""reg + -imm"".; // If the loop IV is going downwards, i.e. if the bump is negative,; // then the iteration count (computed as End-Start) will need to be; // negated. To avoid the negation, just swap Start and End.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:318,avoid,avoid,318,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['avoid'],['avoid']
Safety,"// If Sym is a symbol for an object with instance variables that; // must be released, remove these obligations when the object escapes; // unless via a call to a system function. System functions are; // very unlikely to release instance variables on objects passed to them,; // and are frequently called on 'self' in -dealloc (e.g., to remove; // observers) -- we want to avoid false negatives from escaping on; // them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:374,avoid,avoid,374,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,1,['avoid'],['avoid']
Safety,"// If TheOnlySucc was BB's successor more than once, after transform it; // will be its successor only once. Remove redundant inputs from; // TheOnlySucc's Phis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:116,redund,redundant,116,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,1,['redund'],['redundant']
Safety,"// If True (default): write all training results (weights) as text files only;; // if False: write also in ROOT format (not available for all methods - will abort if not",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:157,abort,abort,157,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['abort'],['abort']
Safety,// If User is inside DestBB block and it is a PHINode then check; // incoming value. If incoming value is not from BB then this is; // a complex condition (e.g. preheaders) we want to avoid here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:184,avoid,avoid,184,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"// If V has multiple uses, then we would have to do more analysis to determine; // if this is safe. For example, the use could be in dynamically unreached; // code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:94,safe,safe,94,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['safe'],['safe']
Safety,"// If X is -1 or 0, then we have an opportunity to avoid constants required in; // the general case below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// If X/C can be simplified by the division-by-constant logic, lower; // X%C to the equivalent of X-X/C*C.; // Reuse the SDIVLike/UDIVLike combines - to avoid mangling nodes, the; // speculative DIV must not cause a DIVREM conversion. We guard against this; // by skipping the simplification if isIntDivCheap(). When div is not cheap,; // combine will not return a DIVREM. Regardless, checking cheapness here; // makes sense since the simplification results in fatter code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:153,avoid,avoid,153,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// If Zcmp extension is not supported, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:39,abort,abort,39,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,1,['abort'],['abort']
Safety,"// If `R` and `I` do not have the same offset, it is safe to add `R` since; // it must come after `I`. Otherwise:; // - If `R` is an insertion, `I` must not be an insertion since it would; // have come after `AtEnd`.; // - If `R` is not an insertion, `I` must be an insertion; otherwise, `R`; // and `I` would have overlapped.; // In either case, we can safely insert `R`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:53,safe,safe,53,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,2,['safe'],"['safe', 'safely']"
Safety,"// If `VF=vscale x N` is safe, then so is `VF=N`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:25,safe,safe,25,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['safe'],['safe']
Safety,"// If a BNE on the cmpxchg comparison result immediately follows the cmpxchg; // operation, it can be folded into the cmpxchg expansion by; // modifying the branch within 'LoopHead' (which performs the same; // comparison). This is a valid transformation because after altering the; // LoopHead's BNE destination, the BNE following the cmpxchg becomes; // redundant and and be deleted. In the case of a masked cmpxchg, an; // appropriate AND and BNE must be matched.; //; // On success, returns true and deletes the matching BNE or AND+BNE, sets the; // LoopHeadBNETarget argument to the target that should be used within the; // loop head, and removes that block as a successor to MBB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp:356,redund,redundant,356,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVExpandAtomicPseudoInsts.cpp,1,['redund'],['redundant']
Safety,"// If a MBB does not dominate loop exiting blocks then it may not safe; // to hoist loads from this block.; // Tri-state: 0 - false, 1 - true, 2 - unknown",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:66,safe,safe,66,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['safe'],['safe']
Safety,"// If a VMLA.F is followed by an VADD.F or VMUL.F with no RAW hazard, the; // VADD.F or VMUL.F will stall 4 cycles before issue. The 4 cycle stall; // preserves the in-order retirement of the instructions.; // Look at the next few instructions, if *most* of them can cause hazards,; // then the scheduler can't *fix* this, we'd better break up the VMLA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:62,hazard,hazard,62,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,2,['hazard'],"['hazard', 'hazards']"
Safety,"// If a block's instruction doesn't always pass the control to its successor; // instruction, mark the block as having implicit control flow. We use them; // to avoid wrong assumptions of sort ""if A is executed and B post-dominates; // A, then B is also executed"". This is not true is there is an implicit; // control flow instruction (e.g. a guard) between them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp:161,avoid,avoid,161,interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionPrecedenceTracking.cpp,1,['avoid'],['avoid']
Safety,"// If a branch is predictable, an out-of-order CPU can avoid blocking on its; // comparison condition. If the compare has more than one use, there's; // probably another cmov or setcc around, so it's not worth emitting a branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:18,predict,predictable,18,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,2,"['avoid', 'predict']","['avoid', 'predictable']"
Safety,"// If a constant has operands, enumerate them. This makes sure that if a; // constant has uses (for example an array of const ints), that they are; // inserted also.; // We prefer to enumerate them with values before we enumerate the user; // itself. This makes it more likely that we can avoid forward references; // in the reader. We know that there can be no cycles in the constants; // graph that don't go through a global variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:289,avoid,avoid,289,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,2,['avoid'],['avoid']
Safety,// If a counter has been maxed out avoid overflow by waiting for; // MAX(CounterType) - 1 instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:35,avoid,avoid,35,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['avoid'],['avoid']
Safety,"// If a field assignment is detected, remove the field from the; // uninitiailized field set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:28,detect,detected,28,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['detect'],['detected']
Safety,"// If a file does not exist, one of the vFileswHists; // will be a vector of length 0. Detect that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx:87,Detect,Detect,87,tree/treeplayer/src/TSimpleAnalysis.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSimpleAnalysis.cxx,1,['Detect'],['Detect']
Safety,"// If a fixed length vector operation has no side effects when applied to; // undefined elements, we can safely use scalable vectors to perform the same; // operation without needing to worry about predication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:105,safe,safely,105,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['safe'],['safely']
Safety,"// If a function has a trailing call, indent all parameters from the; // opening parenthesis. This avoids confusing indents like:; // OuterFunction(InnerFunctionCall( // break; // ParameterToInnerFunction)) // break; // .SecondInnerFunctionCall();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:99,avoid,avoids,99,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['avoid'],['avoids']
Safety,"// If a function is marked as arm_locally_streaming, then the runtime value of; // vscale in the prologue/epilogue is different the runtime value of vscale; // in the function's body. To avoid having to consider multiple vscales,; // we can use `addsvl` to allocate any scalable stack-slots, which under; // most circumstances will be only locals, not callee-save slots.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:187,avoid,avoid,187,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// If a function scope is available, set it on the line 0 location. When; // hoisting a call to a predecessor block, using the function scope avoids; // making it look like the callee was reached earlier than it should be.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:142,avoid,avoids,142,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['avoid'],['avoids']
Safety,"// If a line-comment ends with `\`, the next line continues the comment,; // whether or not it starts with `//`. This is confusing and triggers; // -Wcomment.; // Avoid introducing multiline comments by not allowing a break right; // after '\'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:163,Avoid,Avoid,163,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['Avoid'],['Avoid']
Safety,"// If a memset intrinsic gets inlined by the code gen, we will miss races on it.; // So, we either need to ensure the intrinsic is not inlined, or instrument it.; // We do not instrument memset/memmove/memcpy intrinsics (too complicated),; // instead we simply replace them with regular function calls, which are then; // intercepted by the run-time.; // Since tsan is running after everyone else, the calls should not be; // replaced back with intrinsics. If that becomes wrong at some point,; // we will need to call e.g. __tsan_memset to avoid the intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:541,avoid,avoid,541,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['avoid'],['avoid']
Safety,"// If a non-zero global is <= 32 bytes, always use a memcpy. If it is large,; // do it if it will require 6 or fewer scalar stores.; // TODO: Should budget depends on the size? Avoiding a large global warrants; // plopping in more stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp:177,Avoid,Avoiding,177,interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDecl.cpp,1,['Avoid'],['Avoiding']
Safety,"// If a positive value is specified, we are going to use the LBR in; // latency-mode.; //; // Note:; // - A small value is preferred, but too low a value could result in; // throttling.; // - A prime number is preferred to avoid always skipping certain blocks.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp:223,avoid,avoid,223,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/X86/Target.cpp,1,['avoid'],['avoid']
Safety,"// If a potentially clobbering instruction comes before the load,; // we can still safely sink the load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:83,safe,safely,83,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['safe'],['safely']
Safety,"// If a stack probe will be emitted, spill R4 and LR, since they are; // clobbered by the stack probe call.; // This estimate should be a safe, conservative estimate. The actual; // stack probe is enabled based on the size of the local objects;; // this estimate also includes the varargs store size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:138,safe,safe,138,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['safe'],['safe']
Safety,"// If a store dominates all exit blocks, it is safe to sink.; // As explained above, if an exit block was executed, a dominating; // store must have been executed at least once, so we are not; // introducing stores on paths that did not have them.; // Note that this only looks at explicit exit blocks. If we ever; // start sinking stores into unwind edges (see above), this will break.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:47,safe,safe,47,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safe']
Safety,"// If a timeout has been specified extract the value and try to apply it (it requires; // support for asynchronous open, though; the following is completely transparent if; // such support if not available for the required protocol)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:8,timeout,timeout,8,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['timeout'],['timeout']
Safety,"// If all divisors are ones, we will prefer to avoid the fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// If all lanes are tautological (either all divisors are ones, or divisor; // is not greater than the constant we are comparing with),; // we will prefer to avoid the fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:158,avoid,avoid,158,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// If all of the calls in F are identifiable and are to norecurse functions, F; // is norecurse. This check also detects self-recursion as F is not currently; // marked norecurse, so any called from F to F will not be marked norecurse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:113,detect,detects,113,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['detect'],['detects']
Safety,"// If all our successors anticipate a value, do the insert.; // NOTE: It's possible that not all predecessors of our successor provide the; // correct value. This can occur on critical edges. If we don't split the; // critical edge we'll also have a write vxrm in the succesor that is; // redundant with this one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp:289,redund,redundant,289,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertWriteVXRM.cpp,1,['redund'],['redundant']
Safety,"// If all predecessors of Succ have been eliminated by; // FoldReturnIntoUncondBranch, delete it. It is important to empty it,; // because the ret instruction in there is still using a value which; // eliminateCall will attempt to remove. This block can only contain; // instructions that can't have uses, therefore it is safe to remove.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:322,safe,safe,322,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,1,['safe'],['safe']
Safety,"// If all the diagnostics and subgroups have been marked as being; // covered by -Wpedantic, increment the count of parent groups. Once the; // group's count is equal to the number of subgroups and diagnostics in; // that group, we can safely add this group to -Wpedantic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp:236,safe,safely,236,interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangDiagnosticsEmitter.cpp,1,['safe'],['safely']
Safety,"// If all the regs are reserved, return raw RegPressureSetLimit.; // One example is VRSAVERC in PowerPC.; // Avoid returning zero, getRegPressureSetLimit(Idx) assumes computePSetLimit; // return non-zero value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp:109,Avoid,Avoid,109,interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterClassInfo.cpp,1,['Avoid'],['Avoid']
Safety,"// If all users of instruction are going to be vectorized and this; // instruction itself is not going to be vectorized, consider this; // instruction as dead and remove its cost from the final cost of the; // vectorized tree.; // Also, avoid adjusting the cost for extractelements with multiple uses; // in different graph entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:237,avoid,avoid,237,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"// If all users only use the lower bits, this sext.w is redundant.; // Or if all definitions reaching MI sign-extend their output,; // then sext.w is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp:56,redund,redundant,56,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVOptWInstrs.cpp,2,['redund'],['redundant']
Safety,"// If an aggregate may end up fully in registers, we do not; // use the ByVal method, but pass the aggregate as array.; // This is usually beneficial since we avoid forcing the; // back-end to store the argument to memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:159,avoid,avoid,159,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,1,['avoid'],['avoid']
Safety,"// If an explicit sysroot is set, that will be used and we shouldn't try to; // detect anything else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:80,detect,detect,80,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,1,['detect'],['detect']
Safety,"// If an identical load doesn't depends on any local instructions, it can; // be safely moved to PredBB.; // Also check for the implicit control flow instructions. See the comments; // in PerformLoadPRE for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:81,safe,safely,81,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['safe'],['safely']
Safety,"// If an indexed friend did not match the current entry and if this reader; // is associated with that friend (i.e. its active read entry is -1), avoid; // reading altogether",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:146,avoid,avoid,146,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['avoid'],['avoid']
Safety,"// If any DBG_PHIs referred to a location we didn't understand, don't try to; // compute a value. There might be scenarios where we could recover a value; // for some range of DBG_INSTR_REFs, but at this point we can have high; // confidence that we've seen a bug.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:138,recover,recover,138,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['recover'],['recover']
Safety,"// If any node was created after N, then we cannot safely remap it because; // it might already be in use by another node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/ItaniumManglingCanonicalizer.cpp:51,safe,safely,51,interpreter/llvm-project/llvm/lib/ProfileData/ItaniumManglingCanonicalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/ItaniumManglingCanonicalizer.cpp,1,['safe'],['safely']
Safety,// If any of M's operands demand more bits than MinBW then M cannot be; // performed safely in MinBW.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:85,safe,safely,85,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,1,['safe'],['safely']
Safety,"// If any of the destination registers in the bundle of copies alias any of; // the source registers, try to schedule the instructions to avoid any; // clobbering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:138,avoid,avoid,138,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,1,['avoid'],['avoid']
Safety,"// If any of these registers is available in the MBB, but also a live out of; // the block, then we know outlining is unsafe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:118,unsafe,unsafe,118,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['unsafe'],['unsafe']
Safety,"// If any possible shift value won't fit in the prefered type, just use; // something safe. Assume it will be legalized when the shift is expanded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:86,safe,safe,86,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['safe'],['safe']
Safety,"// If any subunits are used by the instruction, report that the; // subunits of the resource group are available at the first cycle; // in which the unit is available, effectively removing the group; // record from hazarding and basing the hazarding decisions on the; // subunit records. Otherwise, choose the first available instance; // from among the subunits. Specifications which assign cycles to; // both the subunits and the group or which use an unbuffered; // group with buffered subunits will appear to schedule; // strangely. In the first case, the additional cycles for the; // group will be ignored. In the second, the group will be; // ignored entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:215,hazard,hazarding,215,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['hazard'],['hazarding']
Safety,// If bitcasts to larger elements we might lose track of undefs - don't; // allow any to be safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:92,safe,safe,92,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['safe'],['safe']
Safety,"// If both OpA and OpB are adds with NSW/NUW and with one of the operands; // being the same, we can guarantee that the transformation is safe if we can; // prove that OpA won't overflow when Ret added to the other operand of OpA.; // For example:; // %tmp7 = add nsw i32 %tmp2, %v0; // %tmp8 = sext i32 %tmp7 to i64; // ...; // %tmp11 = add nsw i32 %v0, 1; // %tmp12 = add nsw i32 %tmp2, %tmp11; // %tmp13 = sext i32 %tmp12 to i64; //; // Both %tmp7 and %tmp12 have the nsw flag and the first operand is %tmp2.; // It's guaranteed that adding 1 to %tmp7 won't overflow because %tmp11 adds; // 1 to %v0 and both %tmp11 and %tmp12 have the nsw flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:138,safe,safe,138,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,1,['safe'],['safe']
Safety,"// If both V1 and V2 are in use and we can use a direct blend or an unpack,; // do so. This avoids using them to handle blends-with-zero which is; // important as a single pshufb is significantly faster for that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:92,avoid,avoids,92,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// If both induction types are less than the maximum legal integer width,; // promote both to the widest type available so we know calculating; // (OuterTripCount * InnerTripCount) as the new trip count is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:206,safe,safe,206,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,1,['safe'],['safe']
Safety,// If both inputs are splats of the same value then we can safely merge this; // to a single BUILD_VECTOR with undef elements based on the shuffle mask.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,safe,safely,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safely']
Safety,"// If both inputs for this element are either constant or undef and match; // the element type, compute the constant/undef result for this element of; // the vector.; // TODO: Ideally we would use FoldConstantArithmetic() here, but that does; // not handle FP constants. The code within getNode() should be refactored; // to avoid the danger of creating a bogus temporary node here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:325,avoid,avoid,325,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// If both simdlen and safelen clauses are specified, the value of the; // simdlen parameter must be less than or equal to the value of the safelen; // parameter. Therefore, use safelen only in the absence of simdlen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:23,safe,safelen,23,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,3,['safe'],['safelen']
Safety,"// If constant-expression is parsed unsuccessfully, recover by skipping; // current case statement (moving to the colon that ends it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:52,recover,recover,52,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['recover'],['recover']
Safety,"// If counting zeros is expensive, try to avoid it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"// If crash recovery is disabled, do nothing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:12,recover,recovery,12,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['recover'],['recovery']
Safety,"// If default-init fails, attach a recovery-expr initializer to track; // that initialization was attempted and failed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:35,recover,recovery-expr,35,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery-expr']
Safety,"// If destructor is trivial, we can avoid the extra copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:36,avoid,avoid,36,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['avoid'],['avoid']
Safety,"// If disassembly succeeds, we try to resolve the target address; // (jump target or memory operand address) and print it to the; // right of the instruction.; //; // Otherwise, we don't print anything else so that we avoid; // analyzing invalid or incomplete instruction information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:218,avoid,avoid,218,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,1,['avoid'],['avoid']
Safety,"// If either SCEV or LoopInfo is not available for the function then we assume; // any cycle to be unbounded cycle.; // We use scc_iterator which uses Tarjan algorithm to find all the maximal; // SCCs.To detect if there's a cycle, we only need to find the maximal ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:204,detect,detect,204,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['detect'],['detect']
Safety,"// If either node is scheduling for latency, sort them by height/depth; // and latency.; // If neither instruction stalls (!LStall && !RStall) and HazardRecognizer; // is enabled, grouping instructions by cycle, then its height is already; // covered so only its depth matters. We also reach this point if both stall; // but have the same height.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNILPSched.cpp:147,Hazard,HazardRecognizer,147,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNILPSched.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNILPSched.cpp,1,['Hazard'],['HazardRecognizer']
Safety,"// If either the return value(s) or argument(s) are removed, then probably the; // function does not follow standard calling conventions anymore. Hence, add; // DW_CC_nocall to DISubroutineType to inform debugger that it may not be safe; // to call this function or try to interpret the return value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:232,safe,safe,232,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['safe'],['safe']
Safety,"// If even a predictable select is cheap, then a branch can't be cheaper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:13,predict,predictable,13,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['predict'],['predictable']
Safety,"// If every terminators is dominated by coro.destroy, we could know the; // corresponding coro.begin wouldn't escape.; //; // Otherwise hasEscapePath would decide whether there is any paths from; // coro.begin to Terminators which not pass through any of the; // coro.destroys.; //; // hasEscapePath is relatively slow, so we avoid to run it as much as; // possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:326,avoid,avoid,326,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,1,['avoid'],['avoid']
Safety,"// If every value used by the incoming DbgValue is available at block; // entry, ResolvedDbgOps will contain the machine locations/constants for; // those values and will be used to emit a debug location.; // If one or more values are not yet available, but will all be defined in; // this block, then LastUseBeforeDef will track the instruction index in; // this BB at which the last of those values is defined, DbgOps will; // contain the values that we will emit when we reach that instruction.; // If one or more values are undef or not available throughout this block,; // and we can't recover as an entry value, we set IsValueValid=false and; // skip this variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:591,recover,recover,591,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['recover'],['recover']
Safety,"// If exceptions are enabled, do not use parameter to avoid possible crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:54,avoid,avoid,54,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['avoid'],['avoid']
Safety,"// If exponent argument is very large, bring canceling RooMath::erfc() term inside exponent; // to avoid floating point over/underflows of intermediate calculations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooGExpModel.cxx:99,avoid,avoid,99,roofit/roofit/src/RooGExpModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooGExpModel.cxx,1,['avoid'],['avoid']
Safety,"// If found user is an insertelement, do not calculate extract cost but try; // to detect it as a final shuffled/identity match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:83,detect,detect,83,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['detect'],['detect']
Safety,"// If frame pointer elimination has been disabled, abort to avoid breaking the; // ABI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:51,abort,abort,51,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,2,"['abort', 'avoid']","['abort', 'avoid']"
Safety,"// If getUnderlyingObjects fails to find an identifiable object,; // getUnderlyingObjectsForCodeGen also fails for safety.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:115,safe,safety,115,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['safe'],['safety']
Safety,"// If given a uniform (i.e. non-varying) address, see if we can prove the; // access is safe within the loop w/o needing predication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:88,safe,safe,88,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['safe'],['safe']
Safety,"// If has pending forbidden slot, fill nop and recover reorder.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:47,recover,recover,47,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['recover'],['recover']
Safety,"// If highly predictable, branch form is more profitable, unless a; // predictable select is inexpensive in the target architecture.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:13,predict,predictable,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,2,['predict'],['predictable']
Safety,"// If icmp eq has users other than BranchInst and SelectInst, converting it to; // icmp slt/sgt would introduce more redundant LLVM IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:117,redund,redundant,117,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['redund'],['redundant']
Safety,"// If in read mode, uses the cached file status, if available, to avoid; // costly dc_stat() call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/dcache/src/TDCacheFile.cxx:66,avoid,avoid,66,io/dcache/src/TDCacheFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/dcache/src/TDCacheFile.cxx,1,['avoid'],['avoid']
Safety,"// If in the path to join the two instructions,; // there is another high latency instruction,; // or instructions colored for another block; // abort the merge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:145,abort,abort,145,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['abort'],['abort']
Safety,"// If input is integer, we want to print it into the code like one (i.e. avoid the unnecessary '.0000').",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h:73,avoid,avoid,73,roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooFit/Detail/CodeSquashContext.h,1,['avoid'],['avoid']
Safety,// If instruction is unsafe just return false.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:21,unsafe,unsafe,21,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['unsafe'],['unsafe']
Safety,"// If it fits within the safe region of the stack, just subtract.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp:25,safe,safe,25,interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DynAllocaExpander.cpp,1,['safe'],['safe']
Safety,"// If it is a DBG_VALUE describing a constant as:; // DBG_VALUE 0, ...; // we just don't consider such instructions as candidates; // for redundant removal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:138,redund,redundant,138,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,1,['redund'],['redundant']
Safety,"// If it is a load then check if it is guaranteed to execute by making sure; // that it dominates all exiting blocks. If it doesn't, then there is a path; // out of the loop which does not execute this load, so we can't hoist it.; // Loads from constant memory are safe to speculate, for example indexed load; // from a jump table.; // Stores and side effects are already checked by isSafeToMove.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:265,safe,safe,265,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['safe'],['safe']
Safety,"// If it is a non-anonymous struct, mark the type as being visited so that we; // don't recursively visit it. This is safe because we allow forward; // references of these in the bitcode reader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:118,safe,safe,118,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,2,['safe'],['safe']
Safety,"// If it is already predicated but we couldn't analyze its terminator, the; // latter might fallthrough, but we can't determine where to.; // Conservatively avoid if-converting again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:157,avoid,avoid,157,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['avoid'],['avoid']
Safety,"// If it is not beneficial to hoist all the BackCopies, simply remove; // redundant BackCopies in speed mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:74,redund,redundant,74,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['redund'],['redundant']
Safety,"// If it is not safe to hoist/sink all instructions in the; // pre-header, we cannot fuse these loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:16,safe,safe,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['safe'],['safe']
Safety,"// If it is safe to mark the global 'constant', do so now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:12,safe,safe,12,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['safe'],['safe']
Safety,"// If it overlaps no elements, then it is safe to process as padding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:42,safe,safe,42,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['safe'],['safe']
Safety,"// If it's a pass manager, don't emit a remark. (This hinges on the assumption; // that the only passes that return non-null with getAsPMDataManager are pass; // managers.) The reason we have to do this is to avoid emitting remarks for; // CGSCC passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:209,avoid,avoid,209,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,1,['avoid'],['avoid']
Safety,"// If it's a recoverable error, swallow it and retry the write.; //; // Ideally we wouldn't ever see EAGAIN or EWOULDBLOCK here, since; // raw_ostream isn't designed to do non-blocking I/O. However, some; // programs, such as old versions of bjam, have mistakenly used; // O_NONBLOCK. For compatibility, emulate blocking semantics by; // spinning until the write succeeds. If you don't want spinning,; // don't use O_NONBLOCK file descriptors with raw_ostream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:13,recover,recoverable,13,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,1,['recover'],['recoverable']
Safety,"// If it's an incomplete type, it could be a smart pointer; skip it.; // (We don't want to force template instantiation if we can avoid it,; // since that would alter the order in which templates are instantiated.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:130,avoid,avoid,130,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['avoid'],['avoid']
Safety,"// If it's free to do so, push canonicalizes further up the source, which may; // find a canonical source.; //; // TODO: More opcodes. Note this is unsafe for the _ieee minnum/maxnum for; // sNaNs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:148,unsafe,unsafe,148,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['unsafe'],['unsafe']
Safety,// If it's not safe to create a while loop then don't force it and create a; // do-while loop instead,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp:15,safe,safe,15,interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/HardwareLoops.cpp,1,['safe'],['safe']
Safety,"// If it's not safe to move defs of the register class, then abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:15,safe,safe,15,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,2,"['abort', 'safe']","['abort', 'safe']"
Safety,"// If it's safe to speculatively execute, then it should not have side; // effects; therefore, it's safe to sink and possibly *not* execute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:11,safe,safe,11,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,2,['safe'],['safe']
Safety,"// If it's using a non-loop-invariant register, then it's obviously not; // safe to hoist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:76,safe,safe,76,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['safe'],['safe']
Safety,"// If it's using a non-loop-invariant register, then it's obviously; // not safe to hoist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:76,safe,safe,76,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['safe'],['safe']
Safety,"// If lookup didn't find anything, we treat the name as a template-name; // anyway. C++20 requires this, and in prior language modes it improves; // error recovery. But before we commit to this, check that we actually; // have something that looks like a template-argument-list next.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:155,recover,recovery,155,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recovery']
Safety,"// If mini is a minimal signed value, absolute value of it is greater; // than the maximal signed value. In order to avoid these; // complications, we simply return the whole range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:117,avoid,avoid,117,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['avoid'],['avoid']
Safety,"// If name lookup found nothing and we guessed that this was a template name,; // double-check before committing to that interpretation. C++20 requires that; // we interpret this as a template-id if it can be, but if it can't be, then; // this is an error recovery case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:256,recover,recovery,256,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['recover'],['recovery']
Safety,"// If neither instruction stalls (!LStall && !RStall) and HazardRecognizer; // is enabled, grouping instructions by cycle, then its height is already; // covered so only its depth matters. We also reach this point if both stall; // but have the same height.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:58,Hazard,HazardRecognizer,58,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Hazard'],['HazardRecognizer']
Safety,"// If new instruction dominates an existing one, mark existing one as; // redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:74,redund,redundant,74,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redund'],['redundant']
Safety,"// If no `WarningGadget`s ever matched, there is no unsafe operations in the; // function under the analysis. No need to fix any Fixables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:52,unsafe,unsafe,52,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['unsafe'],['unsafe']
Safety,"// If no `WarningGadget`s ever matched, there is no unsafe operations in the; // function under the analysis. Thus, it early returns here as there is; // nothing needs to be fixed.; //; // Note this claim is based on the assumption that there is no unsafe; // variable whose declaration is invisible from the analyzing function.; // Otherwise, we need to consider if the uses of those unsafe varuables needs; // fix.; // So far, we are not fixing any global variables or class members. And,; // lambdas will be analyzed along with the enclosing function. So this early; // return is correct for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:52,unsafe,unsafe,52,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,3,['unsafe'],['unsafe']
Safety,"// If no diagnostic has been emitted yet, likely because we are doing a; // tentative lexing, we do not want to recover here to make sure the token; // will not be incorrectly considered valid. This function will be called; // again and a diagnostic emitted then.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:112,recover,recover,112,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['recover'],['recover']
Safety,"// If no exact entry found, try just the major key version. Only do so when; // a minor version number is present, to avoid recursing indefinitely into; // the major-only check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DarwinSDKInfo.cpp:118,avoid,avoid,118,interpreter/llvm-project/clang/lib/Basic/DarwinSDKInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DarwinSDKInfo.cpp,1,['avoid'],['avoid']
Safety,"// If no hash symbol then iterate to detect symbol; // We Iterate only if BloomFilter and/or SymbolHashTable are not supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:37,detect,detect,37,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['detect'],['detect']
Safety,"// If non-empty, holds the name of a file in which to write the list of; // oject files gold selected for inclusion in the link after symbol; // resolution (i.e. they had selected symbols). This will only be non-empty; // in the thinlto_index_only case. It is used to identify files, which may; // have originally been within archive libraries specified via; // --start-lib/--end-lib pairs, that should be included in the final; // native link process (since intervening function importing and inlining; // may change the symbol resolution detected in the final link and which; // files to include out of --start-lib/--end-lib libraries as a result).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp:540,detect,detected,540,interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/gold/gold-plugin.cpp,1,['detect'],['detected']
Safety,"// If non-null, this field points to the associated unsafe use count stored in; // the DevirtModule::NumUnsafeUsesForTypeTest map below. See the description; // of that field for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:52,unsafe,unsafe,52,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['unsafe'],['unsafe']
Safety,"// If none of the attributes applied, that's fine, we can recover by; // returning the substatement directly instead of making an AttributedStmt; // with no attributes on it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:58,recover,recover,58,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['recover'],['recover']
Safety,"// If none of the successors leads back in a loop, we're on an exit/abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:68,abort,abort,68,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['abort'],['abort']
Safety,"// If not actually striding (add x, 0.0), avoid touching the code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['avoid'],['avoid']
Safety,"// If not provably safe, use a select to form a safe divisor before widening the; // div/rem operation itself. Otherwise fall through to general handling below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:19,safe,safe,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['safe'],['safe']
Safety,"// If not timed-out, exit if not stopped or not aborted; // (player exits status is finished in such a case); otherwise,; // we still need to collect the partial output info",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:48,abort,aborted,48,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,2,['abort'],['aborted']
Safety,"// If onSymbolStart returns Fail, that means it identified some kind; // of special data at this address, but wasn't able to disassemble it; // meaningfully. So we fall back to disassembling the failed region; // as bytes, assuming that the target detected the failure before; // printing anything.; //; // Return values Success or SoftFail (i.e no 'real' failure) are; // expected to mean that the target has emitted its own output.; //; // Either way, 'Size' will have been set to the amount of data; // covered by whatever prologue the target identified. So we advance; // our own position to beyond that. Sometimes that will be the entire; // distance to the next symbol, and sometimes it will be just a; // prologue and we should start disassembling instructions from where; // it left off.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:248,detect,detected,248,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,1,['detect'],['detected']
Safety,"// If one is and the other isn't, it isn't strictly safe but we can fake; // this result if necessary for performance. This does not appear to be; // a common problem in practice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:52,safe,safe,52,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['safe'],['safe']
Safety,"// If one is based on an indirect global and the other isn't, it isn't; // strictly safe but we can fake this result if necessary for performance.; // This does not appear to be a common problem in practice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:84,safe,safe,84,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['safe'],['safe']
Safety,"// If one of the two inputs is undefined then replicate the other one,; // in order to avoid using another register unnecessarily.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:87,avoid,avoid,87,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If our only note is the usual ""invalid subexpression"" note, just point; // the caret at its location rather than producing an essentially; // redundant note.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:145,redund,redundant,145,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['redund'],['redundant']
Safety,"// If our type is followed by an identifier and either ':' or ']', then; // this is probably an Objective-C message send where the leading '[' is; // missing. Recover as if that were the case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:159,Recover,Recover,159,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['Recover'],['Recover']
Safety,"// If point is on one edge, fn may be very small and the normal does not make sense - avoid divzero",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx:86,avoid,avoid,86,geom/geom/src/TGeoArb8.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx,1,['avoid'],['avoid']
Safety,"// If prepExitInclude() detects a problem with the preprocessing; // control stack, it will return false. Pretend that we reached; // the final EOF and stop lexing more tokens by returning false; // to LexToken().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp:24,detect,detects,24,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.cpp,1,['detect'],['detects']
Safety,"// If proposed step less than safety, nothing to check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:30,safe,safety,30,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safety']
Safety,"// If recovery created an ambiguity, just bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:6,recover,recovery,6,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recovery']
Safety,"// If responsible for the TFTP connection, remove it from the; // socket global list to avoid problems with double deletion; // at final cleanup",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx:88,avoid,avoid,88,net/net/src/TNetFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx,1,['avoid'],['avoid']
Safety,"// If result status is < 0, then the driver command signalled an error.; // If result status is 70, then the driver command reported a fatal error.; // On Windows, abort will return an exit code of 3. In these cases,; // generate additional diagnostic information if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:164,abort,abort,164,interpreter/llvm-project/clang/tools/driver/driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp,1,['abort'],['abort']
Safety,"// If running with -E, treat as a C input (this changes the; // builtin macros, for example). This may be overridden by -ObjC; // below.; //; // Otherwise emit an error but still use a valid type to avoid; // spurious errors (e.g., no inputs).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:199,avoid,avoid,199,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['avoid'],['avoid']
Safety,"// If so, and the statement doesn't contain a label, then we do not need to; // generate actual code. This is safe because (1) the current point is; // unreachable, so we don't need to execute the code, and (2) we've already; // handled the statements which update internal data structures (like the; // local variable map) which could be used by subsequent statements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:110,safe,safe,110,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['safe'],['safe']
Safety,"// If so, this load is partially redundant. Remember this info so that we; // can create a PHI node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:33,redund,redundant,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redund'],['redundant']
Safety,"// If some of the uses of IntA.reg is already coalesced away, return false.; // It's not possible to determine whether it's safe to perform the coalescing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:124,safe,safe,124,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['safe'],['safe']
Safety,"// If some transformation has introduced an additional definition of; // this register (breaking SSA), we can safely convert this def to; // a def of an invalid register as the instruction is going away.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:110,safe,safely,110,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['safe'],['safely']
Safety,"// If source is an exiting block, we know the exit edge is dynamically dead; // in the vector loop, and thus we don't need to restrict the mask. Avoid; // adding uses of an otherwise potentially dead instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:145,Avoid,Avoid,145,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['Avoid'],['Avoid']
Safety,"// If stats are enabled, inform StatInfo that this statistic should be; // printed.; // llvm_shutdown calls destructors while holding the ManagedStatic mutex.; // These destructors end up calling PrintStatistics, which takes StatLock.; // Since dereferencing StatInfo and StatLock can require taking the; // ManagedStatic mutex, doing so with StatLock held would lead to a lock; // order inversion. To avoid that, we dereference the ManagedStatics first,; // and only take StatLock afterwards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Statistic.cpp:402,avoid,avoid,402,interpreter/llvm-project/llvm/lib/Support/Statistic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Statistic.cpp,1,['avoid'],['avoid']
Safety,"// If substitution fails, the default argument is set to a; // RecoveryExpr that wraps the uninstantiated default argument so; // that downstream diagnostics are omitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:63,Recover,RecoveryExpr,63,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,3,['Recover'],['RecoveryExpr']
Safety,"// If that base is not DWORD aligned, it's not safe to perform the following; // transforms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULateCodeGenPrepare.cpp:47,safe,safe,47,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULateCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULateCodeGenPrepare.cpp,1,['safe'],['safe']
Safety,"// If that failed, give an error and recover using __strong. __strong; // is the option most likely to prevent spurious second-order diagnostics,; // like when binding a reference to a field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:37,recover,recover,37,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['recover'],['recover']
Safety,"// If that failed, try to recover with a call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:26,recover,recover,26,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Safety,"// If the ""Other"" register is live at a slot Idx, test whether Reg can; // safely be merged with it, or should be marked undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:75,safe,safely,75,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['safe'],['safely']
Safety,"// If the '##' came from expanding an argument, turn it into 'unknown'; // to avoid pasting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:78,avoid,avoid,78,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,2,['avoid'],['avoid']
Safety,"// If the 'InlineParams' in Declarator is unused and big enough, put our; // parameter list there (in an effort to avoid new/delete traffic). If it; // is already used (consider a function returning a function pointer) or too; // small (function with too many parameters), go to the heap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp:115,avoid,avoid,115,interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/DeclSpec.cpp,1,['avoid'],['avoid']
Safety,"// If the AVL is zero, operand 0 will be returned. So it's not safe to fold.; // FIXME: We might be able to improve this if operand 0 is undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:63,safe,safe,63,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['safe'],['safe']
Safety,"// If the CFG was constructed without elements for temporary destructors; // and the just-called constructor created a temporary object then; // stop exploration if the temporary object has a noreturn constructor.; // This can lose coverage because the destructor, if it were present; // in the CFG, would be called at the end of the full expression or; // later (for life-time extended temporaries) -- but avoids infeasible; // paths when no-return temporary destructors are used for assertions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:407,avoid,avoids,407,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['avoid'],['avoids']
Safety,"// If the ISD::CopyToReg has a glue operand, we conservatively assume it; // isn't safe to perform a tail call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp:83,safe,safe,83,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchISelLowering.cpp,2,['safe'],['safe']
Safety,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:1469,safe,safe,1469,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['safe'],['safe']
Safety,"// If the Lo in (ADD_LO hi, lo) is a global variable's address; // (its low part, really), then we can rely on the alignment of that; // variable to provide a margin of safety before low part can overflow; // the 12 bits of the load/store offset. Check if CVal falls within; // that margin; if so (low part + CVal) can't overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:169,safe,safety,169,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['safe'],['safety']
Safety,"// If the MaskedOff value and the Mask are the same value use; // vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt; // This avoids needing to copy v0 to vd before starting the next sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:119,avoid,avoids,119,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['avoid'],['avoids']
Safety,"// If the RHS is a constant in the range [-2049, 0) or (0, 2046], we can; // convert this to the equivalent of (set(u)ge X, C+1) by using; // (xori (slti(u) X, C+1), 1). This avoids materializing a small constant; // in a register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:175,avoid,avoids,175,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// If the SRL is only used by a masking AND, we may be able to adjust; // the ExtVT to make the AND redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:100,redund,redundant,100,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['redund'],['redundant']
Safety,"// If the Terminator is some kind of ""exotic terminator"" that produces a; // value (such as InvokeInst, CallBrInst, or CatchSwitchInst) which the CHI; // uses, it is not safe to hoist the use above the def.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:170,safe,safe,170,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['safe'],['safe']
Safety,"// If the ToPromote set contains nodes that have uses outside of the set; // (except for the original INSERT_SUBREG), then abort the transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:123,abort,abort,123,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['abort'],['abort']
Safety,"// If the [input] type of comparison and select type are different, lets abort; // for now. We could try to compare constants with trunc/[zs]ext though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:73,abort,abort,73,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['abort'],['abort']
Safety,"// If the alloca is already scoped to something smaller than the whole; // function then there's no need to add redundant, less accurate markers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:112,redund,redundant,112,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['redund'],['redundant']
Safety,"// If the argument entered as an enclosing function parameter, skip it to; // avoid false positives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:78,avoid,avoid,78,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['avoid'],['avoid']
Safety,"// If the assumption has been disproven, remove any results that may have; // been based on this assumption. Do this after the Entry updates above to; // avoid iterator invalidation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:154,avoid,avoid,154,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['avoid'],['avoid']
Safety,"// If the atomicrmw's result is used by a single bit AND, we may use; // bts/btr/btc instruction for these operations.; // Note: InstCombinePass can cause a de-optimization here. It replaces the; // SETCC(And(AtomicRMW(P, power_of_2), power_of_2)) with LShr and Xor; // (depending on CC). This pattern can only use bts/btr/btc but we don't; // detect it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:344,detect,detect,344,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,"// If the available queue is empty, it is safe to reset MinAvailableCycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:42,safe,safe,42,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['safe'],['safe']
Safety,"// If the available queue is empty, it is safe to reset MinReadyCycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:42,safe,safe,42,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['safe'],['safe']
Safety,"// If the backedge is guarded by a comparison with the pre-inc value the; // addrec is safe. Also, if the entry is guarded by a comparison with the; // start value and the backedge is guarded by a comparison with the post-inc; // value, the addrec is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:87,safe,safe,87,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,4,['safe'],['safe']
Safety,"// If the base type is an atomic type, this access is undefined behavior per; // C11 6.5.2.3p5. Instead of giving a typecheck error, we'll warn the user; // about the UB and recover by converting the atomic lvalue into a non-atomic; // lvalue. Because this is inherently unsafe as an atomic operation, the; // warning defaults to an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:174,recover,recover,174,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,2,"['recover', 'unsafe']","['recover', 'unsafe']"
Safety,"// If the bit convert changed the number of elements, it is unsafe; // to examine the mask.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:60,unsafe,unsafe,60,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['unsafe'],['unsafe']
Safety,"// If the bit set is sufficiently small, we can avoid a load by bit testing; // a constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:48,avoid,avoid,48,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['avoid'],['avoid']
Safety,"// If the bitcast would be redundant, replace all uses with the source; // register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp:27,redund,redundant,27,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVPreLegalizer.cpp,1,['redund'],['redundant']
Safety,"// If the branch is non-unpredictable, and is predicted to *not* branch to; // the `then` block, then avoid speculating it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:46,predict,predicted,46,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,2,"['avoid', 'predict']","['avoid', 'predicted']"
Safety,"// If the branch is non-unpredictable, see if we either predictably jump to; // the merge bb (if we have only a single 'then' block), or if we predictably; // jump to one specific 'then' block (if we have two of them).; // It isn't beneficial to speculatively execute the code; // from the block that we know is predictably not entered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:56,predict,predictably,56,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,3,['predict'],['predictably']
Safety,"// If the buffer contains preprocessor directives, we do more fine-grained; // rewrites. This is intended to fix code that looks like (which occurs in; // NSURL.h, for example):; //; // #ifdef XYZ; // @interface Foo : NSObject; // #else; // @interface FooBar : NSObject; // #endif; // {; // int i;; // }; // @end; //; // This clause is segregated to avoid breaking the common case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp:350,avoid,avoid,350,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteObjC.cpp,1,['avoid'],['avoid']
Safety,"// If the buffer isn't large enough, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:37,abort,abort,37,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['abort'],['abort']
Safety,"// If the builtin has been declared explicitly with an assembler label,; // disable the specialized emitting below. Ideally we should communicate the; // rename in IR, or at least avoid generating the intrinsic calls that are; // likely to get lowered to the renamed library functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:180,avoid,avoid,180,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['avoid'],['avoid']
Safety,"// If the call instruction is bundled, we can only emit a check safely if; // it's the first instruction in the bundle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp:64,safe,safely,64,interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/KCFI.cpp,1,['safe'],['safely']
Safety,"// If the call is known to never store to the pointer, and if this is a; // load query, we can safely ignore it (scan past it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:95,safe,safely,95,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['safe'],['safely']
Safety,"// If the call result is in ST0 / ST1, it needs to be popped off the x87; // stack. Therefore, if it's not used by the call it is not safe to optimize; // this into a sibcall.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:134,safe,safe,134,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['safe'],['safe']
Safety,"// If the called function is readonly, then it could not mutate the caller's; // copy of the byval'd memory. In this case, it is safe to elide the copy and; // temporary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:129,safe,safe,129,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['safe'],['safe']
Safety,// If the callee saved info is invalid we have to default to true for safety.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:70,safe,safety,70,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['safe'],['safety']
Safety,// If the callee saved register is spilled to a register instead of the; // stack then the spill no longer uses the stack pointer.; // This can lead to two consequences:; // 1) We no longer need to update the stack because the function does not; // spill any callee saved registers to stack.; // 2) We have a situation where we still have to update the stack pointer; // even though some registers are spilled to other registers. In; // this case the current code moves the stack update to an incorrect; // position.; // In either case we should abort moving the stack update operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:546,abort,abort,546,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['abort'],['abort']
Safety,// If the callee saved register is spilled to another register abort the; // stack update movement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:63,abort,abort,63,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['abort'],['abort']
Safety,"// If the canonical template is local, we'll write out this specialization; // when we emit it.; // FIXME: We can do the same thing if there is any local declaration of; // the template, to avoid emitting an update record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:190,avoid,avoid,190,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['avoid'],['avoid']
Safety,"// If the clang binary happens to be named cl.exe for compatibility reasons,; // use clang-cl.exe as the prefix to avoid confusion between clang and MSVC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:115,avoid,avoid,115,interpreter/llvm-project/clang/tools/driver/driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp,1,['avoid'],['avoid']
Safety,// If the class introduced initializers we conservatively assume that we; // don't know if any of them is a designated initializer to avoid possible; // misleading warnings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:134,avoid,avoid,134,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['avoid'],['avoid']
Safety,"// If the class is properly aligned, assume the target offset is, too.; //; // This actually isn't necessarily the right thing to do --- if the; // class is a complete object, but it's only properly aligned for a; // base subobject, then the alignments of things relative to it are; // probably off as well. (Note that this requires the alignment of; // the target to be greater than the NV alignment of the derived; // class.); //; // However, our approach to this kind of under-alignment can only; // ever be best effort; after all, we're never going to propagate; // alignments through variables or parameters. Note, in particular,; // that constructing a polymorphic type in an address that's less; // than pointer-aligned will generally trap in the constructor,; // unless we someday add some sort of attribute to change the; // assumed alignment of 'this'. So our goal here is pretty much; // just to allow the user to explicitly say that a pointer is; // under-aligned and then safely access its fields and vtables.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:985,safe,safely,985,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['safe'],['safely']
Safety,"// If the code is doing reference counting over the parameter,; // it opens up an opportunity for safely calling a destructor function.; // TODO: We should still check for over-releases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:98,safe,safely,98,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,1,['safe'],['safely']
Safety,"// If the common expression is a class or array prvalue, materialize it; // so that we can safely refer to it multiple times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:91,safe,safely,91,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['safe'],['safely']
Safety,"// If the condition constant folds and can be elided, try to avoid emitting; // the condition and the dead arm of the if/else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:61,avoid,avoid,61,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,4,['avoid'],['avoid']
Safety,"// If the condition constant folds and can be elided, try to avoid emitting; // the condition and the dead arm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:61,avoid,avoid,61,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['avoid'],['avoid']
Safety,"// If the condition is in a loop, consider it predictable if the condition; // itself or all its operands are loop-invariant. E.g. this considers a load; // from a loop-invariant address predictable; we were unable to prove that it; // doesn't alias any of the memory-writes in the loop, but it is likely to; // read to same value multiple times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:46,predict,predictable,46,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,2,['predict'],['predictable']
Safety,"// If the conditional branch doesn't kill CPSR, then CPSR can be liveout; // so this transformation is not safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:107,safe,safe,107,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['safe'],['safe']
Safety,"// If the constant divisor has an exact inverse, this is always safe. If not,; // then we can still create a reciprocal if fast-math-flags allow it and the; // constant is a regular number (not zero, infinite, or denormal).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:64,safe,safe,64,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['safe'],['safe']
Safety,"// If the conversion context location is invalid don't complain. We also; // don't want to emit a warning if the issue occurs from the expansion of; // a system macro. The problem is that 'getSpellingLoc()' is slow, so we; // delay this check as long as possible. Once we detect we are in that; // scenario, we just return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:272,detect,detect,272,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['detect'],['detect']
Safety,"// If the copy has a glue operand, we conservatively assume it isn't safe to; // perform a tail call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:69,safe,safe,69,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,4,['safe'],['safe']
Safety,"// If the coroutine frame is an Argument, store it in an alloca to improve; // its availability (e.g. registers may be clobbered).; // Avoid this if optimizations are enabled (they would remove the alloca) or; // if the value is guaranteed to be available through other means (e.g. swift; // ABI guarantees).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:135,Avoid,Avoid,135,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['Avoid'],['Avoid']
Safety,"// If the current CPSR has high latency, try to avoid the false dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:48,avoid,avoid,48,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,1,['avoid'],['avoid']
Safety,"// If the current block doesn't fall through, just move it.; // If the current block can fall through and does not end with a; // conditional branch, we need to append an unconditional jump to; // the (current) next block. To avoid a possible compile-time; // infinite loop, move blocks only backward in this case.; // Also, if there are already 2 branches here, we cannot add a third;; // this means we have the case; // Bcc next; // B elsewhere; // next:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:226,avoid,avoid,226,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['avoid'],['avoid']
Safety,"// If the current block is the header of a reducible cycle that; // contains the divergent branch, then the label should be; // propagated to the cycle exits. Such a header is the ""last; // possible join"" of any disjoint paths within this cycle. This; // prevents detection of spurious joins at the entries of any; // irreducible child cycles.; //; // This conclusion about the header is true for any choice of DFS:; //; // If some DFS has a reducible cycle C with header H, then for; // any other DFS, H is the header of a cycle C' that is a; // superset of C. For a divergent branch inside the subgraph; // C, any join node inside C is either H, or some node; // encountered without passing through H.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h:264,detect,detection,264,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityImpl.h,1,['detect'],['detection']
Safety,"// If the data is already loaded from this address and hasn't been clobbered; // by any stores or calls, this load is likely to be redundant and can be; // eliminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:131,redund,redundant,131,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['redund'],['redundant']
Safety,"// If the decl being referenced had an error, return an error for this; // sub-expr without emitting another error, in order to avoid cascading; // error cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:128,avoid,avoid,128,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['avoid'],['avoid']
Safety,"// If the declarator-id is not a template-id, issue a diagnostic and; // recover by ignoring the 'template' keyword.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:73,recover,recover,73,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,3,['recover'],['recover']
Safety,// If the default value is not found abort unless the default destination; // is unreachable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:37,abort,abort,37,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['abort'],['abort']
Safety,"// If the defs from this range reach SI via all predecessors, it is live.; // It can happen that SI is reached by the defs through some paths, but; // not all. In the IR coming into this optimization, SI would not be; // considered live, since the defs would then not jointly dominate SI.; // That means that SI is an overwriting def, and no implicit use is; // needed at this point. Do not add SI to the extension points, since; // extendToIndices will abort if there is no joint dominance.; // If the abort was avoided by adding extra undefs added to Undefs,; // extendToIndices could actually indicate that SI is live, contrary; // to the original IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:454,abort,abort,454,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,3,"['abort', 'avoid']","['abort', 'avoided']"
Safety,"// If the destination isn't the common one, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:44,abort,abort,44,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['abort'],['abort']
Safety,"// If the destructor exists and has already been marked used in the MS ABI,; // then virtual base destructors have already been checked and marked used.; // Skip checking them again to avoid duplicate diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:185,avoid,avoid,185,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['avoid'],['avoid']
Safety,"// If the destructor is trivial, it's always safe to inline the constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:45,safe,safe,45,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['safe'],['safe']
Safety,"// If the diag id doesn't match we found a different diag, abort. This can; // happen when this function is called with an ID that points into a hole in; // the diagID space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:59,abort,abort,59,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,1,['abort'],['abort']
Safety,"// If the diagnosed code is `[[fallthrough]];` and; // `-Wunreachable-code-fallthrough` is enabled, suppress `code will never; // be executed` warning to avoid generating diagnostic twice",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:154,avoid,avoid,154,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['avoid'],['avoid']
Safety,"// If the division is unsigned and Dividend is known to be short, then; // either; // 1) Divisor is less or equal to Dividend, and the result can be computed; // with a short division.; // 2) Divisor is greater than Dividend. In this case, no division is needed; // at all: The quotient is 0 and the remainder is equal to Dividend.; //; // So instead of checking at runtime whether Divisor fits into BypassType,; // we emit a runtime check to differentiate between these two cases. This; // lets us entirely avoid a long div.; // Split the basic block before the div/rem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:508,avoid,avoid,508,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,1,['avoid'],['avoid']
Safety,"// If the elements match (undef or not), that value is the result. If only; // one element is undef, choose the defined element as the safe result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:135,safe,safe,135,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['safe'],['safe']
Safety,"// If the end does not reside in the same file, try to recover by; // picking the end of the file of begin location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:55,recover,recover,55,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['recover'],['recover']
Safety,"// If the evaluate call resulted in no change, chain to the next eval call; // handler.; // Note, the custom CString evaluation calls assume that basic safety; // properties are held. However, if the user chooses to turn off some of these; // checks, we ignore the issues and leave the call evaluation to a generic; // handler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:152,safe,safety,152,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['safe'],['safety']
Safety,"// If the exception is being emitted in an OpenMP target region,; // and the target is a GPU, we do not support exception handling.; // Therefore, we emit a trap which will abort the program, and; // prompt a warning indicating that a trap will be emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:173,abort,abort,173,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['abort'],['abort']
Safety,// If the exit from the predecessor has the VTYPE we are looking for; // we might be able to avoid a VSETVLI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['avoid'],['avoid']
Safety,"// If the false value simplified to false, then the result of the compare; // is equal to ""Cond && TCmp"". This also catches the case when the false; // value simplified to false and the true value to true, returning ""Cond"".; // Folding select to and/or isn't poison-safe in general; impliesPoison; // checks whether folding it does not convert a well-defined value into; // poison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:266,safe,safe,266,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['safe'],['safe']
Safety,"// If the first component corresponds to a known architecture, preferentially; // use it for the architecture. If the second component corresponds to a; // known vendor, preferentially use it for the vendor, etc. This avoids silly; // component movement when a component parses as (eg) both a valid arch and a; // valid os.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Triple.cpp:218,avoid,avoids,218,interpreter/llvm-project/llvm/lib/TargetParser/Triple.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Triple.cpp,1,['avoid'],['avoids']
Safety,"// If the first letter isn't i or e, it isn't intesting to us. We know that; // this is safe in the face of spelling differences, because there is no way; // to spell an i/e in a strange way that is another letter. Skipping this; // allows us to avoid looking up the identifier info for #define/#undef and; // other common directives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:88,safe,safe,88,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// If the function has an explicit vectorized counterpart, we can safely; // assume that it can be vectorized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:66,safe,safely,66,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['safe'],['safely']
Safety,"// If the function is marked as non-lazy, generate an indirect call; // which loads from the GOT directly. This avoids run-time overhead; // at the cost of eager binding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp:112,avoid,avoids,112,interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kSubtarget.cpp,1,['avoid'],['avoids']
Safety,"// If the function is marked as non-lazy, generate an indirect call; // which loads from the GOT directly. This avoids runtime overhead; // at the cost of eager binding (and one extra byte of encoding).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp:112,avoid,avoids,112,interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.cpp,1,['avoid'],['avoids']
Safety,"// If the function pointer has a non-call user, we cannot eliminate the type; // check, as one of those users may eventually call the pointer. Increment; // the unsafe use count to make sure it cannot reach zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:161,unsafe,unsafe,161,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['unsafe'],['unsafe']
Safety,"// If the function return type is x86_fp80 and the callee return type is not,; // then the FP_EXTEND of the call result is not a nop. It's not safe to; // perform a tailcall optimization here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:143,safe,safe,143,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['safe'],['safe']
Safety,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:303,avoid,avoid,303,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['avoid'],['avoid']
Safety,"// If the head of the list is also a BaseClass, we'll overwrite it to avoid; // note messages like 'this->A::B::x'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:70,avoid,avoid,70,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,1,['avoid'],['avoid']
Safety,"// If the immediate post-dominator is not in a less nested loop,; // then we are stuck in a program with an infinite loop.; // In that case, we will not find a safe point, hence, bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:160,safe,safe,160,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['safe'],['safe']
Safety,"// If the incoming value is the phi node itself, it can safely be skipped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:56,safe,safely,56,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,3,['safe'],['safely']
Safety,"// If the initial strategy fails for any of the operand indexes, then we; // perform reordering again in a second pass. This helps avoid assigning; // high priority to the failed strategy, and should improve reordering for; // the non-failed operand indexes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:131,avoid,avoid,131,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"// If the initializer consists solely of a reference to itself, we; // explicitly mark the variable as uninitialized. This allows code; // like the following:; //; // int x = x;; //; // to deliberately leave a variable uninitialized. Different analysis; // clients can detect this pattern and adjust their reporting; // appropriately, but we need to continue to analyze subsequent uses; // of the variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:269,detect,detect,269,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,1,['detect'],['detect']
Safety,"// If the input to SplitF64 is just BuildPairF64 then the operation is; // redundant. Instead, use BuildPairF64's operands directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:75,redund,redundant,75,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['redund'],['redundant']
Safety,"// If the input to XVCVDPSP is a vector that was built (even; // partially) out of FRSP's, the FRSP(s) can safely be removed; // since this instruction performs the same operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:107,safe,safely,107,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['safe'],['safely']
Safety,"// If the input vector has vector elements wider than the target test size,; // then cast to <X x i64> so it will safely split.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:114,safe,safely,114,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['safe'],['safely']
Safety,"// If the instruction can be easily simplified then do so now in preference; // to value numbering it. Value numbering often exposes redundancies, for; // example if it determines that %y is equal to %x then the instruction; // ""%z = and i32 %x, %y"" becomes ""%z = and i32 %x, %x"" which we now simplify.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:133,redund,redundancies,133,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['redund'],['redundancies']
Safety,"// If the instruction cannot be poison, it's always safe to reuse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:52,safe,safe,52,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['safe'],['safe']
Safety,"// If the instruction defines physical registers and the values *may* be; // used, then it's not safe to replace it with a common subexpression.; // It's also not safe if the instruction uses physical registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:97,safe,safe,97,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,2,['safe'],['safe']
Safety,"// If the instruction doesn't actually need a correct EXEC, then we can; // safely leave Strict mode enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:76,safe,safely,76,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['safe'],['safely']
Safety,"// If the instruction has a two-operand alias, build up the; // matchable here. We'll add them in bulk at the end to avoid; // confusing this loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:117,avoid,avoid,117,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['avoid'],['avoid']
Safety,"// If the instruction has live CPSR def, then it's not safe to fold it; // into load / store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:55,safe,safe,55,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['safe'],['safe']
Safety,"// If the instruction has side effects and no non-dbg uses,; // skip it. This way we avoid computing known bits on an instruction; // that will not help us.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:85,avoid,avoid,85,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,1,['avoid'],['avoid']
Safety,"// If the instruction implicitly writes to ScratchSpacePointerInReg , abort.; // FIXME: We could make a copy of the scratch register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp:70,abort,abort,70,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.cpp,1,['abort'],['abort']
Safety,// If the instruction is not defined in a loop then it can safely replace; // anything.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:59,safe,safely,59,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,1,['safe'],['safely']
Safety,"// If the instruction's operands are invariant and it doesn't read or write; // memory, then it is safe to hoist. Doing this doesn't change the order of; // execution in the preheader, but does prevent the instruction from; // executing in each iteration of the loop. This means it is safe to hoist; // something that might trap, but isn't safe to hoist something that reads; // memory (without proving that the loop doesn't write).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:99,safe,safe,99,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,3,['safe'],['safe']
Safety,"// If the instruction[s] that feed this splat have already splat; // the value, this splat is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:94,redund,redundant,94,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redund'],['redundant']
Safety,"// If the integer type can hold the max FP value, it is safe to cast; // directly to that type. Otherwise, we may create poison via overflow; // that did not exist in the original code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:56,safe,safe,56,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['safe'],['safe']
Safety,"// If the lane selector was originally in a VGPR and copied with; // readfirstlane, there's a hazard to read the same SGPR from the; // VALU. Constrain to a different SGPR to help avoid needing a nop later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:94,hazard,hazard,94,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,2,"['avoid', 'hazard']","['avoid', 'hazard']"
Safety,"// If the lanes written by this instruction were all undef in OtherVNI, it is; // still safe to join the live ranges. This can't be done with a simple value; // mapping, though - OtherVNI will map to multiple values:; //; // 1 %dst:ssub0 = FOO <-- OtherVNI; // 2 %src = BAR <-- VNI; // 3 %dst:ssub1 = COPY killed %src <-- Eliminate this copy.; // 4 BAZ killed %dst; // 5 QUUX killed %src; //; // Here OtherVNI will map to itself in [1;2), but to VNI in [2;5). CR_Replace; // handles this complex value mapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:88,safe,safe,88,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['safe'],['safe']
Safety,"// If the literal can be inlined as-is, apply it and short-circuit the; // tests below. The main motivation for this is to avoid unintuitive; // uses of opsel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:123,avoid,avoid,123,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['avoid'],['avoid']
Safety,"// If the load is defined in a block with exactly one predecessor, it can't be; // partially redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:93,redund,redundant,93,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redund'],['redundant']
Safety,"// If the load is defined in an EH pad, it can't be partially redundant,; // because the edges between the invoke and the EH pad cannot have other; // instructions between them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:62,redund,redundant,62,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redund'],['redundant']
Safety,"// If the loaded value isn't available in any predecessor, it isn't partially; // redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:82,redund,redundant,82,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redund'],['redundant']
Safety,"// If the loop contains a convergent operation, the prelude we'd add; // to do the first few instructions before we hit the unrolled loop; // is unsafe -- it adds a control-flow dependency to the convergent; // operation. Therefore restrict remainder loop (try unrolling without).; //; // TODO: This is quite conservative. In practice, convergent_op(); // is likely to be called unconditionally in the loop. In this; // case, the program would be ill-formed (on most architectures); // unless n were the same on all threads in a thread group.; // Assuming n is the same on all threads, any kind of unrolling is; // safe. But currently llvm's notion of convergence isn't powerful; // enough to express this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:145,unsafe,unsafe,145,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"// If the loop doesn't make satisfying progress, try shuffling.; // The purpose of shuffling is to avoid the heavy tails of the; // distribution (improving the speed of convergence).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:99,avoid,avoid,99,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,1,['avoid'],['avoid']
Safety,"// If the loop has been unrolled, we should use the original loop count; // instead of recalculating the value. This will avoid additional; // 'Add' instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:122,avoid,avoid,122,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['avoid'],['avoid']
Safety,"// If the loop was deleted, abort the run and return to the outer walk.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp:28,abort,abort,28,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPassManager.cpp,2,['abort'],['abort']
Safety,"// If the loop was deleted, release all the loop passes. This frees up; // some memory, and avoids trouble with the pass manager trying to call; // verifyAnalysis on them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp:92,avoid,avoids,92,interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopPass.cpp,1,['avoid'],['avoids']
Safety,"// If the mask covers the least significant bit, then we can replace; // TEST+AND with a SHL and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:128,redund,redundant,128,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['redund'],['redundant']
Safety,"// If the mask covers the most significant bit, then we can replace; // TEST+AND with a SHR and check eflags.; // This emits a redundant TEST which is subsequently eliminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:127,redund,redundant,127,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['redund'],['redundant']
Safety,"// If the mask is all ones, erase the AND. (Currently, the target-independent; // code won't do this, so we have to do it explicitly to avoid an infinite; // loop in obscure cases.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:136,avoid,avoid,136,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If the member is implicit, don't add it to the member list. This avoids; // the member being added to type units by LLVM, while still allowing it; // to be emitted into the type declaration/reference inside the compile; // unit.; // Ditto 'nodebug' methods, for consistency with CodeGenFunction.cpp.; // FIXME: Handle Using(Shadow?)Decls here to create; // DW_TAG_imported_declarations inside the class for base decls brought into; // derived classes. GDB doesn't seem to notice/leverage these when I tried; // it, so I'm not rushing to fix this. (GCC seems to produce them, if; // referenced)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:68,avoid,avoids,68,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['avoid'],['avoids']
Safety,"// If the method is declared on a class that has a non-invariant; // type parameter, don't warn about parameter mismatches after performing; // substitution. This prevents warning when the programmer has purposely; // casted the receiver to a super type or unspecialized type but the analyzer; // has a more precise tracked type than the programmer intends at the call; // site.; //; // For example, consider NSArray (which has a covariant type parameter); // and NSMutableArray (a subclass of NSArray where the type parameter is; // invariant):; // NSMutableArray *a = [[NSMutableArray<NSString *> alloc] init;; //; // [a containsObject:number]; // Safe: -containsObject is defined on NSArray.; // NSArray<NSObject *> *other = [a arrayByAddingObject:number] // Safe; //; // [a addObject:number] // Unsafe: -addObject: is defined on NSMutableArray; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:650,Safe,Safe,650,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,3,"['Safe', 'Unsafe']","['Safe', 'Unsafe']"
Safety,"// If the multiplier is a multiple of 8, scale it down to avoid needing; // to shift the VLENB value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:58,avoid,avoid,58,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If the name begins with a dollar-sign, enclose it in parens. We do this; // to avoid having it look like an integer immediate to the assembler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:82,avoid,avoid,82,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,1,['avoid'],['avoid']
Safety,"// If the nested loop is an innermost loop, prefer to a 32-byte alignment,; // so that we can decrease cache misses and branch-prediction misses.; // Actual alignment of the loop will depend on the hotness check and other; // logic in alignBlocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:127,predict,prediction,127,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['predict'],['prediction']
Safety,"// If the next token is '=' or '==', avoid concatenation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:37,avoid,avoid,37,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,1,['avoid'],['avoid']
Safety,"// If the next token is a binary operator or a selector name, we have; // incorrectly classified the parenthesis as a cast. FIXME: Detect correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:131,Detect,Detect,131,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['Detect'],['Detect']
Safety,"// If the next token isn't valid as our argument, we can't recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:59,recover,recover,59,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['recover'],['recover']
Safety,"// If the object type is const-qualified, we can safely use; // __unsafe_unretained. This is safe (because there are no read; // barriers), and it'll be safe to coerce anything but __weak* to; // the resulting type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:49,safe,safely,49,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,3,['safe'],"['safe', 'safely']"
Safety,"// If the offset is a constant, there may be other adds of constants that; // can be folded with this one. We should do this to avoid having to keep; // a copy of the original base pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:128,avoid,avoid,128,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,// If the offset is a known constant then try to recover the pointer; // info,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:49,recover,recover,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['recover'],['recover']
Safety,"// If the offset is more than 24-bits, it won't fit in a scattered; // relocation offset field, so we fall back to using a non-scattered; // relocation. This is a bit risky, as if the offset reaches out of; // the block and the linker is doing scattered loading on this; // symbol, things can go badly.; //; // Required for 'as' compatibility.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MachObjectWriter.cpp:167,risk,risky,167,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MachObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86MachObjectWriter.cpp,1,['risk'],['risky']
Safety,// If the only instruction immediately following this END_CF is another; // END_CF in the only successor we can avoid emitting exec mask restore here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:112,avoid,avoid,112,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['avoid'],['avoid']
Safety,"// If the only possible side effect of the call is writing to the alloca,; // and the result isn't used, we can safely remove any reads implied by the; // call including those which might read the alloca itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:112,safe,safely,112,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['safe'],['safely']
Safety,"// If the opening brace is not preceded by one of these tokens, we are; // missing the mem-initializer-id. In order to recover better, we need; // to use heuristics to determine if this '{' is most likely the; // beginning of a brace-init-list or the function body.; // Check the token after the corresponding '}'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:119,recover,recover,119,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['recover'],['recover']
Safety,"// If the operation allows fast-math and the target does not support FMA,; // split this into mul+add to avoid libcall(s).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:105,avoid,avoid,105,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If the operation does not change exception status flags, it is safe; // to fold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:66,safe,safe,66,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['safe'],['safe']
Safety,// If the operation was not aborted then update the object offset.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:28,abort,aborted,28,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['abort'],['aborted']
Safety,"// If the original return value was FP, bitcast accordingly. Doing it here; // means that we can avoid adding TableGen patterns for FPs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:97,avoid,avoid,97,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If the pair to store is a mixture of float and int values, we will; // save two bitwise instructions and one float-to-int instruction and; // increase one store instruction. There is potentially a more; // significant benefit because it avoids the float->int domain switch; // for input value. So It is more likely a win.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h:240,avoid,avoids,240,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.h,2,['avoid'],['avoids']
Safety,"// If the parameter is passed through reg $D, which splits into; // two physical registers, avoid creating call site info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp:92,avoid,avoid,92,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If the parameters are callee-cleanup, it's not safe to forward.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp:50,safe,safe,50,interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGClass.cpp,1,['safe'],['safe']
Safety,"// If the parser was confused by the condition and we don't have a ')', try to; // recover by skipping ahead to a semi and bailing out. If condexp is; // semantically invalid but we have well formed code, keep going.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:83,recover,recover,83,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['recover'],['recover']
Safety,"// If the physreg has no defs anywhere, it's just an ambient register; // and we can freely move its uses. Alternatively, if it's allocatable,; // it could get allocated to something with a def during allocation.; // However, if the physreg is known to always be caller saved/restored; // then this use is safe to hoist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp:306,safe,safe,306,interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,2,['safe'],['safe']
Safety,"// If the pointer has been offset from the start of the alloca, we can't; // safely handle this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:77,safe,safely,77,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['safe'],['safely']
Safety,"// If the pointer is store in VGPRs, then we need to move them to; // SGPRs using v_readfirstlane. This is safe because we only select; // loads with uniform pointers to SMRD instruction so we know the; // pointer value is uniform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:107,safe,safe,107,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['safe'],['safe']
Safety,"// If the predecessor is falling through to this block, we could reverse; // the branch condition and fold the tail call into that. However, after; // that we might have to re-arrange the CFG to fall through to the other; // block and there is a high risk of regressing code size rather than; // improving it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:251,risk,risk,251,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['risk'],['risk']
Safety,// If the preferred alignment is greater than the natural stack alignment; // then don't round up. This avoids dynamic stack realignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:104,avoid,avoids,104,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['avoid'],['avoids']
Safety,"// If the previous block ended with a widenable branch, determine if reusing; // the target block is profitable and legal. This will have the effect of; // ""widening"" PBI, but doesn't require us to reason about hosting safety.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:219,safe,safety,219,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safety']
Safety,"// If the provided initializer fails to initialize the var decl,; // we attach a recovery expr for better recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:81,recover,recovery,81,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['recover'],['recovery']
Safety,"// If the proxies in the proxy list still don't correspond to _compRSet and; // _compCSet, it's time to print errors. And try to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx:129,recover,recover,129,roofit/roofitcore/src/RooProduct.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProduct.cxx,1,['recover'],['recover']
Safety,"// If the qualifiers come from a conversion function type, don't diagnose; // them -- they're not necessarily redundant, since such a conversion; // operator can be explicitly called as ""x.operator const int()"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:110,redund,redundant,110,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['redund'],['redundant']
Safety,"// If the record is invalid, some of it's members are invalid. To avoid; // confusion, we forgo checking the initializer for the entire record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:66,avoid,avoid,66,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['avoid'],['avoid']
Safety,"// If the register can only be described by a complex expression (i.e.,; // multiple subregisters) it doesn't safely compose with another complex; // expression. For example, it is not possible to apply a DW_OP_deref; // operation to multiple DW_OP_pieces, since composite location descriptions; // do not push anything on the DWARF stack.; //; // DW_OP_entry_value operations can only hold a DWARF expression or a; // register location description, so we can't emit a single entry value; // covering a composite location description. In the future we may want to; // emit entry value operations for each register location in the composite; // location, but until that is supported do not emit anything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:110,safe,safely,110,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,1,['safe'],['safely']
Safety,"// If the register doesn't have defining instructions, and is not a; // live-in, then something is wrong and the fixup must always be; // inserted to be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp:153,safe,safe,153,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,1,['safe'],['safe']
Safety,"// If the register is undefined (for example if it's a reserved register),; // it may still be possible to extend the range, but it's safer to be; // conservative and just punt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:134,safe,safer,134,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,1,['safe'],['safer']
Safety,"// If the rest of the next line fits into the current line below the; // column limit, we can safely reflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp:94,safe,safely,94,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.cpp,1,['safe'],['safely']
Safety,"// If the result of an agg expression is unused, then the emission; // of the LHS might need to create a destination slot. That's fine; // with us, and we can safely emit the RHS into the same slot, but; // we shouldn't claim that it's already being destructed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:159,safe,safely,159,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['safe'],['safely']
Safety,"// If the return types are not the same, this might be a case where more; // code needs to run to compensate for it. For example, the derived; // method might return a type that inherits form from the return; // type of MD and has a prefix.; // For now we just avoid devirtualizing these covariant cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:261,avoid,avoid,261,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['avoid'],['avoid']
Safety,"// If the routine name is invalid, just skip until the closing paren to; // recover more gracefully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:76,recover,recover,76,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['recover'],['recover']
Safety,"// If the scalar cannot be safely casted to the vector element type,; // reject it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:27,safe,safely,27,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['safe'],['safely']
Safety,"// If the scalar is poison, or it is undef and there is no risk of; // propagating poison from the vector value, simplify to the vector value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:59,risk,risk,59,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['risk'],['risk']
Safety,"// If the segments are not overlapping, we need to move to the beginning; // index of the next segment to avoid having instructions not attached to; // any register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:106,avoid,avoid,106,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['avoid'],['avoid']
Safety,"// If the select condition is obviously predictable, then the misprediction; // rate is zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:40,predict,predictable,40,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['predict'],['predictable']
Safety,"// If the selected successor is the landing pad, clear the chunk; // successors to avoid creating a regular branch to the landing pad which; // would result in invalid IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceBasicBlocks.cpp:83,avoid,avoid,83,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceBasicBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceBasicBlocks.cpp,1,['avoid'],['avoid']
Safety,"// If the set of defs and uses intersect then we cannot add this instruction; // to the clause, so we have a hazard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:109,hazard,hazard,109,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// If the sign extend extends from a narrower width than the load's width,; // then we can narrow the load width when we combine to a G_SEXTLOAD.; // Avoid widening the load at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:150,Avoid,Avoid,150,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['Avoid'],['Avoid']
Safety,"// If the signed type can represent all values of the unsigned type, it; // wins. Because we are dealing with 2's complement and types that are; // powers of two larger than each other, this is always safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:201,safe,safe,201,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,2,['safe'],['safe']
Safety,"// If the size is unknown (0) then keep this location def to be safe.; // Do the same for defs of large variables, which would be expensive; // to represent with a BitVector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:64,safe,safe,64,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['safe'],['safe']
Safety,"// If the skipped block has no labels in it, just emit the executed block.; // This avoids emitting dead code and simplifies the CFG substantially.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:84,avoid,avoids,84,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['avoid'],['avoids']
Safety,"// If the source is already a VMOVIMM or VMVNIMM splat, the VDUPLANE is; // redundant. Ignore bit_converts for now; element sizes are checked below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:76,redund,redundant,76,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['redund'],['redundant']
Safety,"// If the start values for both Src and Sink also vary according to an outer; // loop, then it's probably better to avoid creating diff checks because; // they may not be hoisted. We should instead let llvm::addRuntimeChecks; // do the expanded full range overlap checks, which can be hoisted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:116,avoid,avoid,116,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['avoid'],['avoid']
Safety,"// If the store is guaranteed to execute, both properties are satisfied.; // We may want to check if a store is guaranteed to execute even if we; // already know that promotion is safe, since it may have higher; // alignment than any other guaranteed stores, in which case we can; // raise the alignment on the promoted store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:180,safe,safe,180,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safe']
Safety,"// If the string is by itself, then it can safely be histogrammed as; // in a string based axis. To histogram the number inside the string; // just make it part of a useless expression (for example: mystring+0)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:43,safe,safely,43,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['safe'],['safely']
Safety,"// If the styler is in a callback, abort further processing.; // TODO: check this!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx:35,abort,abort,35,gui/guihtml/src/TGHtml.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtml.cxx,1,['abort'],['abort']
Safety,"// If the target doesn't support variable shifts, use either FP conversion; // or integer multiplication to avoid shifting each element individually.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:108,avoid,avoid,108,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If the target has hardware branch prediction that can handle indirect; // branches, duplicating them can often make them predictable when there; // are common paths through the code. The limit needs to be high enough; // to allow undoing the effects of tail merging and other optimizations; // that rearrange the predecessors of the indirect branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:37,predict,prediction,37,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,2,['predict'],"['predictable', 'prediction']"
Safety,"// If the template parameter has pointer type but the address of; // this object was not taken, complain and (possibly) recover by; // taking the address of the entity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:120,recover,recover,120,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Safety,"// If the terminator is the only instruction in the block and Uses is not; // empty (or we would have returned above), we can still safely hoist; // instructions just before the terminator as long as the Defs/Uses are not; // violated (which is checked in HoistCommonCodeInSuccs).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:132,safe,safely,132,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['safe'],['safely']
Safety,"// If the then or else stmt is invalid and the other is valid (and present),; // turn the invalid one into a null stmt to avoid dropping the other; // part. If both are invalid, return error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:122,avoid,avoid,122,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['avoid'],['avoid']
Safety,"// If the time between now and when the instruction will be ready can cover; // the spill code, then avoid adding it to the ready queue. This gives long; // stalls highest priority and allows hoisting across calls. It should also; // speed up processing the available queue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:101,avoid,avoid,101,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avoid'],['avoid']
Safety,"// If the token after the colon isn't an identifier, it's still an; // error, but they probably meant something else strange so don't; // recover like this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:138,recover,recover,138,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recover']
Safety,"// If the token is an identifier named ""__declspec"" and Microsoft; // extensions are not enabled, it is likely that there will be cascading; // parse errors if this really is a __declspec attribute. Attempt to; // recognize that scenario and recover gracefully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:242,recover,recover,242,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Safety,"// If the tokens were already space separated, or if they must be to avoid; // them being implicitly pasted, add a space between them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:69,avoid,avoid,69,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,1,['avoid'],['avoid']
Safety,"// If the transform is aborted, discard the ScalarizationResults.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:23,abort,aborted,23,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['abort'],['aborted']
Safety,"// If the translation unit has been marked as unsafe to free, just discard; // it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:46,unsafe,unsafe,46,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['unsafe'],['unsafe']
Safety,"// If the trip count is computed in terms of a max (due to ScalarEvolution; // being unable to find a sufficient guard, for example), change the loop; // comparison to use SLT or ULT instead of NE.; // One consequence of doing this now is that it disrupts the count-down; // optimization. That's not always a bad thing though, because in such; // cases it may still be worthwhile to avoid a max.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:383,avoid,avoid,383,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['avoid'],['avoid']
Safety,"// If the two calls are the same, return Inst as a Def, so that; // Call can be found redundant and eliminated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:86,redund,redundant,86,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['redund'],['redundant']
Safety,"// If the type corresponding to the vtable is private to this translation; // unit, we know that we can see all virtual functions which might use it,; // so VFE is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:164,safe,safe,164,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,1,['safe'],['safe']
Safety,"// If the type is a pointer to an array, check the size of the array; // elements. To avoid false positives coming from assumption that the; // values x and &x are equal when x is an array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp:86,avoid,avoid,86,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCContainersASTChecker.cpp,1,['avoid'],['avoid']
Safety,"// If the type is a struct with no body provided, treat is conservatively.; // There cannot be actual definitions of object of such a type in this CU; // (only references), so assuming that they are not in sdata is safe. If; // these objects end up in the sdata, the references will still be valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp:215,safe,safe,215,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonTargetObjectFile.cpp,1,['safe'],['safe']
Safety,"// If the type is legal but the operation isn't, this node might survive all; // the way to operation legalization. If we end up there and we do not have; // the ability to widen the type (if VT*2 is not legal), we cannot expand the; // node.; // Coax the legalizer into expanding the node during type legalization instead; // by bumping the size by one bit. This will force it to Promote, enabling the; // early expansion and avoiding the need to expand later.; // We don't have to do this if Scale is 0; that can always be expanded, unless; // it's a saturating signed operation. Those can experience true integer; // division overflow, a case which we must avoid.; // FIXME: We wouldn't have to do this (or any of the early; // expansion/promotion) if it was possible to expand a libcall of an; // illegal type during operation legalization. But it's not, so things; // get a bit hacky.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:427,avoid,avoiding,427,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,['avoid'],"['avoid', 'avoiding']"
Safety,"// If the underlying declarations are unnamed records these can be; // imported as different types. We should create a distinct typedef; // node in this case.; // If we found an existing underlying type with a record in a; // different context (than the imported), this is already reason for; // having distinct typedef nodes for these.; // Again this can create situation like; // 'typedef int T; typedef int T;' but this is hard to avoid without; // a rename strategy at import.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:434,avoid,avoid,434,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['avoid'],['avoid']
Safety,"// If the unsafe registers in this block are all dead, then we don't need; // to compute liveness here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:10,unsafe,unsafe,10,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['unsafe'],['unsafe']
Safety,"// If the use is an instruction which treats the source operand as i32,; // it is safe to avoid truncate here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:82,safe,safe,82,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// If the user is a MFOCRF instruction, we know this is safe.; // Otherwise we give up for right now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:56,safe,safe,56,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['safe'],['safe']
Safety,"// If the user is going to see an error here, recover by making the; // definition visible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:46,recover,recover,46,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,2,['recover'],['recover']
Safety,"// If the user provided a superfluous scope specifier that refers back to the; // class in which the entity is already declared, diagnose and ignore it.; //; // class X {; // void X::f();; // };; //; // Note, it was once ill-formed to give redundant qualification in all; // contexts, but that rule was removed by DR482.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:240,redund,redundant,240,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['redund'],['redundant']
Safety,"// If the value is the load that we will be eliminating, and the block it's; // available in is the block that the load is in, then don't add it as; // SSAUpdater will resolve the value to the relevant phi which may let it; // avoid phi construction entirely if there's actually only one value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:227,avoid,avoid,227,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avoid'],['avoid']
Safety,"// If the value is unavailable in one of predecessors, we will end up; // inserting a new instruction into them. It is only valid if all the; // instructions before LoadI are guaranteed to pass execution to its; // successor, or if LoadI is safe to speculate.; // TODO: If this logic becomes more complex, and we will perform PRE insertion; // farther than to a predecessor, we need to reuse the code from GVN's PRE.; // It requires domination tree analysis, so for this simple case it is an; // overkill.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:241,safe,safe,241,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['safe'],['safe']
Safety,"// If the value wasn't vectorized, we must maintain the original scalar; // type. Skip those here, after incrementing NumProcessedRecipes. Also; // skip casts which do not need to be handled explicitly here, as; // redundant casts will be removed during recipe simplification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:215,redund,redundant,215,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['redund'],['redundant']
Safety,"// If the visit this instruction detected an uninlinable pattern, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:33,detect,detected,33,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,2,"['abort', 'detect']","['abort', 'detected']"
Safety,// If the vtable is hidden then it is not safe to emit an available_externally; // copy of vtable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:42,safe,safe,42,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['safe'],['safe']
Safety,"// If there are a sufficient number of reduction values, reduce; // to a nearby power-of-2. We can safely generate oversized; // vectors and rely on the backend to split them to legal sizes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:99,safe,safely,99,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safely']
Safety,// If there are any load-<modified> options then turn on flag overrides; // to avoid flag mismatch errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp:79,avoid,avoid,79,interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-jitlink/llvm-jitlink.cpp,1,['avoid'],['avoid']
Safety,"// If there are any pending errors, report them now. Clients wishing; // to avoid report_fatal_error calls should check for errors with; // has_error() and clear the error flag with clear_error() before; // destructing raw_ostream objects which may have errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:76,avoid,avoid,76,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,1,['avoid'],['avoid']
Safety,"// If there are dependent noexcept specs, assume everything is fine. Unlike; // with the equivalency check, this is safe in this case, because we don't; // want to merge declarations. Checks after instantiation will catch any; // omissions we make here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:116,safe,safe,116,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['safe'],['safe']
Safety,"// If there are fewer arguments than referenced parameters, treat the; // parameter as empty.; // FIXME: Potentially fully abort the expansion instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp:123,abort,abort,123,interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/MacroExpander.cpp,1,['abort'],['abort']
Safety,"// If there are lifetime intrinsics which couldn't be traced back to an; // alloca, we may not know exactly when a variable enters scope, and; // therefore should ""fail safe"" by not poisoning them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:169,safe,safe,169,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['safe'],['safe']
Safety,"// If there are lots of uses, conservatively say that the value; // is captured to avoid taking too much compile time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:83,avoid,avoid,83,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,1,['avoid'],['avoid']
Safety,// If there are no basic blocks with lower frequency than the preheader then; // we can avoid the detailed analysis as we will never find profitable sinking; // opportunities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:88,avoid,avoid,88,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,1,['avoid'],['avoid']
Safety,"// If there are no instructions available, don't try to issue anything, and; // don't advance the hazard recognizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp:98,hazard,hazard,98,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGVLIW.cpp,1,['hazard'],['hazard']
Safety,"// If there are no nans, it's safe to simply replace this with the non-IEEE; // version.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:30,safe,safe,30,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['safe'],['safe']
Safety,"// If there are no places where we have to save LR, then note that we; // don't have to update the stack. Otherwise, give every candidate the; // default call type, as long as it's safe to do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:181,safe,safe,181,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['safe'],['safe']
Safety,// If there are no unsafe definitions...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp:19,unsafe,unsafe,19,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,1,['unsafe'],['unsafe']
Safety,"// If there are other uses of the shuffle, the swap cannot be avoided.; // Forcing the use of an X-Form (since swapped stores only have; // X-Forms) without removing the swap is unprofitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:62,avoid,avoided,62,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avoid'],['avoided']
Safety,"// If there are reads outside the promoted set, then promoting stores is; // definitely not safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:92,safe,safe,92,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safe']
Safety,"// If there are still tail instructions, abort the merge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:41,abort,abort,41,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['abort'],['abort']
Safety,"// If there are two 'or' instructions concat variables in opposite order:; //; // Slot1 and Slot2 are all zero bits.; // | Slot1 | Low | Slot2 | High |; // LowHigh = or (shl (zext Low), ZextLowShlAmt), (zext High); // | Slot2 | High | Slot1 | Low |; // HighLow = or (shl (zext High), ZextHighShlAmt), (zext Low); //; // the latter 'or' can be safely convert to; // -> HighLow = fshl LowHigh, LowHigh, ZextHighShlAmt; // if ZextLowShlAmt + ZextHighShlAmt == Width.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:343,safe,safely,343,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safely']
Safety,"// If there are users outside the set to be eliminated, we abort the; // transformation. No gain can be expected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:59,abort,abort,59,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['abort'],['abort']
Safety,"// If there has been no definition for the declaration, call RAUW; // with ourselves, that will destroy the temporary MDNode and; // replace it with a standard one, avoiding leaking memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:165,avoid,avoiding,165,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['avoid'],['avoiding']
Safety,"// If there have been some defines between the last Filter and this Range node we won't detect them:; // Ranges don't keep track of Defines (they have no RColumnRegister data member).; // Let's pretend that the Defines of this node are the same as the node above, so that in the graph; // the Defines will just appear below the Range instead (no functional change).; // TODO: Converting the string_views for backward compatibility.; // Since they are names of defined columns, they were added to the; // register of column names of the RLoopManager object by the; // RColumnRegister, so we could also change GetDefinedColumns to return string_views directly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx:88,detect,detect,88,tree/dataframe/inc/ROOT/RDF/RRange.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RRange.hxx,1,['detect'],['detect']
Safety,"// If there is a chain of insertvalue instructions (each of them except the; // last one has only one use and it's another insertvalue insn from this; // chain), check if any of the 'children' uses the same indices as the first; // instruction. In this case, the first one is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:276,redund,redundant,276,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['redund'],['redundant']
Safety,// If there is a code-completion point avoid the fast scan because it; // doesn't check for '\0'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:39,avoid,avoid,39,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['avoid'],['avoid']
Safety,"// If there is a definition in the module, then it wins over the alias.; // This is dubious, but allow it to be safe. Just ignore the alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:112,safe,safe,112,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['safe'],['safe']
Safety,"// If there is a dominating assume with the same condition as this one,; // then this one is redundant, and should be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:93,redund,redundant,93,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['redund'],['redundant']
Safety,"// If there is a result abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:24,abort,abort,24,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['abort'],['abort']
Safety,"// If there is enough room in the type to upscale the LHS or downscale the; // RHS before the division, we can perform it in this type without having to; // resize. For signed operations, the LHS headroom is the number of; // redundant sign bits, and for unsigned ones it is the number of zeroes.; // The headroom for the RHS is the number of trailing zeroes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:226,redund,redundant,226,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['redund'],['redundant']
Safety,// If there is no NSConstantString interface defined then treat this; // as error and recover from it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:86,recover,recover,86,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['recover'],['recover']
Safety,"// If there is no colon, treat as if the reduction operator was missing, else; // we probably will not recover from it in the case where an expression starts; // with one of the operator tokens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:103,recover,recover,103,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['recover'],['recover']
Safety,"// If there is no debug location, we do not have to rewrite this; // MDNode. This loop also initializes DILocationReachable, later; // needed by updateLoopMetadataDebugLocationsImpl; the use of; // count_if avoids an early exit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:207,avoid,avoids,207,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['avoid'],['avoids']
Safety,"// If there is no user-defined mapper, set the mapper array to nullptr to; // avoid an unnecessary data privatization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:78,avoid,avoid,78,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['avoid'],['avoid']
Safety,"// If there was an error parsing the assignment-expression, recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:60,recover,recover,60,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Safety,"// If there were delayed typos in the LHS or ArgExprs, call SkipUntil; // instead of PT.consumeClose() to avoid emitting extra diagnostics for; // the unmatched l_paren.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:106,avoid,avoid,106,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['avoid'],['avoid']
Safety,"// If there were no values, or one of the predecessors couldn't have a; // value, then give up immediately. It's not safe to produce a live-in; // value. Leave as whatever it was before.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:117,safe,safe,117,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['safe'],['safe']
Safety,"// If there's a ## before the __VA_OPT__, we might have discovered; // that the __VA_OPT__ begins with a placeholder. We delay action on; // that to now to avoid messing up our stashed count of tokens before; // __VA_OPT__.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:156,avoid,avoid,156,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['avoid'],['avoid']
Safety,"// If there's a G_AND feeding into this branch, try to fold it away by; // emitting a TB(N)Z instead.; //; // Note: If we have LT, then it *is* possible to fold, but it wouldn't be; // beneficial. When we have an AND and LT, we need a TST/ANDS, so folding; // would be redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:269,redund,redundant,269,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['redund'],['redundant']
Safety,"// If there's a mix of covered and non-covered exits, just put the untag; // on exits, so we avoid the redundancy of untagging twice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp,2,"['avoid', 'redund']","['avoid', 'redundancy']"
Safety,"// If there's at most one path, no path components are redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:55,redund,redundant,55,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redund'],['redundant']
Safety,"// If these are identical non-return blocks with no successors, merge them.; // Such blocks are typically cold calls to noreturn functions like abort, and; // are unlikely to become a fallthrough target after machine block placement.; // Tail merging these blocks is unlikely to create additional unconditional; // branches, and will reduce the size of this cold code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:144,abort,abort,144,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['abort'],['abort']
Safety,"// If these non-separator path components differ by more than just case,; // then we may be looking at symlinked paths. Bail on this diagnostic to; // avoid noisy false positives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:151,avoid,avoid,151,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['avoid'],['avoid']
Safety,"// If they aren't the same type, then the input hasn't been processed; // by the loop above yet (which canonicalizes sequential index types to; // intptr_t). Just avoid transforming this until the input has been; // normalized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:163,avoid,avoid,163,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['avoid'],['avoid']
Safety,"// If they're still different, there's some facet we don't understand; // (currently only ""inreg"", but in future who knows). It may be OK but the; // only safe option is to reject the tail call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp:155,safe,safe,155,interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/Analysis.cpp,1,['safe'],['safe']
Safety,"// If this BB has more than one successor, we can create a new BB and; // move the compare instruction in the new BB.; // So far, we do not move compare instruction to a BB having multiple; // successors to avoid potentially increasing code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:207,avoid,avoid,207,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['avoid'],['avoid']
Safety,"// If this BB loops back to itself, conservatively avoid narrowing the; // first instruction that does partial flag update.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,2,['avoid'],['avoid']
Safety,"// If this FS has its own working dir, use it to make Path absolute.; // The returned twine is safe to use as long as both Storage and Path live.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:95,safe,safe,95,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['safe'],['safe']
Safety,"// If this a full set, we need special handling to avoid needing an extra bit; // to represent the size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['avoid'],['avoid']
Safety,"// If this angle is in the context of an expression, we need to be more; // hesitant to detect it as opening template parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:88,detect,detect,88,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['detect'],['detect']
Safety,"// If this block ends with a branch instruction, and if there is a; // predecessor that ends on a branch of the same condition, make; // this conditional branch redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:161,redund,redundant,161,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['redund'],['redundant']
Safety,"// If this block has no successors (e.g. it is a return block or ends with; // a call to a no-return function like abort or __cxa_throw) and if the pred; // falls through into this block, and if it would otherwise fall through; // into the block after this, move this block to the end of the function.; //; // We consider it more likely that execution will stay in the function (e.g.; // due to loops) than it is to exit it. This asserts in loops etc, moving; // the assert condition out of the loop body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:115,abort,abort,115,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['abort'],['abort']
Safety,"// If this block is not done, it makes little sense to make any decisions; // based on clearance information. We need to make a second pass anyway,; // and by then we'll have better information, so we can avoid doing the work; // to try and break dependencies now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:205,avoid,avoid,205,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,2,['avoid'],['avoid']
Safety,"// If this builtin takes an immediate argument, we need to #define it rather; // than use a standard declaration, so that SemaChecking can range check; // the immediate passed by the user.; // Pointer arguments need to use macros to avoid hiding aligned attributes; // from the pointer type.; // It is not permitted to pass or return an __fp16 by value, so intrinsics; // taking a scalar float16_t must be implemented as macros.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:233,avoid,avoid,233,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,1,['avoid'],['avoid']
Safety,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:90,risk,risk,90,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,3,"['avoid', 'risk']","['avoid', 'avoided', 'risk']"
Safety,"// If this instruction is dead now, delete it. Don't do it now to avoid; // invalidating iterators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:66,avoid,avoid,66,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['avoid'],['avoid']
Safety,"// If this is &rvalue, then it's ill-formed and we have already diagnosed; // it. Don't produce a redundant warning about the lifetime of the; // temporary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:98,redund,redundant,98,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['redund'],['redundant']
Safety,// If this is Pointer->Pointer avoid conversion to and from int.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:31,avoid,avoid,31,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['avoid'],['avoid']
Safety,// If this is SSE1 only convert to FAND to avoid scalarization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:43,avoid,avoid,43,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// If this is SSE1 only convert to FOR to avoid scalarization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// If this is SSE1 only convert to FXOR to avoid scalarization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:43,avoid,avoid,43,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If this is a 256-bit store of concatenated ops, we are better off splitting; // that store into two 128-bit stores. This avoids spurious use of 256-bit ops; // and each half can execute independently. Some cores would split the op into; // halves anyway, so the concat (vinsertf128) is purely an extra op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:124,avoid,avoids,124,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// If this is a DP->SP conversion fed by an FRSP, the FRSP is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:62,redund,redundant,62,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redund'],['redundant']
Safety,"// If this is a XMM/YMM load of the same lower bits as another YMM/ZMM; // load, then just extract the lower subvector and avoid the second load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:123,avoid,avoid,123,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// If this is a bitcast between a MVT::v4i1/v2i1 and an illegal integer; // type, widen both sides to avoid a trip through memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:102,avoid,avoid,102,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// If this is a bitcast between a MVT::v4i1/v2i1/v1i1 and an illegal integer; // type, widen both sides to avoid a trip through memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:107,avoid,avoid,107,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If this is a catch-all, register that and abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:45,abort,abort,45,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['abort'],['abort']
Safety,"// If this is a code completion run, avoid invoking the plugin consumers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:37,avoid,avoid,37,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,1,['avoid'],['avoid']
Safety,"// If this is a constant i1/i8/i16 argument, promote to i32 to avoid an extra; // instruction. This is safe because it is common to all FastISel supported; // calling conventions on x86.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:63,avoid,avoid,63,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,// If this is a constant index and we know the value plus the number of the; // elements in the subvector minus one is less than the minimum number of; // elements then it's safe to return Idx.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:174,safe,safe,174,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['safe'],['safe']
Safety,"// If this is a direct call, avoid the wrapper if we don't need to do any; // loads or adds. This allows SDAG ISel to match direct calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:29,avoid,avoid,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If this is a final macro, make the deprecation and header unsafe bits; // stick around after the undefinition so they apply to any redefinitions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:61,unsafe,unsafe,61,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['unsafe'],['unsafe']
Safety,"// If this is a forward declaration and we are supposed to warn in this; // case, do it.; // FIXME: Recover nicely in the hidden case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:100,Recover,Recover,100,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,2,['Recover'],['Recover']
Safety,"// If this is a funcref call, to avoid hidden GC roots, we need to clear the; // table slot with ref.null upon call_indirect return.; //; // This generates the following code, which comes right after a call_indirect; // of a funcref:; //; // i32.const 0; // ref.null func; // table.set __funcref_call_table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp:33,avoid,avoid,33,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If this is a function-like macro invocation, it's safe to trivially expand; // as long as the identifier is not a macro argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:53,safe,safe,53,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['safe'],['safe']
Safety,"// If this is a large problem, avoid visiting the same basic blocks multiple; // times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:31,avoid,avoid,31,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['avoid'],['avoid']
Safety,"// If this is a large problem, avoid visiting the same basic blocks; // multiple times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:31,avoid,avoid,31,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['avoid'],['avoid']
Safety,// If this is a line comment we can drop it safely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:44,safe,safely,44,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['safe'],['safely']
Safety,"// If this is a module entry function, we can also sanity check against; // the static frame. Strictly it would be better to check against the; // attribute, i.e. that the variable is within the always-allocated; // section, and not within some other non-absolute-address object; // allocated here, but the extra error detection is minimal and we would; // have to pass the Function around or cache the attribute value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp:51,sanity check,sanity check,51,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMachineFunction.cpp,2,"['detect', 'sanity check']","['detection', 'sanity check']"
Safety,"// If this is a non-landingpad EH pad, mark this function as using; // funclets.; // FIXME: SEH catchpads do not create EH scope/funclets, so we could avoid; // setting this in such cases in order to improve frame layout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp:151,avoid,avoid,151,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/FunctionLoweringInfo.cpp,1,['avoid'],['avoid']
Safety,"// If this is a really simple expression (like x ? 4 : 5), emit this as a; // select instead of as control flow. We can only do this if it is cheap and; // safe to evaluate the LHS and RHS unconditionally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:156,safe,safe,156,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['safe'],['safe']
Safety,"// If this is a redefinition, recover by making this; // struct be anonymous, which will make any later; // references get the previous definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:30,recover,recover,30,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recover']
Safety,"// If this is a redefinition, recover by making this; // struct be anonymous, which will make any later; // references get the previous definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:30,recover,recover,30,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['recover'],['recover']
Safety,"// If this is a scalar LLVM value then assume LLVM will pass it in the right; // place naturally.; //; // This assumption is optimistic, as there could be free registers available; // when we need to pass this argument in memory, and LLVM could try to pass; // the argument in the free register. This does not seem to happen currently,; // but this code would be much safer if we could mark the argument with; // 'onstack'. See PR12193.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:368,safe,safer,368,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['safe'],['safer']
Safety,"// If this is a splat fed by a splatting load, the splat is; // redundant. Replace with a copy. This doesn't happen directly due; // to code in PPCDAGToDAGISel.cpp, but it can happen when converting; // a load of a double to a vector of 64-bit integers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:64,redund,redundant,64,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redund'],['redundant']
Safety,"// If this is a srem by a one, avoid the fold since it can be constant-folded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:31,avoid,avoid,31,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// If this is a srem by a powers-of-two (including INT_MIN), avoid the fold; // since it can be best implemented as a bit test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:61,avoid,avoid,61,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// If this is a store of a scalar_to_vector to v1i1, just use a scalar store.; // This will avoid a copy to k-register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:92,avoid,avoid,92,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If this is a tag declaration with a typedef name for linkage, it's safe; // to load that typedef now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:70,safe,safe,70,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['safe'],['safe']
Safety,"// If this is a totally extraneous copy for C++03 reference; // binding purposes, just return the original initialization; // expression. We don't generate an (elided) copy operation here; // because doing so would require us to pass down a flag to avoid; // infinite recursion, where each step adds another extraneous,; // elidable copy.; // Instantiate the default arguments of any extra parameters in; // the selected copy constructor, as if we were going to create a; // proper call to the copy constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:249,avoid,avoid,249,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['avoid'],['avoid']
Safety,"// If this is a urem by a powers-of-two, avoid the fold since it can be; // best implemented as a bit test.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:41,avoid,avoid,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// If this is a widening shuffle, we must be able to extend with poison; // elements. If the original binop does not produce a poison in the high; // lanes, then this transform is not safe.; // Similarly for poison lanes due to the shuffle mask, we can only; // transform binops that preserve poison.; // TODO: We could shuffle those non-poison constant values into the; // result by using a constant vector (rather than an poison vector); // as operand 1 of the new binop, but that might be too aggressive; // for target-independent shuffle creation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:184,safe,safe,184,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['safe'],['safe']
Safety,"// If this is actually a '<<<<<<<' version control conflict marker,; // recognize it as such and recover nicely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:97,recover,recover,97,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['recover'],['recover']
Safety,"// If this is actually a '>>>>' conflict marker, recognize it as such; // and recover nicely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:78,recover,recover,78,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['recover'],['recover']
Safety,"// If this is an extension token, diagnose its use.; // We avoid diagnosing tokens that originate from macro definitions.; // FIXME: This warning is disabled in cases where it shouldn't be,; // like ""#define TY typeof"", ""TY(1) x"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:59,avoid,avoid,59,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['avoid'],['avoid']
Safety,"// If this is an instruction with a load folded into it, try unfolding; // the load, e.g. avoid this:; // movq %rdx, %rcx; // addq (%rax), %rcx; // in favor of this:; // movq (%rax), %rcx; // addq %rdx, %rcx; // because it's preferable to schedule a load than a register copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:90,avoid,avoid,90,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['avoid'],['avoid']
Safety,"// If this is an interior node of a reassociable tree, ignore it until we; // get to the root of the tree, to avoid N^2 analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:110,avoid,avoid,110,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['avoid'],['avoid']
Safety,"// If this is an object-like macro invocation, it is safe to trivially expand; // it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:53,safe,safe,53,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['safe'],['safe']
Safety,"// If this is just redundant braces around an initializer, step over it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:19,redund,redundant,19,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['redund'],['redundant']
Safety,"// If this is the GNU "", ## __VA_ARGS__"" extension, and we just learned; // that __VA_ARGS__ expands to multiple tokens, avoid a pasting error when; // the expander tries to paste ',' with the first token of the __VA_ARGS__; // expansion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:121,avoid,avoid,121,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['avoid'],['avoid']
Safety,"// If this is the first argument and its string representation; // begins with the global scope specifier ('::foo'), add a space; // to avoid printing the diagraph '<:'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:136,avoid,avoid,136,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,1,['avoid'],['avoid']
Safety,"// If this is the first non-preferred node for this cycle, then; // record it and continue searching for a preferred node. If this; // is not the first non-preferred node, then treat it as though; // there had been a hazard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:217,hazard,hazard,217,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['hazard'],['hazard']
Safety,"// If this is the root of the dag we're matching, we emit a redundant opcode; // check to ensure that this gets folded into the normal top-level; // OpcodeSwitch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:60,redund,redundant,60,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,2,['redund'],['redundant']
Safety,"// If this is uitofp (fptosi F), the source needs an extra bit to avoid; // potential rounding of negative FP input values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:66,avoid,avoid,66,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['avoid'],['avoid']
Safety,"// If this isn't a memory inst, hoisting is safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:44,safe,safe,44,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['safe'],['safe']
Safety,"// If this isn't a memory inst, sinking is safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:43,safe,safe,43,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['safe'],['safe']
Safety,"// If this loop isn't forced to be unrolled, avoid unrolling it when the; // loop has an explicit unroll-and-jam pragma. This is to prevent automatic; // unrolling from interfering with the user requested transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['avoid'],['avoid']
Safety,"// If this loop isn't forced to be unrolled, avoid unrolling it when the; // parent loop has an explicit unroll-and-jam pragma. This is to prevent; // automatic unrolling from interfering with the user requested; // transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp,1,['avoid'],['avoid']
Safety,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:291,risk,risk,291,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['risk'],['risk']
Safety,"// If this node already has this dependence, don't add a redundant one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp:57,redund,redundant,57,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAG.cpp,1,['redund'],['redundant']
Safety,"// If this occurs outside a template instantiation, warn the user about; // it; they probably didn't mean to specify a redundant qualifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:119,redund,redundant,119,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['redund'],['redundant']
Safety,"// If this operation is not supported, lower it to 'abort()' call",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:52,abort,abort,52,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['abort'],['abort']
Safety,"// If this phi has a single use, and if that use just computes a value for; // the next iteration of a loop, delete the phi. This occurs with unused; // induction variables, e.g. ""for (int j = 0; ; ++j);"". Detecting this; // common case here is good because the only other things that catch this; // are induction variable analysis (sometimes) and ADCE, which is only run; // late.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:206,Detect,Detecting,206,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['Detect'],['Detecting']
Safety,"// If this pointer is always safe to load, or if we can prove that there; // is already a load in the block, then we can move the load to the pred; // block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:29,safe,safe,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['safe'],['safe']
Safety,"// If this resource is already used in this sequence, add the current; // entry's cycles so that the same resource appears to be used; // serially, rather than multiple parallel uses. This is important for; // in-order machine where the resource consumption is a hazard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp:263,hazard,hazard,263,interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/SubtargetEmitter.cpp,1,['hazard'],['hazard']
Safety,"// If this select has a condition (setcc) with narrower operands than the; // select, try to widen the compare to match the select width.; // TODO: This should be extended to handle any constant.; // TODO: This could be extended to handle non-loading patterns, but that; // requires thorough testing to avoid regressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:303,avoid,avoid,303,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// If this token is valid for implicit int, e.g. ""static x = 4"", then; // we just avoid eating the identifier, so it will be parsed as the; // identifier in the declarator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:82,avoid,avoid,82,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['avoid'],['avoid']
Safety,"// If this value has only one use, that use is a kill. This is a; // conservative approximation. InstrEmitter does trivial coalescing; // with CopyFromReg nodes, so don't emit kill flags for them.; // Avoid kill flags on Schedule cloned nodes, since there will be; // multiple uses.; // Tied operands are never killed, so we need to check that. And that; // means we need to determine the index of the operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp:201,Avoid,Avoid,201,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,1,['Avoid'],['Avoid']
Safety,"// If this wasn't already an extending load, we need to widen the result; // register to avoid creating a load with a narrower result than the source.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:89,avoid,avoid,89,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['avoid'],['avoid']
Safety,"// If true, cleans up redundant/erroneous code around changed code with; // clang-format's cleanup functionality, e.g. redundant commas around deleted; // parameter or empty namespaces introduced by deletions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h:22,redund,redundant,22,interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Refactoring/AtomicChange.h,2,['redund'],['redundant']
Safety,"// If true, split the backedge of a loop when placing the safepoint, otherwise; // split the latch block itself. Both are useful to support for; // experimentation, but in practice, it looks like splitting the backedge; // optimizes better.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:58,safe,safepoint,58,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,"// If truncating more than the original extended value, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:56,abort,abort,56,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['abort'],['abort']
Safety,"// If two pointers are in the same address space, they have the same size,; // so we don't need to do any truncation, etc. This avoids introducing; // ptrtoint instructions for pointers that may be non-integral.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:128,avoid,avoids,128,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,1,['avoid'],['avoids']
Safety,"// If two symbols with differing sizes end up in the same mergeable section; // that section can be assigned an incorrect entry size. To avoid this we; // usually put symbols of the same size into distinct mergeable sections with; // the same name. Doing so relies on the "",unique ,"" assembly feature. This; // feature is not avalible until bintuils version 2.35; // (https://sourceware.org/bugzilla/show_bug.cgi?id=25380).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:137,avoid,avoid,137,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['avoid'],['avoid']
Safety,"// If unsafe fp math optimization is enabled and there are no other uses of; // the CMP operands, and the condition code is EQ or NE, we can optimize it; // to an integer comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:6,unsafe,unsafe,6,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['unsafe'],['unsafe']
Safety,"// If v16i32 is to be avoided, we'll need to split and concatenate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,avoid,avoided,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avoid'],['avoided']
Safety,// If we actually eliminated a barrier we need to eliminate the associated; // llvm.assumes as well to avoid creating UB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:103,avoid,avoid,103,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['avoid'],['avoid']
Safety,"// If we already had a dynamic specification, parse the noexcept for,; // recovery, but emit a diagnostic and don't store the results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:74,recover,recovery,74,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recovery']
Safety,"// If we already have a constant addrspacecast, it should be safe to cast it; // off.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp:61,safe,safe,61,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp,1,['safe'],['safe']
Safety,"// If we already have head sample counts, we must have value profile; // for call sites added already. Skip to avoid double counting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp:111,avoid,avoid,111,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,1,['avoid'],['avoid']
Safety,"// If we are already folding into another operand of MI, then; // we can't commute the instruction, otherwise we risk making the; // other fold illegal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:113,risk,risk,113,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['risk'],['risk']
Safety,"// If we are before legalize types, we want the other legalization to happen; // first (for example, to avoid messing with soft float).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:104,avoid,avoid,104,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// If we are building a TU prefix for serialization, it is safe to transfer; // these over, even though they are not parsed. The end of the TU should be; // outside of any eager template instantiation scope, so when this AST is; // deserialized, these templates will not be parsed until the end of the; // combined TU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:59,safe,safe,59,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['safe'],['safe']
Safety,"// If we are doing PreLinkOpt, the function is external. So it is safe to; // use getOrInsertFunction() at this stage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:66,safe,safe,66,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['safe'],['safe']
Safety,"// If we are inserting one variable into a vector of non-zero constants, try; // to avoid loading each constant element as a scalar. Load the constants as a; // vector and then insert the variable scalar element. If insertion is not; // supported, fall back to a shuffle to get the scalar blended with the; // constants. Insertion into a zero vector is handled as a special-case; // somewhere below here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:84,avoid,avoid,84,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If we are just checking for a icmp eq of a single bit and zext'ing it; // to an integer, then shift the bit to the appropriate place and then; // cast to integer to avoid the comparison.; // FIXME: This set of transforms does not check for extra uses and/or creates; // an extra instruction (an optional final cast is not included; // in the transform comments). We may also want to favor icmp over; // shifts in cases of equal instructions because icmp has better; // analysis in general (invert the transform).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:168,avoid,avoid,168,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['avoid'],['avoid']
Safety,"// If we are loading the first and last elements of a vector, it is safe and; // always faster to load the whole vector. Replace the masked load with a; // vector load and select.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:68,safe,safe,68,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['safe'],['safe']
Safety,"// If we are not in ""HazardRecognizerMode"" and therefore not being run from; // the scheduler, track possible stalls from hazards but don't insert noops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:21,Hazard,HazardRecognizerMode,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,2,"['Hazard', 'hazard']","['HazardRecognizerMode', 'hazards']"
Safety,"// If we are not statically linked, we should register the pragmas ourselves; // because the dlopen happens after creating the clang::Preprocessor which; // calls RegisterBuiltinPragmas.; // FIXME: This can be avoided by refactoring our routine and moving it to; // the CIFactory. This requires an abstraction which allows us to; // conditionally create MultiplexingConsumers.; // Copied from Lex/Pragma.cpp; // Pragmas added by plugins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp:210,avoid,avoided,210,interpreter/cling/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp,1,['avoid'],['avoided']
Safety,"// If we are shifting by X+/-/^N where N == 0 mod Size, then just shift by X; // to avoid the ADD/SUB/XOR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:84,avoid,avoid,84,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// If we are shifting by X+/-N where N == 0 mod Size, then just shift by X; // to avoid the ADD/SUB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:82,avoid,avoid,82,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// If we are shifting by X+N where N == 0 mod Size, then just shift by X; // to avoid the ADD.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:80,avoid,avoid,80,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,2,['avoid'],['avoid']
Safety,"// If we are sinking div/rem after a select, we may need to freeze the; // condition because div/rem may induce immediate UB with a poison operand.; // For example, the following transform is not safe if Cond can ever be poison; // because we can replace poison with zero and then we have div-by-zero that; // didn't exist in the original code:; // Cond ? x/y : x/z --> x / (Cond ? y : z)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:196,safe,safe,196,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['safe'],['safe']
Safety,"// If we are substituting an absorber constant into a binop and extra; // poison can't leak if we remove the select -- because both operands of; // the binop are based on the same value -- then it may be safe to replace; // the value with the absorber constant. Examples:; // (Op == 0) ? 0 : (Op & -Op) --> Op & -Op; // (Op == 0) ? 0 : (Op * (binop Op, C)) --> Op * (binop Op, C); // (Op == -1) ? -1 : (Op | (binop C, Op) --> Op | (binop C, Op)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:204,safe,safe,204,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['safe'],['safe']
Safety,"// If we are supporting bundling/unbundling and the current action is an; // input action of non-source file, we replace the host action by the; // unbundling action. The bundler tool has the logic to detect if an input; // is a bundle or not and if the input is not a bundle it assumes it is a; // host file. Therefore it is safe to create an unbundling action even if; // the input is not a bundle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:201,detect,detect,201,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,2,"['detect', 'safe']","['detect', 'safe']"
Safety,"// If we are using GNU as before 2.35, then this symbol might have; // been placed in an incompatible mergeable section. Emit an error if this; // is the case to avoid creating broken output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:162,avoid,avoid,162,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['avoid'],['avoid']
Safety,"// If we broke out of the loop, we still need to wait for everything to; // avoid race access to the chunk set.; //; // TODO: Create a way to kill remaining items we're ignoring; they could; // take a long time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp:76,avoid,avoid,76,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/Delta.cpp,1,['avoid'],['avoid']
Safety,// If we can actually detect overflow do so. Otherwise leave Overflow as; // nullopt (we assume it may have happened).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp:22,detect,detect,22,interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/KnownBits.cpp,1,['detect'],['detect']
Safety,"// If we can find the original types to work on instead of a vector of i1,; // we can avoid extend/extract conversion instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If we can return a reference to the data, do so to avoid copying it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp:54,avoid,avoid,54,interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitstream/Reader/BitstreamReader.cpp,1,['avoid'],['avoid']
Safety,"// If we can't analyze propagation through this instruction, just skip it; // and transitive users. Safe as false is a conservative result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,Safe,Safe,100,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['Safe'],['Safe']
Safety,"// If we can't generally expand the expression (e.g. it contains; // a divide), but it is already at a loop invariant point before the; // loop, wrap it in an unknown (to prevent the expander from trying; // to re-expand in a potentially unsafe way.) The restriction to; // integer types is required because the unknown hides the base, and; // SCEV can't compute the difference of two unknown pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:238,unsafe,unsafe,238,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['unsafe'],['unsafe']
Safety,"// If we can't prove that the sign bit is zero, we must add one to the; // maximum bit width to account for the unknown sign bit. This preserves; // the existing sign bit so we can safely sign-extend the root back to the; // original type. Otherwise, if we know the sign bit is zero, we will; // zero-extend the root instead.; //; // FIXME: This is somewhat suboptimal, as there will be cases where adding; // one to the maximum bit width will yield a larger-than-necessary; // type. In general, we need to add an extra bit only if we can't; // prove that the upper bit of the original type is equal to the; // upper bit of the proposed smaller type. If these two bits are the; // same (either zero or one) we know that sign-extending from the; // smaller type will result in the same value. Here, since we can't; // yet prove this, we are just making the proposed smaller type; // larger to ensure correctness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:181,safe,safely,181,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safely']
Safety,"// If we can, encode the offset directly into the instruction. If this is a; // normal PPC ""ri"" instruction, any 16-bit value can be safely encoded. If; // this is a PPC64 ""ix"" instruction, only a 16-bit value with the low two bits; // clear can be encoded. This is extremely uncommon, because normally you; // only ""std"" to a stack slot that is at least 4-byte aligned, but it can; // happen in invalid code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp:133,safe,safely,133,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCRegisterInfo.cpp,1,['safe'],['safely']
Safety,"// If we cannot use LEA to adjust SP, we may need to use ADD, which; // clobbers the EFLAGS. Check that we do not need to preserve it,; // otherwise, conservatively assume this is not; // safe to insert the epilogue here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:188,safe,safe,188,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['safe'],['safe']
Safety,"// If we commuted, regB may have changed so we should re-sample it to avoid; // confusing the three address conversion below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:70,avoid,avoid,70,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['avoid'],['avoid']
Safety,"// If we convert to something else than the supported type, e.g., to v4f64,; // abort early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:80,abort,abort,80,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['abort'],['abort']
Safety,"// If we could not compute the declaration context, it's because the; // declaration context is dependent but does not refer to a class,; // class template, or class template partial specialization. Complain; // and return early, to avoid the coming semantic disaster.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:233,avoid,avoid,233,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,"// If we couldn't recover from invalid arguments, don't form an annotation; // token -- we don't know how much to annotate.; // FIXME: This can lead to duplicate diagnostics if we retry parsing this; // template-id in another context. Try to annotate anyway?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:18,recover,recover,18,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['recover'],['recover']
Safety,"// If we detect a cycle in the PHI nodes, we exit. It would be; // possible to change cycles as well, but that would add a lot; // of complexity for a case that is unlikely to occur with MMA; // code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:9,detect,detect,9,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['detect'],['detect']
Safety,"// If we detect a loop of Phi nodes being processed by this method, for; // example:; //; // %a = phi i32 [ %some1, %preheader ], [ %b, %latch ]; // %b = phi i32 [ %some2, %preheader ], [ %a, %latch ]; //; // we don't want to deal with a case that complex, so return conservative; // answer false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:9,detect,detect,9,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['detect'],['detect']
Safety,"// If we detect infinite loops, force; // instrumenting the entry edge:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/CFGMST.h:9,detect,detect,9,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/CFGMST.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/CFGMST.h,1,['detect'],['detect']
Safety,// If we detect proper case - correct virtual register class; // if needed and go to another inlineasm operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp:9,detect,detect,9,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelDAGToDAG.cpp,1,['detect'],['detect']
Safety,"// If we detect that an instruction becomes unprofitable to sink,; // all earlier instructions won't be sunk either,; // so preemptively keep InstructionsProfitableToSink in sync.; // FIXME: is this the most performant approach?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:9,detect,detect,9,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['detect'],['detect']
Safety,"// If we didn't duplicate a bb into a particular predecessor, we; // might still have added an entry to SSAUpdateVals to correcly; // recompute SSA. If that case, avoid adding a dummy extra argument; // this PHI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:163,avoid,avoid,163,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['avoid'],['avoid']
Safety,"// If we didn't find any viable functions, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:43,abort,abort,43,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['abort'],['abort']
Safety,"// If we didn't manage to figure out if the value is constant or not,; // it is safe to assume that it's not constant and unsafe to assume; // that it's constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BuiltinFunctionChecker.cpp:80,safe,safe,80,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BuiltinFunctionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BuiltinFunctionChecker.cpp,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,// If we don't have PSHUFB then its worth avoiding an AND constant mask; // by performing 3 byte shifts. Shuffle combining can kick in above that.; // TODO: There may be some cases where VSH{LR}DQ+PAND is still better.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:42,avoid,avoiding,42,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoiding']
Safety,// If we don't have any not emitted inline virtual function then we are safe; // to emit an available_externally copy of vtable.; // FIXME we can still emit a copy of the vtable if we; // can emit definition of the inline functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:72,safe,safe,72,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['safe'],['safe']
Safety,"// If we don't have red zones, we need to compute the expected return; // address prior to the call and store it in a register that lives across; // the call.; //; // In some ways, this is doubly satisfying as a mitigation because it will; // also successfully detect stack smashing bugs in some cases (typically,; // when a callee-saved register is used and the callee doesn't push it onto; // the stack). But that isn't our primary goal, so we only use it as; // a fallback.; //; // FIXME: It isn't clear that this is reliable in the face of; // rematerialization in the register allocator. We somehow need to force; // that to not occur for this particular instruction, and instead to spill; // or otherwise preserve the value computed *prior* to the call.; //; // FIXME: It is even less clear why MachineCSE can't just fold this when we; // end up having to use identical instructions both before and after the; // call to feed the comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:261,detect,detect,261,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['detect'],['detect']
Safety,"// If we don't have the libcall or if the function we are compiling is the; // implementation of the expected libcall (avoid inf-loop), expand inline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:119,avoid,avoid,119,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['avoid'],['avoid']
Safety,"// If we don't know the file size, use fstat to find out. fstat on an open; // file descriptor is cheaper than stat on a random path.; // FIXME: this chunk of code is duplicated, but it avoids a fstat when; // RequiresNullTerminator = false and MapSize != -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp:186,avoid,avoids,186,interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,1,['avoid'],['avoids']
Safety,"// If we don't require privatization of device pointers, we emit the body in; // between the runtime calls. This avoids duplicating the body code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:113,avoid,avoids,113,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['avoid'],['avoids']
Safety,"// If we exhausted the entire block, we have no safe ranges to outline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:48,safe,safe,48,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['safe'],['safe']
Safety,"// If we find a trailing comment, iterate backwards to determine whether; // it seems to relate to a specific parameter. If so, break before that; // parameter to avoid changing the comment's meaning. E.g. don't move 'b'; // to the previous line in:; // SomeFunction(a,; // b, // comment; // c);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:163,avoid,avoid,163,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['avoid'],['avoid']
Safety,"// If we get foo:bar, this is almost certainly a typo for foo::bar. Recover; // and emit a fixit hint for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:68,Recover,Recover,68,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['Recover'],['Recover']
Safety,"// If we get here, then this source is importing from a temporary ASTContext; // that also has another ExternalASTMerger attached. It could be; // possible that the current ExternalASTMerger and the temporary ASTContext; // share a common ImporterSource, which means that the temporary; // AST could contain declarations that were imported from a source; // that this ExternalASTMerger can access directly. Instead of importing; // such declarations from the temporary ASTContext, they should instead; // be directly imported by this ExternalASTMerger from the original; // source. This way the ExternalASTMerger can safely do a minimal import; // without creating incomplete declarations originated from a temporary; // ASTContext. If we would try to complete such declarations later on, we; // would fail to do so as their temporary AST could be deleted (which means; // that the missing parts of the minimally imported declaration in that; // ASTContext were also deleted).; //; // The following code tracks back any declaration that needs to be; // imported from the temporary ASTContext to a persistent ASTContext.; // Then the ExternalASTMerger tries to import from the persistent; // ASTContext directly by using the associated ASTImporter. If that; // succeeds, this ASTImporter just maps the declarations imported by; // the other (persistent) ASTImporter to this (temporary) ASTImporter.; // The steps can be visualized like this:; //; // Target AST <--- 3. Indirect import --- Persistent AST; // ^ of persistent decl ^; // | |; // 1. Current import 2. Tracking back to persistent decl; // 4. Map persistent decl |; // & pretend we imported. |; // | |; // Temporary AST -------------------------------'; // First, ask the ExternalASTMerger of the source where the temporary; // declaration originated from.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:617,safe,safely,617,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,1,['safe'],['safely']
Safety,"// If we get here, we should have issued a diagnostic and formed a recovery; // lookup result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:67,recover,recovery,67,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recovery']
Safety,"// If we got a numeric constant, check to see if it comes from a macro that; // corresponds to the predefined __clang__ macro. If it does, warn the user; // and recover by pretending they said _Clang instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:161,recover,recover,161,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recover']
Safety,"// If we got an ambiguity involving a non-function template, treat this; // as a template name, and pick an arbitrary template for error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:137,recover,recovery,137,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recovery']
Safety,"// If we got here protocol must be at least its short form ""^root.*:"" :; // make sure that it is in the full form to avoid problems in TFTP",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx:117,avoid,avoid,117,net/net/src/TNetFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFile.cxx,1,['avoid'],['avoid']
Safety,"// If we had at least one store that could be merged in, add the starting; // store as well. We try to avoid this unless there is at least something; // interesting as a small compile-time optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:103,avoid,avoid,103,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['avoid'],['avoid']
Safety,"// If we had valid trailing '=' characters strip the right number of bytes; // from the end of the output buffer. We already know that the Input length; // it a multiple of 4 and is not zero, so direct character access is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Base64.cpp:222,safe,safe,222,interpreter/llvm-project/llvm/lib/Support/Base64.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Base64.cpp,1,['safe'],['safe']
Safety,"// If we have (sext (setcc A B)) and A and B are cheap to extend,; // we can move the sext into the arguments and have the same result. For; // example, if A and B are both loads, we can make those extending loads and; // avoid an extra instruction. This pattern appears often in VLS code; // generation where the inputs to the setcc have a different size to the; // instruction that wants to use the result of the setcc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:222,avoid,avoid,222,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If we have SSE[12] support, try to form min/max nodes. SSE min/max; // instructions match the semantics of the common C idiom x<y?x:y but not; // x<=y?x:y, because of how they handle negative zero (which can be; // ignored in unsafe-math mode).; // We also try to create v2f32 min/max nodes, which we later widen to v4f32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:229,unsafe,unsafe-math,229,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['unsafe'],['unsafe-math']
Safety,"// If we have SUB(r1, r2) and CMP(r2, r1), the condition code based on CMP; // needs to be updated to be based on SUB. Push the condition code; // operands to OperandsToUpdate. If it is safe to remove CmpInstr, the; // condition code of these operands will be modified.; // Here, Value == 0 means we haven't converted comparison against 1 or -1 to; // comparison against 0, which may modify predicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:186,safe,safe,186,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['safe'],['safe']
Safety,"// If we have SUB(r1, r2) and CMP(r2, r1), the condition code based on; // CMP needs to be updated to be based on SUB. Push the condition; // code operands to OperandsToUpdate. If it is safe to remove; // CmpInstr, the condition code of these operands will be modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:186,safe,safe,186,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,1,['safe'],['safe']
Safety,"// If we have SUB(r1, r2) and CMP(r2, r1), the condition code based; // on CMP needs to be updated to be based on SUB.; // If we have ADD(r1, r2, X) and CMP(r1, r2), the condition code also; // needs to be modified.; // Push the condition code operands to OperandsToUpdate.; // If it is safe to remove CmpInstr, the condition code of these; // operands will be modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:287,safe,safe,287,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['safe'],['safe']
Safety,"// If we have S_Use or S_CanRelease, perform our check for cfg hazard; // checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:63,hazard,hazard,63,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['hazard'],['hazard']
Safety,"// If we have a TClass compiled initialization, we can safely assume that; // there will also be a collection proxy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:55,safe,safely,55,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['safe'],['safely']
Safety,"// If we have a complex operand on the RHS and FastMath is not allowed, we; // delegate to a libcall to handle all of the complexities and minimize; // underflow/overflow cases. When FastMath is allowed we construct the; // divide inline using the same algorithm as for integer operands.; //; // FIXME: We would be able to avoid the libcall in many places if we; // supported imaginary types in addition to complex types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp:323,avoid,avoid,323,interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprComplex.cpp,1,['avoid'],['avoid']
Safety,"// If we have a constant operand, increment/decrement it and change the; // condition to avoid an invert.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:89,avoid,avoid,89,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If we have a constant shift amount, the non-SSE41 path is best as; // avoiding bitcasts make it easier to constant fold and reduce to PBLENDW.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:73,avoid,avoiding,73,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoiding']
Safety,"// If we have a global variable with internal linkage and thread-safe statics; // are disabled, we can just let the guard variable be of type i8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:65,safe,safe,65,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['safe'],['safe']
Safety,"// If we have a limit constant, try to form PCMPGT (signed cmp) to avoid; // not-of-PCMPEQ:; // X != INT_MIN --> X >s INT_MIN; // X != INT_MAX --> X <s INT_MAX --> INT_MAX >s X; // +X != 0 --> +X >s 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,avoid,avoid,67,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If we have a macro, that means the top of the file was ok. Set our state; // back to ""not having read any tokens"" so we can detect anything after the; // #endif.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h:127,detect,detect,127,interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,1,['detect'],['detect']
Safety,"// If we have a nest, we can quickly clone the entire loop nest using an; // iterative approach because it is a tree. We keep the cloned parent in the; // data structure to avoid repeatedly querying through a map to find it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:173,avoid,avoid,173,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['avoid'],['avoid']
Safety,"// If we have a template template parameter with translation unit context,; // then we're performing substitution into a default template argument of; // this template template parameter before we've constructed the template; // that will own this template template parameter. In this case, we; // use empty template parameter lists for all of the outer templates; // to avoid performing any substitutions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:371,avoid,avoid,371,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['avoid'],['avoid']
Safety,"// If we have a weak, non-discardable alias (weak, weak_odr), like an extern; // template instantiation or a dllexported class, avoid forming it on COFF.; // A COFF weak external alias cannot satisfy a normal undefined symbol; // reference from another TU. The other TU must also mark the referenced; // symbol as weak, which we cannot rely on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp:128,avoid,avoid,128,interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXX.cpp,1,['avoid'],['avoid']
Safety,"// If we have already seen another instruction that defines the same; // register, then this is not safe. Two defs is indicated by setting a; // PhysRegClobbers bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:100,safe,safe,100,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['safe'],['safe']
Safety,"// If we have an Objective-C class name followed by an identifier; // and either ':' or ']', this is an Objective-C class message; // send that's missing the opening '['. Recovery; // appropriately. Also take this path if we're performing code; // completion after an Objective-C class name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:171,Recover,Recovery,171,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['Recover'],['Recovery']
Safety,"// If we have an inalloca parameter that we can safely remove the; // inalloca attribute from, do so. This unlocks optimizations that; // wouldn't be safe in the presence of inalloca.; // FIXME: We should also hoist alloca affected by this to the entry; // block if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:48,safe,safely,48,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,2,['safe'],"['safe', 'safely']"
Safety,"// If we have an instruction which loads or stores, we can't guarantee that; // it is identical.; //; // For example, we may have; //; // %x1 = G_LOAD %addr (load N from @somewhere); // ...; // call @foo; // ...; // %x2 = G_LOAD %addr (load N from @somewhere); // ...; // %or = G_OR %x1, %x2; //; // It's possible that @foo will modify whatever lives at the address we're; // loading from. To be safe, let's just assume that all loads and stores; // are different (unless we have something which is guaranteed to not; // change.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:396,safe,safe,396,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['safe'],['safe']
Safety,"// If we have empty structures inside a union, we can assign both; // the same offset. Just avoid pushing them twice in the list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:92,avoid,avoid,92,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['avoid'],['avoid']
Safety,"// If we have fptrunc(OpI (fpextend x), (fpextend y)), we would like to; // simplify this expression to avoid one or more of the trunc/extend; // operations if we can do so without changing the numerical results.; //; // The exact manner in which the widths of the operands interact to limit; // what we can and cannot do safely varies from operation to operation, and; // is explained below in the various case statements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:104,avoid,avoid,104,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,2,"['avoid', 'safe']","['avoid', 'safely']"
Safety,"// If we have have to work around the fract/frexp bug, we're worse off than; // using the fdiv.fast expansion. The full safe expansion is faster if we have; // fast FMA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:120,safe,safe,120,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['safe'],['safe']
Safety,"// If we have seen an instruction with side effects, it's unsafe to reorder an; // instruction which reads memory or itself has side effects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:58,unsafe,unsafe,58,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['unsafe'],['unsafe']
Safety,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // FIXME: don't do this if they're efficiently moveable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:99,avoid,avoid,99,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['avoid'],['avoid']
Safety,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // FIXME: this may not actually make any sense if we can efficiently move; // elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:99,avoid,avoid,99,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['avoid'],['avoid']
Safety,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // From the original LLVM implementation:; // FIXME: don't do this if they're efficiently moveable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:99,avoid,avoid,99,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['avoid'],['avoid']
Safety,"// If we have to grow to have enough elements, destroy the current elements.; // This allows us to avoid copying them during the grow.; // From the original LLVM implementation:; // FIXME: this may not actually make any sense if we can efficiently move; // elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:99,avoid,avoid,99,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['avoid'],['avoid']
Safety,"// If we have to update users but EFLAGS is live-out abort, since we cannot; // easily find all of the users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:53,abort,abort,53,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['abort'],['abort']
Safety,// If we have to use more than one INSERT_VECTOR_ELT then this; // optimization is likely to increase code size; avoid peforming it in; // such a case. We can use a load from a constant pool in this case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:113,avoid,avoid,113,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If we have two real floating types, convert the smaller operand to the; // bigger result; // Note: Safe to skip updating bitwidth because this must terminate",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h:102,Safe,Safe,102,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,1,['Safe'],['Safe']
Safety,"// If we haven't created a valid MachineOperand for every DbgOp, abort and; // produce an undef DBG_VALUE.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp:65,abort,abort,65,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,1,['abort'],['abort']
Safety,"// If we hit an error and recovered by parsing up to a semicolon, eat the; // semicolon and don't issue further diagnostics about missing brackets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:26,recover,recovered,26,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recovered']
Safety,"// If we keep it in the safe module, then delete it in the test module",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:24,safe,safe,24,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,1,['safe'],['safe']
Safety,"// If we know the index is in the first half, and we know the subvector; // doesn't cross the boundary between the halves, we can avoid spilling the; // vector, and insert into the lower half of the split vector directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:130,avoid,avoid,130,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['avoid'],['avoid']
Safety,"// If we know the trip count or a multiple of it, we can safely use an; // unconditional branch for some iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:57,safe,safely,57,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,1,['safe'],['safely']
Safety,"// If we look through a vector bitcast, the caller will bitcast the operands; // to match the condition's number of bits (N x i1).; // To make this poison-safe, disallow bitcast from wide element to narrow; // element. That could allow poison in lanes where it was not present in the; // original code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:155,safe,safe,155,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safe']
Safety,"// If we looked through copies to find source modifiers on an SGPR operand,; // we now have an SGPR register source. To avoid potentially violating the; // constant bus restriction, we need to insert a copy to a VGPR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:120,avoid,avoid,120,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,1,['avoid'],['avoid']
Safety,"// If we made no changes so far, we are safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:40,safe,safe,40,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['safe'],['safe']
Safety,"// If we need to check two pointers to the same underlying object; // with a non-constant difference, we shouldn't perform any pointer; // grouping with those pointers. This is because we can easily get; // into cases where the resulting check would return false, even when; // the accesses are safe.; //; // The following example shows this:; // for (i = 0; i < 1000; ++i); // a[5000 + i * m] = a[i] + a[i + 9000]; //; // Here grouping gives a check of (5000, 5000 + 1000 * m) against; // (0, 10000) which is always false. However, if m is 1, there is no; // dependence. Not grouping the checks for a[i] and a[i + 9000] allows; // us to perform an accurate check in this case.; //; // The above case requires that we have an UnknownDependence between; // accesses to the same underlying object. This cannot happen unless; // FoundNonConstantDistanceDependence is set, and therefore UseDependencies; // is also false. In this case we will use the fallback path and create; // separate checking groups for all pointers.; // If we don't have the dependency partitions, construct a new; // checking pointer group for each pointer. This is also required; // for correctness, because in this case we can have checking between; // pointers to the same underlying object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:295,safe,safe,295,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['safe'],['safe']
Safety,"// If we need to materialize a 64-bit immediate, it will be split up later; // anyway. Avoid creating the harder to understand 64-bit immediate; // materialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:87,Avoid,Avoid,87,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,"// If we need to zero extend the backedge count, check if we can add one to; // it prior to zero extending without overflow. Provided this is safe, it; // allows better simplification of the +1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:142,safe,safe,142,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['safe'],['safe']
Safety,// If we only used V2 then splat the lane blend mask to avoid any demanded; // elts from V1 in this lane (the V1 equivalent is implicit with a zero; // blend mask bit).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:56,avoid,avoid,56,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If we pass all the checks, it's safe to remove the PTEST and use the flags; // as they are prior to PTEST. Sometimes this requires the tested PTEST; // operand to be replaced with an equivalent instruction that also sets the; // flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:35,safe,safe,35,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['safe'],['safe']
Safety,"// If we phi-translated the op, it must be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:43,safe,safe,43,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['safe'],['safe']
Safety,"// If we reached the end, it is safe to clobber Reg at the end of a block of; // no successor has it live in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:32,safe,safe,32,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,1,['safe'],['safe']
Safety,"// If we read this section from an object file, use its original size for the; // padding of the LEB value to avoid changing the file size. Otherwise, pad; // out to 5 bytes to make it predictable, and match the behavior of clang.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/wasm/WasmWriter.cpp:110,avoid,avoid,110,interpreter/llvm-project/llvm/lib/ObjCopy/wasm/WasmWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/wasm/WasmWriter.cpp,2,"['avoid', 'predict']","['avoid', 'predictable']"
Safety,"// If we receive a broken type, recover by assuming 'int' and; // marking this declaration as invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:32,recover,recover,32,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recover']
Safety,"// If we recovered from a misplaced module begin, we expect to hit a; // misplaced module end too. Stay in the current context when this; // happens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:9,recover,recovered,9,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['recover'],['recovered']
Safety,"// If we run in unsafe-math mode, then convert the FMAX and FMIN nodes; // into FMINC and FMAXC, which are Commutative operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:16,unsafe,unsafe-math,16,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['unsafe'],['unsafe-math']
Safety,"// If we run out of data, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:26,abort,abort,26,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,1,['abort'],['abort']
Safety,"// If we see two releases in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second release, which may allow us to; // eliminate the first release too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:381,avoid,avoids,381,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,1,['avoid'],['avoids']
Safety,"// If we see two retains in a row on the same pointer. If so, make; // a note, and we'll cicle back to revisit it after we've; // hopefully eliminated the second retain, which may allow us to; // eliminate the first retain too.; // Theoretically we could implement removal of nested retain+release; // pairs by making PtrState hold a stack of states, but this is; // simple and avoids adding overhead for the non-nested case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:378,avoid,avoids,378,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,1,['avoid'],['avoids']
Safety,// If we still have uses that are not accounted for by the expression; // then it is not safe to modify the value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:89,safe,safe,89,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['safe'],['safe']
Safety,"// If we use the original shuffle mask and op1 is *variable*, we would be; // putting an undef into operand 1 of div/rem/shift. This is either UB or; // poison. We do not have to guard against UB when *constants* are op1; // because safe constants guarantee that we do not overflow sdiv/srem (and; // there's no danger for other opcodes).; // TODO: To allow this case, create a new shuffle mask with no undefs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:233,safe,safe,233,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['safe'],['safe']
Safety,"// If we utilize a flow-based count inference, then we trust the computed; // counts and set the entry count as computed by the algorithm. This is; // primarily done to sync the counts produced by profi and BFI inference,; // which uses the entry count for mass propagation.; // If profi produces a zero-value for the entry count, we fallback to; // Samples->getHeadSamples() + 1 to avoid functions with zero count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h:383,avoid,avoid,383,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseImpl.h,1,['avoid'],['avoid']
Safety,"// If we were able to eliminate all unsafe uses for a type checked load,; // eliminate the associated type tests by replacing them with true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:36,unsafe,unsafe,36,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['unsafe'],['unsafe']
Safety,"// If we would have cleared the state foregoing the fact that we are known; // safe, stop code motion. This is because whether or not it is safe to; // remove RR pairs via KnownSafe is an orthogonal concept to whether we; // are allowed to perform code motion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:79,safe,safe,79,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,2,['safe'],['safe']
Safety,"// If we would output half of a line ending, advance one character to output; // the whole line ending. All buffers are null terminated, so looking ahead; // one byte is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp:170,safe,safe,170,interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/InclusionRewriter.cpp,1,['safe'],['safe']
Safety,// If we write (or read-write) to a single destination and there are no; // other reads in this loop then is it safe to vectorize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:112,safe,safe,112,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['safe'],['safe']
Safety,"// If we're adding a bitcode file to the archive, detect the Archive kind; // based on the target triple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp:50,detect,detect,50,interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,1,['detect'],['detect']
Safety,"// If we're allowed to diagnose this and recover, do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:41,recover,recover,41,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Safety,"// If we're backed by a real file system, perform; // the detection only once and save the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Distro.cpp:58,detect,detection,58,interpreter/llvm-project/clang/lib/Driver/Distro.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Distro.cpp,1,['detect'],['detection']
Safety,"// If we're being run from the command-line, the module build stack will not; // have been filled in yet, so complete it now in order to allow us to detect; // module cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:149,detect,detect,149,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,1,['detect'],['detect']
Safety,"// If we're creating a BFI instruction avoid cases where we need more; // instructions to materialize the BFI constant as compared to the original; // ORR. A BFXIL will use the same constant as the original ORR, so the code; // should be no worse in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// If we're dealing with an un-offset LLVM IR type, then it means that we're; // returning an 8-byte unit starting with it. See if we can safely use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:138,safe,safely,138,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['safe'],['safely']
Safety,"// If we're doing a merge on a path that's previously seen a partial; // merge, conservatively drop the sequence, to avoid doing partial; // RR elimination. If the branch predicates for the two merge differ,; // mixing them is unsafe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp:117,avoid,avoid,117,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.cpp,2,"['avoid', 'unsafe']","['avoid', 'unsafe']"
Safety,"// If we're in -debug-pass=Executions mode, construct the SCC node list,; // otherwise avoid constructing this string as it is expensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:87,avoid,avoid,87,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,1,['avoid'],['avoid']
Safety,"// If we're just performing this lookup for error-recovery purposes,; // don't extend the nested-name-specifier. Just return now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:50,recover,recovery,50,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['recover'],['recovery']
Safety,"// If we're loading retained from a __strong xvalue, we can avoid; // an extra retain/release pair by zeroing out the source of this; // ""move"" operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:60,avoid,avoid,60,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['avoid'],['avoid']
Safety,"// If we're narrowing a shift, the shift amount must be safe (less than the; // width) in the narrower type. If the shift amount is greater, instsimplify; // usually handles that case, but we can't guarantee/assert it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:56,safe,safe,56,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safe']
Safety,"// If we're negating a FMUL node on a target with FMA, then we can avoid the; // use of a constant by performing (-0 - A*B) instead.; // FIXME: Check rounding control flags as well once it becomes available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,avoid,avoid,67,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If we're optimizing for size, only fold if at least one of the constants is; // only used once or the combined shuffle has included a variable mask; // shuffle, this is to avoid constant pool bloat.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:175,avoid,avoid,175,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// If we're reducing the load width in order to avoid having to use an extra; // instruction to do extension then it's probably a good idea.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:48,avoid,avoid,48,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// If we're returning 'self', kill the initial retain. This is a; // heuristic attempt to ""encourage correctness"" in the really unfortunate; // case where we have a return of self during a dealloc and we desperately; // need to avoid the possible autorelease.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:228,avoid,avoid,228,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['avoid'],['avoid']
Safety,"// If we're saving temps and the temp file conflicts with the input file,; // then avoid overwriting input file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:83,avoid,avoid,83,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['avoid'],['avoid']
Safety,"// If we're storing a formatv_object, we can avoid an extra copy by formatting; // it immediately and returning the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Twine.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/Support/Twine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Twine.cpp,1,['avoid'],['avoid']
Safety,"// If we're using the '*' case here or if this check is redundant, then we; // use the enclosing version to check both branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:56,redund,redundant,56,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['redund'],['redundant']
Safety,"// If we've already decided this function is invalid, e.g. because; // we saw a `return` whose expression had an error, don't keep; // trying to deduce its return type.; // (Some return values may be needlessly wrapped in RecoveryExpr).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:222,Recover,RecoveryExpr,222,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['Recover'],['RecoveryExpr']
Safety,"// If we've already handled this import, just return the cached result.; // This one-element cache is important to eliminate redundant diagnostics; // when both the preprocessor and parser see the same import declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:125,redund,redundant,125,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['redund'],['redundant']
Safety,"// If we've got a scalar value of the right size, try to avoid going; // through memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:57,avoid,avoid,57,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,2,['avoid'],['avoid']
Safety,"// If we've inlined the constructor, then DstEvaluated would be empty.; // In this case we still want a sink, which could be implemented; // in processCallExit. But we don't have that implemented at the moment,; // so if you hit this assertion, see if you can avoid inlining; // the respective constructor when analyzer-config cfg-temporary-dtors; // is set to false.; // Otherwise there's nothing wrong with inlining such constructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:260,avoid,avoid,260,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['avoid'],['avoid']
Safety,"// If we've performed some kind of recovery, (re-)build the type source; // information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:35,recover,recovery,35,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['recover'],['recovery']
Safety,// If we've previously reserved a register for long branches; // avoid running the scavenger and just use those registers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:65,avoid,avoid,65,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// Ignore 'IsInsideToken' to allow matching trailing comments which; // need to be reflowed as that causes the token to appear in two; // different changes, which will cause incorrect alignment as we'll; // reflow early due to detecting multiple aligning tokens per line.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:227,detect,detecting,227,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,1,['detect'],['detecting']
Safety,"// Ignore VD to avoid completing the variable itself, e.g. in 'int foo = ^'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:16,avoid,avoid,16,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['avoid'],['avoid']
Safety,// Ignore any side-effects from a failed evaluation. This is safe because; // they can't interfere with any other argument evaluation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:61,safe,safe,61,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,2,['safe'],['safe']
Safety,// Ignore attributes unrelated to thread-safety,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:41,safe,safety,41,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,1,['safe'],['safety']
Safety,// Ignore dead code to save time and avoid bugs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:37,avoid,avoid,37,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,1,['avoid'],['avoid']
Safety,// Ignore dispatch hazards or invalid buffer sizes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:19,hazard,hazards,19,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['hazard'],['hazards']
Safety,"// Ignore filenames not beginning with ""llvmcache-"" or ""Thin-"". This; // includes the timestamp file as well as any files created by the user.; // This acts as a safeguard against data loss if the user specifies the; // wrong directory as their cache directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp:162,safe,safeguard,162,interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CachePruning.cpp,1,['safe'],['safeguard']
Safety,"// Ignore opportunities to avoid placing safepoints on backedges, useful for; // validation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,2,"['avoid', 'safe']","['avoid', 'safepoints']"
Safety,// Ignore the SymbolName field to avoid a string compare. Comparing the; // function hash serves the same purpose.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h:34,avoid,avoid,34,interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/MemProf.h,1,['avoid'],['avoid']
Safety,// Ignore type-casting instructions we identified during induction; // detection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:71,detect,detection,71,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['detect'],['detection']
Safety,// Ignore type-promoting instructions we identified during reduction; // detection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:73,detect,detection,73,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['detect'],['detection']
Safety,"// Ignore uses which are part of other SCEV expressions, to avoid; // analyzing them multiple times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:60,avoid,avoid,60,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['avoid'],['avoid']
Safety,"// IgnoreFilesFunc_t takes a const reference to avoid having to; // include the actual definition of PresumedLoc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h:48,avoid,avoid,48,interpreter/cling/include/cling/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Interpreter.h,1,['avoid'],['avoid']
Safety,// Immediate has larger code size than register. So avoid folding the; // immediate if it has more than 1 use and we are optimizing for size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:52,avoid,avoid,52,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['avoid'],['avoid']
Safety,// Immediates for SVE llvm intrinsics are always 32bit. We can safely; // truncate because the immediate has been range checked and no valid; // immediate requires more than a handful of bits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:63,safe,safely,63,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['safe'],['safely']
Safety,"// Implement some heroics to detect shifts of masked values where the mask can; // be replaced by extending the shift and undoing that in the addressing mode; // scale. Patterns such as (shl (srl x, c1), c2) are canonicalized into (and; // (srl x, SHIFT), MASK) by DAGCombines that don't know the shl can be done in; // the addressing mode. This results in code such as:; //; // int f(short *y, int *lookup_table) {; // ...; // return *y + lookup_table[*y >> 11];; // }; //; // Turning into:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $11, %ecx; // addl (%rsi,%rcx,4), %eax; //; // Instead of:; // movzwl (%rdi), %eax; // movl %eax, %ecx; // shrl $9, %ecx; // andl $124, %rcx; // addl (%rsi,%rcx), %eax; //; // Note that this function assumes the mask is provided as a mask *after* the; // value is shifted. The input chain may or may not match that, but computing; // such a mask is trivial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:29,detect,detect,29,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['detect'],['detect']
Safety,"// Implementation detail: all the cleverness here should happen without; // creating new SCEV expressions -- our caller knowns tricks to avoid creating; // SCEV expressions when possible, and we should not break that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:137,avoid,avoid,137,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,"// Implementation file cannot be found anywhere, warn user and abort operation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:63,abort,abort,63,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['abort'],['abort']
Safety,// Implicit uses may safely overlap true operands,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:21,safe,safely,21,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['safe'],['safely']
Safety,"// Import the type parameter list after MapImported, to avoid; // loops when bringing in their DeclContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:56,avoid,avoid,56,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['avoid'],['avoid']
Safety,"// Important note regarding the order of checks. They are ordered by weight; // from lowest to highest. Doing that allows to avoid ""unstable"" results; // when several conditions heuristics can be applied simultaneously.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:125,avoid,avoid,125,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,1,['avoid'],['avoid']
Safety,"// Important special case: The caller has given up and just wants us to; // skip the rest of the file. Do this without recursing, since we can; // get here precisely because the caller detected too much recursion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:185,detect,detected,185,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['detect'],['detected']
Safety,// Improve St's chain. Use a new node to avoid creating a loop from CombineTo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:41,avoid,avoid,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,// Improve compile time by avoiding linear scans when there is no work.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:27,avoid,avoiding,27,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['avoid'],['avoiding']
Safety,"// In ""llc-safe"" mode, default to using LLC as the ""safe"" backend.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:11,safe,safe,11,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,2,['safe'],['safe']
Safety,"// In -output-dir mode, it's safe to use multiple threads to print files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp:29,safe,safe,29,interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CodeCoverage.cpp,1,['safe'],['safe']
Safety,"// In ARC, move out of consumed arguments so that the release cleanup; // entered by StartFunction doesn't cause an over-release. This isn't; // optimal -O0 code generation, but it should get cleaned up when; // optimization is enabled. This also assumes that delegate calls are; // performed exactly once for a set of arguments, but that should be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:349,safe,safe,349,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['safe'],['safe']
Safety,"// In C++, don't return an invalid declaration. We can't recover well from; // the cases where we make the type anonymous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:57,recover,recover,57,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recover']
Safety,"// In C++14, we can't safely access any mutable state when we might be; // evaluating after an unmodeled side effect. Parameters are modeled as state; // in the caller, but aren't visible once the call returns, so they can be; // modified in a speculatively-evaluated call.; //; // FIXME: Not all local state is mutable. Allow local constant subobjects; // to be read here (but take care with 'mutable' fields).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:22,safe,safely,22,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['safe'],['safely']
Safety,"// In C, extern is typically used to avoid tentative definitions when; // declaring variables in headers, but adding an intializer makes it a; // definition. This is somewhat confusing, so GCC and Clang both warn on it.; // In C++, extern is often used to give implictly static const variables; // external linkage, so don't warn in that case. If selectany is present,; // this might be header code intended for C and C++ inclusion, so apply the; // C++ rules.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:37,avoid,avoid,37,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,"// In C, it is common to represent an array of structs as a pointer to the first; // object in the array. If the caller indexes a pointer to an object that does not; // define indexing, then highly likely such C-style indexing is the goal. Just; // like C, this is potentially unsafe, so caveat emptor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx:277,unsafe,unsafe,277,bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPInstance.cxx,1,['unsafe'],['unsafe']
Safety,"// In C, we allow this as a (popular) extension / bug. Don't bother; // producing further diagnostics for redundant qualifiers after this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:106,redund,redundant,106,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['redund'],['redundant']
Safety,"// In GCC, $1 is not widely used in generated code (it's used only in a few; // specific situations), so there is no real need for users to add it to; // the clobbers list if they want to use it in their inline assembly code.; //; // In LLVM, $1 is treated as a normal GPR and is always allocatable during; // code generation, so using it in inline assembly without adding it to the; // clobbers list can cause conflicts between the inline assembly code and; // the surrounding generated code.; //; // Another problem is that LLVM is allowed to choose $1 for inline assembly; // operands, which will conflict with the "".set at"" assembler option (which; // we use only for inline assembly, in order to maintain compatibility with; // GCC) and will also conflict with the user's usage of $1.; //; // The easiest way to avoid these conflicts and keep $1 as an allocatable; // register for generated code is to automatically clobber $1 for all inline; // assembly code.; //; // FIXME: We should automatically clobber $1 only for inline assembly code; // which actually uses it. This would allow LLVM to use $1 for inline; // assembly operands if the user's assembly code doesn't use it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h:817,avoid,avoid,817,interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Mips.h,1,['avoid'],['avoid']
Safety,"// In ILP32 (x32) mode, pointers are 32 bits and need to be zero-extended to; // 64 bits. Instructions with 32-bit register addresses perform this zero; // extension for us and we can safely ignore the high bits of Offset.; // Instructions with only a 32-bit immediate address do not, though: they; // sign extend instead. This means only address the low 2GB of address space; // is directly addressable, we need indirect addressing for the high 2GB of; // address space.; // TODO: Some of the earlier checks may be relaxed for ILP32 mode as the; // implicit zero extension of instructions would cover up any problem.; // However, we have asserts elsewhere that get triggered if we do, so keep; // the checks for now.; // TODO: We would actually be able to accept these, as well as the same; // addresses in LP64 mode, by adding the EIZ pseudo-register as an operand; // to get an address size override to be emitted. However, this; // pseudo-register is not part of any register class and therefore causes; // MIR verification to fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:184,safe,safely,184,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['safe'],['safely']
Safety,"// In JavaScript, some @tags can be followed by {, and machinery that parses; // these comments will fail to understand the comment if followed by a line; // break. So avoid ever breaking before a {.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:168,avoid,avoid,168,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['avoid'],['avoid']
Safety,"// In ObjC ARC mode with no ObjC ARC exception safety, tell the ARC; // optimizer it can aggressively ignore unwind edges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:47,safe,safety,47,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,3,['safe'],['safety']
Safety,"// In Objective-C type declarations, avoid breaking after the category's; // open paren (we'll prefer breaking after the protocol list's opening; // angle bracket, if present).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:37,avoid,avoid,37,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['avoid'],['avoid']
Safety,// In OpenCL captures for blocks called as lambda functions; // are located in the private address space. Blocks used in; // enqueue_kernel can be located in a different address space; // depending on a vendor implementation. Thus preventing; // taking an address of the capture to avoid invalid AS casts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:282,avoid,avoid,282,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,"// In Phase 1 we iterate through the instructions of the block and for each; // instruction we get its mode usage. If the instruction uses the Mode register; // we:; // - update the Change status, which tracks the changes to the Mode register; // made by this block; // - if this instruction's requirements are compatible with the current setting; // of the Mode register we merge the modes; // - if it isn't compatible and an InsertionPoint isn't set, then we set the; // InsertionPoint to the current instruction, and we remember the current; // mode; // - if it isn't compatible and InsertionPoint is set we insert a seteg before; // that instruction (unless this instruction forms part of the block's; // entry requirements in which case the insertion is deferred until Phase 3; // when predecessor exit values are known), and move the insertion point to; // this instruction; // - if this is a setreg instruction we treat it as an incompatible instruction.; // This is sub-optimal but avoids some nasty corner cases, and is expected to; // occur very rarely.; // - on exit we have set the Require, Change, and initial Exit modes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIModeRegister.cpp:990,avoid,avoids,990,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIModeRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIModeRegister.cpp,1,['avoid'],['avoids']
Safety,"// In SPIR-V address space casting can only happen to and from the Generic; // storage class. We can also only case Workgroup, CrossWorkgroup, or Function; // pointers to and from Generic pointers. As such, we can convert e.g. from; // Workgroup to Function by going via a Generic pointer as an intermediary. All; // other combinations can only be done by a bitcast, and are probably not safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:388,safe,safe,388,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,1,['safe'],['safe']
Safety,"// In SecA == SecB case. If the linker relaxation is enabled, we need record; // the ADD, SUB relocations. Otherwise the FixedValue has already been calc-; // ulated out in evaluateFixup, return true and avoid record relocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp:204,avoid,avoid,204,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchAsmBackend.cpp,1,['avoid'],['avoid']
Safety,"// In Thumb2 mode, the negative offset is very limited. Try to avoid; // out of range references. ldr <rt>,[<rn>, #-<imm8>]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:63,avoid,avoid,63,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// In X == Y ? f(X) : Z, try to evaluate f(Y) and replace the operand.; // Make sure Y cannot be undef though, as we might pick different values for; // undef in the icmp and in f(Y). Additionally, take care to avoid replacing; // X == Y ? X : Z with X == Y ? Y : Z, as that would lead to an infinite; // replacement cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:211,avoid,avoid,211,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['avoid'],['avoid']
Safety,"// In a class method, class messages to 'self' that return instancetype can; // be typed as the current class. We can safely do this in ARC because self; // can't be reassigned, and we do it unsafely outside of ARC because in; // practice people never reassign self in class methods and there's some; // virtue in not being aggressively pedantic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:118,safe,safely,118,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,2,"['safe', 'unsafe']","['safely', 'unsafely']"
Safety,"// In a register that is covered by its sub-registers, try to find redundant; // sub-registers. For example:; //; // QQ0 = {Q0, Q1}; // Q0 = {D0, D1}; // Q1 = {D2, D3}; //; // We can infer that D1_D2 is also a sub-register, even if it wasn't named in; // the register definition.; //; // The explicitly specified registers form a tree. This function discovers; // sub-register relationships that would force a DAG.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:67,redund,redundant,67,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['redund'],['redundant']
Safety,"// In addition to the cases handle just above, we need to prevent; // allocas and loads/stores from moving below a stacksave or a; // stackrestore. Avoiding moving allocas below stackrestore is currently; // thought to be conservatism. Moving loads/stores below a stackrestore; // can lead to incorrect code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:148,Avoid,Avoiding,148,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['Avoid'],['Avoiding']
Safety,"// In addition to the checks required for a register base, check that; // we do not try to use an unsafe Disp with a frame index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:98,unsafe,unsafe,98,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['unsafe'],['unsafe']
Safety,"// In asan mode emit a function call instead of a regular load and let the; // run-time deal with it: if the shadow is properly poisoned return the; // cookie, otherwise return 0 to avoid an infinite loop calling DTORs.; // We can't simply ignore this load using nosanitize metadata because; // the metadata may be lost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:182,avoid,avoid,182,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['avoid'],['avoid']
Safety,"// In assert-less builds, avoid crashing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:26,avoid,avoid,26,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,1,['avoid'],['avoid']
Safety,"// In canonical mode we compute the addrec as an expression of a canonical IV; // using evaluateAtIteration and expand the resulting SCEV expression. This; // way we avoid introducing new IVs to carry on the computation of the addrec; // throughout the loop.; //; // For nested addrecs evaluateAtIteration might need a canonical IV of a; // type wider than the addrec itself. Emitting a canonical IV of the; // proper type might produce non-legal types, for example expanding an i64; // {0,+,2,+,1} addrec would need an i65 canonical IV. To avoid this just fall; // back to non-canonical mode for nested addrecs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:166,avoid,avoid,166,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,2,['avoid'],['avoid']
Safety,"// In case of named arguments, the RooFormula will replace the argument names; // with x[0] to x[n]. There are two things that can go wrong if RooFormula is; // not implemented right. First, if there is a variable named ""x"" it should; // only be substituted if the matching substring is not followed by ""["", to not; // replace existing x[i]. Second, variables with integer names like ""0"" should; // only be substituted if the match is not followed by a ""]"", again to avoid; // replacing x[i]. This test checks that these cases are handled correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFormula.cxx:467,avoid,avoid,467,roofit/roofitcore/test/testRooFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFormula.cxx,1,['avoid'],['avoid']
Safety,"// In case of partial redundancy, we need to swap operands; // in another compare instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:22,redund,redundancy,22,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redund'],['redundancy']
Safety,"// In case of strict alignment, avoid an excessive number of byte wide stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// In case the ConstrainedDecl comes from modules, it is necessary to use; // the canonical decl to avoid different atomic constraints with the 'same'; // declarations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:100,avoid,avoid,100,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,1,['avoid'],['avoid']
Safety,"// In case the new lower limits of h2 axis are 0, it is better to set them to the minimum of; // the data set (which should be >0) to avoid data cut when plotting in log scale.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx:134,avoid,avoid,134,tree/treeplayer/src/TSelectorDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx,2,['avoid'],['avoid']
Safety,"// In debug mode, assert that we've found exactly one gadget.; // This helps us avoid conflicts in .bind() tags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:80,avoid,avoid,80,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['avoid'],['avoid']
Safety,// In error-recovery cases it's possible to get here even if we failed to; // synthesize the __begin and __end variables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:12,recover,recovery,12,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['recover'],['recovery']
Safety,// In general we cannot safely assume that the subscripts recovered from GEPs; // are in the range of values defined for their corresponding array; // dimensions. For example some C language usage/interpretation make it; // impossible to verify this at compile-time. As such we can only delinearize; // iff the subscripts are positive and are less than the range of the; // dimension.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:24,safe,safely,24,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,2,"['recover', 'safe']","['recovered', 'safely']"
Safety,"// In general, appending the expression wrapped by a CXXDefaultInitExpr; // may cause the same Expr to appear more than once in the CFG. Doing it; // here is safe because there's only one initializer per field.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:158,safe,safe,158,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['safe'],['safe']
Safety,"// In general, for error recovery purposes, the initalizer doesn't play; // part in the valid bit of the declaration. There are a few exceptions:; // 1) if the var decl has a deduced auto type, and the type cannot be; // deduced by an invalid initializer;; // 2) if the var decl is decompsition decl with a non-deduced type, and; // the initialization fails (e.g. `int [a] = {1, 2};`);; // Case 1) was already handled elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:25,recover,recovery,25,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery']
Safety,"// In general, if the root node is already created and linked, it is not safe; // to add new nodes since they may be unreachable by the root. However,; // pi-block nodes need to be added after the root node is linked, and they are; // always reachable by the root, because they represent components that are; // already reachable by root.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp:73,safe,safe,73,interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DDG.cpp,1,['safe'],['safe']
Safety,"// In general, we're looking for any cut of the graph which ensures; // there's a call safepoint along every edge between Header and Pred.; // For the moment, we look only for the 'cuts' that consist of a single call; // instruction in a block which is dominated by the Header and dominates the; // loop latch (Pred) block. Somewhat surprisingly, walking the entire chain; // of such dominating blocks gets substantially more occurrences than just; // checking the Pred and Header blocks themselves. This may be due to the; // density of loop exit conditions caused by range and null checks.; // TODO: structure this as an analysis pass, cache the result for subloops,; // avoid dom tree recalculations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:87,safe,safepoint,87,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,2,"['avoid', 'safe']","['avoid', 'safepoint']"
Safety,"// In host compilation the kernel is emitted as a stub function, which is; // a helper function for launching the kernel. The instructions in the helper; // function has nothing to do with the source code of the kernel. Do not emit; // debug info for the stub function to avoid confusing the debugger.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:272,avoid,avoid,272,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['avoid'],['avoid']
Safety,"// In implementations which use a barrier to achieve release semantics, we can; // delay emitting this barrier until we know a store is actually going to be; // attempted. The cost of this delay is that we need 2 copies of the block; // emitting the load-linked, affecting code size.; //; // Ideally, this logic would be unconditional except for the minsize check; // since in other cases the extra blocks naturally collapse down to the; // minimal loop. Unfortunately, this puts too much stress on later; // optimisations so we avoid emitting the extra logic in those cases too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:529,avoid,avoid,529,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['avoid'],['avoid']
Safety,"// In minimal SSA form, all Phi nodes are MultiVal.; // During conversion to SSA, incomplete Phi nodes may be introduced, which; // are later determined to be SingleVal, and are thus redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h:183,redund,redundant,183,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTIL.h,1,['redund'],['redundant']
Safety,"// In most cases the types of LHS and RHS will be the same, but in some; // crazy cases one or the other may be a pointer. ScalarEvolution doesn't; // depend on the type for correctness, but handling types carefully can; // avoid extra casts in the SCEVExpander. The LHS is more likely to be; // a pointer type than the RHS, so use the RHS' type here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:224,avoid,avoid,224,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,1,['avoid'],['avoid']
Safety,"// In non-aggressive mode, only warn on use-after-move of local variables; // (or local rvalue references) and of STL objects. The former is possible; // because local variables (or local rvalue references) are not tempting; // their user to re-use the storage. The latter is possible because STL; // objects are known to end up in a valid but unspecified state after the; // move and their state-reset methods are also known, which allows us to; // predict precisely when use-after-move is invalid.; // Some STL objects are known to conform to additional contracts after move,; // so they are not tracked. However, smart pointers specifically are tracked; // because we can perform extra checking over them.; // In aggressive mode, warn on any use-after-move because the user has; // intentionally asked us to completely eliminate use-after-move; // in his code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:450,predict,predict,450,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,1,['predict'],['predict']
Safety,"// In order to avoid a virtual call, we assume ROOT developers will override; // the default GenerateOffsetArray for cases where this function does not apply.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeaf.cxx:15,avoid,avoid,15,tree/tree/src/TLeaf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TLeaf.cxx,1,['avoid'],['avoid']
Safety,"// In order to avoid insert_subvector, used v4i32 than v2i32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:15,avoid,avoid,15,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// In order to avoid pointer reuse/recycling, skip the values that might; // have been deleted during a pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:15,avoid,avoid,15,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,1,['avoid'],['avoid']
Safety,"// In order to avoid register pressure, on an average, the number of DWORDS; // loaded together by all clustered mem ops should not exceed 8. This is an; // empirical value based on certain observations and performance related; // experiments.; // The good thing about this heuristic is - it avoids clustering of too many; // sub-word loads, and also avoids clustering of wide loads. Below is the; // brief summary of how the heuristic behaves for various `LoadSize`.; // (1) 1 <= LoadSize <= 4: cluster at max 8 mem ops; // (2) 5 <= LoadSize <= 8: cluster at max 4 mem ops; // (3) 9 <= LoadSize <= 12: cluster at max 2 mem ops; // (4) 13 <= LoadSize <= 16: cluster at max 2 mem ops; // (5) LoadSize >= 17: do not cluster",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:15,avoid,avoid,15,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,3,['avoid'],"['avoid', 'avoids']"
Safety,"// In order to avoid starting the next string at the terminating curly; // brace, advance the end position past it if we found an opening curly; // brace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterInst.cpp:15,avoid,avoid,15,interpreter/llvm-project/llvm/utils/TableGen/AsmWriterInst.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterInst.cpp,1,['avoid'],['avoid']
Safety,"// In order to be able to safely move MI over instructions that define; // ""Defs"" and use ""Uses"", no def operand from MI can be defined or used; // and no use operand can be defined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:26,safe,safely,26,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['safe'],['safely']
Safety,"// In order to transition away from ""__original_main"" gracefully, emit an; // alias for ""main"" in the no-argument case so that libc can detect when; // new-style no-argument main is in used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:136,detect,detect,136,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['detect'],['detect']
Safety,"// In order to turn ""IV - Offset < Limit"" into ""IV < Limit + Offset"", we need; // to be able to freely move values from left side of inequality to right side; // (just as in normal linear arithmetics). Overflows make things much more; // complicated, so we want to avoid this.; //; // Let's prove that the initial subtraction doesn't overflow with all IV's; // values from the safe range constructed for that check.; //; // [Case 1] IV - Offset < Limit; // It doesn't overflow if:; // SINT_MIN <= IV - Offset <= SINT_MAX; // In terms of scaled SINT we need to prove:; // SINT_MIN + Offset <= IV <= SINT_MAX + Offset; // Safe range will be constructed:; // 0 <= IV < Limit + Offset; // It means that 'IV - Offset' doesn't underflow, because:; // SINT_MIN + Offset < 0 <= IV; // and doesn't overflow:; // IV < Limit + Offset <= SINT_MAX + Offset; //; // [Case 2] Offset - IV > Limit; // It doesn't overflow if:; // SINT_MIN <= Offset - IV <= SINT_MAX; // In terms of scaled SINT we need to prove:; // -SINT_MIN >= IV - Offset >= -SINT_MAX; // Offset - SINT_MIN >= IV >= Offset - SINT_MAX; // Safe range will be constructed:; // 0 <= IV < Offset - Limit; // It means that 'Offset - IV' doesn't underflow, because; // Offset - SINT_MAX < 0 <= IV; // and doesn't overflow:; // IV < Offset - Limit <= Offset - SINT_MIN; //; // For the computed upper boundary of the IV's range (Offset +/- Limit) we; // don't know exactly whether it overflows or not. So if we can't prove this; // fact at compile time, we scale boundary computations to a wider type with; // the intention to add runtime overflow check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:265,avoid,avoid,265,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,4,"['Safe', 'avoid', 'safe']","['Safe', 'avoid', 'safe']"
Safety,"// In order to turn ""LV + C1 < C2"" into ""LV < C2 - C1"", we need to be able to; // freely move values from left side of inequality to right side (just as in; // normal linear arithmetics). Overflows make things much more complicated, so; // we want to avoid this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:251,avoid,avoid,251,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['avoid'],['avoid']
Safety,"// In order to turn ""LV - C1 < C2"" into ""LV < C2 + C1"", we need to be able to; // freely move values from left side of inequality to right side (just as in; // normal linear arithmetics). Overflows make things much more complicated, so; // we want to avoid this. Likewise, for ""C1 - LV < C2"" we need to prove that; // ""C1 - C2"" does not overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:251,avoid,avoid,251,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['avoid'],['avoid']
Safety,"// In particular this detect if the class has a version number.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:22,detect,detect,22,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['detect'],['detect']
Safety,// In place hoisting is safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:24,safe,safe,24,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['safe'],['safe']
Safety,"// In practice we should never have an undef CCR operand, if we do; // abort here as we are not prepared to preserve the flag.; // ??? Is this required?; // if (iter->getOperand(1).isUndef()); // return true;; // Working from the bottom, handle the first conditional branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp:71,abort,abort,71,interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kInstrInfo.cpp,1,['abort'],['abort']
Safety,"// In presence of finite 'safelen', it may be unsafe to mark all; // the memory instructions parallel, because loop-carried; // dependences of 'safelen' iterations are possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:26,safe,safelen,26,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,6,"['safe', 'unsafe']","['safelen', 'unsafe']"
Safety,"// In presence of finite 'safelen', it may be unsafe to mark all; // the memory instructions parallel, because loop-carried; // dependences of 'safelen' iterations are possible.; // If clause order(concurrent) is specified then the memory instructions; // are marked parallel even if 'safelen' is finite.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:26,safe,safelen,26,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,4,"['safe', 'unsafe']","['safelen', 'unsafe']"
Safety,"// In some cases a register may exist, but never be defined or used.; // It should never appear anywhere, but mark it as ""fixed"", just to be; // safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp:145,safe,safe,145,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSplitDouble.cpp,1,['safe'],['safe']
Safety,"// In some cases the shift/extend needs to be explicitly parsed together; // with the register, rather than as a separate operand. This is needed; // for addressing modes where the instruction as a whole dictates the; // scaling/extend, rather than specific bits in the instruction.; // By parsing them as a single operand, we avoid the need to pass an; // extra operand in all CodeGen patterns (because all operands need to; // have an associated value), and we avoid the need to update TableGen to; // accept operands that have no associated bits in the instruction.; //; // An added benefit of parsing them together is that the assembler; // can give a sensible diagnostic if the scaling is not correct.; //; // The default is 'lsl #0' (HasExplicitAmount = false) if no; // ShiftExtend is specified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:327,avoid,avoid,327,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,2,['avoid'],['avoid']
Safety,"// In some cases we remove a little to fast the period, we add; // it back if we need. It is assumed that 'right' and the rest of; // the name was cut by a delimiter, so this should be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:185,safe,safe,185,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['safe'],['safe']
Safety,"// In some cases, fPrimitives has the kMustCleanup bit set which will lead; // its destructor to call RecursiveRemove and since this pad is still; // likely to be (indirectly) in the list of cleanups, we must set; // fPrimitives to nullptr to avoid TPad::RecursiveRemove from calling; // a member function of a partially destructed object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:243,avoid,avoid,243,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['avoid'],['avoid']
Safety,"// In some platforms _setjmp and _longjmp are used instead. Change these to; // use setjmp/longjmp instead, because we later detect these functions by; // their names.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp:125,detect,detect,125,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLowerEmscriptenEHSjLj.cpp,1,['detect'],['detect']
Safety,"// In some very specific cases, semantic analysis of the RHS as an; // expression may require it to be rewritten. In these cases, we; // cannot safely keep the OVE around. Fortunately, we don't really; // need to: we don't use this particular OVE in multiple places, and; // no clients rely that closely on matching up expressions in the; // semantic expression with expressions from the syntactic form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:144,safe,safely,144,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,1,['safe'],['safely']
Safety,"// In standalone mode, for the serializer with a string table, emit the; // metadata first and set DidEmitMeta to avoid emitting it again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkSerializer.cpp:114,avoid,avoid,114,interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkSerializer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkSerializer.cpp,1,['avoid'],['avoid']
Safety,"// In strict mode, we must avoid spurious exceptions, and therefore; // must make sure to only emit a single STRICT_SINT_TO_FP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['avoid'],['avoid']
Safety,"// In that case, remapped buffer will be deleted by CompilerInstance on; // BeginSourceFile, so we call release() to avoid double deletion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:117,avoid,avoid,117,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,1,['avoid'],['avoid']
Safety,"// In the MS C++ ABI, the compiler emits destructor variants where they are; // used. If the destructor is used here but defined elsewhere, mark the; // virtual base destructors referenced. If those virtual base destructors; // are inline, this will ensure they are defined when emitting the complete; // destructor variant. This checking may be redundant if the destructor is; // provided later in this TU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:346,redund,redundant,346,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['redund'],['redundant']
Safety,"// In the case Repl is a load or a store, we make all their GEPs; // available: GEPs are not hoisted by default to avoid the address; // computations to be hoisted without the associated load or store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:115,avoid,avoid,115,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['avoid'],['avoid']
Safety,"// In the case of 'kDelayWrite' the caller want to avoid having to; // write the output objects once for every input file and instead; // write it only once at the end of the process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx:51,avoid,avoid,51,io/io/src/TFileMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx,1,['avoid'],['avoid']
Safety,"// In the case of an if statement, we try to hoist an invoke.; // FIXME: Can we define a safety predicate for CallBr?; // FIXME: Test case llvm/test/Transforms/SimplifyCFG/2009-06-15-InvokeCrash.ll; // removed in 4c923b3b3fd0ac1edebf0603265ca3ba51724937 commit?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:89,safe,safety,89,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safety']
Safety,"// In the case of namespace, even if we have loaded before we need to; // load again in case there was new data member added.; // Mark the list as loaded to avoid an infinite recursion in the case; // where we have a data member that is a variable size array. In that; // case TDataMember::Init needs to get/load the list to find the data; // member used as the array size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfDataMembers.cxx:157,avoid,avoid,157,core/meta/src/TListOfDataMembers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfDataMembers.cxx,2,['avoid'],['avoid']
Safety,"// In the case of type streams which we don't know the number of records of,; // it's possible to search for a type index triggering a full scan, but then; // later additional records are added since we didn't know how many there; // would be until we did a full visitation, then you try to access the new; // type triggering another full scan. To avoid this, we assume that if the; // database has some records, this must be what's going on. We can also; // assume that this index must be larger than the largest type index we've; // visited, so we start from there and scan forward.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/LazyRandomTypeCollection.cpp:348,avoid,avoid,348,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/LazyRandomTypeCollection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/LazyRandomTypeCollection.cpp,1,['avoid'],['avoid']
Safety,"// In the epilogue, addi sp, sp, 496 is used to recover the sp and it; // can be compressed(C.ADDI16SP, offset can be [-512, 496]), but; // addi sp, sp, 512 can not be compressed. So try to use 496 first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:48,recover,recover,48,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,1,['recover'],['recover']
Safety,"// In the inverse CFG, the dominance frontier of basic block (BB) is the; // point where ANTIC needs to be computed for instructions which are going; // to be hoisted. Since this point does not change during gvn-hoist,; // we compute it only once (on demand).; // The ides is inspired from:; // ""Partial Redundancy Elimination in SSA Form""; // ROBERT KENNEDY, SUN CHAN, SHIN-MING LIU, RAYMOND LO, PENG TU and FRED CHOW; // They use similar idea in the forward graph to find fully redundant and; // partially redundant expressions, here it is used in the inverse graph to; // find fully anticipable instructions at merge point (post-dominator in; // the inverse CFG).; // Returns the edge via which an instruction in BB will get the values from.; // Returns true when the values are flowing out to each edge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:304,Redund,Redundancy,304,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,3,"['Redund', 'redund']","['Redundancy', 'redundant']"
Safety,"// In the past, when Minuit2 was not the default minimizer yet, there was; // also a check that the number of invalid NLL evaluations was reduced with; // the error recovery:; //; // EXPECT_LT(fitResultNew->numInvalidNLL(), fitResultOld->numInvalidNLL());; //; // However, Minuit2 takes less evaluations to realize that the minimization; // without error recovery is hopeless, resulting in less invalid NLL; // evaluations when the error recovery is off. Hence, the comparison is not; // meaningful and was commended out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:165,recover,recovery,165,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,3,['recover'],['recovery']
Safety,"// In the rare case where Fatal does not abort, we erase, clamp and continue",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:41,abort,abort,41,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,1,['abort'],['abort']
Safety,"// In the reader, initializers of GlobalValues are set *after* all the; // globals have been read. Rather than awkwardly modeling this behaviour; // directly in predictValueUseListOrderImpl(), just assign IDs to; // initializers of GlobalValues before GlobalValues themselves to model this; // implicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp:161,predict,predictValueUseListOrderImpl,161,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILValueEnumerator.cpp,1,['predict'],['predictValueUseListOrderImpl']
Safety,"// In theory we might now need a write hazard, but actually it's; // unnecessary because there's no local-accessing code between; // the try's write hazard and here.; //Hazards.emitWriteHazard();; // Extract the new exception and save it to the; // propagating-exception slot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:39,hazard,hazard,39,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,3,"['Hazard', 'hazard']","['Hazards', 'hazard']"
Safety,"// In theory, the filename component should also be canonicalized if it; // on a case-insensitive filesystem. However, the extra canonicalization is; // expensive and if clang looked up the filename it will always be lowercase.; // Remove ., remove redundant separators, and switch to native separators.; // This is needed for separators between CanonicalDir and the filename.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp:249,redund,redundant,249,interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/ModuleMap.cpp,1,['redund'],['redundant']
Safety,"// In this switch we intentionally use 'continue' instead of; // 'break' to avoid running the 2nd switch (see later in this; // function).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoWriteBuffer.cxx:76,avoid,avoid,76,io/io/src/TStreamerInfoWriteBuffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoWriteBuffer.cxx,1,['avoid'],['avoid']
Safety,"// In tools that will exit soon anyway, going through the process of explicitly; // deallocating resources can be unnecessary - better to leak the resources and; // let the OS clean them up when the process ends. Use this function to ensure; // the memory is not misdiagnosed as an unintentional leak by leak detection; // tools (this is achieved by preserving pointers to the object in a globally; // visible array).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BuryPointer.h:309,detect,detection,309,interpreter/llvm-project/llvm/include/llvm/Support/BuryPointer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BuryPointer.h,1,['detect'],['detection']
Safety,"// Inaccurate rcp is allowed with unsafe-fp-math or afn.; //; // Defer to codegen to handle this.; //; // TODO: Decide on an interpretation for interactions between afn + arcp +; // !fpmath, and make it consistent between here and codegen. For now, defer; // expansion of afn to codegen. The current interpretation is so aggressive we; // don't need any pre-consideration here when we have better information. A; // more conservative interpretation could use handling here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:34,unsafe,unsafe-fp-math,34,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['unsafe'],['unsafe-fp-math']
Safety,// IncV is safe to hoist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:11,safe,safe,11,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['safe'],['safe']
Safety,// Include some standard headers to avoid CUDA headers including them; // while some required macros (like __THROW) are in a weird state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h:36,avoid,avoid,36,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_runtime_wrapper.h,1,['avoid'],['avoid']
Safety,"// Increase the relevant timeouts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:25,timeout,timeouts,25,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['timeout'],['timeouts']
Safety,"// IndVar is of the form ""A + B * I"" (where ""I"" is the canonical induction; // variable, that may or may not exist as a real llvm::Value in the loop) and; // this inductive range check is a range check on the ""C + D * I"" (""C"" is; // getBegin() and ""D"" is getStep()). We rewrite the value being range; // checked to ""M + N * IndVar"" where ""N"" = ""D * B^(-1)"" and ""M"" = ""C - NA"".; //; // The actual inequalities we solve are of the form; //; // 0 <= M + 1 * IndVar < L given L >= 0 (i.e. N == 1); //; // Here L stands for upper limit of the safe iteration space.; // The inequality is satisfied by (0 - M) <= IndVar < (L - M). To avoid; // overflows when calculating (0 - M) and (L - M) we, depending on type of; // IV's iteration space, limit the calculations by borders of the iteration; // space. For example, if IndVar is unsigned, (0 - M) overflows for any M > 0.; // If we figured out that ""anything greater than (-M) is safe"", we strengthen; // this to ""everything greater than 0 is safe"", assuming that values between; // -M and 0 just do not exist in unsigned iteration space, and we don't want; // to deal with overflown values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:538,safe,safe,538,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,4,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// Index of the resources kind that contains this kind.; // Number of resources that may be buffered.; //; // Buffered resources (BufferSize != 0) may be consumed at some indeterminate; // cycle after dispatch. This should be used for out-of-order cpus when; // instructions that use this resource can be buffered in a reservaton; // station.; //; // Unbuffered resources (BufferSize == 0) always consume their resource some; // fixed number of cycles after dispatch. If a resource is unbuffered, then; // the scheduler will avoid scheduling instructions with conflicting resources; // in the same cycle. This is for in-order cpus, or the in-order portion of; // an out-of-order cpus.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:525,avoid,avoid,525,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['avoid'],['avoid']
Safety,// Indices that are used to avoid recreating the same integer literals and; // composite boolean values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h:28,avoid,avoid,28,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Arena.h,1,['avoid'],['avoid']
Safety,"// Infer instruction flags. For example, we can detect loads,; // stores, and side effects in many cases by examining an; // instruction's pattern.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:48,detect,detect,48,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['detect'],['detect']
Safety,// Infer the role of the l_paren based on the previous token if we haven't; // detected one yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:79,detect,detected,79,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['detect'],['detected']
Safety,"// Infinite loops need special handling. If we give the back edge an infinite; // mass, they may saturate all the other scales in the function down to 1,; // making all the other region temperatures look exactly the same. Choose an; // arbitrary scale to avoid these issues.; //; // FIXME: An alternate way would be to select a symbolic scale which is later; // replaced to be the maximum of all computed scales plus 1. This would; // appropriately describe the loop as having a large scale, without skewing; // the final frequency computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:255,avoid,avoid,255,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,1,['avoid'],['avoid']
Safety,"// Inform caller that recovery failed, the error must be handled at upper; // level. This will generate the desired ""missing '}' at end of module""; // diagnostics on the way out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:22,recover,recovery,22,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['recover'],['recovery']
Safety,"// Inform the user and abort if we can't find a module with a given name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:23,abort,abort,23,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['abort'],['abort']
Safety,// Information this intrinsic contained has been transferred to; // MachineFunction in SelectionDAGISel::PrepareEHLandingPad. We can safely; // delete it now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:133,safe,safely,133,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['safe'],['safely']
Safety,"// Init progress timer, if requested; // The timer is destroyed (and therefore stopped) by the relevant TPacketizer implementation; // in GetNextPacket when end of work is detected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx:172,detect,detected,172,proof/proof/src/TVirtualPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TVirtualPacketizer.cxx,1,['detect'],['detected']
Safety,// InitSeqs gets its own mutex to avoid locking the whole session when; // aggregating data from the jitlink.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ELFNixPlatform.h:34,avoid,avoid,34,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ELFNixPlatform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ELFNixPlatform.h,1,['avoid'],['avoid']
Safety,"// Initial prediction for least squares is the weighted mean",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx:11,predict,prediction,11,tmva/tmva/src/LossFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx,1,['predict'],['prediction']
Safety,// Initialise a new builder with the iteration count expression. In; // combination with the value's SCEV this enables recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:119,recover,recovery,119,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['recover'],['recovery']
Safety,// Initialize helper which will detect jumps which can cause invalid; // lifetime markers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:32,detect,detect,32,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['detect'],['detect']
Safety,"// Initialize resource counts.; // Initialize the HazardRecognizers. If itineraries don't exist, are empty, or; // are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:50,Hazard,HazardRecognizers,50,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['Hazard'],"['HazardRecognizers', 'HazardRecs']"
Safety,"// Initialize the HazardRecognizers. If itineraries don't exist, are empty, or; // are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:18,Hazard,HazardRecognizers,18,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,2,['Hazard'],"['HazardRecognizers', 'HazardRecs']"
Safety,"// Initialize the HazardRecognizers. If itineraries don't exist, are empty,; // or are disabled, then these HazardRecs will be disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:18,Hazard,HazardRecognizers,18,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,2,['Hazard'],"['HazardRecognizers', 'HazardRecs']"
Safety,"// Initialize the fBegin and fEnd iterators.; // We can safely assume that the std::vector layout does not really depend on; // the content!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TVirtualCollectionIterators.h:56,safe,safely,56,io/io/inc/TVirtualCollectionIterators.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TVirtualCollectionIterators.h,1,['safe'],['safely']
Safety,// Initialize the trailing array of SourceLocation.; // This is safe since SourceLocation is POD-like.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:64,safe,safe,64,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['safe'],['safe']
Safety,// Initialized to avoid compiler warnings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:18,avoid,avoid,18,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['avoid'],['avoid']
Safety,// Initialized to avoid warnings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:18,avoid,avoid,18,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['avoid'],['avoid']
Safety,"// Initializers of GlobalValues are processed in; // BitcodeReader::ResolveGlobalAndAliasInits(). Match the order there rather; // than ValueEnumerator, and match the code in predictValueUseListOrderImpl(); // by giving IDs in reverse order.; //; // Since GlobalValues never reference each other directly (just through; // initializers), their relative IDs only matter for determining order of; // uses in their initializers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:175,predict,predictValueUseListOrderImpl,175,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,2,['predict'],['predictValueUseListOrderImpl']
Safety,"// Inline asm may contain some directives like .bytes which we don't; // currently have the ability to parse accurately. To be safe, just avoid; // computing a size and bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CompressJumpTables.cpp:127,safe,safe,127,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CompressJumpTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CompressJumpTables.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// Inline the safepoint poll implementation - this will get all the branch,; // control flow, etc.. Most importantly, it will introduce the actual slow; // path call - where we need to insert a safepoint (parsepoint).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:14,safe,safepoint,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,2,['safe'],['safepoint']
Safety,"// Inline, capitalize the first letter of each word, lowercase the; // rest of the letters in each word, and then take out the spaces; // between the words. This may make the TString shorter, which is; // safe to do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:205,safe,safe,205,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['safe'],['safe']
Safety,// Insert Phis for all conflicts; // TODO: adjust naming patterns to avoid this order of iteration dependency,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:69,avoid,avoid,69,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['avoid'],['avoid']
Safety,// Insert V_SWAP_B32 instruction(s) and run hazard recognizer on them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:44,hazard,hazard,44,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// Insert __stack_pointer restoring instructions at the beginning of each EH; // pad, after the catch instruction. Here it is safe to assume that SP32; // holds the latest value of __stack_pointer, because the only exception for; // this case is when a function uses the red zone, but that only happens; // with leaf functions, and we don't restore __stack_pointer in leaf; // functions anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLateEHPrepare.cpp:126,safe,safe,126,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLateEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyLateEHPrepare.cpp,1,['safe'],['safe']
Safety,// Insert a dummy call with all of the deopt operands we'll need for the; // actual safepoint insertion as arguments. This ensures reference operands; // in the deopt argument list are considered live through the safepoint (and; // thus makes sure they get relocated.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:84,safe,safepoint,84,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,2,['safe'],['safepoint']
Safety,// Insert a label at the end of the invoke call to mark the try range. This; // can be used to detect deletion of the invoke via the MachineModuleInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:95,detect,detect,95,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['detect'],['detect']
Safety,// Insert a label before the invoke call to mark the try range. This can be; // used to detect deletion of the invoke via the MachineModuleInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:88,detect,detect,88,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['detect'],['detect']
Safety,"// Insert a read hazard before the call. This will ensure that; // any writes to the locals are performed before making the; // call. If the call throws, then this is sufficient to; // guarantee correctness as long as it doesn't also write to any; // locals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:17,hazard,hazard,17,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['hazard'],['hazard']
Safety,"// Insert a safepoint poll immediately before the given instruction. Does; // not handle the parsability of state at the runtime call, that's the; // callers job.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:12,safe,safepoint,12,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,"// Insert an extension before type-legalization to avoid scalarization, e.g.:; // v2f64 = uint_to_fp v2i16; // =>; // v2f64 = uint_to_fp (v2i64 zero_extend v2i16)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Insert code to call abort in the TrapBB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:23,abort,abort,23,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,1,['abort'],['abort']
Safety,// Insert extra int3 instructions after trailing call instructions to avoid; // issues in the unwinder.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp:70,avoid,avoid,70,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetMachine.cpp,1,['avoid'],['avoid']
Safety,// Insert read hazards as required in the new blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:15,hazard,hazards,15,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['hazard'],['hazards']
Safety,"// Insert the new `VORRq qN, qN, qN`. There are a few details here:; //; // The uses are marked as killed, even if the original use of OperandToFixup; // is not killed, as the new instruction is clobbering the register. This is; // safe even if there are other uses of `qN`, as the VORRq value-wise a no-op; // (it is inserted for microarchitectural reasons).; //; // The def and the uses are still marked as Renamable if the original register; // was, to avoid having to rummage through all the other uses and defs and; // unset their renamable bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp:232,safe,safe,232,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// InsertAt points at the first instruction that will be removed. We need; // to move it out of the way, so it remains valid after removing all the; // old stores, and so we are able to recover it back to the proper insertion; // position.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp:186,recover,recover,186,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonStoreWidening.cpp,1,['recover'],['recover']
Safety,"// Insertion `R` is adjacent to a non-insertion replacement `I`, so they; // are order-independent. It is safe to assume that `R` will not conflict; // with any replacement before `I` since all replacements before `I` must; // either end before `R` or end at `R` but has length > 0 (if the; // replacement before `I` is an insertion at `R`, it would have been `I`; // since it is a lower bound of `AtEnd` and ordered before the current `I`; // in the set).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp:106,safe,safe,106,interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Core/Replacement.cpp,1,['safe'],['safe']
Safety,// Inserts fixup instructions before unsafe AES operations. Instructions may; // be inserted at the start of blocks and at within blocks so this pass has to; // come before those below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp:37,unsafe,unsafe,37,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetMachine.cpp,1,['unsafe'],['unsafe']
Safety,"// Inspect the initializer of the variable declaration which is; // being referenced prior to its initialization. We emit; // specialized diagnostics for self-initialization, and we; // specifically avoid warning about self references which take the; // form of:; //; // int x = x;; //; // This is used to indicate to GCC that 'x' is intentionally left; // uninitialized. Proven code paths which access 'x' in; // an uninitialized state after this will still warn.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:199,avoid,avoid,199,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['avoid'],['avoid']
Safety,"// Instead of casting everything to bytes for the vselect, cast to the; // original value type. This will avoid complications with casting masks.; // For example, in cases when the original mask applied to i32, it could; // be converted to a mask applicable to i8 via pred_typecast intrinsic,; // but if the mask is not exactly of HVX length, extra handling would be; // needed to make it work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:106,avoid,avoid,106,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['avoid'],['avoid']
Safety,"// Instead of creating global variables, the printf format strings are; // extracted and passed as metadata. This avoids polluting llvm's symbol; // tables in this module. Metadata is going to be extracted by the backend; // passes and inserted into the OpenCL binary as appropriate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPrintfRuntimeBinding.cpp:114,avoid,avoids,114,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPrintfRuntimeBinding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUPrintfRuntimeBinding.cpp,1,['avoid'],['avoids']
Safety,"// Instruction already belongs to another closure, avoid conflicts between; // closure and mark this closure as illegal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,1,['avoid'],['avoid']
Safety,"// Instruction has a ""Length"" field, safe to parse the first token as; // the ""Length"" field",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:37,safe,safe,37,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,1,['safe'],['safe']
Safety,"// Instruction is side-effect free and constant.; // If the instruction has uses outside this block or a phi node slot for; // the block, it is not safe to bypass the instruction since it would then; // no longer dominate all its uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:148,safe,safe,148,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,// Instructions emitted after the current instruction will be processed by the; // parent loop of the hazard recognizer in a natural way.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:102,hazard,hazard,102,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,// Instructions in the internal condition blocks should be safe; // to hoist up.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:59,safe,safe,59,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,1,['safe'],['safe']
Safety,"// Instructions used for type-casts of the induction variable,; // that are redundant when guarded with a runtime SCEV overflow check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:76,redund,redundant,76,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,1,['redund'],['redundant']
Safety,// Instructions which cause va_vdst==0 expire hazard,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:46,hazard,hazard,46,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,3,['hazard'],['hazard']
Safety,"// Instructions with void type don't return a value, so there's; // no point in trying to find redundancies in them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:95,redund,redundancies,95,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['redund'],['redundancies']
Safety,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:52,redund,redundant,52,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,1,['redund'],['redundant']
Safety,"// Intentionally computes the hash on a subset of the operands for; // performance reason. The subset has to be significant enough to avoid; // collision ""most of the time"". There is no correctness issue in case of; // collision because of the full check above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h:134,avoid,avoid,134,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.h,4,['avoid'],['avoid']
Safety,"// Intentionally use struct instead of pair because we don't need default; // init.; // Add macro decls to be able to revert them for error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Transaction.h:140,recover,recovery,140,interpreter/cling/include/cling/Interpreter/Transaction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/Transaction.h,1,['recover'],['recovery']
Safety,"// Interface to force RooRealIntegral to offer given observable for internal integration; // even if this is deemed unsafe. This default implementation returns always false",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h:116,unsafe,unsafe,116,roofit/roofitcore/inc/RooAbsReal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsReal.h,1,['unsafe'],['unsafe']
Safety,// Interfaces to the major aspects of target machine information:; //; // -- Instruction opcode and operand information; // -- Pipelines and scheduling information; // -- Stack frame information; // -- Selection DAG lowering information; // -- Call lowering information; //; // N.B. These objects may change during compilation. It's not safe to cache; // them between functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:337,safe,safe,337,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['safe'],['safe']
Safety,"// Interferenc matrices are incredibly regular - they're only a function of; // the allowed sets, so we cache them to avoid the overhead of constructing; // and uniquing them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp:118,avoid,avoid,118,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocPBQP.cpp,1,['avoid'],['avoid']
Safety,"// Interrupt handlers don't save off the VFP regs automatically on ARM,; // so there's some risk when calling out to non-interrupt handler functions; // that the callee might not preserve them. This is easy to diagnose here,; // but can be very challenging to debug.; // Likewise, X86 interrupt handlers may only call routines with attribute; // no_caller_saved_registers since there is no efficient way to; // save and restore the non-GPR state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:92,risk,risk,92,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['risk'],['risk']
Safety,// Intersect FMF on both new binops. Other (poison-generating) flags are; // dropped to be safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:91,safe,safe,91,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['safe'],['safe']
Safety,"// Intrinsics don't overlap w/libcalls; if our module has a large number of; // intrinsics, this ends up being an interesting compile time win since we; // avoid string normalization and comparison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:156,avoid,avoid,156,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['avoid'],['avoid']
Safety,// Introduce DefRegs set to skip the redundant register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:37,redund,redundant,37,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,1,['redund'],['redundant']
Safety,"// Invalidate any widening decisions we might have made, in case the loop; // requires prediction (decided later), but we have already made some; // load/store widening decisions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:87,predict,prediction,87,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['predict'],['prediction']
Safety,// Invalidate the decl as we don't know the type for recovery-expr yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:53,recover,recovery-expr,53,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery-expr']
Safety,"// Invoke through interpreter to avoid REve dependece on RGL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveText.cxx:33,avoid,avoid,33,graf3d/eve7/src/REveText.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveText.cxx,1,['avoid'],['avoid']
Safety,// Irreducible backedge. Abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:25,Abort,Abort,25,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,1,['Abort'],['Abort']
Safety,"// Is V an instruction thats result can trivially promoted, or has safe; // wrapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:67,safe,safe,67,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,1,['safe'],['safe']
Safety,"// Is the set of underlying objects all things which must be disjoint from; // noalias calls. We assume that indexing from such disjoint storage; // into the heap is undefined, and thus offsets can be safely ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:201,safe,safely,201,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['safe'],['safely']
Safety,"// Is this a candidate for ld/st merging or pairing? For example, we don't; // touch volatiles or load/stores that have a hint to avoid pair formation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:130,avoid,avoid,130,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['avoid'],['avoid']
Safety,// Is this a min specifically of our two inputs? (Avoid the risk of; // ValueTracking getting smarter looking back past our immediate inputs.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:50,Avoid,Avoid,50,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,2,"['Avoid', 'risk']","['Avoid', 'risk']"
Safety,"// Is this l-value object safe for use as integration observable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCategory.h:26,safe,safe,26,roofit/roofitcore/inc/RooAbsCategory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsCategory.h,1,['safe'],['safe']
Safety,// Issue a warning. ArgIndex == -1: Deprecated but not unsafe (has size; // restrictions).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp:55,unsafe,unsafe,55,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckSecuritySyntaxOnly.cpp,1,['unsafe'],['unsafe']
Safety,"// IssueWidth is the maximum number of instructions that may be scheduled in; // the same per-cycle group. This is meant to be a hard in-order constraint; // (a.k.a. ""hazard""). In the GenericScheduler strategy, no more than; // IssueWidth micro-ops can ever be scheduled in a particular cycle.; //; // In practice, IssueWidth is useful to model any bottleneck between the; // decoder (after micro-op expansion) and the out-of-order reservation; // stations or the decoder bandwidth itself. If the total number of; // reservation stations is also a bottleneck, or if any other pipeline stage; // has a bandwidth limitation, then that can be naturally modeled by adding an; // out-of-order processor resource.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:167,hazard,hazard,167,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['hazard'],['hazard']
Safety,"// It can happen that after widening of the IV, flattening may not be; // possible/happening, e.g. when it is deemed unprofitable. So bail here if; // that is the case.; // TODO: IV widening without performing the actual flattening transformation; // is not ideal. While this codegen change should not matter much, it is an; // unnecessary change which is better to avoid. It's unlikely this happens; // often, because if it's unprofitibale after widening, it should be; // unprofitabe before widening as checked in the first round of checks. But; // 'RepeatedInstructionThreshold' is set to only 2, which can probably be; // relaxed. Because this is making a code change (the IV widening, but not; // the flattening), we return true here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:366,avoid,avoid,366,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,1,['avoid'],['avoid']
Safety,// It doesn't make sense to generate debug info for PowerPC MMA vector types.; // So we return a safe type here to avoid generating an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:97,safe,safe,97,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,// It is always safe to classify this as an integer type up to i64 that; // isn't larger than the structure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:16,safe,safe,16,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['safe'],['safe']
Safety,// It is beneficial to create MSKOR here instead of combiner to avoid; // artificial dependencies introduced by RMW,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:64,avoid,avoid,64,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// It is common for the tokens immediately after a /**/ comment to be; // whitespace. Instead of going through the big switch, handle it; // efficiently now. This is safe even in KeepWhitespaceMode because we would; // have already returned above with the comment as a token.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:166,safe,safe,166,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['safe'],['safe']
Safety,"// It is good practice to always have a ""default"" label in a ""switch"", even; // if we should never get there. It can be used to detect errors, for; // instance. Unreachable code directly under a ""default"" label is therefore; // likely to be a false positive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp:128,detect,detect,128,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UnreachableCodeChecker.cpp,1,['detect'],['detect']
Safety,"// It is important to remove the sections first. For example, we want to; // remove the relocation sections before removing the symbols. That allows; // us to avoid reporting the inappropriate errors about removing symbols; // named in relocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp:159,avoid,avoid,159,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObjcopy.cpp,1,['avoid'],['avoid']
Safety,"// It is legal to register an atexit handler from within another atexit; // handler and furthor-more the standard says they need to run in reverse; // order, so this function must be recursion safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp:193,safe,safe,193,interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalExecutor.cpp,1,['safe'],['safe']
Safety,// It is necessary to limit this to rvalue reference to avoid calling this; // function with a bitfield lvalue argument since non-const reference to; // bitfield is not allowed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:56,avoid,avoid,56,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,4,['avoid'],['avoid']
Safety,"// It is not in general safe to propagate flags valid on an add within; // the addrec scope to one outside it. We must prove that the inner; // scope is guaranteed to execute if the outer one does to be able to; // safely propagate. We know the program is undefined if poison is; // produced on the inner scoped addrec. We also know that *for this use*; // the outer scoped add can't overflow (because of the flags we just; // computed for the inner scoped add) without the program being undefined.; // Proving that entry to the outer scope neccesitates entry to the inner; // scope, thus proves the program undefined if the flags would be violated; // in the outer scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:24,safe,safe,24,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['safe'],"['safe', 'safely']"
Safety,// It is not safe to do PRE when P->CurrentBlock is a loop backedge.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['safe'],['safe']
Safety,"// It is not safe to load directly from the pointer, but we can still peek; // through gep offsets and check if it safe to load from a base address with; // updated alignment. If it is, we can shuffle the element(s) into place; // after loading.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,2,['safe'],['safe']
Safety,// It is not safe to modify initializers of global variables with the; // external_initializer marker since the value may be changed at runtime; // before C++ initializers are evaluated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalVariable.h:13,safe,safe,13,interpreter/llvm-project/llvm/include/llvm/IR/GlobalVariable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalVariable.h,1,['safe'],['safe']
Safety,// It is not safe to move I1 and I2 into one combine if I2 has a true; // dependence on I1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,1,['safe'],['safe']
Safety,"// It is not safe to promote a load/store from the loop if the load/store is; // conditional. For example, turning:; //; // for () { if (c) *P += 1; }; //; // into:; //; // tmp = *P; for () { if (c) tmp +=1; } *P = tmp;; //; // is not safe, because *P may only be valid to access if 'c' is true.; //; // The safety property divides into two parts:; // p1) The memory may not be dereferenceable on entry to the loop. In this; // case, we can't insert the required load in the preheader.; // p2) The memory model does not allow us to insert a store along any dynamic; // path which did not originally have one.; //; // If at least one store is guaranteed to execute, both properties are; // satisfied, and promotion is legal.; //; // This, however, is not a necessary condition. Even if no store/load is; // guaranteed to execute, we can still establish these properties.; // We can establish (p1) by proving that hoisting the load into the preheader; // is safe (i.e. proving dereferenceability on all paths through the loop). We; // can use any access within the alias set to prove dereferenceability,; // since they're all must alias.; //; // There are two ways establish (p2):; // a) Prove the location is thread-local. In this case the memory model; // requirement does not apply, and stores are safe to insert.; // b) Prove a store dominates every exit block. In this case, if an exit; // blocks is reached, the original dynamic path would have taken us through; // the store, so inserting a store into the exit block is safe. Note that this; // is different from the store being guaranteed to execute. For instance,; // if an exception is thrown on the first iteration of the loop, the original; // store is never executed, but the exit blocks are not executed either.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,6,['safe'],"['safe', 'safety']"
Safety,"// It is not safe to transform things like div, urem, etc. because we may; // create undefined behavior when executing those on unknown vector elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['safe'],['safe']
Safety,"// It is only legal to clone a function if a block address within that; // function is never referenced outside of the function. Given that, we; // want to map block addresses from the old function to block addresses in; // the clone. (This is different from the generic ValueMapper; // implementation, which generates an invalid blockaddress when; // cloning a function.); //; // Note that we don't need to fix the mapping for unreachable blocks;; // the default mapping there is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:481,safe,safe,481,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,1,['safe'],['safe']
Safety,// It is only safe to move the retain to the store if we can prove; // conservatively that nothing besides the release can decrement reference; // counts in between the retain and the store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:14,safe,safe,14,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['safe'],['safe']
Safety,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,safe,safe,14,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['safe'],['safe']
Safety,// It is only safe to sign extend the BaseReg if we know that the math; // required to create it did not overflow before we extend it. Since; // the original IR value was tossed in favor of a constant back when; // the AddrMode was created we need to bail out gracefully if widths; // do not match instead of extending it.; //; // (See below for code to add the scale.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:14,safe,safe,14,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['safe'],['safe']
Safety,"// It is possible for very late stage optimizations (such as SimplifyCFG); // to introduce PHI nodes too late to be cleaned up. If we detect such a; // trivial PHI, go ahead and zap it here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:134,detect,detect,134,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['detect'],['detect']
Safety,"// It is possible that the CFG cannot be constructed.; // Be safe, and check if the CalleeCFG is valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:61,safe,safe,61,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['safe'],['safe']
Safety,// It is possible that the type refers to a RecoveryExpr created earlier; // in the tree transformation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:44,Recover,RecoveryExpr,44,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['Recover'],['RecoveryExpr']
Safety,"// It is possible to have a non-standard definition of memset. Validate; // we have enough arguments, and if not, abort further checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:114,abort,abort,114,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['abort'],['abort']
Safety,"// It is possible to hit a zero-cost cycle (phi/gep instructions for example),; // so limit the recursion depth.; // TODO: While this recursion limit does prevent pathological behavior, it; // would be better to track visited instructions to avoid cycles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:242,avoid,avoid,242,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"// It is redundant to fully-specify this here, but nice to make it explicit; // so that it is clear the DXIL module version is different.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp:9,redund,redundant,9,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILBitcodeWriter.cpp,1,['redund'],['redundant']
Safety,"// It is safe and potentially profitable to load a vector directly:; // inselt undef, load Scalar, 0 --> load VecPtr",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:9,safe,safe,9,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['safe'],['safe']
Safety,// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:9,safe,safe,9,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['safe'],['safe']
Safety,"// It is safe to assign a weak reference into a strong variable.; // Although this code can still have problems:; // id x = self.weakProp;; // id y = self.weakProp;; // we do not warn to warn spuriously when 'x' and 'y' are on separate; // paths through the function. This should be revisited if; // -Wrepeated-use-of-weak is made flow-sensitive.; // For ObjCWeak only, we do not warn if the assign is to a non-weak; // variable, which will be valid for the current autorelease scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,safe,safe,9,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['safe'],['safe']
Safety,// It is safe to assume Preheader exist as it was checked in; // parent function RunOnLoop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:9,safe,safe,9,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['safe'],['safe']
Safety,// It is safe to assume that the scalar types have a fixed size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp:9,safe,safe,9,interpreter/llvm-project/llvm/lib/IR/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Type.cpp,1,['safe'],['safe']
Safety,"// It is safe to decrement the pointers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpVar.cxx:9,safe,safe,9,math/quadp/src/TQpVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpVar.cxx,1,['safe'],['safe']
Safety,// It is safe to delete node now,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:9,safe,safe,9,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,"// It is safe to down cast from int64_t, NumInsts is always positive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:9,safe,safe,9,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,1,['safe'],['safe']
Safety,// It is safe to down cast since we know the arguments; // cannot be negative and Cost is of type int64_t.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h:9,safe,safe,9,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,1,['safe'],['safe']
Safety,// It is safe to drop mask parameter as masked-off elements are undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:9,safe,safe,9,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['safe'],['safe']
Safety,"// It is safe to elide the body of the switch if it doesn't contain labels; // etc. If it is safe, return successfully with an empty ResultStmts list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:9,safe,safe,9,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,2,['safe'],['safe']
Safety,// It is safe to remove CmpInstr if EFLAGS is updated again or killed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:9,safe,safe,9,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safe']
Safety,// It is safe to remove CmpInstr if EFLAGS is updated again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:9,safe,safe,9,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safe']
Safety,"// It is safe to replace the two loads if they have different alignments,; // but the new load must be the minimum (most restrictive) alignment of the; // inputs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:9,safe,safe,9,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,// It is safe to treat TargetExtType as its layout type since the underlying; // bits are only copied and are not inspected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp:9,safe,safe,9,interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/ExecutionEngine.cpp,1,['safe'],['safe']
Safety,"// It is twice the size of the block because there might be easily around 8; // transactions in flight which can be empty, which might lead to refill of; // the smallvector and then the return for reuse will exceed the capacity; // of the smallvector causing redundant copy of the elements.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/TransactionPool.h:259,redund,redundant,259,interpreter/cling/lib/Interpreter/TransactionPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/TransactionPool.h,1,['redund'],['redundant']
Safety,// It is unsafe to contract this fsub into the PH multiply.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:9,unsafe,unsafe,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['unsafe'],['unsafe']
Safety,"// It is very unlikely that a MIG callback will be called from anywhere; // within the project under analysis and the caller isn't itself a routine; // that follows the MIG calling convention. Therefore we're safe to believe; // that it's always the top frame that is of interest. There's a slight chance; // that the user would want to enforce the MIG calling convention upon; // a random routine in the middle of nowhere, but given that the convention is; // fairly weird and hard to follow in the first place, there's relatively; // little motivation to spread it this way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp:209,safe,safe,209,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MIGChecker.cpp,1,['safe'],['safe']
Safety,"// It loads same immediate value to the same Reg, which is redundant.; // We would unset kill flag in previous Reg usage to extend live range; // of Reg first, then remove the redundancy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:59,redund,redundant,59,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,2,['redund'],"['redundancy', 'redundant']"
Safety,"// It may be not necessary to start all over at this point, but it's; // safer do this anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp:73,safe,safer,73,interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/MSP430/MSP430BranchSelector.cpp,1,['safe'],['safer']
Safety,"// It may be possible to have a vgpr = load sgpr mapping here, because; // the mubuf instructions support this kind of load, but probably for only; // gfx7 and older. However, the addressing mode matching in the instruction; // selector should be able to do a better job of detecting and selecting; // these kinds of loads from the vgpr = load vgpr mapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:274,detect,detecting,274,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['detect'],['detecting']
Safety,"// It may happen that AP will be absent even HasAlloca && HasExtraAlign; // is true. HasExtraAlign may be set because of vector spills, without; // aligned locals or aligned outgoing function arguments. Since vector; // spills will ultimately be ""unaligned"", it is safe to use FP as the; // base register.; // In fact, in such a scenario the stack is actually not required to be; // aligned, although it may end up being aligned anyway, since this; // particular case is not easily detectable. The alignment will be; // unnecessary, but not incorrect.; // Unfortunately there is no quick way to verify that the above is; // indeed the case (and that it's not a result of an error), so just; // assume that missing AP will be replaced by FP.; // (A better fix would be to rematerialize AP from FP and always align; // vector spills.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:265,safe,safe,265,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,2,"['detect', 'safe']","['detectable', 'safe']"
Safety,"// It may not be safe to change a compare predicate in the presence of; // undefined elements, so replace those elements with the first safe constant; // that we found.; // TODO: in case of poison, it is safe; let's replace undefs only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:17,safe,safe,17,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,3,['safe'],['safe']
Safety,// It may not be safe to execute a binop on a vector with poison elements; // because the entire instruction can be folded to undef or create poison; // that did not exist in the original code.; // TODO: The shift case should not be necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,safe,safe,17,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['safe'],['safe']
Safety,"// It may not be safe to reorder shuffles and things like div, urem, etc.; // because we may trap when executing those ops on unknown vector elements.; // See PR20059.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,safe,safe,17,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['safe'],['safe']
Safety,// It might be worthwhile to try to recover by creating an; // appropriate declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:36,recover,recover,36,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recover']
Safety,"// It might not be safe to rely on TROOT::RecursiveRemove to take the readlock in case user code; // is calling directly gROOT->GetListOfCleanups()->RecursiveRemove(...); // However this can become a significant bottleneck if there are a very large number of; // TDirectory object.; // If we need to enabling this read lock, we need to move the fSize check afterwards.; // TList::RecursiveRemove has the same pattern.; // R__COLLECTION_READ_LOCKGUARD(ROOT::gCoreMutex);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx:19,safe,safe,19,core/cont/src/THashList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/THashList.cxx,1,['safe'],['safe']
Safety,// It would be complicated to avoid reading the methods anyway. So don't.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:30,avoid,avoid,30,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['avoid'],['avoid']
Safety,// It would be nice to avoid this copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:23,avoid,avoid,23,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['avoid'],['avoid']
Safety,// It's also unsafe/illegal to hoist an instruction above its instruction; // operands,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,unsafe,unsafe,13,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['unsafe'],['unsafe']
Safety,// It's always safe to look through zero extends.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:15,safe,safe,15,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,// It's always safe to select the minimum alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:15,safe,safe,15,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['safe'],['safe']
Safety,// It's better to avoid folding and recomputing shifts when we don't have a; // fastpath.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:18,avoid,avoid,18,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['avoid'],['avoid']
Safety,// It's fine (but redundant) to check this for __generic on the; // fallthrough path; we only form the __generic token in OpenCL mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,redund,redundant,18,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['redund'],['redundant']
Safety,"// It's highly likely that most programs do not contain CallBrInsts. Follow a; // similar pattern from SafeStackLegacyPass::runOnFunction to reuse previous; // domtree analysis if available, otherwise compute it lazily. This avoids; // forcing Dominator Tree Construction at -O0 for programs that likely do not; // contain CallBrInsts. It does pessimize programs with callbr at higher; // optimization levels, as the DominatorTree created here is not reused by; // subsequent passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp:103,Safe,SafeStackLegacyPass,103,interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CallBrPrepare.cpp,2,"['Safe', 'avoid']","['SafeStackLegacyPass', 'avoids']"
Safety,"// It's is not safe to walk the use list of global value, because function; // passes aren't allowed to look outside their functions.; // FIXME: this could be fixed by filtering instructions from outside; // of current function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:15,safe,safe,15,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['safe'],['safe']
Safety,// It's not generally safe to move VALU instructions across these since it will; // start using the register as a base index rather than directly.; // XXX - Why isn't hasSideEffects sufficient for these?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:22,safe,safe,22,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['safe'],['safe']
Safety,"// It's not safe to change register allocation for source operands of; // instructions that have special allocation requirements. Also assume all; // registers used in a call must not be changed (ABI).; // FIXME: The issue with predicated instruction is more complex. We are being; // conservative here because the kill markers cannot be trusted after; // if-conversion:; // %r6 = LDR %sp, %reg0, 92, 14, %reg0; mem:LD4[FixedStack14]; // ...; // STR %r0, killed %r6, %reg0, 0, 0, %cpsr; mem:ST4[%395]; // %r6 = LDR %sp, %reg0, 100, 0, %cpsr; mem:LD4[FixedStack12]; // STR %r0, killed %r6, %reg0, 0, 14, %reg0; mem:ST4[%396](align=8); //; // The first R6 kill is not really a kill since it's killed by a predicated; // instruction which may not be executed. The second R6 def may or may not; // re-define R6 so it's not safe to change it since the last R6 use cannot be; // changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.cpp,2,['safe'],['safe']
Safety,// It's not safe to copy YAML nodes; the document is streamed and the position; // is part of the state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h:12,safe,safe,12,interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLParser.h,1,['safe'],['safe']
Safety,// It's not safe to eliminate the sign / zero extension of the return value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,2,['safe'],['safe']
Safety,// It's not safe to merge globals that may be preempted,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,1,['safe'],['safe']
Safety,// It's not safe to sink instructions to EH landing pad. Control flow into; // landing pad is implicitly defined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['safe'],['safe']
Safety,"// It's not safe to use the two value CombineTo variant here. e.g.; // v1, chain2 = load chain1, loc; // v2, chain3 = load chain2, loc; // v3 = add v2, c; // Now we replace use of chain2 with chain1. This makes the second load; // isomorphic to the one we are deleting, and thus makes this load live.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,// It's not safe to walk the use list of a global value because function; // passes aren't allowed to look outside their functions.; // FIXME: this could be fixed by filtering instructions from outside of; // current function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSA.cpp,1,['safe'],['safe']
Safety,"// It's not vectorizable if the distance is smaller than the minimum distance; // needed for a vectroized/unrolled version. Vectorizing one iteration in; // front needs TypeByteSize * Stride. Vectorizing the last iteration needs; // TypeByteSize (No need to plus the last gap distance).; //; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // foo(int *A) {; // int *B = (int *)((char *)A + 14);; // for (i = 0 ; i < 1024 ; i += 2); // B[i] = A[i] + 1;; // }; //; // Two accesses in memory (stride is 2):; // | A[0] | | A[2] | | A[4] | | A[6] | |; // | B[0] | | B[2] | | B[4] |; //; // Distance needs for vectorizing iterations except the last iteration:; // 4 * 2 * (MinNumIter - 1). Distance needs for the last iteration: 4.; // So the minimum distance needed is: 4 * 2 * (MinNumIter - 1) + 4.; //; // If MinNumIter is 2, it is vectorizable as the minimum distance needed is; // 12, which is less than distance.; //; // If MinNumIter is 4 (Say if a user forces the vectorization factor to be 4),; // the minimum distance needed is 28, which is greater than distance. It is; // not safe to do vectorization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:1103,safe,safe,1103,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['safe'],['safe']
Safety,// It's only safe to hoist if every instruction before the Div/Rem in the; // basic block is guaranteed to transfer execution.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,1,['safe'],['safe']
Safety,// It's only safe to look through sign extends when Index is signed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,"// It's possible that this symbol has already been removed, e.g. if a; // materialization failure happens concurrently with a ResourceTracker or; // JITDylib removal. In that case we can safely skip this symbol and; // continue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:187,safe,safely,187,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['safe'],['safely']
Safety,"// It's possible we replaced this SDNode with other(s) and therefore; // didn't generate code for it. It's better to catch these cases where; // they happen and transfer the debug info, but trying to guarantee that; // in all cases would be very fragile; this is a safeguard for any; // that were missed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp:265,safe,safeguard,265,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/InstrEmitter.cpp,1,['safe'],['safeguard']
Safety,// It's safe to delete the original now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:8,safe,safe,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['safe'],['safe']
Safety,"// It's safe to go with the first one we find, because CodeGenInstAlias; // validates that all operands with the same name have the same record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp:8,safe,safe,8,interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmMatcherEmitter.cpp,1,['safe'],['safe']
Safety,// It's safe to hoist if the denominator is not 0 or -1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:8,safe,safe,8,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['safe'],['safe']
Safety,// It's safe to outline from MF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:8,safe,safe,8,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,3,['safe'],['safe']
Safety,// It's safe to use operator==.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DirectoryEntry.h:8,safe,safe,8,interpreter/llvm-project/clang/include/clang/Basic/DirectoryEntry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DirectoryEntry.h,2,['safe'],['safe']
Safety,"// It's tempting to use replaceAllUsesWith here to fully replace the old; // comparison, but that's not immediately safe, since users of the old; // comparison may not be dominated by the new comparison. Instead, just; // update the branch to use the new comparison; in the common case this; // will make old comparison dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:116,safe,safe,116,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['safe'],['safe']
Safety,"// It's unsafe to duplicate convergent instructions in this context, so set; // BBI.CannotBeCopied to true if MI is convergent. To see why, consider the; // following CFG, which is subject to our ""simple"" transformation.; //; // BB0 // if (c1) goto BB1; else goto BB2;; // / \; // BB1 |; // | BB2 // if (c2) goto TBB; else goto FBB;; // | / |; // | / |; // TBB |; // | |; // | FBB; // |; // exit; //; // Suppose we want to move TBB's contents up into BB1 and BB2 (in BB1 they'd; // be unconditional, and in BB2, they'd be predicated upon c2), and suppose; // TBB contains a convergent instruction. This is safe iff doing so does; // not add a control-flow dependency to the convergent instruction -- i.e.,; // it's safe iff the set of control flows that leads us to the convergent; // instruction does not get smaller after the transformation.; //; // Originally we executed TBB if c1 || c2. After the transformation, there; // are two copies of TBB's instructions. We get to the first if c1, and we; // get to the second if !c1 && c2.; //; // There are clearly fewer ways to satisfy the condition ""c1"" than; // ""c1 || c2"". Since we've shrunk the set of control flows which lead to; // our convergent instruction, the transformation is unsafe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:8,unsafe,unsafe,8,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,4,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"// Itanium ABI:; // An implementation supporting thread-safety on multiprocessor; // systems must also guarantee that references to the initialized; // object do not occur before the load of the initialization flag.; //; // In LLVM, we do this by marking the load Acquire.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:56,safe,safety,56,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['safe'],['safety']
Safety,// Iter = Acc / Prod; // If there is at least one more inner loop to avoid; // multiplication by 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:69,avoid,avoid,69,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['avoid'],['avoid']
Safety,"// Iterate over all operands looking for defs to create substitutions for.; // Avoid creating new instr numbers unless we create a new substitution.; // While this has no functional effect, it risks confusing someone reading; // MIR output.; // Examine all the operands, or the first N specified by the caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:79,Avoid,Avoid,79,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,2,"['Avoid', 'risk']","['Avoid', 'risks']"
Safety,"// Iterate over all the existing uses of From. New uses will be added; // to the beginning of the use list, which we avoid visiting.; // This specifically avoids visiting uses of From that arise while the; // replacement is happening, because any such uses would be the result; // of CSE: If an existing node looks like From after one of its operands; // is replaced by To, we don't want to replace of all its users with To; // too. See PR3018 for more info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:117,avoid,avoid,117,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,['avoid'],"['avoid', 'avoids']"
Safety,// Iterate over header and compute safety info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:35,safe,safety,35,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,1,['safe'],['safety']
Safety,// Iterate over loop blocks and instructions of each block and check; // instruction safety.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:85,safe,safety,85,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['safe'],['safety']
Safety,// Iterate over loop instructions and compute safety info.; // Skip header as it has been computed and stored in HeaderMayThrow.; // The first block in loopinfo.Blocks is guaranteed to be the header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp:46,safe,safety,46,interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MustExecute.cpp,1,['safe'],['safety']
Safety,// Iterate over strings correctly to avoid comments and newlines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:37,avoid,avoid,37,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,1,['avoid'],['avoid']
Safety,"// Iterate over the dominance tree in post order to start with the small; // regions from the bottom of the dominance tree. If the small regions are; // detected first, detection of bigger regions is faster, as we can jump; // over the small regions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:153,detect,detected,153,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,2,['detect'],"['detected', 'detection']"
Safety,"// Iterate over the original function, only adding insts to the worklist; // if they actually need to be revisited. This avoids having to pre-init; // the worklist with the entire function's worth of instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp:121,avoid,avoids,121,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DCE.cpp,2,['avoid'],['avoids']
Safety,"// Iterate through all nodes, interested in the following case:; //; // . loads from ConstantStruct or ConstantArray of constructs; // which can be turns into constant itself, with this we can; // avoid reading from read-only section at runtime.; //; // . Removing redundant AND for intrinsic narrow loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp:197,avoid,avoid,197,interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFISelDAGToDAG.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// Iterate through all the unique predecessors and tail-duplicate this; // block into them, if possible. Copying the list ahead of time also; // avoids trouble with the predecessor list reallocating.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:145,avoid,avoids,145,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['avoid'],['avoids']
Safety,// Iterate through the phi nodes of the function rather than iterating through; // DepthMap in order to get predictable ordering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp:108,predict,predictable,108,interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/PhiValues.cpp,1,['predict'],['predictable']
Safety,"// Iterating over NewPhiNodes is deterministic, so it is safe to try to; // simplify and RAUW them as we go. If it was not, we could add uses to; // the values we replace with in a non-deterministic order, thus creating; // non-deterministic def->use chains.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:57,safe,safe,57,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['safe'],['safe']
Safety,"// Iterating over a DenseMap is safe here, because the only thing in the body; // of the loop is inserting into another DenseMap (ComputedEdges).; // ComputedEdges is never iterated, so this doesn't lead to non-determinism.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:32,safe,safe,32,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['safe'],['safe']
Safety,"// JavaScript (or more precisely TypeScript) can have semicolons in braced; // lists (in so-called TypeMemberLists). Thus, the semicolon cannot be; // used for error recovery if we have otherwise determined that this is; // a braced list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:166,recover,recovery,166,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['recover'],['recovery']
Safety,"// JavaScript can just have free standing methods and getters/setters in; // object literals. Detect them by a ""{"" following "")"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:94,Detect,Detect,94,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['Detect'],['Detect']
Safety,"// Jitted nodes of the computation graph (e.g. RJittedAction, RJittedDefine) usually don't need to register; // themselves with the RLoopManager: the _concrete_ nodes will be registered with the RLoopManager right before; // the event loop, at jitting time, and that is good enough.; // RJittedFilter is an exception: RLoopManager needs to know about what filters have been booked even before; // the event loop in order to return a correct list from RLoopManager::GetFiltersNames().; // So RJittedFilters register themselves with RLoopManager at construction time and deregister themselves; // in SetFilter, i.e. when they are sure that the concrete filter has been instantiated in jitted code and it has; // been registered with RLoopManager, making the RJittedFilter registration redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx:783,redund,redundant,783,tree/dataframe/src/RJittedFilter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RJittedFilter.cxx,1,['redund'],['redundant']
Safety,// Jump threading may have introduced redundant debug values into BB; // which should be removed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:38,redund,redundant,38,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redund'],['redundant']
Safety,// Just continue execution when built with compilers that have no; // support. This is a debugging aid and not intended to force the; // program to abort if encountered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Compiler.h:148,abort,abort,148,interpreter/llvm-project/llvm/include/llvm/Support/Compiler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Compiler.h,1,['abort'],['abort']
Safety,"// Just to be safe, assume the worst case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:14,safe,safe,14,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['safe'],['safe']
Safety,"// KCFI allows indirect calls to any location that's preceded by a valid; // type identifier. To avoid encoding the full constant into an instruction,; // and thus emitting potential call target gadgets at each indirect call; // site, load a negated constant to a register and compare that to the; // expected value at the call target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp:97,avoid,avoid,97,interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MCInstLower.cpp,1,['avoid'],['avoid']
Safety,"// KCFI type identifier constants are only necessary for external assembly; // functions, which means it's safe to skip unusual names. Subset of; // MCAsmInfo::isAcceptableChar() and MCAsmInfoXCOFF::isAcceptableChar().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:107,safe,safe,107,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['safe'],['safe']
Safety,// KXOR is safe to use because it doesn't affect flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:11,safe,safe,11,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safe']
Safety,"// Kahan's algorithm for summing to avoid loss of precision",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:36,avoid,avoid,36,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,2,['avoid'],['avoid']
Safety,// Keep a reference to avoid repeated lookups.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:23,avoid,avoid,23,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['avoid'],['avoid']
Safety,// Keep the module name as a string for now. It's not safe to create a new; // IdentifierInfo from an ASTReader callback.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:54,safe,safe,54,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['safe'],['safe']
Safety,"// Keep the old instruction around to avoid breaking iterators, but; // replace it with a dummy instruction to remove uses.; //; // FIXME: We should not invert how this pass looks at operands to avoid; // this. Should track set of foldable movs instead of looking for uses; // when looking at a use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:38,avoid,avoid,38,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,2,['avoid'],['avoid']
Safety,// Keep the order of tree nodes to avoid non-determinism.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,avoid,avoid,35,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// Keep the order to avoid non-determinism.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:21,avoid,avoid,21,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"// Keep this value, check for conflicts when analyzing OtherVNI. Avoid; // revisiting OtherVNI->id in JoinVals::computeAssignment() below before it; // is assigned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:65,Avoid,Avoid,65,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['Avoid'],['Avoid']
Safety,"// Keep track of already used bits to detect overlapping values.; // In that case, we will just abort the transformation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:38,detect,detect,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,"['abort', 'detect']","['abort', 'detect']"
Safety,// Keep track of completed checks to avoid repeating work,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/WasmObjectFile.cpp:37,avoid,avoid,37,interpreter/llvm-project/llvm/lib/Object/WasmObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/WasmObjectFile.cpp,1,['avoid'],['avoid']
Safety,"// Keep track of each multiply we see, to avoid triggering on (X*4)+(X*4); // where they are actually the same multiply.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['avoid'],['avoid']
Safety,"// Keep track of implicit defs of CSMI and MI, to clear possibly; // made-redundant kill flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:74,redund,redundant,74,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['redund'],['redundant']
Safety,"// Keep track of the bits in the register we already emitted, so we; // can avoid emitting redundant aliasing subregs. Because this is; // just doing a greedy scan of all subregisters, it is possible that; // this doesn't find a combination of subregisters that fully cover; // the register (even though one may exist).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp:76,avoid,avoid,76,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfExpression.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// Keep track of the classes keys; // This is done to avoid duplications of keys with typedefs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:54,avoid,avoid,54,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['avoid'],['avoid']
Safety,"// Keep track of whether anything changed; /// For nodes that are of legal width, and that have more than one use, this; /// map indicates what regularized operand to use. This allows us to avoid; /// legalizing the same thing more than once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:190,avoid,avoid,190,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['avoid'],['avoid']
Safety,// Keep track of whether the previous instruction was an LFENCE to avoid; // adding redundant LFENCEs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp:67,avoid,avoid,67,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// KeepWhitespaceMode; // We know the lexer hasn't changed, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:139,avoid,avoid,139,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['avoid'],['avoid']
Safety,"// KeepWhitespaceMode; // We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:129,avoid,avoid,129,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,3,['avoid'],['avoid']
Safety,// Keeps the reordered operands to avoid code duplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:35,avoid,avoid,35,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// KeyValueNode eats the TK_Key. That way it can detect null keys.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:49,detect,detect,49,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['detect'],['detect']
Safety,// Kill the largest clobbered super-register.; // This avoids needless implicit operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp:55,avoid,avoids,55,interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveVariables.cpp,1,['avoid'],['avoids']
Safety,"// Knowing that this alloca is promotable, we know that it's safe to kill all; // instructions except for load and store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:61,safe,safe,61,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['safe'],['safe']
Safety,"// Known bases won't need new instructions introduced and can be; // ignored safely. However, this can only be done when InVal and Base; // are both scalar or both vector. Otherwise, we need to find a; // correct BDV for InVal, by creating an entry in the lattice; // (States).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:77,safe,safely,77,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safely']
Safety,"// LLVM 'nocapture' attribute is only set for arguments whose address; // is not stored, passed around, or used in any other non-trivial way.; // We assume that passing a pointer to an object as a 'nocapture; // readnone' argument is safe.; // FIXME: a more precise solution would require an interprocedural; // analysis here, which would look at all uses of an argument inside; // the function being called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:234,safe,safe,234,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['safe'],['safe']
Safety,// LLVM Dwarf parser is not thread-safe and we need to parse all DWARF up; // front before we start accessing any DIEs since there might be; // cross compile unit references in the DWARF. If we don't do this we can; // end up crashing.; // We need to call getAbbreviations sequentially first so that getUnitDIE(); // only works with its local data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp:35,safe,safe,35,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,1,['safe'],['safe']
Safety,"// LLVM had a bug where constructors with the same priority would not be; // stably sorted. This has been fixed upstream by; // https://github.com/llvm/llvm-project/pull/95532, but to avoid relying; // on a backport this pass works around the issue: The idea is that we; // lower the default priority of concerned constructors to make them sort; // correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp:184,avoid,avoid,184,interpreter/cling/lib/Interpreter/BackendPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/BackendPasses.cpp,1,['avoid'],['avoid']
Safety,"// LLVM register Num, which has kind Kind. In some ways it might be; // easier for this class to have a register bank (general, floating-point; // or access) and a raw register number (0-15). This would postpone the; // interpretation of the operand to the add*() methods and avoid the need; // for context-dependent parsing. However, we do things the current way; // because of the virtual getReg() method, which needs to distinguish; // between (say) %r0 used as a single register and %r0 used as a pair.; // Context-dependent parsing can also give us slightly better error; // messages when invalid pairs like %r1 are used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp:276,avoid,avoid,276,interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/AsmParser/SystemZAsmParser.cpp,1,['avoid'],['avoid']
Safety,"// LR is stack-allocated. LiveRegMatrix caches queries by a key that; // includes the address of the live range. If (for the same reg unit) this; // checkInterference overload is called twice, without any other query(); // calls in between (on heap-allocated LiveRanges) - which would invalidate; // the cached query - the LR address seen the second time may well be the; // same as that seen the first time, while the Start/End/valno may not - yet; // the same cached result would be fetched. To avoid that, we don't cache; // this query.; //; // FIXME: the usability of the Query API needs to be improved to avoid; // subtle bugs due to query identity. Avoiding caching, for example, would; // greatly simplify things.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp:497,avoid,avoid,497,interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRegMatrix.cpp,3,"['Avoid', 'avoid']","['Avoiding', 'avoid']"
Safety,"// LSR is not APInt clean, do not touch integers bigger than 64-bits.; // Also avoid creating IVs of non-native types. For example, we don't want a; // 64-bit IV in 32-bit code just because the loop has one 64-bit cast.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:79,avoid,avoid,79,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,1,['avoid'],['avoid']
Safety,"// LTO with assembly output shares a single line table amongst multiple CUs.; // To avoid the compilation directory being ambiguous, let the line table; // explicitly describe the directory of all files, never relying on the; // compilation directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:84,avoid,avoid,84,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['avoid'],['avoid']
Safety,"// LV doesn't consider a phi use live-out, so isLiveOut only returns true; // when the source register is live-out for some other reason than a phi; // use. That means the copy we will insert in PreMBB won't be a kill, and; // there is a risk it may not be coalesced away.; //; // If the copy would be a kill, there is no need to split the edge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp:238,risk,risk,238,interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIElimination.cpp,1,['risk'],['risk']
Safety,// Labels generally can't safely be outlined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:26,safe,safely,26,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['safe'],['safely']
Safety,"// Lacking those, try to detect the correct set of system includes for the; // target triple.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:25,detect,detect,25,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,1,['detect'],['detect']
Safety,// Language detected from -x or the filename. Never TY_INVALID.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:12,detect,detected,12,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,1,['detect'],['detected']
Safety,// Language keyword or named operator.; // Look up information on when we should avoid concatenation with prevtok.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:81,avoid,avoid,81,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,1,['avoid'],['avoid']
Safety,"// Large vectors don't map directly to this conversion, so to avoid too many; // edge cases, we don't apply it here. The conversion will likely still be; // applied later via multiple smaller vectors, whose results are concatenated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:62,avoid,avoid,62,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Larger sanity check. Two uniform distributions; // with equal weights should yield AUC of 0.5.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:10,sanity check,sanity check,10,tmva/tmva/test/ROC/testRocWeights.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx,1,['sanity check'],['sanity check']
Safety,"// Larger sanity check. Using uniform dist as signal; // and triangular as background should yield AUC of 2/3.; //; // Using 0.002 as the limit should yield a probability; // of an error of 0.0001%. (Estimated numerically).; // If the error is triggered, consider changing the seed of ""generator"" and/or; // increase either the error limit, the number of datapoints or the number of; // averagings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:10,sanity check,sanity check,10,tmva/tmva/test/ROC/testRocWeights.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx,1,['sanity check'],['sanity check']
Safety,"// Last safety not computed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:8,safe,safety,8,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safety']
Safety,"// LastInst can still be null at this point if there's either not an entry; // for BB in BlocksSchedules or there's no ScheduleData available for; // VL.back(). This can be the case if buildTree_rec aborts for various; // reasons (e.g., the maximum recursion depth is reached, the maximum region; // size is reached, etc.). ScheduleData is initialized in the scheduling; // ""dry-run"".; //; // If this happens, we can still find the last instruction by brute force. We; // iterate forwards from Front (inclusive) until we either see all; // instructions in the bundle or reach the end of the block. If Front is the; // last instruction in program order, LastInst will be set to Front, and we; // will visit all the remaining instructions in the block.; //; // One of the reasons we exit early from buildTree_rec is to place an upper; // bound on compile-time. Thus, taking an additional compile-time hit here is; // not ideal. However, this should be exceedingly rare since it requires that; // we both exit early from buildTree_rec and that the bundle be out-of-order; // (causing us to iterate all the way to the end of the block).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:199,abort,aborts,199,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['abort'],['aborts']
Safety,// LayoutIndexUpdateStarted is used to avoid updating the index of any field; // twice by mistake.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['avoid'],['avoid']
Safety,// Lazily compute the possible classes for LHS. Avoid computing it twice if; // RHS is a 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:48,Avoid,Avoid,48,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['Avoid'],['Avoid']
Safety,// Lazily load the key function to avoid deserializing every method so we can; // compute it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:35,avoid,avoid,35,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['avoid'],['avoid']
Safety,// Leave a space between * and /* to avoid C4138 `comment end` found outside; // of comment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:37,avoid,avoid,37,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['avoid'],['avoid']
Safety,"// Leave lifetime markers for the static alloca's, scoping them to the; // function we just inlined.; // We need to insert lifetime intrinsics even at O0 to avoid invalid; // access caused by multithreaded coroutines. The check; // `Caller->isPresplitCoroutine()` would affect AlwaysInliner at O0 only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:157,avoid,avoid,157,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['avoid'],['avoid']
Safety,// Leave the MemoryUses alone.; // Also make sure we skip ourselves to avoid self references.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:71,avoid,avoid,71,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['avoid'],['avoid']
Safety,// Leave the other dead instructions to avoid clobbering iterators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:40,avoid,avoid,40,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['avoid'],['avoid']
Safety,"// Legalize a VGPR Rsrc; //; // If the instruction is _ADDR64, we can avoid a waterfall by extracting; // the base pointer from the VGPR Rsrc, adding it to the VAddr, then using; // a zero-value SRsrc.; //; // If the instruction is _OFFSET (both idxen and offen disabled), and we; // support ADDR64 instructions, we can convert to ADDR64 and do the same as; // above.; //; // Otherwise we are on non-ADDR64 hardware, and/or we have; // idxen/offen/bothen and we fall back to a waterfall loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:70,avoid,avoid,70,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// LegalizeUpdates function simplifies updates assuming a graph structure.; // This function serves double purpose:; // a) It removes redundant updates, which makes it easier to reverse-apply; // them when traversing CFG.; // b) It optimizes away updates that cancel each other out, as the end result; // is the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CFGUpdate.h:134,redund,redundant,134,interpreter/llvm-project/llvm/include/llvm/Support/CFGUpdate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CFGUpdate.h,1,['redund'],['redundant']
Safety,"// Let R be the ratio of CycleSavings to Size. We accept the inlining; // opportunity if R is really high and reject if R is really low. If R is; // somewhere in the middle, we fall back to the cost-based analysis.; //; // Specifically, let R = CycleSavings / Size, we accept the inlining; // opportunity if:; //; // PSI->getOrCompHotCountThreshold(); // R > -------------------------------------------------; // getInliningCostBenefitAnalysisSavingsMultiplier(); //; // and reject the inlining opportunity if:; //; // PSI->getOrCompHotCountThreshold(); // R <= ----------------------------------------------------; // getInliningCostBenefitAnalysisProfitableMultiplier(); //; // Otherwise, we fall back to the cost-based analysis.; //; // Implementation-wise, use multiplication (CycleSavings * Multiplier,; // HotCountThreshold * Size) rather than division to avoid precision loss.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:862,avoid,avoid,862,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['avoid'],['avoid']
Safety,// Let the subtarget (CPU) decide if a predictable select is more expensive; // than the corresponding branch. This information is used in CGP to decide; // when to convert selects into branches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:39,predict,predictable,39,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['predict'],['predictable']
Safety,// Let's avoid copies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:9,avoid,avoid,9,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,2,['avoid'],['avoid']
Safety,"// Lex all the tokens in raw mode, to avoid entering #includes or expanding; // macros.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp:38,avoid,avoid,38,interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Rewrite/HTMLRewrite.cpp,2,['avoid'],['avoid']
Safety,"// Lex tokens in raw mode until we hit the end of the range, to avoid; // entering #includes or expanding macros.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:64,avoid,avoid,64,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['avoid'],['avoid']
Safety,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:165,safe,safe,165,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['safe'],['safe']
Safety,"// Like lookups(), but avoids loading external declarations.; // If PreserveInternalState, avoids building lookup data structures too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:23,avoid,avoids,23,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,2,['avoid'],['avoids']
Safety,// Likewise for some builtin preprocessor macros.; // FIXME: This is inconsistent; we usually suggest detecting; // builtin macros via #ifdef. Don't add more cases here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:102,detect,detecting,102,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['detect'],['detecting']
Safety,// Limit MaxScalableVF by the maximum safe dependence distance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:38,safe,safe,38,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['safe'],['safe']
Safety,// Limit max number of arguments to avoid creation of unreasonably big; // SCEVAddRecs with very complex operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,"// Limit number of instructions we look at, to avoid scanning through large; // blocks. The current limit is chosen arbitrarily.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['avoid'],['avoid']
Safety,"// Limit number of nodes to inline, to avoid quadratic compile times.; // We have to add the outstanding Token Factors to Ops, otherwise we might; // drop Ops from the resulting Token Factors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,// Limit recursion to avoid excessive compile times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,avoid,avoid,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Limit the CFG of the loop body for targets with a branch predictor.; // Allowing 4 blocks permits if-then-else diamonds in the body.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp:60,predict,predictor,60,interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMTargetTransformInfo.cpp,2,['predict'],['predictor']
Safety,// Limit the number of chains to avoid quadratic behavior. We don't expect to; // have more than a few IV increment chains in a loop. Missing a Chain falls; // back to normal LSR behavior for those uses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:33,avoid,avoid,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['avoid'],['avoid']
Safety,// Limit the scan radius to avoid running in quadratice time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:28,avoid,avoid,28,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['avoid'],['avoid']
Safety,"// Limit the width of DAG chains. This is important in general to prevent; // DAG-based analysis from blowing up. For example, alias analysis and; // load clustering may not complete in reasonable time. It is difficult to; // recognize and avoid this situation within each individual analysis, and; // future analyses are likely to have the same behavior. Limiting DAG width is; // the safe approach and will be especially important with global DAGs.; //; // MaxParallelChains default is arbitrarily high to avoid affecting; // optimization, but could be lowered to improve compile time. Any ld-ld-st-st; // sequence over this should have been converted to llvm.memcpy by the; // frontend. It is easy to induce this behavior with .ll code such as:; // %buffer = alloca [4096 x i8]; // %data = load [4096 x i8]* %argPtr; // store [4096 x i8] %data, [4096 x i8]* %buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:240,avoid,avoid,240,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,// Linkage Spec can just be ignored; // FIXME: Any other DeclContext kinds that can be safely disregarded,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp:87,safe,safely,87,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchersInternal.cpp,1,['safe'],['safely']
Safety,"// Linux kernels prior to 4.1 will sometimes locate the heap of a PIE binary; // relatively close to the stack (they are only guaranteed to be 128MiB; // apart). This results in crashes if we happen to heap-allocate more than; // 128MiB before we reach our stack high-water mark.; //; // To avoid these crashes, ensure that we have sufficient virtual memory; // pages allocated before we start running.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp:291,avoid,avoid,291,interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1_main.cpp,1,['avoid'],['avoid']
Safety,// List of address-significant symbols; // for safe ICF.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:47,safe,safe,47,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['safe'],['safe']
Safety,"// List of all function attributes which must be stripped when lowering from; // abstract machine model to physical machine model. Essentially, these are; // all the effects a safepoint might have which we ignored in the abstract; // machine model for purposes of optimization. We have to strip these on; // both function declarations and call sites.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:176,safe,safepoint,176,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safepoint']
Safety,// List of safe values should be anticipable at TI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:11,safe,safe,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['safe'],['safe']
Safety,"// Live-in physreg copies that are glued to SMSTART are applied as; // implicit-def's in the InstrEmitter. Here we remove them, allowing the; // register allocator to pass call args in callee saved regs, without extra; // copies to avoid these fake clobbers of actually-preserved GPRs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:232,avoid,avoid,232,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Load delay slot hazards are only for MIPS1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:19,hazard,hazards,19,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,1,['hazard'],['hazards']
Safety,"// Load predictions to double vector; // NOTE: The signal probability is given at the output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:8,predict,predictions,8,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,2,['predict'],['predictions']
Safety,// Load the whole vector and avoid masking off the top bits as it makes; // the codegen worse.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:29,avoid,avoid,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// Loading address from XGOT; // External GOT: lui $tmp, %got_hi(symbol)($gp); // addu $tmp, $tmp, $gp; // lw $tmp, %got_lo(symbol)($tmp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:255,redund,redundant,255,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['redund'],['redundant']
Safety,// Loads are handled via masking (or speculated if safe to do so.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:51,safe,safe,51,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['safe'],['safe']
Safety,// Loads within this basic block after an LFENCE are not at risk of; // speculatively executing with invalid predicates from prior control; // flow. So break out of this block but continue scanning the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:60,risk,risk,60,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['risk'],['risk']
Safety,"// Local variables and local rvalue references are classified as ""Local"".; // For the purposes of this checker, we classify move-safe STL types; // as not-""STL"" types, because that's how the checker treats them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:129,safe,safe,129,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,1,['safe'],['safe']
Safety,"// Location list entries with empty location descriptions are redundant; // information in DWARF, so do not emit those.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp:62,redund,redundant,62,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.cpp,1,['redund'],['redundant']
Safety,"// Locking mainly for Win32 multi thread safety - but no harm in all using it; // During normal draws a draw lock is taken in other thread (Win32) in RequestDraw(); // to ensure thread safety. For PrintObjects repeated Draw() calls are made.; // If no draw lock taken get one now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx:41,safe,safety,41,graf3d/gl/src/TGLViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLViewer.cxx,2,['safe'],['safety']
Safety,"// Logical shift the result back to the lower byte, leaving a zero upper; // byte meaning that we can safely pack with PACKUSWB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:102,safe,safely,102,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['safe'],['safely']
Safety,// Long integer divisions are often used in hashtable implementations. It's; // not worth bypassing such divisions because hash values are extremely; // unlikely to have enough leading zeros. The call below tries to detect; // values that are unlikely to fit BypassType (including hashes).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:216,detect,detect,216,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,1,['detect'],['detect']
Safety,// Look for MOVMSK that is maybe truncated and then bitcasted to vXi1.; // Turn it into a sign bit compare that produces a k-register. This avoids; // a trip through a GPR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:140,avoid,avoids,140,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoids']
Safety,// Look for VMLx RAW hazard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:21,hazard,hazard,21,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,1,['hazard'],['hazard']
Safety,// Look for a redundant movzx/movsx that can occur after an 8-bit divrem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:14,redund,redundant,14,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['redund'],['redundant']
Safety,"// Look for an equivalent binop except that one operand has been shuffled.; // If the demand for this binop only includes elements that are the same as; // the other binop, then we may be able to replace this binop with a use of; // the earlier one.; //; // Example:; // %other_bo = bo (shuf X, {0}), Y; // %this_extracted_bo = extelt (bo X, Y), 0; // -->; // %other_bo = bo (shuf X, {0}), Y; // %this_extracted_bo = extelt %other_bo, 0; //; // TODO: Handle demand of an arbitrary single element or more than one; // element instead of just element 0.; // TODO: Unlike general demanded elements transforms, this should be safe; // for any (div/rem/shift) opcode too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:622,safe,safe,622,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['safe'],['safe']
Safety,"// Look for any tail calls referencing the coroutine frame and remove tail; // attribute from them, since now coroutine frame resides on the stack and tail; // call implies that the function does not references anything on the stack.; // However if it's a musttail call, we cannot remove the tailcall attribute.; // It's safe to keep it there as the musttail call is for symmetric transfer,; // and by that point the frame should have been destroyed and hence not; // interfering with operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp:321,safe,safe,321,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroElide.cpp,1,['safe'],['safe']
Safety,"// Look for cases where the source of a simple store or the destination; // of a simple load is being spilled. Try to use MVC instead.; //; // Although MVC is in practice a fast choice in these cases, it is still; // logically a bytewise copy. This means that we cannot use it if the; // load or store is volatile. We also wouldn't be able to use MVC if; // the two memories partially overlap, but that case cannot occur here,; // because we know that one of the memories is a full frame index.; //; // For performance reasons, we also want to avoid using MVC if the addresses; // might be equal. We don't worry about that case here, because spill slot; // coloring happens later, and because we have special code to remove; // MVCs that turn out to be redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp:544,avoid,avoid,544,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZInstrInfo.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes. This is what gcc calls sibcall.; // Can't do sibcall if stack needs to be dynamically re-aligned. PEI needs to; // emit a special epilogue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:20,safe,safe,20,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,['safe'],['safe']
Safety,// Look for obvious safe cases to perform tail call optimization that do not; // require ABI changes. This is what gcc calls sibcall.; // Exception-handling functions need a special set of instructions to indicate; // a return to the hardware. Tail-calling another function would probably; // break this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:20,safe,safe,20,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['safe'],['safe']
Safety,"// Look for recursion (direct recursion should have been collapsed by; // module summary analysis, here we should just be detecting mutual; // recursion). Mark these nodes so we don't try to clone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:122,detect,detecting,122,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['detect'],['detecting']
Safety,"// Look for situations like this:; // %reg1024 = MOV r1; // %reg1025 = MOV r0; // %reg1026 = ADD %reg1024, %reg1025; // r2 = MOV %reg1026; // Turn ADD into a 3-address instruction to avoid a copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp:183,avoid,avoid,183,interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp,1,['avoid'],['avoid']
Safety,// Look for special VMLA / VMLS hazards. A VMUL / VADD / VSUB following; // a VMLA / VMLS will cause 4 cycle stall.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp:32,hazard,hazards,32,interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,1,['hazard'],['hazards']
Safety,"// Look for the Objective-C modifier flags, if any.; // We parse these here, even if they don't apply to; // the conversion specifier, and then emit an error; // later if the conversion specifier isn't '@'. This; // enables better recovery, and we don't know if; // these flags are applicable until later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp:231,recover,recovery,231,interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/PrintfFormatString.cpp,1,['recover'],['recovery']
Safety,"// Look up and classify the identifier. We don't perform any typo-correction; // after a scope specifier, because in general we can't recover from typos; // there (eg, after correcting 'A::template B<X>::C' [sic], we would need to; // jump back into scope specifier parsing).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:134,recover,recover,134,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['recover'],['recover']
Safety,"// Look up the directory for the file. When looking up something like; // sys/foo.h we'll discover all of the search directories that have a 'sys'; // subdirectory. This will let us avoid having to waste time on known-to-fail; // searches when we go to find sys/bar.h, because all the search directories; // without a 'sys' subdir will get a cached failure result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:182,avoid,avoid,182,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['avoid'],['avoid']
Safety,"// Looking to try to avoid a situation like this one:; // %2 = tail call i64 @llvm.fshl.i64(i64 %word, i64 %word, i64 23); // %and1 = and i64 %2, 9223372036854775807; // In this function we are looking to try to match RLDCL. However, the above; // DAG would better match RLDICL instead which is not what we are looking; // for here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:21,avoid,avoid,21,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,// Lookup of an unqualified type name has failed in MSVC compatibility mode.; // Give Sema a chance to recover if we are in a template with dependent base; // classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:103,recover,recover,103,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Safety,// Lookup the current thread local recovery object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:35,recover,recovery,35,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,3,['recover'],['recovery']
Safety,"// Loop on selected classes. If they don't have the attribute ""rootmap""; // set to ""false"", store them in the list of classes for the rootmap; // Returns 0 in case of success and 1 in case of issues.; // An unordered_set to keep track of the existing classes.; // We want to avoid duplicates there as they may hint to a serious corruption",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:275,avoid,avoid,275,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['avoid'],['avoid']
Safety,"// Loop over each variable and place PHIs for it, then propagate values; // between blocks. This keeps the locality of working on one lexical scope at; // at time, but avoids re-processing variable values because some other; // variable has been assigned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:168,avoid,avoids,168,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avoid'],['avoids']
Safety,// Loop over path components manually. This makes it easier to detect; // non-preferred slashes and double separators that must be canonicalized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Path.cpp:63,detect,detect,63,interpreter/llvm-project/llvm/lib/Support/Path.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Path.cpp,1,['detect'],['detect']
Safety,"// Loop over the blocks, adding them to our set-vector, and aborting with an; // empty set if we encounter invalid blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:60,abort,aborting,60,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['abort'],['aborting']
Safety,"// Loop through all loop latches (branches controlling backedges). We need; // to place a safepoint on every backedge (potentially).; // Note: In common usage, there will be only one edge due to LoopSimplify; // having run sometime earlier in the pipeline, but this code must be correct; // w.r.t. loops with multiple backedges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:90,safe,safepoint,90,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,"// Loop until we find a DeclContext that is either a function/method or the; // translation unit, which are the only two valid places to implicitly define; // a function. This avoids accidentally defining the function within a tag; // declaration, for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:176,avoid,avoids,176,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoids']
Safety,"// LoopInfo does not detect irreducible control flow, just natural; // loops. That is, it is possible that there is cyclic control; // flow within the ""innermost loop"" or around the ""outermost; // loop"".; /// Return true if the loop does not contain any (natural) loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h:21,detect,detect,21,interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,1,['detect'],['detect']
Safety,"// LoopSink pass sinks instructions hoisted by LICM, which serves as a; // canonicalization pass that enables other optimizations. As a result,; // LoopSink pass needs to be a very late IR pass to avoid undoing LICM; // result too early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:197,avoid,avoid,197,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['avoid'],['avoid']
Safety,// Lower bound on lifetime to mark an allocation cold (in addition to accesses; // per byte per sec above). This is to avoid pessimizing short lived objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp:119,avoid,avoid,119,interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryProfileInfo.cpp,1,['avoid'],['avoid']
Safety,"// Lower the number of redundant components when there's a mismatch; // between the first path, and the path under consideration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:23,redund,redundant,23,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redund'],['redundant']
Safety,// M68k doesn't have an i8 cmov. If both operands are the result of a; // truncate widen the cmov and push the truncate through. This avoids; // introducing a new branch during isel and doesn't add any extensions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:134,avoid,avoids,134,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// MBB isn't a special case, so it's safe to be split to the cold section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:37,safe,safe,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['safe'],['safe']
Safety,"// MC predictions (smeared templates)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TFractionFitter.h:6,predict,predictions,6,hist/hist/inc/TFractionFitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TFractionFitter.h,1,['predict'],['predictions']
Safety,// MI has an unwanted D-register dependency.; // Avoid defs in the previous N instructrions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:49,Avoid,Avoid,49,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['Avoid'],['Avoid']
Safety,"// MIMG instructions create a hazard if they don't use a 256-bit T# and; // the store size is greater than 8 bytes and they have more than two bits; // of their dmask set.; // All our MIMG definitions use a 256-bit T#, so we can skip checking for them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:30,hazard,hazard,30,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,// MIR printing is redundant with -filetype=null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp:19,redund,redundant,19,interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LLVMTargetMachine.cpp,1,['redund'],['redundant']
Safety,"// MOV32r0 is implemented with xor which clobbers condition code. It is; // safe to move up, if the definition to EFLAGS is dead and earlier; // instructions do not read or write EFLAGS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:76,safe,safe,76,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safe']
Safety,"// MPEG transport streams use the "".ts"" file extension. clang-format should; // not attempt to format those. MPEG TS' frame format starts with 0x47 every; // 189 bytes - detect that and return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:170,detect,detect,170,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['detect'],['detect']
Safety,// MSVC allows imported or exported template classes that have UniqueExternal; // linkage. This occurs when the template class has been instantiated with; // a template parameter which itself has internal linkage.; // We drop the attribute to avoid exporting or importing any members.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:243,avoid,avoid,243,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['avoid'],['avoid']
Safety,"// MSVC does not pad out symbol records to four bytes, but LLVM does to avoid; // an extra copy of every symbol record in LLD. This increases object file; // size by less than 1% in the clang build, and is compatible with the Visual; // C++ linker.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:72,avoid,avoid,72,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['avoid'],['avoid']
Safety,"// MSVC: If previous token was pasted, this must be a recovery from an invalid; // paste operation. Ignore spaces before this token to mimic MSVC output.; // Required for generating valid UUID strings in some MS headers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:54,recover,recovery,54,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['recover'],['recovery']
Safety,"// MVE does not have a single instruction to perform the truncation of a v4i32; // into the lower half of a v8i16, in the same way that a NEON vmovn would.; // Most of the instructions in MVE follow the 'Beats' system, where moving; // values from different lanes is usually something that the instructions; // avoid.; //; // Instead it has top/bottom instructions such as VMOVLT/B and VMOVNT/B,; // which take a the top/bottom half of a larger lane and extend it (or do the; // opposite, truncating into the top/bottom lane from a larger lane). Note; // that because of the way we widen lanes, a v4i16 is really a v4i32 using the; // bottom 16bits from each vector lane. This works really well with T/B; // instructions, but that doesn't extend to v8i32->v8i16 where the lanes need; // to move order.; //; // But truncates and sext/zext are always going to be fairly common from llvm.; // We have several options for how to deal with them:; // - Wherever possible combine them into an instruction that makes them; // ""free"". This includes loads/stores, which can perform the trunc as part; // of the memory operation. Or certain shuffles that can be turned into; // VMOVN/VMOVL.; // - Lane Interleaving to transform blocks surrounded by ext/trunc. So; // trunc(mul(sext(a), sext(b))) may become; // VMOVNT(VMUL(VMOVLB(a), VMOVLB(b)), VMUL(VMOVLT(a), VMOVLT(b))). (Which in; // this case can use VMULL). This is performed in the; // MVELaneInterleavingPass.; // - Otherwise we have an option. By default we would expand the; // zext/sext/trunc into a series of lane extract/inserts going via GPR; // registers. One for each vector lane in the vector. This can obviously be; // very expensive.; // - The other option is to use the fact that loads/store can extend/truncate; // to turn a trunc into two truncating stack stores and a stack reload. This; // becomes 3 back-to-back memory operations, but at least that is less than; // all the insert/extracts.; //; // In order to do the last, we convert c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:311,avoid,avoid,311,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoid']
Safety,// MachineIRBuilder::DebugLoc can outlive the DILocation it holds. Clear it; // to avoid accessing free’d memory (in runOnMachineFunction) and to avoid; // destroying it twice (in ~IRTranslator() and ~LLVMContext()),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:83,avoid,avoid,83,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,2,['avoid'],['avoid']
Safety,"// Make GPR register Reg speculation-safe by putting it through the; // SpeculationSafeValue pseudo instruction, if we can't prove that; // the value in the register has already been hardened.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:37,safe,safe,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['safe'],['safe']
Safety,// Make S.front() and S.drop_front().front() (if S.front() is [+-]) calls; // safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:78,safe,safe,78,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['safe'],['safe']
Safety,"// Make a policy decision about whether this loop needs a safepoint or; // not. Note that this is about unburdening the optimizer in loops, not; // avoiding the runtime cost of the actual safepoint.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:58,safe,safepoint,58,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,3,"['avoid', 'safe']","['avoiding', 'safepoint']"
Safety,"// Make a quick check if variable can be default NULL initialized; // and avoid going through rest of code which may do, for c++11,; // initialization of memory to all NULLs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp:74,avoid,avoid,74,interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,1,['avoid'],['avoid']
Safety,"// Make extra render pass to avoid flickering when quads are too small.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveDigitSet.h:29,avoid,avoid,29,graf3d/eve/inc/TEveDigitSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/inc/TEveDigitSet.h,2,['avoid'],['avoid']
Safety,"// Make our local copy of the tree, so we can safely loop through it.; // We need a custom deleter, because if we don't deregister the Tree from the directory; // of the original, it tears it down at destruction time!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:46,safe,safely,46,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,1,['safe'],['safely']
Safety,// Make set_size() private to avoid misuse in subclasses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:30,avoid,avoid,30,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['avoid'],['avoid']
Safety,"// Make sure any conversions are pushed back into the call; this is; // type safe since unordered compare builtins are declared as ""_Bool; // foo(...)"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:77,safe,safe,77,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['safe'],['safe']
Safety,"// Make sure it is not smaller then the cache, if the info is available and the size; // synchronization is required. But apply the cache-packet size synchronization only if there; // are enough left files to process and the files are all of similar sizes. Otherwise we risk; // to not exploit optimally all potentially active workers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:270,risk,risk,270,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,1,['risk'],['risk']
Safety,"// Make sure motion is detected too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGButton.cxx:23,detect,detected,23,gui/gui/src/TGButton.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGButton.cxx,1,['detect'],['detected']
Safety,// Make sure reusing the instruction is poison-safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:47,safe,safe,47,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['safe'],['safe']
Safety,// Make sure that after checking in the top-most frame the list of; // tracked ivars is empty. This is intended to detect accidental leaks in; // the UnreleasedIvarMap program state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp:115,detect,detect,115,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CheckObjCDealloc.cpp,1,['detect'],['detect']
Safety,"// Make sure that any load of address and any other address computation; // remains scalar unless there is gather/scatter support. This avoids; // inevitable extracts into address registers, and also has the benefit of; // activating LSR more, since that pass can't optimize vectorized; // addresses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:136,avoid,avoids,136,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avoid'],['avoids']
Safety,"// Make sure that the exponent fits inside an ""int"" of size DstWidth,; // thus avoiding any range issues that FP has not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:79,avoid,avoiding,79,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['avoid'],['avoiding']
Safety,"// Make sure that the selector abort status is reset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:31,abort,abort,31,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['abort'],['abort']
Safety,"// Make sure that we don't make an ill-formed AST where the type of the; // Class is non-dependent and its attached base class specifier is an; // dependent type, which violates invariants in many clang code paths (e.g.; // constexpr evaluator). If this case happens (in errory-recovery mode), we; // explicitly mark the Class decl invalid. The diagnostic was already; // emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:278,recover,recovery,278,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recovery']
Safety,"// Make sure that we won't clobber any live ins to the sibling block by; // hoisting Dependency. For instance, we can't hoist INST to before the; // null check (even if it safe, and does not violate any dependencies in; // the non_null_block) if %rdx is live in to _null_block.; //; // test %rcx, %rcx; // je _null_block; // _non_null_block:; // %rdx = INST; // ...; //; // This restriction does not apply to the faulting load inst because in; // case the pointer loaded from is in the null page, the load will not; // semantically execute, and affect machine state. That is, if the load; // was loading into %rax and it faults, the value of %rax should stay the; // same as it would have been had the load not have executed and we'd have; // branched to NullSucc directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:172,safe,safe,172,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['safe'],['safe']
Safety,"// Make sure the associated call site argument has the same type at all call; // sites and it is an allocation we know is safe to privatize, for now that; // means we only allow alloca instructions.; // TODO: We can additionally analyze the accesses in the callee to create; // the type from that information instead. That is a little more; // involved and will be done in a follow up patch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:122,safe,safe,122,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['safe'],['safe']
Safety,// Make sure the literal ends up in .rodata to allow for safe ICF and for; // the static linker to adjust permissions to read-only later on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:57,safe,safe,57,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['safe'],['safe']
Safety,"// Make sure the macro is in the Preprocessor. Not sure if not redundant; // because removeMacro looks for the macro anyway in the DenseMap Macros[]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:63,redund,redundant,63,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['redund'],['redundant']
Safety,"// Make sure the memory at this pointer cannot be freed, therefore we can; // safely reload from it after clobber.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:78,safe,safely,78,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['safe'],['safely']
Safety,// Make sure the operands don't reference something unsafe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:52,unsafe,unsafe,52,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,1,['unsafe'],['unsafe']
Safety,"// Make sure the prototype is as expected, otherwise the rest of the; // function is probably invalid and likely to abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:116,abort,abort,116,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['abort'],['abort']
Safety,// Make sure the subregisters match.; // Otherwise we risk changing the size of the load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:54,risk,risk,54,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['risk'],['risk']
Safety,"// Make sure there is no 'def' or 'use' of any of the uses of; // feeder insn between its definition, this MI and jump, jmpInst; // skipping compare, cmpInst.; // Here's the example.; // r21=memub(r22+r24<<#0); // p0 = cmp.eq(r21, #0); // r4=memub(r3+r21<<#0); // if (p0.new) jump:t .LBB29_45; // Without this check, it will be converted into; // r4=memub(r3+r21<<#0); // r21=memub(r22+r24<<#0); // p0 = cmp.eq(r21, #0); // if (p0.new) jump:t .LBB29_45; // and result WAR hazards if converted to New Value Jump.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:472,hazard,hazards,472,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,1,['hazard'],['hazards']
Safety,"// Make sure this is really a binary operator that is safe to pass into; // BinaryOperator::getOverloadedOpcode(), e.g. it's not a subscript op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:54,safe,safe,54,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['safe'],['safe']
Safety,// Make sure we only try to split 256/512-bit types to avoid creating; // narrow vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:55,avoid,avoid,55,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Make sure we only visit each class once to avoid infinite loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterBankEmitter.cpp:46,avoid,avoid,46,interpreter/llvm-project/llvm/utils/TableGen/RegisterBankEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/RegisterBankEmitter.cpp,1,['avoid'],['avoid']
Safety,// Make the mask's bitwidth at least 8-bit and a power-of-2 to avoid; // unnecessary illegal types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:63,avoid,avoid,63,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,// Make the selection of the recovery decl deterministic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:29,recover,recovery,29,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery']
Safety,"// Make these distinct, to avoid merging two lexical blocks on the same; // file/line/column.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DIBuilder.cpp,1,['avoid'],['avoid']
Safety,"// Make this tuple mutable to avoid casts that obfuscate const-correctness; // issues. Const-correctness of references is taken care of by `zippy` that; // defines const-non and const iterator types that will propagate down to; // `enumerator_result`'s `Refs`.; // Note that unlike the results of `zip*` functions, `enumerate`'s result are; // supposed to be modifiable even when defined as; // `const`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:30,avoid,avoid,30,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['avoid'],['avoid']
Safety,"// Make use of SelectCC to generate the comparison to set CR bits, for; // equality comparisons having one literal operand, SelectCC probably; // doesn't need to materialize the whole literal and just use xoris to; // check it first, it leads the following comparison result can't; // exactly represent GT/LT relationship. So to avoid this we specify; // SETGT/SETUGT here instead of SETEQ.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:329,avoid,avoid,329,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// Making a new compiled class is not thread safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx:45,safe,safe,45,roofit/roofitcore/src/RooClassFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooClassFactory.cxx,1,['safe'],['safe']
Safety,// Making clamping conditional on CSSC extension as without legal types we; // lower to CMP which can fold one of the two sxtb's we'd otherwise need; // if we detect a type smaller than 32-bit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp:159,detect,detect,159,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64LegalizerInfo.cpp,1,['detect'],['detect']
Safety,"// MallocOverflowSecurityChecker.cpp - Check for malloc overflows -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects a common memory allocation security flaw.; // Suppose 'unsigned int n' comes from an untrusted source. If the; // code looks like 'malloc (n * 4)', and an attacker can make 'n' be; // say MAX_UINT/4+2, then instead of allocating the correct 'n' 4-byte; // elements, this will actually allocate only two because of overflow.; // Then when the rest of the program attempts to store values past the; // second element, these values will actually overwrite other items in; // the heap, probably allowing the attacker to execute arbitrary code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:396,detect,detects,396,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,1,['detect'],['detects']
Safety,// Manually compute the global's type to avoid building it when unnecessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:41,avoid,avoid,41,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['avoid'],['avoid']
Safety,// Manually open up the bundle to avoid introducing additional dependencies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp:34,avoid,avoid,34,interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-debuginfo-analyzer/llvm-debuginfo-analyzer.cpp,1,['avoid'],['avoid']
Safety,"// Manually restore values not restored by libcall & Push/Pop.; // Keep the same order as in the prologue. There is no need to reverse the; // order in the epilogue. In addition, the return address will be restored; // first in the epilogue. It increases the opportunity to avoid the; // load-to-use data hazard between loading RA and return by RA.; // loadRegFromStackSlot can insert multiple instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp:274,avoid,avoid,274,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp,2,"['avoid', 'hazard']","['avoid', 'hazard']"
Safety,"// Many math library functions read the rounding mode. We will only; // vectorize a loop if it contains known function calls that don't set; // the flag. Therefore, it is safe to ignore this read from memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:171,safe,safe,171,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['safe'],['safe']
Safety,"// Many of MSVC builtins are on x64, ARM and AArch64; to avoid repeating code,; // we handle them here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:57,avoid,avoid,57,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['avoid'],['avoid']
Safety,// Map each group of one or two GPRs to corresponding VSR for spilling.; // TODO: Use local table in methods to avoid this mutable member.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h:112,avoid,avoid,112,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.h,1,['avoid'],['avoid']
Safety,"// Map functions to the iterators of the FunctionNode which contains them; // in the FnTree. This must be updated carefully whenever the FnTree is; // modified, i.e. in insert(), remove(), and replaceFunctionInTree(), to avoid; // dangling iterators into FnTree. The invariant that preserves this is that; // there is exactly one mapping F -> FN for each FunctionNode FN in FnTree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:221,avoid,avoid,221,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,1,['avoid'],['avoid']
Safety,"// Map of pointer to avoid circulation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/inc/TStructViewer.h:21,avoid,avoid,21,graf3d/gviz3d/inc/TStructViewer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/inc/TStructViewer.h,1,['avoid'],['avoid']
Safety,"// Map to disk files where possible, to pick up any missing stat; // information. This also means we don't need to check the unresolved; // headers list when emitting resolved headers in the first loop below.; // FIXME: It'd be preferable to avoid doing this if we were given; // sufficient stat information in the module map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:242,avoid,avoid,242,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['avoid'],['avoid']
Safety,"// Map to keep track of created compares, The key is the pair of operands for; // the compare, to allow detecting and re-using redundant compares.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:104,detect,detecting,104,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,2,"['detect', 'redund']","['detecting', 'redundant']"
Safety,"// Maps catchswitches and cleanuppads that unwind to siblings to the; // terminators that indicate the unwind, used to detect cycles therein.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:119,detect,detect,119,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['detect'],['detect']
Safety,"// Mark all case blocks reachable to avoid problems with switching on; // constants, covered enums, etc.; // These blocks can contain fall-through annotations, and we don't want to; // issue a warn_fallthrough_attr_unreachable for them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:37,avoid,avoid,37,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['avoid'],['avoid']
Safety,// Mark all regions that were interesting before as NOT interesting now; // to avoid extra notes coming from invalidation points higher up the; // bugpath. This ensures that only the last invalidation point is marked; // with a note tag.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp:79,avoid,avoid,79,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/cert/InvalidPtrChecker.cpp,1,['avoid'],['avoid']
Safety,// Mark all the enclosing scopes from which you can safely jump; // into the target scope. 'Min' will end up being the index of; // the shallowest such scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:52,safe,safely,52,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,1,['safe'],['safely']
Safety,"// Mark li as unspillable if all live ranges are tiny and the interval; // is not live at any reg mask. If the interval is live at a reg mask; // spilling may be required. If li is live as use in statepoint instruction; // spilling may be required due to if we mark interval with use in statepoint; // as not spillable we are risky to end up with no register to allocate.; // At the same time STATEPOINT instruction is perfectly fine to have this; // operand on stack, so spilling such interval and folding its load from stack; // into instruction itself makes perfect sense.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp:326,risk,risky,326,interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CalcSpillWeights.cpp,1,['risk'],['risky']
Safety,// Mark string variable as defined to detect collisions between; // string and numeric variables in parseNumericVariableUse() and; // defineCmdlineVariables() when the latter is created later than the; // former. We cannot reuse GlobalVariableTable for this by populating; // it with an empty string since we would then lose the ability to; // detect the use of an undefined variable in match().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:38,detect,detect,38,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,2,['detect'],['detect']
Safety,// Mark the loop as already vectorized to avoid vectorizing again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,['avoid'],['avoid']
Safety,// Mark the new function `noreturn` if applicable. Terminators which resume; // exception propagation are treated as returning instructions. This is to; // avoid inserting traps after calls to outlined functions which unwind.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:156,avoid,avoid,156,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['avoid'],['avoid']
Safety,"// Mark the new loop as partially unswitched, to avoid unswitching on; // the same condition again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:49,avoid,avoid,49,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['avoid'],['avoid']
Safety,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:302,redund,redundant,302,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['redund'],['redundant']
Safety,// Mark the registration node. The backend needs to know which alloca it is so; // that it can recover the original frame pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp:95,recover,recover,95,interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86WinEHState.cpp,1,['recover'],['recover']
Safety,// Mark the string variable as defined to detect collisions between; // string and numeric variables in defineCmdlineVariables when the latter; // is created later than the former. We cannot reuse GlobalVariableTable; // for this by populating it with an empty string since we would then; // lose the ability to detect the use of an undefined variable in; // match().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:42,detect,detect,42,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,2,['detect'],['detect']
Safety,"// Mark these STRICTWQM, but only for the instruction, not its operands.; // This avoid unnecessarily marking M0 as requiring WQM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:82,avoid,avoid,82,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['avoid'],['avoid']
Safety,// Mark u available for cycle detection,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp:30,detect,detection,30,interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/GCOV.cpp,1,['detect'],['detection']
Safety,"// Mark undef, erase record of this DBG_VALUE to avoid revisiting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:49,avoid,avoid,49,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['avoid'],['avoid']
Safety,// Mark us visited so we can detect a cycle,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:29,detect,detect,29,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['detect'],['detect']
Safety,"// Mask in the target value a byte at a time (we don't have an alignment; // guarantee for the target address, so this is safest).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h:122,safe,safest,122,interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/RuntimeDyld/Targets/RuntimeDyldMachOAArch64.h,1,['safe'],['safest']
Safety,"// Mask off the upper bits in the new value that are not going to go into; // the lower value. This avoids a left shift of a negative value, which; // is undefined behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Endian.h:100,avoid,avoids,100,interpreter/llvm-project/llvm/include/llvm/Support/Endian.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Endian.h,1,['avoid'],['avoids']
Safety,"// Match an equality compare with a non-poison constant as Cmp0.; // Also, give up if the compare can be constant-folded to avoid looping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:124,avoid,avoid,124,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['avoid'],['avoid']
Safety,"// Match the following pattern, which is a common idiom when writing; // overflow-safe integer arithmetic functions. The source performs an addition; // in wider type and explicitly checks for overflow using comparisons against; // INT_MIN and INT_MAX. Simplify by using the sadd_with_overflow intrinsic.; //; // TODO: This could probably be generalized to handle other overflow-safe; // operations if we worked out the formulas to compute the appropriate magic; // constants.; //; // sum = a + b; // if (sum+128 >u 255) ... -> llvm.sadd.with.overflow.i8",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:82,safe,safe,82,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,2,['safe'],['safe']
Safety,// Matches a `Stmt` node iff the node is in a safe-buffer opt-out region,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:46,safe,safe-buffer,46,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['safe'],['safe-buffer']
Safety,// Materialize a boolean comparison for integers so we can avoid branching.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:59,avoid,avoid,59,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Materialize this into a scalar move for scalar address to avoid; // readfirstlane.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:61,avoid,avoid,61,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// Max insertion offset in the original code. For example, we want to avoid; // inserting new #includes into the actual code section (e.g. after a; // declaration).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h:70,avoid,avoid,70,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h,1,['avoid'],['avoid']
Safety,// Max recursion depth for collectBitParts used when detecting bswap and; // bitreverse idioms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:53,detect,detecting,53,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['detect'],['detecting']
Safety,// Maximum recursion level. Used to avoid stack overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/RustDemangle.cpp,1,['avoid'],['avoid']
Safety,"// Maybe IC, maybe Prediction Restriction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp:19,Predict,Prediction,19,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,1,['Predict'],['Prediction']
Safety,"// Maybe we ought to prefix the name to avoid ambiguity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:40,avoid,avoid,40,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['avoid'],['avoid']
Safety,"// Maybe we should also check if holes are in the opposite direction, just to be safe ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:81,safe,safe,81,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['safe'],['safe']
Safety,"// Measure the scope level (i.e. depth of (), [], {}) of the first token, and; // abort when we hit any token in a higher scope than the starting one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:82,abort,abort,82,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,1,['abort'],['abort']
Safety,"// Memoize the result of each visit so that we only compute once for; // the same input SCEV. This is to avoid redundant computations when; // a SCEV is referenced by multiple SCEVs. Without memoization, this; // visit algorithm would have exponential time complexity in the worst; // case, causing the compiler to hang on certain tests.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:105,avoid,avoid,105,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// Memory check:; // Transform phase will generate a versioned loop and also a runtime check to; // ensure the pointers are independent and they don’t alias.; // In version variant of loop, alias meta data asserts that all access are; // mutually independent.; //; // Pointers aliasing in alias domain are avoided because with multiple; // aliasing domains we may not be able to hoist potential loop invariant; // access out of the loop.; //; // Iterate over alias tracker sets, and confirm AliasSets doesn't have any; // must alias set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:306,avoid,avoided,306,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['avoid'],['avoided']
Safety,"// Memory operand. Note that on PowerPC targets, m can; // include addresses that update the base register. It; // is therefore only safe to use `m' in an asm statement; // if that asm statement accesses the operand exactly once.; // The asm statement must also use `%U<opno>' as a; // placeholder for the ""update"" flag in the corresponding; // load or store instruction. For example:; // asm (""st%U0 %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is correct but:; // asm (""st %1,%0"" : ""=m"" (mem) : ""r"" (val));; // is not. Use es rather than m if you don't want the base; // register to be updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h:133,safe,safe,133,interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/PPC.h,1,['safe'],['safe']
Safety,"// Merge is safe for ""normal"" internal or external globals only",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,1,['safe'],['safe']
Safety,"// Merge overload to error out in case no valid HIST::Merge method was detected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:71,detect,detected,71,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['detect'],['detected']
Safety,// Merging of extern globals is enabled by default on non-Mach-O as we; // expect it to be generally either beneficial or harmless. On Mach-O it; // is disabled as we emit the .subsections_via_symbols directive which; // means that merging extern globals is not safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp:262,safe,safe,262,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,2,['safe'],['safe']
Safety,// Meta Instructions have no output and do not change any values and so; // can be safely ignored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp:83,safe,safely,83,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DbgEntityHistoryCalculator.cpp,1,['safe'],['safely']
Safety,"// Metadata can be dependent on the condition we are hoisting above.; // Strip all UB-implying metadata on the instruction. Drop the debug loc; // to avoid making it appear as if the condition is a constant, which would; // be misleading while debugging.; // Similarly strip attributes that maybe dependent on condition we are; // hoisting above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:150,avoid,avoid,150,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,// Microsoft property fields can have multiple sizeless array chunks; // (i.e. int x[][][]). Skip all of these except one to avoid creating; // bad incomplete array types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:125,avoid,avoid,125,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['avoid'],['avoid']
Safety,"// Minor canonicalization of the accumulated shuffle mask to make it easier; // to match below. All this does is detect masks with sequential pairs of; // elements, and shrink them to the half-width mask. It does this in a loop; // so it will reduce the size of the mask to the minimal width mask which; // performs an equivalent shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:113,detect,detect,113,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['detect'],['detect']
Safety,"// Miscellaneous memory related features, detected by; // using the 0x80000008 leaf of the CPUID instruction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:42,detect,detected,42,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,1,['detect'],['detected']
Safety,// Miscompilation detected!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:18,detect,detected,18,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,1,['detect'],['detected']
Safety,// MispredictPenalty is the typical number of extra cycles the processor; // takes to recover from a branch misprediction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h:86,recover,recover,86,interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSchedule.h,1,['recover'],['recover']
Safety,"// Missing fBranchCount. let's attempts to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:43,recover,recover,43,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['recover'],['recover']
Safety,"// Module import found where it should not be, for instance, inside a; // namespace. Recover by importing the module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:85,Recover,Recover,85,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Recover'],['Recover']
Safety,// More accurate safety checking is done in getOutliningCandidateInfo.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp:17,safe,safety,17,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.cpp,1,['safe'],['safety']
Safety,// More error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:14,recover,recovery,14,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['recover'],['recovery']
Safety,"// More possible optimizations:; // Avoid call the virtual version of TBuffer::ReadInt and co.; // Merge the Reading of the version and the looking up or the StreamerInfo; // Avoid if (bytecnt) inside the CheckByteCount routines and avoid multiple (mostly useless nested calls); // Try to avoid if statement on onfile class being set (TBufferFile::ReadClassBuffer).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:36,Avoid,Avoid,36,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,4,"['Avoid', 'avoid']","['Avoid', 'avoid']"
Safety,"// More sanity checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:8,sanity check,sanity checks,8,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,2,['sanity check'],['sanity checks']
Safety,"// Most LLVM intrinsics are things which do not expand to actual calls, or; // at least if they do, are leaf functions that cause only finite stack; // growth. In particular, the optimizer likes to form things like memsets; // out of stores in the original IR. Another important example is; // llvm.localescape which must occur in the entry block. Inserting a; // safepoint before it is not legal since it could push the localescape; // out of the entry block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:364,safe,safepoint,364,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,// Most LLVM intrinsics do not take safepoints.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:36,safe,safepoints,36,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['safe'],['safepoints']
Safety,// Most targets cannot deal with loads of size < 8 and need to re-legalize to; // at least byte loads. Avoid creating such loads here,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:103,Avoid,Avoid,103,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['Avoid'],['Avoid']
Safety,// Move illegal artifacts to RetryList instead of aborting because; // legalizing InstList may generate artifacts that allow; // ArtifactCombiner to combine away them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp:50,abort,aborting,50,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/Legalizer.cpp,1,['abort'],['aborting']
Safety,// Move the iterators to the beginning of the MBB if we only got debug; // instructions before the tail. This is to avoid splitting a block when we; // only got debug instructions before the tail (to be invariant on -g).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:116,avoid,avoid,116,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['avoid'],['avoid']
Safety,"// Move the last case to the default successor. This is valid as if the; // default got unswitched it cannot be reached. This has the advantage of; // being simple and keeping the number of edges from this switch to; // successors the same, and avoiding any PHI update complexity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:245,avoid,avoiding,245,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['avoid'],['avoiding']
Safety,// Move the symbol into the error state.; // Note that this may be redundant: The symbol might already have been; // moved to this state in response to the failure of a dependence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp:67,redund,redundant,67,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Core.cpp,1,['redund'],['redundant']
Safety,"// Move the vector predicate SubV to a vector register, and scale it; // down to match the representation (bytes per type element) that VecV; // uses. The scaling down will pick every 2nd or 4th (every Scale-th; // in general) element and put them at the front of the resulting; // vector. This subvector will then be inserted into the Q2V of VecV.; // To avoid having an operation that generates an illegal type (short; // vector), generate a full size vector.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp:356,avoid,avoid,356,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLoweringHVX.cpp,1,['avoid'],['avoid']
Safety,// Movement within the same loop does not break LCSSA (the equality check is; // to avoid doing a hashtable lookup in case of intra-block movement).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:84,avoid,avoid,84,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,1,['avoid'],['avoid']
Safety,// Multiple income types. Abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:26,Abort,Abort,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['Abort'],['Abort']
Safety,// Multiplications are only custom-lowered for 128-bit and 64-bit vectors so; // that VMULL can be detected. Otherwise v2i64 multiplications are not legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:99,detect,detected,99,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['detect'],['detected']
Safety,// Multiplications are only custom-lowered for 128-bit vectors so that; // VMULL can be detected. Otherwise v2i64 multiplications are not legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:88,detect,detected,88,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['detect'],['detected']
Safety,"// Must be multiple of 16 to avoid padding issues below...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/testGenVectorVc.cxx:29,avoid,avoid,29,test/testGenVectorVc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/testGenVectorVc.cxx,1,['avoid'],['avoid']
Safety,// Must increase the shuffling treshold to avoid the small; // probability of infinite looping without making progress.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:43,avoid,avoid,43,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,1,['avoid'],['avoid']
Safety,// N = N + Idx * ElementSize;; // Avoid doing it for ElementSize of 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp:34,Avoid,Avoid,34,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp,1,['Avoid'],['Avoid']
Safety,"// NB: RCID is not an RCID. In fact it is 0 or 1 for scalar or vector; // registers. See getRegisterClassForType for the implementation.; // In this case vector registers are not vector in terms of; // VGPRs, but those which can hold multiple values.; // This is really the number of registers to fill when vectorizing /; // interleaving loops, so we lie to avoid trying to use all registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:358,avoid,avoid,358,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['avoid'],['avoid']
Safety,// NB: testing for not starting with a double quote to avoid; // breaking `template strings`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:55,avoid,avoid,55,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['avoid'],['avoid']
Safety,// NDEBUG; /// Avoid quadratic complexity in unusually large basic blocks by limiting the; /// size of the ready lists.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:15,Avoid,Avoid,15,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['Avoid'],['Avoid']
Safety,"// NOLINT: not allowed to use = default because of TObject::kIsOnHeap detection, see ROOT-10300",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TUrl.h:70,detect,detection,70,core/base/inc/TUrl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TUrl.h,14,['detect'],['detection']
Safety,"// NOLINT: not allowed to use = default because of TObject::kIsOnHeap detection, see ROOT-10300; // TBuffer objects cannot be copied or assigned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TBufferFile.h:70,detect,detection,70,io/io/inc/TBufferFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TBufferFile.h,1,['detect'],['detection']
Safety,"// NOLINT: not allowed to use = default because of TObject::kIsOnHeap detection, see https://sft.its.cern.ch/jira/browse/ROOT-10300",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumIntFactory.h:70,detect,detection,70,roofit/roofitcore/inc/RooNumIntFactory.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooNumIntFactory.h,1,['detect'],['detection']
Safety,"// NOTE! Windows uses LLP64 for 64bit mode. So, cast pointer to long long; // as this avoids warning in any 64bit/32bit compilation model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:86,avoid,avoids,86,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['avoid'],['avoids']
Safety,"// NOTE(gparolini): these TFile and TTree are created on the heap to work around a know bug that can; // cause a TObject to be incorrectly marked as ""on heap"" and attempted to be freed despite; // living on the stack.; // The bug is caused by the magic bit pattern `kObjectAllocMemValue` used by TStorage to; // mark a heap object appearing by chance on the stack.; // This is not a problem with a clear solution and in fact the whole heap detection system relies on UB,; // so for now we are forced to work around the bug rather than fixing it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx:440,detect,detection,440,tree/dataframe/test/dataframe_simple.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_simple.cxx,1,['detect'],['detection']
Safety,// NOTE: Sema assumes that PartialDiagnostic is location-invariant; // in the sense that its bits can be safely memcpy'ed and destructed; // in the new location.; /// The diagnostic ID.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/PartialDiagnostic.h:105,safe,safely,105,interpreter/llvm-project/clang/include/clang/Basic/PartialDiagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/PartialDiagnostic.h,1,['safe'],['safely']
Safety,"// NOTE: VC++ treats enums as signed, avoid using ObjCPropertyAttribute::Kind",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:38,avoid,avoid,38,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,1,['avoid'],['avoid']
Safety,"// NOTE: VC++ treats enums as signed, avoid using the AccessControl enum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:38,avoid,avoid,38,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['avoid'],['avoid']
Safety,"// NOTE: We assume that ONLY the first dimension of a leaf can have a variable; // size AND contain the index for the size of yet another sub-dimension.; // I.e. a variable size array inside a variable size array can only have its; // size vary with the VERY FIRST physical dimension of the leaf.; // Thus once the index of the first dimension is found, all other dimensions; // are fixed!; // NOTE: We could unroll some of this loops to avoid a few tests.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:438,avoid,avoid,438,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['avoid'],['avoid']
Safety,"// NOTE: We detected a bug, but the checker under whose name we would emit the; // error could be disabled. Generally speaking, the MallocChecker family is an; // integral part of the Static Analyzer, and disabling any part of it should; // only be done under exceptional circumstances, such as frequent false; // positives. If this is the case, we can reasonably believe that there are; // serious faults in our understanding of the source code, and even if we; // don't emit an warning, we should terminate further analysis with a sink; // node.; // Nonlocs can't be freed, of course.; // Non-region locations (labels and fixed addresses) also shouldn't be freed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp:12,detect,detected,12,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocChecker.cpp,1,['detect'],['detected']
Safety,"// NOTE: We need to delete the contents of OwnedModules, but Module's dtor; // will call LLVMContextImpl::removeModule, thus invalidating iterators into; // the container. Avoid iterators during this operation:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp:172,Avoid,Avoid,172,interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LLVMContextImpl.cpp,1,['Avoid'],['Avoid']
Safety,"// NOTE: if we wanted to, this is where to detect integer MIN/MAX",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:43,detect,detect,43,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['detect'],['detect']
Safety,"// NOTE: outlined to avoid including RPageStorage in the header",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleInspector.cxx:21,avoid,avoid,21,tree/ntupleutil/v7/src/RNTupleInspector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntupleutil/v7/src/RNTupleInspector.cxx,1,['avoid'],['avoid']
Safety,"// NOTE: the Limit is included! The lexer recovery only ever inserts a; // single token past the end of the FileID, specifically the ) when a; // macro-arg containing a comma should be guarded by parentheses.; //; // It is safe to include the Limit here because SourceManager allocates; // FileSize + 1 for each SLocEntry.; //; // See https://github.com/llvm/llvm-project/issues/60722.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:42,recover,recovery,42,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,2,"['recover', 'safe']","['recovery', 'safe']"
Safety,"// NOTE: the ROOT compression libraries aren't consistently written in C++; hence the; // #ifdef's to avoid problems with C code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/lz4/inc/ZipLZ4.h:102,avoid,avoid,102,core/lz4/inc/ZipLZ4.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/lz4/inc/ZipLZ4.h,2,['avoid'],['avoid']
Safety,"// NOTE: these counters aren't thread safe like the ones above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:38,safe,safe,38,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['safe'],['safe']
Safety,// NOTE: we avoid letting illegal types through even if we're before legalize; // ops – legalization has a hard time producing good code for the code that; // follows.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:12,avoid,avoid,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,// NOTE: we avoid letting illegal types through even if we're before legalize; // ops – legalization has a hard time producing good code for this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:12,avoid,avoid,12,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// NOTE: we now use the upper-bit of the fNevBufSize to see if we have serialized any of the; // optional IOBits. If that bit is set, we immediately read out the IOBits; to replace this; // (minimal) safeguard against corruption, we will set aside the upper-bit of fIOBits to do; // the same thing (the fact this bit is reserved is tested in the unit tests). If there is; // someday a need for more than 7 IOBits, we'll widen the field using the same trick.; //; // We like to keep this safeguard because we immediately will allocate a buffer based on; // the value of fNevBufSize -- and would like to avoid wildly inappropriate allocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:200,safe,safeguard,200,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,3,"['avoid', 'safe']","['avoid', 'safeguard']"
Safety,"// NOTE: we read the entire chunk in `bufCur`, but we only advance the pointer by `nbytesFirstChunk`,; // since the last part of `bufCur` will later be overwritten by the next chunk's payload.; // We do this to avoid a second ReadAt to read in the chunk offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx:211,avoid,avoid,211,tree/ntuple/v7/src/RMiniFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RMiniFile.cxx,1,['avoid'],['avoid']
Safety,"// NOTE:; // This type cannot fit all possible indexes representable by JSON, but is; // chosen because it is the largest unsigned type that can be safely; // converted to an \c int64_t.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h:148,safe,safely,148,interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Sarif.h,1,['safe'],['safely']
Safety,"// Name comes from FileEntry/DirectoryEntry::getName(), so it is safe to; // store it in the DenseMap below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp:65,safe,safe,65,interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/FileManager.cpp,1,['safe'],['safe']
Safety,"// NaryReassociate on GEPs creates redundant common expressions, so run; // EarlyCSE after it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:35,redund,redundant,35,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,2,['redund'],['redundant']
Safety,// Need to avoid trying to rewrite casts contained in macros.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:11,avoid,avoid,11,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['avoid'],['avoid']
Safety,// Need to avoid trying to rewrite synthesized casts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:11,avoid,avoid,11,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['avoid'],['avoid']
Safety,// Need to cast all indices to the same type before vectorization to; // avoid crash.; // Required to be able to find correct matches between different gather; // nodes and reuse the vectorized values rather than trying to gather them; // again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:73,avoid,avoid,73,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"// Need to cast objc_msgSend to ""void *"" (to workaround a GCC bandaid).; // If we don't do this cast, we get the following bizarre warning/note:; // xx.m:13: warning: function called through a non-compatible type; // xx.m:13: note: if this code is reached, the program will abort",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:274,abort,abort,274,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['abort'],['abort']
Safety,// Need to concat with zero vector for strict fp to avoid spurious; // exceptions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:52,avoid,avoid,52,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avoid'],['avoid']
Safety,// Need to concat with zero vector for strict fp to avoid spurious; // exceptions.; // TODO: Should we just do this for non-strict as well?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:52,avoid,avoid,52,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,['avoid'],['avoid']
Safety,// Need to resize this on each safepoint - we need the two to stay in sync and; // the clear patterns of a SelectionDAGBuilder have no relation to; // FunctionLoweringInfo. Also need to ensure used bits get cleared.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:31,safe,safepoint,31,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['safe'],['safepoint']
Safety,"// Need to set ofs=-1 to avoid sending another; // cleanup request",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSecContext.cxx:25,avoid,avoid,25,net/net/src/TSecContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSecContext.cxx,1,['avoid'],['avoid']
Safety,"// Needs to be included first to avoid redefinition of _POSIX_C_SOURCE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyAdaBoost.cxx:33,avoid,avoid,33,tmva/pymva/src/MethodPyAdaBoost.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyAdaBoost.cxx,4,['avoid'],['avoid']
Safety,// Negate RHS and add.; // The cast avoids undefined behavior if the constant is INT64_MIN.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:36,avoid,avoids,36,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,1,['avoid'],['avoids']
Safety,// Never recoverable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:9,recover,recoverable,9,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recoverable']
Safety,// New loop counter instructions are redundant in the loop preheader when; // code generation for workshare loop is finshed. That's why mark them as; // ready for deletion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:37,redund,redundant,37,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['redund'],['redundant']
Safety,"// Next, brutally remove the operand list. This is safe to do, as there are; // no cycles in the graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:51,safe,safe,51,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['safe'],['safe']
Safety,"// No GPR32 live Def, safe to return false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:22,safe,safe,22,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,1,['safe'],['safe']
Safety,"// No GPR64 dead Def, so all those GPR32 live Def can't have alias, therefore; // must be truely live, safe to return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp:103,safe,safe,103,interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFMIChecking.cpp,1,['safe'],['safe']
Safety,"// No bugs detected, update the state and add a single note tag which; // summarizes the new assumptions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:11,detect,detected,11,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,1,['detect'],['detected']
Safety,// No collision; // Collision detected,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:30,detect,detected,30,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detected']
Safety,"// No current marker, create one and absorb in. (FIXME: we can avoid an; // allocation in the future).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp:63,avoid,avoid,63,interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BasicBlock.cpp,1,['avoid'],['avoid']
Safety,// No failure of the predicate was detected,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h:35,detect,detected,35,interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ListReducer.h,1,['detect'],['detected']
Safety,// No fixit; we can't recover as if there were a semicolon here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:22,recover,recover,22,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['recover'],['recover']
Safety,"// No information is available for this EHPad from itself or any of its; // descendants. An unwind all the way out to a pad in the caller would; // need also to agree with the unwind dest of the parent funclet, so; // search up the chain to try to find a funclet with information. Put; // null entries in the memo map to avoid re-processing as we go up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:321,avoid,avoid,321,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['avoid'],['avoid']
Safety,// No need to do anything for pthreads. Claim argument to avoid warning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:58,avoid,avoid,58,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,2,['avoid'],['avoid']
Safety,"// No need to handle invariant loads when avoiding WAR conflicts, as; // there cannot be a vector store to the same memory location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:42,avoid,avoiding,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['avoid'],['avoiding']
Safety,"// No overflow detected, return [StartLower, StartUpper + Offset + 1) range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:15,detect,detected,15,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['detect'],['detected']
Safety,"// No point in doing this for one-operand phis.; // Since all PHIs for operands must be in the same block, then they must; // have the same number of operands so we can just abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:174,abort,abort,174,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['abort'],['abort']
Safety,// No pre-allocated free block was large enough. Allocate a new memory region.; // Note that all sections get allocated as read-write. The permissions will; // be updated later based on memory group.; //; // FIXME: It would be useful to define a default allocation size (or add; // it as a constructor parameter) to minimize the number of allocations.; //; // FIXME: Initialize the Near member for each memory group to avoid; // interleaving.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp:419,avoid,avoid,419,interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/SectionMemoryManager.cpp,1,['avoid'],['avoid']
Safety,// No removal fixit: can't recover from this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:27,recover,recover,27,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recover']
Safety,// No safepoint needed or wanted,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:6,safe,safepoint,6,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,"// No sequencing is specified between the true and false expression.; // However since exactly one of both is going to be evaluated we can; // consider them to be sequenced. This is needed to avoid warning on; // something like ""x ? y+= 1 : y += 2;"" in the case where we will visit; // both the true and false expressions because we can't evaluate x.; // This will still allow us to detect an expression like (pre C++17); // ""(x ? y += 1 : y += 2) = y"".; //; // We don't wrap the visitation of the true and false expression with; // SequencedSubexpression because we don't want to downgrade modifications; // as side effect in the true and false expressions after the visition; // is done. (for example in the expression ""(x ? y++ : y++) + y"" we should; // not warn between the two ""y++"", but we should warn between the ""y++""; // and the ""y"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:192,avoid,avoid,192,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,2,"['avoid', 'detect']","['avoid', 'detect']"
Safety,// No side effects: it is safe to hoist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,safe,safe,26,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['safe'],['safe']
Safety,// Non constant index/out of bounds index -> folding is unlikely.; // The latter is more of a sanity check because canonical IR should just; // have replaced those with poison.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:94,sanity check,sanity check,94,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['sanity check'],['sanity check']
Safety,// Non-constant size => unsafe. FIXME: try SCEV getRange.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:24,unsafe,unsafe,24,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['unsafe'],['unsafe']
Safety,"// Non-header phi nodes that have outside uses can be vectorized. Add; // them to the list of allowed exits.; // Unsafe cyclic dependencies with header phis are identified during; // legalization for reduction, induction and fixed order; // recurrences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:113,Unsafe,Unsafe,113,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['Unsafe'],['Unsafe']
Safety,"// Non-permuting loads are currently unsafe. We can use special; // handling for this in the future. By not marking these as; // IsSwap, we ensure computations containing them will be rejected; // for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:37,unsafe,unsafe,37,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['unsafe'],['unsafe']
Safety,"// Non-permuting stores are currently unsafe. We can use special; // handling for this in the future. By not marking these as; // IsSwap, we ensure computations containing them will be rejected; // for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:38,unsafe,unsafe,38,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['unsafe'],['unsafe']
Safety,"// None of the specific case has been detected, give generic error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:38,detect,detected,38,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['detect'],['detected']
Safety,"// Normalise columns to avoid rounding errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx:24,avoid,avoid,24,graf3d/gl/src/TGLBoundingBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLBoundingBox.cxx,1,['avoid'],['avoid']
Safety,"// Normally VALU use of exec would block the rematerialization, but that; // is OK in this case to have an implicit exec read as all VALU do.; // We really want all of the generic logic for this except for this.; // Another potential implicit use is mode register. The core logic of; // the RA will not attempt rematerialization if mode is set anywhere; // in the function, otherwise it is safe since mode is not changed.; // There is difference to generic method which does not allow; // rematerialization if there are virtual register uses. We allow this,; // therefore this method includes SOP instructions as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:390,safe,safe,390,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['safe'],['safe']
Safety,"// Normally this function only searches for already instantiated declaration; // however we have to make an exclusion for local types used before; // definition as in the code:; //; // template<typename T> void f1() {; // void g1(struct x1);; // struct x1 {};; // }; //; // In this case instantiation of the type of 'g1' requires definition of; // 'x1', which is defined later. Error recovery may produce an enum used; // before definition. In these cases we need to instantiate relevant; // declarations here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp:384,recover,recovery,384,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiateDecl.cpp,1,['recover'],['recovery']
Safety,"// Normally you can't use a MappedBlockStream without having fully parsed the; // PDB file, because it accesses the directory and various other things, which; // is exactly what we are attempting to parse. By specifying a custom; // subclass of IPDBStreamData which only accesses the fields that have already; // been parsed, we can avoid this and reuse MappedBlockStream.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp:333,avoid,avoid,333,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/PDBFile.cpp,1,['avoid'],['avoid']
Safety,"// Normally, in the cases we can prove no-overflow via a; // backedge guarding condition, we can also compute a backedge; // taken count for the loop. The exceptions are assumptions and; // guards present in the loop -- SCEV is not great at exploiting; // these to compute max backedge taken counts, but can still use; // these to prove lack of overflow. Use this fact to avoid; // doing extra work that may not pay off.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:372,avoid,avoid,372,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,3,['avoid'],['avoid']
Safety,"// Normally, it's not safe to use register enum values directly with; // addition to get the next register, but for VFP registers, the; // sort order is guaranteed because they're all of the form D<n>.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp:22,safe,safe,22,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMInstPrinter.cpp,8,['safe'],['safe']
Safety,"// Normally, with an optional key/value where the value is an empty sequence,; // the whole key/value can be not written. But, that produces wrong yaml; // if the key/value is the only thing in the map and the map is used in; // a sequence. This detects if the this sequence is the first key/value; // in map that itself is embedded in a sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLTraits.cpp:246,detect,detects,246,interpreter/llvm-project/llvm/lib/Support/YAMLTraits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLTraits.cpp,1,['detect'],['detects']
Safety,// Not a redundant move: fix build on gcc-7.5,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp:9,redund,redundant,9,interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/OrcV2Examples/LLJITWithExecutorProcessControl/LLJITWithExecutorProcessControl.cpp,2,['redund'],['redundant']
Safety,"// Not a text macro; not usable in TextItem context. Since we haven't used; // the token, put it back for better error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:119,recover,recovery,119,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['recover'],['recovery']
Safety,"// Not all calling conventions have only stack MOVs between the stack; // adjust and the call.; // We want to tolerate other instructions, to cover more cases.; // In particular:; // a) PCrel calls, where we expect an additional COPY of the basereg.; // b) Passing frame-index addresses.; // c) Calling conventions that have inreg parameters. These generate; // both copies and movs into registers.; // To avoid creating lots of special cases, allow any instruction; // that does not write into memory, does not def or use the stack; // pointer, and does not def any register that was used by a preceding; // push.; // (Reading from memory is allowed, even if referenced through a; // frame index, since these will get adjusted properly in PEI); // The reason for the last condition is that the pushes can't replace; // the movs in place, because the order must be reversed.; // So if we have a MOV32mr that uses EDX, then an instruction that defs; // EDX, and then the call, after the transformation the push will use; // the modified version of EDX, and not the original one.; // Since we are still in SSA form at this point, we only need to; // make sure we don't clobber any *physical* registers that were; // used by an earlier mov that will become a push.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:406,avoid,avoid,406,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,1,['avoid'],['avoid']
Safety,"// Not all intrinsic calls should have a discriminator.; // We want to avoid a non-deterministic assignment of discriminators at; // different debug levels. We still allow discriminators on memory; // intrinsic calls because those can be early expanded by SROA into; // pairs of loads and stores, and the expanded load/store instructions; // should have a valid discriminator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:71,avoid,avoid,71,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,1,['avoid'],['avoid']
Safety,"// Not all of these are entirely move-safe, but they do provide *some*; // guarantees, and it means that somebody is using them after move; // in a valid manner.; // TODO: We can still try to identify *unsafe* use after move,; // like we did with smart pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:38,safe,safe,38,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"// Not all operands are correctly disassembled at the moment. This means; // that some machine instructions won't have all the necessary operands; // set.; // To avoid asserting, print <unknown> instead until the necessary support; // has been implemented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp:162,avoid,avoid,162,interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/MCTargetDesc/AVRInstPrinter.cpp,2,['avoid'],['avoid']
Safety,"// Not always safe to do this translation.; // DAG Builder attempts to reduce dependence edges using transitive; // nature of dependencies. Here is an example:; //; // r0 = tfr_pt ... (1); // r0 = tfr_pf ... (2); // r0 = tfr_pt ... (3); //; // There will be an output dependence between (1)->(2) and (2)->(3).; // However, there is no dependence edge between (1)->(3). This results; // in all 3 instructions going in the same packet. We ignore dependce; // only once to avoid this situation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:14,safe,safe,14,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,// Not having a limit is safe because InstCombine removes unreachable; // code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:25,safe,safe,25,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['safe'],['safe']
Safety,// Not in the worklist.; // Null out the entry rather than erasing it to avoid a linear operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:73,avoid,avoid,73,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// Not initialized yet.; // SetupCallEnv is likely to require/take the interpreter lock.; // Grab it now to avoid dead-lock. In particular TPluginHandler::ExecPluginImpl; // takes the gInterpreterMutex and *then* call (indirectly) code that; // take the lock in fHandlers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx:108,avoid,avoid,108,core/base/src/TPluginManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TPluginManager.cxx,1,['avoid'],['avoid']
Safety,"// Not inlined in order to avoid const casted away warning in user code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMD5.h:27,avoid,avoid,27,core/base/inc/TMD5.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TMD5.h,2,['avoid'],['avoid']
Safety,// Not safe. Stop searching.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:7,safe,safe,7,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,1,['safe'],['safe']
Safety,// Not thread-safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp:14,safe,safe,14,interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-ml/llvm-ml.cpp,2,['safe'],['safe']
Safety,// Not using 'GCOVOptions::getDefault' allows us to avoid exiting if; // LLVM's -default-gcov-version flag is set to something invalid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:52,avoid,avoid,52,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['avoid'],['avoid']
Safety,"// Note that Apple's kernel linker doesn't support symbol; // coalescing, so we need to avoid linkonce and weak linkages there.; // Normally, this means we just map to internal, but for explicit; // instantiations we'll map to external.; // In C++, the compiler has to emit a definition in every translation unit; // that references the function. We should use linkonce_odr because; // a) if all references in this translation unit are optimized away, we; // don't need to codegen it. b) if the function persists, it needs to be; // merged with other definitions. c) C++ has the ODR, so we know the; // definition is dependable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:88,avoid,avoid,88,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['avoid'],['avoid']
Safety,"// Note that an XXPERMDI requires a VSRC, so if the SUBREG_TO_REG; // is copying to a VRRC, we need to be careful to avoid a register; // assignment problem. In this case we must copy from VRRC to VSRC; // prior to the swap, and from VSRC to VRRC following the swap.; // Coalescing will usually remove all this mess.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:117,avoid,avoid,117,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['avoid'],['avoid']
Safety,"// Note that it is not safe to speculate into a malloc'd region because; // malloc may return null.; // For GEPs, determine if the indexing lands within the allocated object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:23,safe,safe,23,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['safe'],['safe']
Safety,"// Note that it is safe to allocate CallExpr on the stack here because; // there are 0 arguments (i.e., nothing is allocated using ASTContext's; // allocator).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:19,safe,safe,19,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['safe'],['safe']
Safety,// Note that proving a load safe to speculate requires proving; // sufficient alignment at the target location. Proving it guaranteed; // to execute does as well. Thus we can increase our guaranteed; // alignment as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:28,safe,safe,28,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safe']
Safety,"// Note that the VP intrinsic causes undefined behavior if the Explicit Vector; // Length parameter is strictly greater-than the number of vector elements of; // the operation. This function returns true when this is detected statically; // in the IR.; // Check whether ""W == vscale * EC.getKnownMinValue()""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp:217,detect,detected,217,interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/IntrinsicInst.cpp,1,['detect'],['detected']
Safety,"// Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; // to indicates they are not yet properly protection against mutli-thread access.; //; // However, the use of these functions is rare and mostly done at library loading time which should; // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; // on that same TClass object.; //; // Summary: need careful review but risk of problem is extremely low.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:73,safe,safe,73,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,"['risk', 'safe']","['risk', 'safe']"
Safety,"// Note that the fInFlightClusters is accessed concurrently only by the I/O thread. The I/O thread; // never changes the structure of the in-flight clusters array (it does not add, remove, or swap elements).; // Therefore, it is safe to access the element pointed to by itr here even after fLockWorkQueue; // is released. We need to release the lock before potentially blocking on the cluster future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx:229,safe,safe,229,tree/ntuple/v7/src/RClusterPool.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RClusterPool.cxx,1,['safe'],['safe']
Safety,"// Note that the redundancy and structure in this code is tailored to improve; // efficiencies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:17,redund,redundancy,17,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['redund'],['redundancy']
Safety,"// Note that there are cases where we insert SEH opcodes in the; // epilogue when we had no SEH opcodes in the prologue. For; // example, when there is no stack frame but there are stack; // arguments. Insert the SEH_EpilogStart and remove it later if it; // we didn't emit any SEH opcodes to avoid generating WinCFI for; // functions that don't need it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:293,avoid,avoid,293,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['avoid'],['avoid']
Safety,// Note that this correctly re-maps both when we do a swap and when; // we observe the other side of the swap above. We rely on that to; // avoid swapping the members of the input list directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:140,avoid,avoid,140,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Note that this is UTF-8 safe, since if isPunctuation(Content[0]) is; // true, then the first code point must be 1 byte long.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:27,safe,safe,27,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['safe'],['safe']
Safety,"// Note that this module is part of the module build stack, so that we; // can detect cycles in the module graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:79,detect,detect,79,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['detect'],['detect']
Safety,// Note that we can't usefully rewrite this to the inverse without complex; // analysis of the users of the setCC. Largely we rely on duplicates which; // could have been avoided already being avoided here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp:171,avoid,avoided,171,interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FlagsCopyLowering.cpp,2,['avoid'],['avoided']
Safety,"// Note that we have to do this with our own collection, because there are; // times where a constraint-expression check can cause us to need to evaluate; // other constriants that are unrelated, such as when evaluating a recovery; // expression, or when trying to determine the constexpr-ness of special; // members. Otherwise we could just use the; // Sema::InstantiatingTemplate::isAlreadyBeingInstantiated function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:222,recover,recovery,222,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,1,['recover'],['recovery']
Safety,"// Note that we have to take special care to avoid looking through; // truncating casts, e.g., int2ptr/ptr2int with appropriate sizes, as well; // as casts that can alter the value, e.g., AddrSpaceCasts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['avoid'],['avoid']
Safety,"// Note that we lie to shouldClusterMemOps about the size of the; // cluster. When shouldClusterMemOps is called from the machine; // scheduler it limits the size of the cluster to avoid increasing; // register pressure too much, but this pass runs after register; // allocation so there is no need for that kind of limit.; // We also lie about the Offset and OffsetIsScalable parameters,; // as they aren't used in the SIInstrInfo implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp:181,avoid,avoid,181,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertHardClauses.cpp,1,['avoid'],['avoid']
Safety,"// Note that we need to check for non-int types above before asking for; // demanded bits. Normally, the only way to reach an instruction with an; // non-int type is via an instruction that has side effects (or otherwise; // will demand its input bits). However, if we have a readnone function; // that returns an unsized type (e.g., void), we must avoid asking for the; // demanded bits of the function call's return value. A void-returning; // readnone function is always dead (and so we can stop walking the use/def; // chain here), but the check is necessary to avoid asserting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp:349,avoid,avoid,349,interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/BDCE.cpp,2,['avoid'],['avoid']
Safety,// Note that we only check if a File was returned. If it was out-of-date; // we have complained but we will continue creating a FileID to recover; // gracefully.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:138,recover,recover,138,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['recover'],['recover']
Safety,"// Note that we open here with @{ the Doxygen group vecops and it is; // closed again at the end of the C++ namespace VecOps; /**; * \defgroup vecops VecOps; * A ""std::vector""-like collection of values implementing handy operation to analyse them; * @{; */; // From the original SmallVector code:; // This is a 'vector' (really, a variable-sized array), optimized; // for the case when the array is small. It contains some number of elements; // in-place, which allows it to avoid heap allocation when the actual number of; // elements is below that threshold. This allows normal ""small"" cases to be; // fast without losing generality for large inputs.; //; // Note that this does not attempt to be exception safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:475,avoid,avoid,475,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// Note! I deliberately want it to fall thru so, we have a; // a property implementation and to avoid future warnings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:96,avoid,avoid,96,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,2,['avoid'],['avoid']
Safety,"// Note: EvaluatedStmt contains an APValue, which usually holds; // resources not allocated from the ASTContext. We need to do some; // work to avoid leaking those, but we do so in VarDecl::evaluateValue; // where we can detect whether there's anything to clean up or not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp:144,avoid,avoid,144,interpreter/llvm-project/clang/lib/AST/Decl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Decl.cpp,2,"['avoid', 'detect']","['avoid', 'detect']"
Safety,"// Note: In general, we do not create new shuffles in InstCombine because we; // do not know if a target can lower an arbitrary shuffle optimally. In this; // case, the shuffle uses the existing mask, so there is no additional risk.; // Select the variable vectors first, then perform the binop:; // shuffle (op X, C0), (op Y, C1), M --> op (shuffle X, Y, M), C'; // shuffle (op C0, X), (op C1, Y), M --> op C', (shuffle X, Y, M)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:227,risk,risk,227,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['risk'],['risk']
Safety,"// Note: IsUndef is sort of redundant. We could have determine it by; // checking that at all Ops are undef. Alternatively, we could have; // generate a build_vector of undefs and rely on another combine to; // clean that up. For now, given we already gather this information; // in tryCombineConcatVectors, just save compile time and issue the; // right thing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,redund,redundant,28,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['redund'],['redundant']
Safety,"// Note: It is legal for a single derived pointer to be listed multiple; // times. It's non-optimal, but it is legal. It can also happen after; // insertion if we strip a bitcast away.; // Note: It is really tempting to check that each base is relocated and; // that a derived pointer is never reused as a base pointer. This turns; // out to be problematic since optimizations run after safepoint insertion; // can recognize equality properties that the insertion logic doesn't know; // about. See example statepoint.ll in the verifier subdirectory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:387,safe,safepoint,387,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['safe'],['safepoint']
Safety,// Note: Only consider instructions with <= 2 operands to avoid; // complexity explosion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:58,avoid,avoid,58,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"// Note: Proxy-helper needs to ""embrace"" the entire; // streaming of this STL container if the container; // is a set/multiset/map/multimap (what we do not; // know here).; // For vector/list/deque Allocate == Resize; // and Commit == noop.; // TODO: Exception safety a la TPushPop",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:261,safe,safety,261,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['safe'],['safety']
Safety,"// Note: Technically, needing a safepoint isn't quite the right; // condition here. We should instead be checking if the target method; // has an; // unconditional poll. In practice, this is only a theoretical concern; // since we don't have any methods with conditional-only safepoint; // polls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:32,safe,safepoint,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,2,['safe'],['safepoint']
Safety,// Note: The SystemZLDCleanupPass will remove redundant computations; // of the module base offset. Count total number of local-dynamic; // accesses to trigger execution of that pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:46,redund,redundant,46,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['redund'],['redundant']
Safety,"// Note: This functionality is used only when unsafe-fp-math is enabled, and; // on cores with reciprocal estimates (which are used when unsafe-fp-math is; // enabled for division), this functionality is redundant with the default; // combiner logic (once the division -> reciprocal/multiply transformation; // has taken place). As a result, this matters more for older cores than for; // newer ones.; // Combine multiple FDIVs with the same divisor into multiple FMULs by the; // reciprocal if there are two or more FDIVs (for embedded cores with only; // one FP pipeline) for three or more FDIVs (for generic OOO cores).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:46,unsafe,unsafe-fp-math,46,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,3,"['redund', 'unsafe']","['redundant', 'unsafe-fp-math']"
Safety,"// Note: This is only semantically legal since we won't do any further; // IPO or inlining before the actual call insertion.. If we hadn't, we; // might latter loose this call safepoint.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:176,safe,safepoint,176,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,// Note: Using context-free form to avoid compile time blow up,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['avoid'],['avoid']
Safety,"// Note: We are transferring ownership here.; // In case a class contains an external enum, the enum will be seen as a; // class. We must detect this special case and make the class a Zombie.; // Here we assume that a class has at least one method.; // We can NOT call TClass::Property from here, because this method; // assumes that the TClass is well formed to do a lot of information; // caching. The method SetClassInfo (i.e. here) is usually called during; // the building phase of the TClass, hence it is NOT well formed yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:138,detect,detect,138,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['detect'],['detect']
Safety,"// Note: We need to release the buffer here to avoid double delete.; // The memory of a TBufferFile is allocated with new[], so we can let; // TMemBlock delete it, as its destructor calls ""delete [] fBuffer;""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx:47,avoid,avoid,47,io/io/src/TMemFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMemFile.cxx,1,['avoid'],['avoid']
Safety,"// Note: below two commands should be run atomically for thread safety (if that ever becomes an issue)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Queue.cxx:64,safe,safety,64,roofit/multiprocess/src/Queue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Queue.cxx,1,['safe'],['safety']
Safety,"// Note: can't re-use Utility::AddClass here, as there's the risk of; // a recursive call. Simply add method directly, as we're guaranteed; // that it doesn't exist yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx:61,risk,risk,61,bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPScope.cxx,1,['risk'],['risk']
Safety,// Note: loop indexes are signed to avoid underflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SwitchLoweringUtils.cpp,2,['avoid'],['avoid']
Safety,// Note: the CleanupLocalDynamicTLSPass will remove redundant computations; // of Base.; // Build x@dtpoff.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:52,redund,redundant,52,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['redund'],['redundant']
Safety,// Note: there used to be some attempt at recovery here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,recover,recovery,42,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery']
Safety,"// Note: there used to be some attempt at recovery here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:42,recover,recovery,42,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['recover'],['recovery']
Safety,// Note: we avoid integral promotion for comparison.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:12,avoid,avoid,12,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['avoid'],['avoid']
Safety,"// Note: we can't do Hesse here. Without the error recovery, Minuit2; // would print errors that would cause the unit test to fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:51,recover,recovery,51,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,1,['recover'],['recovery']
Safety,"// Note: we can't use Hesse or Minos. Without the error recovery, Minuit2; // would print errors that would cause the unit test to fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:56,recover,recovery,56,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,1,['recover'],['recovery']
Safety,"// Note: we could insert here a wait for all thread to be finished.; // this is questionable though as we need to balance between fixing a; // user error (the thread was let lose and the caller did not explicit wait); // and the risk that we can not terminate a failing process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx:229,risk,risk,229,core/thread/src/TThread.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx,1,['risk'],['risk']
Safety,"// Note: we're round tripping operand bundles through memory here, and that; // can potentially be avoided with a cleverer API design that we do not have; // as of this time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:99,avoid,avoided,99,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['avoid'],['avoided']
Safety,"// Note: zmq context is automatically created in the ZeroMQSvc class and maintained as singleton,; // but we must close any possibly existing state before reusing it. This assumes that our Messenger; // is the only user of ZeroMQSvc and that there is only one Messenger at a time. Beware that; // this must be designed more carefully if either of these assumptions change! Note also that this; // call must be done before the ProcessManager forks new processes, otherwise the master process'; // context that will be cloned to all forked processes will be closed multiple times, which will; // hang, because the ZeroMQ context creates threads and these will not be cloned along with the; // fork. See the ZeroMQ documentation for more details on this. In principle, one could design this; // in a more finegrained way by keeping the context on the master process and only recreating it; // on child processes (while avoiding calling the destructor on the child processes!). This; // approach may offer more flexibility if this is needed in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/ProcessManager.cxx:916,avoid,avoiding,916,roofit/multiprocess/src/ProcessManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/ProcessManager.cxx,1,['avoid'],['avoiding']
Safety,// Nothing to do: a ReturnStmt with no value is fine recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:53,recover,recovery,53,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['recover'],['recovery']
Safety,"// Notify the name of those which did timeout",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:38,timeout,timeout,38,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['timeout'],['timeout']
Safety,"// Now `FixItsForVariable` gets further reduced: a variable is in; // `FixItsForVariable` iff it can be fixed and all its group mates can be; // fixed.; // Fix-its of bounds-safe overloads of `D` are shared by parameters of `D`.; // That is, when fixing multiple parameters in one step, these fix-its will; // be applied only once (instead of being applied per parameter).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:174,safe,safe,174,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['safe'],['safe']
Safety,"// Now add each dependency in the order it was seen, but avoiding; // duplicates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:57,avoid,avoiding,57,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,1,['avoid'],['avoiding']
Safety,"// Now copy the implicit operands from BLR to BL and copy other necessary; // info.; // However, both BLR and BL instructions implictly use SP and implicitly; // define LR. Blindly copying implicit operands would result in SP and LR; // operands to be present multiple times. While this may not be too much of; // an issue, let's avoid that for cleanliness, by removing those implicit; // operands from the BL created above before we copy over all implicit; // operands from the BLR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SLSHardening.cpp:330,avoid,avoid,330,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SLSHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SLSHardening.cpp,1,['avoid'],['avoid']
Safety,"// Now copy the implicit operands from IndirectCall to BL and copy other; // necessary info.; // However, both IndirectCall and BL instructions implictly use SP and; // implicitly define LR. Blindly copying implicit operands would result in SP; // and LR operands to be present multiple times. While this may not be too; // much of an issue, let's avoid that for cleanliness, by removing those; // implicit operands from the BL created above before we copy over all; // implicit operands from the IndirectCall.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp:348,avoid,avoid,348,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp,1,['avoid'],['avoid']
Safety,// Now copy the result back out to a GPR.; // FIXME: Try to avoid this if all uses could actually just use the FPR64; // directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AdvSIMDScalarPass.cpp:60,avoid,avoid,60,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AdvSIMDScalarPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64AdvSIMDScalarPass.cpp,1,['avoid'],['avoid']
Safety,"// Now harden this register's value, getting a hardened reg that is safe to; // use. Note that we insert the instructions to compute this *after* the; // defining instruction, not before it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:68,safe,safe,68,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['safe'],['safe']
Safety,// Now it is safe to release dispatch/issue resources.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MCA/HardwareUnits/ResourceManager.cpp,1,['safe'],['safe']
Safety,// Now it's safe to change instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,1,['safe'],['safe']
Safety,// Now it's safe to remove the substs identified earlier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,1,['safe'],['safe']
Safety,// Now its safe to mmap the files into memory because both files; // have a non-zero size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp:11,safe,safe,11,interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileUtilities.cpp,1,['safe'],['safe']
Safety,// Now safe to delete the load and lsl. The LEA will be removed later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:7,safe,safe,7,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['safe'],['safe']
Safety,// Now that 'Ret' has unique predecessor we can safely remove all phi nodes; // from it,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:48,safe,safely,48,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safely']
Safety,"// Now that GetTarget() has (potentially) replaced TripleName, it's safe to; // construct the Triple object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp:68,safe,safe,68,interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc/llvm-mc.cpp,1,['safe'],['safe']
Safety,"// Now that all loop invariants have been removed from the loop, promote any; // memory references to scalars that we can.; // Don't sink stores from loops without dedicated block exits. Exits; // containing indirect branches are not transformed by loop simplify,; // make sure we catch that. An additional load may be generated in the; // preheader for SSA updater, so also avoid sinking when no preheader; // is available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:375,avoid,avoid,375,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['avoid'],['avoid']
Safety,"// Now that the Calls vector is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:49,safe,safe,49,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['safe'],['safe']
Safety,"// Now that the Callsites vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:53,safe,safe,53,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['safe'],['safe']
Safety,"// Now that the ConstVCallList vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:58,safe,safe,58,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['safe'],['safe']
Safety,"// Now that the Params is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:43,safe,safe,43,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['safe'],['safe']
Safety,"// Now that the Refs vector is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:48,safe,safe,48,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['safe'],['safe']
Safety,"// Now that the TI vector is finalized, it is safe to save the locations; // of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:46,safe,safe,46,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['safe'],['safe']
Safety,"// Now that the TypeTests vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:53,safe,safe,53,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['safe'],['safe']
Safety,"// Now that the VFuncIdList vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:55,safe,safe,55,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['safe'],['safe']
Safety,"// Now that the VTableFuncs vector is finalized, it is safe to save the; // locations of any forward GV references that need updating later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:55,safe,safe,55,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['safe'],['safe']
Safety,"// Now that the suspicious clone detector has checked for pattern errors,; // we also filter all clones who don't have matching patterns",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp:33,detect,detector,33,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CloneChecker.cpp,1,['detect'],['detector']
Safety,"// Now that we are done with the graph it is safe to add the new; // CallsiteInfo structs to the function summary vectors. The graph nodes; // point into locations within these vectors, so we don't want to add them; // any earlier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:45,safe,safe,45,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['safe'],['safe']
Safety,"// Now that we have built the index, load the global decl attachments; // that were deferred during that process. This avoids creating; // temporaries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp:119,avoid,avoids,119,interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/MetadataLoader.cpp,1,['avoid'],['avoids']
Safety,"// Now that we have figured out which replacements must be made, do them all; // now. This avoid invalidating the pointers in CMap, which are unneeded; // now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:91,avoid,avoid,91,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,1,['avoid'],['avoid']
Safety,"// Now that we know the removal is safe, remove the loop by changing the; // branch from the preheader to go to the single exit block.; //; // Because we're deleting a large chunk of code at once, the sequence in which; // we remove things is very important to avoid invalidation issues.; // Tell ScalarEvolution that the loop is deleted. Do this before; // deleting the loop so that ScalarEvolution can look at the loop; // to determine what it needs to clean up.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:35,safe,safe,35,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// Now that we've identified all the needed safepoint poll locations, insert; // safepoint polls themselves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:44,safe,safepoint,44,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,2,['safe'],['safepoint']
Safety,"// Now that we've visited every function, verify that we never asked to; // recover a frame index that wasn't escaped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:76,recover,recover,76,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['recover'],['recover']
Safety,"// Now try to simplify the ops to avoid placing a phi.; // This may return null if we never created a phi yet, that's okay",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:34,avoid,avoid,34,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['avoid'],['avoid']
Safety,"// Now we are at the point where declarator parsing is finished.; //; // Try to catch keywords in place of the identifier in a declarator, and; // in particular the common case where:; // 1 identifier comes at the end of the declarator; // 2 if the identifier is dropped, the declarator is valid but anonymous; // (no identifier); // 3 declarator parsing succeeds, and then we have a trailing keyword,; // which is never valid in a param list (e.g. missing a ','); // And we can't handle this in ParseDeclarator because in general keywords; // may be allowed to follow the declarator. (And in some cases there'd be; // better recovery like inserting punctuation). ParseDeclarator is just; // treating this as an anonymous parameter, and fortunately at this point; // we've already almost done that.; //; // We care about case 1) where the declarator type should be known, and; // the identifier should be null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:626,recover,recovery,626,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recovery']
Safety,// Now we are safe to optimize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp:14,safe,safe,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeVGPRLiveRange.cpp,2,['safe'],['safe']
Safety,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:219,avoid,avoid,219,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,4,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// Now we know where we will insert load. We must ensure that it is safe; // to speculatively execute the load at that points.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:68,safe,safe,68,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['safe'],['safe']
Safety,"// Now we've checked for aliasing hazards, merge any stores left.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:34,hazard,hazards,34,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,1,['hazard'],['hazards']
Safety,"// Now we've finished modifying that vector, it's safe to make; // a vector of StringRefs pointing into it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:50,safe,safe,50,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,1,['safe'],['safe']
Safety,"// Now were done, clear the list but do not delete the objects as; // they have been moved to the list of closed objects and must be; // deleted from there in order to avoid a double delete from a; // use objects (on the interpreter stack).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:168,avoid,avoid,168,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['avoid'],['avoid']
Safety,"// Now, we do not need to emit the check in *all* of the cases.; // We can avoid emitting it in some obvious cases where it would have been; // dropped by the opt passes (instcombine) always anyways.; // If it's a cast between effectively the same type, no check.; // NOTE: this is *not* equivalent to checking the canonical types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:75,avoid,avoid,75,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['avoid'],['avoid']
Safety,"// Null check the pointer.; //; // We could avoid this null check if we can determine that the object; // destruction is trivial and doesn't require an array cookie; we can; // unconditionally perform the operator delete call in that case. For now, we; // assume that deleted pointers are null rarely enough that it's better to; // keep the branch. This might be worth revisiting for a -O0 code size win.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:44,avoid,avoid,44,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['avoid'],['avoid']
Safety,"// Number of insts issued, including advanced cycles.; // Various things that can cause a structural hazard.; // HasCTRSet - If the CTR register is set in this group, disallow BCTRL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:101,hazard,hazard,101,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,1,['hazard'],['hazard']
Safety,"// Number of possible unclosed <s we've seen so far. These might be templates,; // and might not, but if there were none of them (or we know for sure that; // we're within a template), we can avoid a tentative parse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:192,avoid,avoid,192,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['avoid'],['avoid']
Safety,// Number of stores in this congruence class.; // This is used so we can detect store equivalence changes properly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:73,detect,detect,73,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['detect'],['detect']
Safety,"// Numbered lists may also start with a number followed by '.'; // To avoid issues if a line starts with a number which is actually the end; // of a previous line, we only consider numbers with up to 2 digits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:70,avoid,avoid,70,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['avoid'],['avoid']
Safety,"// NumericLiteralParser wants to overread by one character. Add padding to; // the buffer in case the token is copied to the buffer. If getSpelling(); // returns a StringRef to the memory buffer, it should have a null char at; // the EOF, so it is also safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:253,safe,safe,253,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['safe'],['safe']
Safety,"// OC Redundancy flags",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h:6,Redund,Redundancy,6,tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/libdaos_mock/daos.h,1,['Redund'],['Redundancy']
Safety,"// ODRHash is used to calculate a hash based on AST node contents that; // does not rely on pointer addresses. This allows the hash to not vary; // between runs and is usable to detect ODR problems in modules. To use,; // construct an ODRHash object, then call Add* methods over the nodes that; // need to be hashed. Then call CalculateHash to get the hash value.; // Typically, only one Add* call is needed. clear can be called to reuse the; // object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h:178,detect,detect,178,interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRHash.h,1,['detect'],['detect']
Safety,"// ORI Rd, 0x0 is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp:18,redund,redundant,18,interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRExpandPseudoInsts.cpp,1,['redund'],['redundant']
Safety,// Object is compatible with /safeseh.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:30,safe,safeseh,30,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,1,['safe'],['safeseh']
Safety,// Objective-C++: Detect C++ keywords and try to prevent further errors by; // treating these keyword as valid member names.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:18,Detect,Detect,18,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['Detect'],['Detect']
Safety,// Objective-C++: Recover by treating this keyword as a valid identifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:18,Recover,Recover,18,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Recover'],['Recover']
Safety,"// Objects referenced by writeonly GV initializer should not be; // promoted, because there is no any kind of read access to them; // on behalf of this writeonly GV. To avoid promotion we convert; // GV initializer to 'zeroinitializer'. This effectively drops; // references in IR module (not in combined index), so we can; // ignore them when computing import. We do not export references; // of writeonly object. See computeImportForReferencedGlobals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:169,avoid,avoid,169,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,1,['avoid'],['avoid']
Safety,"// Observe directly the sink's metrics to avoid an additional prefix from the fill context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleWriter.cxx:42,avoid,avoid,42,tree/ntuple/v7/src/RNTupleWriter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RNTupleWriter.cxx,1,['avoid'],['avoid']
Safety,// Offset by precision to avoid denormal range.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp:26,avoid,avoid,26,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp,1,['avoid'],['avoid']
Safety,"// Offsets in vaddr must be positive if range checking is enabled.; //; // The total computation of vaddr + soffset + offset must not overflow. If; // vaddr is negative, even if offset is 0 the sgpr offset add will end up; // overflowing.; //; // Prior to gfx9, MUBUF instructions with the vaddr offset enabled would; // always perform a range check. If a negative vaddr base index was used,; // this would fail the range check. The overall address computation would; // compute a valid address, but this doesn't happen due to the range; // check. For out-of-bounds MUBUF loads, a 0 is returned.; //; // Therefore it should be safe to fold any VGPR offset on gfx9 into the; // MUBUF vaddr, but not on older subtargets which can only do this if the; // sign bit is known 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:627,safe,safe,627,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,"// Ok -- we actually need to partition the symbols. Promote the symbol; // linkages/names, expand the partition to include any required symbols; // (i.e. symbols that can't be separated from our partition), and; // then extract the partition.; //; // FIXME: We apply this promotion once per partitioning. It's safe, but; // overkill.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp:310,safe,safe,310,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/CompileOnDemandLayer.cpp,1,['safe'],['safe']
Safety,"// Ok, handle the in-lane shuffles by detecting if and when they repeat.; // Adjust second vector indices to start at LaneSize instead of Size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:38,detect,detecting,38,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detecting']
Safety,"// Ok, if we are here the guard above guarantee us that; // QueryInst is a non-atomic or unordered load/store.; // SI is atomic with monotonic or release semantic (seq_cst for store; // is actually a release semantic plus total order over other seq_cst; // instructions, as soon as QueryInst is not seq_cst we can consider it; // as simple release semantic).; // Monotonic and Release semantic allows re-ordering before store; // so we are safe to go further and check the aliasing. It will prohibit; // re-ordering in case locations are may or must alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:440,safe,safe,440,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['safe'],['safe']
Safety,"// Ok, the transformation is legal and appears profitable. Go for it.; // Negation will be emitted later to avoid creating dangling nodes if this; // was an unprofitable LEA.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:108,avoid,avoid,108,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// Ok, the transformation is safe and the heuristics suggest it is; // profitable. Update the graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:29,safe,safe,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['safe'],['safe']
Safety,"// Ok, we can reorder to get a smaller immediate.; // But, its possible the original immediate allowed an AND to become MOVZX.; // Doing this late due to avoid the MakedValueIsZero call as late as; // possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:154,avoid,avoid,154,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// Okay, everything is safe, we can transform this!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:23,safe,safe,23,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['safe'],['safe']
Safety,"// Okay, if there weren't any loop invariants to be folded, check to see; // if there are multiple AddRec's with the same loop induction variable; // being multiplied together. If so, we can fold them.; // {A1,+,A2,+,...,+,An}<L> * {B1,+,B2,+,...,+,Bn}<L>; // = {x=1 in [ sum y=x..2x [ sum z=max(y-x, y-n)..min(x,n) [; // choose(x, 2x)*choose(2x-y, x-z)*A_{y-z}*B_z; // ]]],+,...up to x=2n}.; // Note that the arguments to choose() are always integers with values; // known at compile time, never SCEV objects.; //; // The implementation avoids pointless extra computations when the two; // addrec's are of different length (mathematically, it's equivalent to; // an infinite stream of zeros on the right).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:538,avoid,avoids,538,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoids']
Safety,"// Okay, it is safe to hoist the terminator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:15,safe,safe,15,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,"// Okay, it's possible to fold this. Check to see if it is actually; // *profitable* to do so. We use a simple cost model to avoid increasing; // register pressure too much.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:125,avoid,avoid,125,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"// Okay, it's safe to do this! Remember this instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:14,safe,safe,14,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,"// Okay, now we know that the argument is only used by load instructions, and; // it is safe to unconditionally perform all of them. Use alias analysis to; // check to see if the pointer is guaranteed to not be modified from entry of; // the function to each of the load instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:88,safe,safe,88,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['safe'],['safe']
Safety,"// Okay, there was no semicolon and one was expected. If we see a; // declaration specifier, just assume it was missing and continue parsing.; // Otherwise things are very confused and we skip to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:196,recover,recover,196,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Safety,"// Okay, this instruction has a user outside of the current loop; // and varies predictably *inside* the loop. Evaluate the value it; // contains when the loop exits, if possible. We prefer to start with; // expressions which are true for all exits (so as to maximize; // expression reuse by the SCEVExpander), but resort to per-exit; // evaluation if that fails.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:80,predict,predictably,80,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['predict'],['predictably']
Safety,"// Okay, we decided that this is a safe thing to do: go ahead and start; // inserting cast instructions as necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:35,safe,safe,35,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['safe'],['safe']
Safety,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy in the loop preheader now if we want. However, this; // would be unsafe to do if there is anything else in the loop that may read; // or write the memory region we're storing to. This includes the load that; // feeds the stores. Check for an alias by generating the base address and; // checking everything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:159,unsafe,unsafe,159,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['unsafe'],['unsafe']
Safety,"// Okay, we have a strided store ""p[i]"" of a loaded value. We can turn; // this into a memcpy/memmove in the loop preheader now if we want. However,; // this would be unsafe to do if there is anything else in the loop that may; // read or write the memory region we're storing to. For memcpy, this; // includes the load that feeds the stores. Check for an alias by generating; // the base address and checking everything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp:167,unsafe,unsafe,167,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonLoopIdiomRecognition.cpp,1,['unsafe'],['unsafe']
Safety,"// Okay, we have a strided store ""p[i]"" of a splattable value. We can turn; // this into a memset in the loop preheader now if we want. However, this; // would be unsafe to do if there is anything else in the loop that may read; // or write to the aliased location. Check for any overlap by generating the; // base pointer and checking the region.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:163,unsafe,unsafe,163,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['unsafe'],['unsafe']
Safety,"// Okay, we just invalidated anything we knew about loaded values. Try; // to salvage *something* by remembering that the stored value is a live; // version of the pointer. It is safe to forward from volatile stores; // to non-volatile loads, so we don't have to check for volatility of; // the store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:179,safe,safe,179,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['safe'],['safe']
Safety,"// Okay, we know we can transform this function if safe. Scan its body; // looking for calls marked musttail or calls to llvm.vastart.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:51,safe,safe,51,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,1,['safe'],['safe']
Safety,// Omit redundant decls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h:8,redund,redundant,8,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h,1,['redund'],['redundant']
Safety,"// On 64-bit platforms, we can run into an issue where a frame index; // includes a displacement that, when added to the explicit displacement,; // will overflow the displacement field. Assuming that the frame index; // displacement fits into a 31-bit integer (which is only slightly more; // aggressive than the current fundamental assumption that it fits into; // a 32-bit integer), a 31-bit disp should always be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:416,safe,safe,416,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,"// On AIX, except if constinit and also neither of class type or of; // (possibly multi-dimensional) array of class type, thread_local vars; // will have init routines regardless of whether they are; // const-initialized. Since the routine is guaranteed to exist, we can; // unconditionally call it without testing for its existance. This; // avoids potentially unresolved weak symbols which the AIX linker; // isn't happy with.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:343,avoid,avoids,343,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['avoid'],['avoids']
Safety,"// On Darwin external linkage needs to be preserved, otherwise; // dsymutil cannot preserve the debug info for the merged; // variables. If they have external linkage, use the symbol name; // of the first variable merged as the suffix of global symbol; // name. This avoids a link-time naming conflict for the; // _MergedGlobals symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:267,avoid,avoids,267,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,1,['avoid'],['avoids']
Safety,"// On ELF, if -fno-semantic-interposition is specified and the target; // supports local aliases, there will be neither CC1; // -fsemantic-interposition nor -fhalf-no-semantic-interposition. Set; // dso_local on the function if using a local alias is preferable (can avoid; // PLT indirection).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:267,avoid,avoid,267,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['avoid'],['avoid']
Safety,"// On ELFv2, we can avoid allocating the parameter area if all the arguments; // can be passed to the callee in registers.; // For the fast calling convention, there is another check below.; // Note: We should keep consistent with LowerFormalArguments_64SVR4()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:20,avoid,avoid,20,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// On Mingw and Cygwin, an external symbol named '__main' is called from the; // generated 'main' function to allow static initialization. To avoid linking; // problems with remote targets (because lli's remote target support does not; // currently handle external linking) we add a secondary module which defines; // an empty '__main' function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:142,avoid,avoid,142,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,1,['avoid'],['avoid']
Safety,"// On REL ABI's (e.g. O32), these relocations form pairs. The pairing is done; // by the static linker by matching the symbol and offset.; // We only see one relocation at a time but it's still safe to relocate with; // the section so long as both relocations make the same decision.; //; // Some older linkers may require the symbol for particular cases. Such cases; // are not supported yet but can be added as required.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp:194,safe,safe,194,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFObjectWriter.cpp,1,['safe'],['safe']
Safety,"// On Swift, we mostly care about hazards from multiplication instructions; // writing the accumulator and the pipelining of loop iterations by out-of-; // order execution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp:34,hazard,hazards,34,interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MLxExpansionPass.cpp,1,['hazard'],['hazards']
Safety,"// On Windows, if abort() was previously triggered (and caught by a previous; // CrashRecoveryContext) the Windows CRT removes our installed signal handler,; // so we need to install it again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:18,abort,abort,18,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['abort'],['abort']
Safety,"// On Windows, vectors are passed directly if registers are available, or; // indirectly if not. This avoids the need to align argument memory. Pass; // user-defined vector types larger than 512 bits indirectly for simplicity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:102,avoid,avoids,102,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['avoid'],['avoids']
Safety,// On `wasip2` the default linker is `wasm-component-ld` which wraps the; // execution of `wasm-ld`. Find `wasm-ld` and pass it as an argument of where; // to find it to avoid it needing to hunt and rediscover or search `PATH` for; // where it is.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:170,avoid,avoid,170,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,1,['avoid'],['avoid']
Safety,"// On error, recover by dropping the exception specification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:13,recover,recover,13,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['recover'],['recover']
Safety,// On gfx90a+ relevant hazards are checked in checkMAIVALUHazards(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:23,hazard,hazards,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazards']
Safety,"// On mingw, global dtors should not call exit().; // report_fatal_error() invokes exit(). We know report_fatal_error(); // might not write messages to stderr when any errors were detected; // on FD == 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:180,detect,detected,180,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,1,['detect'],['detected']
Safety,"// On some 'newer' platform (Fedora Core 17+, Ubuntu 12), the; // initialization order is (by default?) is 'wrong' and so we can't; // delete the interpreter now .. because any of the static in the; // interpreter's library have already been deleted.; // On the link line, we must list the most dependent .o file; // and end with the least dependent (LLVM libraries), unfortunately,; // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; // in the same order (hence doing libCore's before LLVM's and; // vice et versa for both the destructor. We worked around the; // initialization order by delay the TROOT creation until first use.; // We can not do the same for destruction as we have no way of knowing; // the last access ...; // So for now, let's avoid delete TCling except in the special build; // checking the completeness of the termination deletion.; // TODO: Should we do more cleanup here than just call delete?; // Segfaults rootcling in some cases, debug and uncomment:; //; // delete fInterpreter;; // We cannot delete fCleanups because of the logic in atexit which needs it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:768,avoid,avoid,768,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['avoid'],['avoid']
Safety,"// On some platform and in some case of layout non-basic data types needs; // to be aligned. So let's be on the safe side and align on the size of; // the pointers. (Question: is that the right thing on x32 ABI ?)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:112,safe,safe,112,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['safe'],['safe']
Safety,"// On targets not supporting constant in soffset field, turn zero to; // SGPR_NULL to avoid generating an extra s_mov with zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// On the RHS of [A], if Pos is the result of operation on Pos' that won't; // affect Mask's demanded bits, just replace Pos with Pos'. These operations; // are redundant for the purpose of the equality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:161,redund,redundant,161,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['redund'],['redundant']
Safety,"// On workers we do not send the logs to masters (to avoid duplication of; // text) unless asked explicitly, e.g. after an Exec(...) request.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:53,avoid,avoid,53,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['avoid'],['avoid']
Safety,"// Once all the live-ins don't change on mlocJoin(), we've eliminated all; // redundant PHIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:78,redund,redundant,78,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['redund'],['redundant']
Safety,"// Once the cloning is done, separate the trees,; // to avoid as many side-effects as possible; // The list of clones is guaranteed to exist since we; // just cloned the tree.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:56,avoid,avoid,56,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['avoid'],['avoid']
Safety,"// Once we've found all of the instructions to add to instcombine's worklist,; // add them in reverse order. This way instcombine will visit from the top; // of the function down. This jives well with the way that it adds all uses; // of instructions to the worklist after doing a transformation, thus avoiding; // some N^2 behavior in pathological cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:302,avoid,avoiding,302,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['avoid'],['avoiding']
Safety,"// One corner case deals with the following scenario:; // Trying to add; // a) %r24 = A2_tfrt %p0, %r25; // to this packet:; // {; // b) %r25 = A2_tfrf %p0, %r24; // c) %p0 = C2_cmpeqi %r26, 1; // }; //; // On general check a) and b) are complements, but presence of c) will; // convert a) to .new form, and then it is not a complement.; // We attempt to detect it by analyzing existing dependencies in the packet.; // Analyze relationships between all existing members of the packet.; // Look for Anti dependecy on the same predicate reg as used in the; // candidate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp:355,detect,detect,355,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVLIWPacketizer.cpp,1,['detect'],['detect']
Safety,"// One corner case we have to handle is two IVs ""chasing"" each-other,; // that is %IV2 = phi [...], [ %IV1, %latch ]; // In this case, if IV1 has an external use, we need to avoid adding both; // ""last value of IV1"" and ""penultimate value of IV2"". So, verify that we; // don't already have an incoming value for the middle block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:174,avoid,avoid,174,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avoid'],['avoid']
Safety,"// One of operands might be an Imm operand, and OpNo may refer to it after; // the call of commuteInstruction() below. Such situations are avoided; // here explicitly as OpNo must be a register operand to be a candidate; // for memory folding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:139,avoid,avoided,139,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['avoid'],['avoided']
Safety,"// One of the operands of the writelane is also the output operand.; // This creates the insertion of redundant delays. Hence, we have to; // ignore this operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertDelayAlu.cpp:102,redund,redundant,102,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertDelayAlu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertDelayAlu.cpp,1,['redund'],['redundant']
Safety,// One of the symbol involved is part of a fragment being laid out. Quit now; // to avoid a self loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:84,avoid,avoid,84,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,1,['avoid'],['avoid']
Safety,"// One of types is a pointer and another one is not. We cannot extend; // them properly to a wider type, so let us just reject this case.; // TODO: Usage of getEffectiveSCEVType for DTy, FRHSTy etc should help; // to avoid this check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:217,avoid,avoid,217,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,// One special case for assumptions about memory content. These; // are neither reads nor writes. They are however always modeled; // as read to avoid using them for write removal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:145,avoid,avoid,145,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['avoid'],['avoid']
Safety,"// Only add a thunk if one of the functions has the corresponding feature; // enabled in its subtarget, and doesn't enable external thunks. The target; // can use InsertedThunks to detect whether relevant thunks have already; // been inserted.; // FIXME: Conditionalize on indirect calls so we don't emit a thunk when; // nothing will end up calling it.; // FIXME: It's a little silly to look at every function just to enumerate; // the subtargets, but eventually we'll want to look at them for indirect; // calls, so maybe this is OK.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h:181,detect,detect,181,interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,1,['detect'],['detect']
Safety,"// Only compute the cost for the first 1000 items in the queue, to avoid; // excessive compile-times for very large queues.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:67,avoid,avoid,67,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avoid'],['avoid']
Safety,// Only consider 8-bit values to avoid constant-extenders.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp:33,avoid,avoid,33,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitSimplify.cpp,1,['avoid'],['avoid']
Safety,// Only convert instructions that we've verified are safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp:53,safe,safe,53,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupLEAs.cpp,1,['safe'],['safe']
Safety,"// Only copy sret from the first argument. For C++ instance methods, clang can; // stick an sret marking on a later argument, but it doesn't actually affect; // the ABI, so we can omit it. This avoids triggering a verifier assertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp:194,avoid,avoids,194,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Arm64ECCallLowering.cpp,1,['avoid'],['avoids']
Safety,"// Only do this before legalization to avoid conflicting with target-specific; // transforms in the other direction (create a select from a zext/sext). There; // is also a target-independent combine here in DAGCombiner in the other; // direction for (select Cond, -1, 0) when the condition is not i1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,// Only generate implicit WQM if implicit derivatives are required.; // This avoids inserting unintended WQM if a shader type without; // implicit derivatives uses an image sampling instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:77,avoid,avoids,77,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['avoid'],['avoids']
Safety,"// Only go on to actually process the inner loops when we are done; // removing irreducible control flow and changing the graph. Modifying; // the graph as we go is possible, and that might let us avoid looking at; // the already-fixed loops again if we are careful, but all that is; // complex and bug-prone. Since irreducible loops are rare, just starting; // another iteration is best.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp:197,avoid,avoid,197,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixIrreducibleControlFlow.cpp,1,['avoid'],['avoid']
Safety,// Only hazard if register is defined by a VALU and a DGEMM is found after; // after the def.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:8,hazard,hazard,8,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,// Only issue the fixit if we're prepared to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:45,recover,recover,45,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Safety,"// Only keep an S_WAIT_LOADCNT_DSCNT if both counters actually need; // to be waited for. Otherwise, let the instruction be deleted so; // the appropriate single counter wait instruction can be inserted; // instead, when new S_WAIT_*CNT instructions are inserted by; // createNewWaitcnt(). As a side effect, resetting the wait counts will; // cause any redundant S_WAIT_LOADCNT or S_WAIT_DSCNT to be removed by; // the loop below that deals with single counter instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:353,redund,redundant,353,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['redund'],['redundant']
Safety,"// Only look at the first use, avoid hurting compile time with long uselists",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:31,avoid,avoid,31,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"// Only pass -x if gcc will understand it; otherwise hope gcc; // understands the suffix correctly. The main use case this would go; // wrong in is for linker inputs if they happened to have an odd; // suffix; really the only way to get this to happen is a command; // like '-x foobar a.c' which will treat a.c like a linker input.; //; // FIXME: For the linker case specifically, can we safely convert; // inputs into '-Wl,' options?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:388,safe,safely,388,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,2,['safe'],['safely']
Safety,// Only preexpand the argument if it could possibly need it. This; // avoids some work in common cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:70,avoid,avoids,70,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['avoid'],['avoids']
Safety,// Only promote the compare up to I32 if it is a 16 bit operation; // with an immediate. 16 bit immediates are to be avoided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:117,avoid,avoided,117,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,['avoid'],['avoided']
Safety,"// Only propagate the section size encoding length if it's not the minimal; // size or 5 (the default ""padded"" value). This is to avoid having every; // YAML output polluted with this value when we usually don't care about it; // (and avoid rewriting all the test expectations).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/wasm2yaml.cpp:130,avoid,avoid,130,interpreter/llvm-project/llvm/tools/obj2yaml/wasm2yaml.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/obj2yaml/wasm2yaml.cpp,2,['avoid'],['avoid']
Safety,// Only records can be unsafe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:23,unsafe,unsafe,23,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['unsafe'],['unsafe']
Safety,// Only run if this pass is forced enabled or we detect the relevant function; // attribute requesting SLH.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:49,detect,detect,49,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['detect'],['detect']
Safety,// Only safe to do if this function may be discarded if it is not used; // in the compilation unit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:8,safe,safe,8,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,1,['safe'],['safe']
Safety,// Only safe to perform the optimization if the source is also defined in; // this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:8,safe,safe,8,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['safe'],['safe']
Safety,"// Only solve DestType is vector to avoid inverse transform in visitBitCast.; // bitcast (extractelement <1 x elt>, dest) -> bitcast(<1 x elt>, dest)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['avoid'],['avoid']
Safety,"// Only test the conditional argument of cmpxchg instruction.; // The other argument can potentially be uninitialized, but we can not; // detect this situation reliably without possible false positives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:138,detect,detect,138,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['detect'],['detect']
Safety,"// Only the first lane is executes, so readfirstlane is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:56,safe,safe,56,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,2,['safe'],['safe']
Safety,"// Only the fit with error recovery should have status zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:27,recover,recovery,27,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,2,['recover'],['recovery']
Safety,// Only try to recover from lookup into dependent bases in static methods or; // contexts where 'this' is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:15,recover,recover,15,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Safety,"// Only visit each node once. Metadata can be mutually recursive, so this; // avoids infinite recursion here, as well as being an optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:78,avoid,avoids,78,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,2,['avoid'],['avoids']
Safety,"// Opcodes used for non-expressions. This includes constant aggregates; // (struct, array, vector) that might need expansion, as well as non-leaf; // constants that don't need expansion (no_cfi, dso_local, blockaddress),; // but still go through BitcodeConstant to avoid different uselist orders; // between the two cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:265,avoid,avoid,265,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['avoid'],['avoid']
Safety,"// Open authenticated connection to remote PROOF slave server.; // If a connection was already open (fSocket != 0), re-use it; // to perform authentication (optimization needed to avoid a double; // opening in case this is called by TXSlave).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx:180,avoid,avoid,180,proof/proof/src/TSlave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx,1,['avoid'],['avoid']
Safety,// Open the file first to avoid racing with a cache pruner.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp:26,avoid,avoid,26,interpreter/llvm-project/llvm/lib/Support/Caching.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp,1,['avoid'],['avoid']
Safety,"// OpenACC 3.3, section 2.16:; // the term 'async-argument' means a nonnegative scalar integer expression, or; // one of the special values 'acc_async_noval' or 'acc_async_sync', as defined; // in the C header file and the Fortran opacc module.; //; // We are parsing this simply as list of assignment expressions (to avoid; // comma being troublesome), and will ensure it is an integral type. The; // 'special' types are defined as macros, so we can't really check those; // (other than perhaps as values at one point?), but the standard does say it; // is implementation-defined to use any other negative value.; //; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:318,avoid,avoid,318,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['avoid'],['avoid']
Safety,"// OpenMP 4.5 [2.8.1, simd Construct, Restrictions]; // If both simdlen and safelen clauses are specified, the value of the; // simdlen parameter must be less than or equal to the value of the safelen; // parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:76,safe,safelen,76,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,['safe'],['safelen']
Safety,"// OpenMP [2.5, Restrictions]; // At most one num_threads clause can appear on the directive.; // OpenMP [2.8.1, simd construct, Restrictions]; // Only one safelen clause can appear on a simd directive.; // Only one simdlen clause can appear on a simd directive.; // Only one collapse clause can appear on a simd directive.; // OpenMP [2.11.1, task Construct, Restrictions]; // At most one if clause can appear on the directive.; // At most one final clause can appear on the directive.; // OpenMP [teams Construct, Restrictions]; // At most one num_teams clause can appear on the directive.; // At most one thread_limit clause can appear on the directive.; // OpenMP [2.9.1, task Construct, Restrictions]; // At most one priority clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one grainsize clause can appear on the directive.; // OpenMP [2.9.2, taskloop Construct, Restrictions]; // At most one num_tasks clause can appear on the directive.; // OpenMP [2.11.3, allocate Directive, Restrictions]; // At most one allocator clause can appear on the directive.; // OpenMP 5.0, 2.10.1 task Construct, Restrictions.; // At most one detach clause can appear on the directive.; // OpenMP 5.1, 2.3.6 dispatch Construct, Restrictions.; // At most one novariants clause can appear on a dispatch directive.; // At most one nocontext clause can appear on a dispatch directive.; // OpenMP [5.1, error directive, Restrictions]; // At most one message clause can appear on the directive",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:156,safe,safelen,156,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['safe'],['safelen']
Safety,"// OpenMP [2.8.1, simd construct, Description]; // The parameter of the safelen clause must be a constant; // positive integer expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:72,safe,safelen,72,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['safe'],['safelen']
Safety,"// OpenMP directives parsed in this section are represented as a; // CapturedStatement with an associated statement. If a syntax error; // is detected during the parsing of the associated statement, the; // compiler must abort processing and close the CapturedStatement.; //; // Combined directives such as 'target parallel' have more than one; // nested CapturedStatements. This RAII ensures that we unwind out; // of all the nested CapturedStatements when an error is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:142,detect,detected,142,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,2,"['abort', 'detect']","['abort', 'detected']"
Safety,"// Operands with the same APO can be reordered. We therefore need to count; // how many of them we have for each APO, like this: Cnt[APO] = x.; // Since we only have two APOs, namely true and false, we can avoid using; // a map. Instead we can simply count the number of operands that; // correspond to one of them (in this case the 'true' APO), and calculate; // the other by subtracting it from the total number of operands.; // Operands with the same instruction opcode and parent are more; // profitable since we don't need to move them in many cases, with a high; // probability such lane already can be vectorized effectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:206,avoid,avoid,206,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// OptBBClobberedRegs is used when optimizing away redundant copies/moves.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp:51,redund,redundant,51,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp,1,['redund'],['redundant']
Safety,"// Optimizations is performed based on fpmath, fast math flags as well as; // denormals to optimize fdiv with either rcp or fdiv.fast.; //; // With rcp:; // 1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is; // allowed with unsafe-fp-math or afn.; //; // a/b -> a*rcp(b) when inaccurate rcp is allowed with unsafe-fp-math or afn.; //; // With fdiv.fast:; // a/b -> fdiv.fast(a, b) when !fpmath >= 2.5ulp with denormals flushed.; //; // 1/x -> fdiv.fast(1,x) when !fpmath >= 2.5ulp.; //; // NOTE: rcp is the preference in cases that both are legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:243,unsafe,unsafe-fp-math,243,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,2,['unsafe'],['unsafe-fp-math']
Safety,"// Optimizations may assume builtin semantics for functions defined as; // nobuiltin due to attributes at call-sites. To avoid applying IPO based; // on nobuiltin semantics, treat such function definitions as maybe; // derefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h:121,avoid,avoid,121,interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/GlobalValue.h,1,['avoid'],['avoid']
Safety,"// Optimize (srl (and X, C2), C) ->; // (srli (slli X, (XLen-C3), (XLen-C3) + C); // Where C2 is a mask with C3 trailing ones.; // Taking into account that the C2 may have had lower bits unset by; // SimplifyDemandedBits. This avoids materializing the C2 immediate.; // This pattern occurs when type legalizing right shifts for types with; // less than XLen bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:227,avoid,avoids,227,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['avoid'],['avoids']
Safety,// Optimize away the now-redundant range checks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:25,redund,redundant,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['redund'],['redundant']
Safety,"// Optimize concat_vectors of truncated vectors, where the intermediate; // type is illegal, to avoid said illegality, e.g.,; // (v4i16 (concat_vectors (v2i16 (truncate (v2i64))),; // (v2i16 (truncate (v2i64))))); // ->; // (v4i16 (truncate (vector_shuffle (v4i32 (bitcast (v2i64))),; // (v4i32 (bitcast (v2i64))),; // <0, 2, 4, 6>))); // This isn't really target-specific, but ISD::TRUNCATE legality isn't keyed; // on both input and result type, so we might generate worse code.; // On AArch64 we know it's fine for v2i64->v4i16 and v4i32->v8i8.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:96,avoid,avoid,96,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Optimize fdiv with rcp:; //; // 1/x -> rcp(x) when rcp is sufficiently accurate or inaccurate rcp is; // allowed with unsafe-fp-math or afn.; //; // a/b -> a*rcp(b) when arcp is allowed, and we only need provide ULP 1.0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:121,unsafe,unsafe-fp-math,121,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['unsafe'],['unsafe-fp-math']
Safety,"// Optimize sequence; // %dst = S_OR_SAVEEXEC %src; // ... instructions not modifying exec ...; // %tmp = S_AND $exec, %dst; // $exec = S_XOR_term $exec, %tmp; // =>; // %dst = S_OR_SAVEEXEC %src; // ... instructions not modifying exec ...; // $exec = S_XOR_term $exec, %dst; //; // Clean up potentially unnecessary code added for safety during; // control flow lowering.; //; // Return whether any changes were made to MBB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp:331,safe,safety,331,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp,1,['safe'],['safety']
Safety,"// Optimize sequence; // %sel = V_CNDMASK_B32_e64 0, 1, %cc; // %cmp = V_CMP_NE_U32 1, %sel; // $vcc = S_AND_B64 $exec, %cmp; // S_CBRANCH_VCC[N]Z; // =>; // $vcc = S_ANDN2_B64 $exec, %cc; // S_CBRANCH_VCC[N]Z; //; // It is the negation pattern inserted by DAGCombiner::visitBRCOND() in the; // rebuildSetCC(). We start with S_CBRANCH to avoid exhaustive search, but; // only 3 first instructions are really needed. S_AND_B64 with exec is a; // required part of the pattern since V_CNDMASK_B32 writes zeroes for inactive; // lanes.; //; // Returns true on success.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp:338,avoid,avoid,338,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMaskingPreRA.cpp,1,['avoid'],['avoid']
Safety,"// Optimize the program a bit.; // Add any arguments intended for CC. We locate them here because this is; // most likely -L and -l options that need to come before other libraries but; // after the source. Other options won't be sensitive to placement on the; // command line, so this should be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:296,safe,safe,296,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['safe'],['safe']
Safety,// Optimizing constants makes the use-list order difficult to predict.; // Disable it for now when trying to preserve the order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:62,predict,predict,62,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,1,['predict'],['predict']
Safety,// Optimizing for varargs on Win64 is unlikely to be safe without; // additional testing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:53,safe,safe,53,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['safe'],['safe']
Safety,"// Optionally, we are shuffling the loaded vector element(s) into place.; // For the mask set everything but element 0 to undef to prevent poison from; // propagating from the extra loaded memory. This will also optionally; // shrink/grow the vector from the loaded size to the output size.; // We assume this operation has no cost in codegen if there was no offset.; // Note that we could use freeze to avoid poison problems, but then we might; // still need a shuffle to change the vector size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:404,avoid,avoid,404,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['avoid'],['avoid']
Safety,// Ordered. Assume ordered for undefined.; // Only do this after legalization to avoid interfering with other combines; // which might occur.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:81,avoid,avoid,81,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Other keywords are handled in the switch below, to avoid problems due; // to duplicate case labels when using the #include trick.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:54,avoid,avoid,54,interpreter/llvm-project/clang/lib/Format/FormatToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h,1,['avoid'],['avoid']
Safety,// Other safe-to-copy-by-value common option types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:9,safe,safe-to-copy-by-value,9,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['safe'],['safe-to-copy-by-value']
Safety,// OtherI is pointing to a tainted value. Abort the join if the tainted; // lanes escape the block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:42,Abort,Abort,42,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['Abort'],['Abort']
Safety,"// Otherwise SELECT_CC; // We cannot do this optimization if any pair of {RLD, LLD} is a; // predecessor to {RLD, LLD, CondLHS, CondRHS}. As we've already compared; // the Loads, we only need to check if CondLHS/CondRHS is a successor to; // one of the loads. We can further avoid this if there's no use of their; // chain value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:275,avoid,avoid,275,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,// Otherwise it's a non-recoverable error. Note it and quit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp:24,recover,recoverable,24,interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_ostream.cpp,1,['recover'],['recoverable']
Safety,// Otherwise it's safe to move.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp:18,safe,safe,18,interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCycleAnalysis.cpp,2,['safe'],['safe']
Safety,// Otherwise recover by skipping to next semi or mandatory function body.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:13,recover,recover,13,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['recover'],['recover']
Safety,// Otherwise strip off redundant namespace qualifications from the new name.; // We use the fully qualified name of the namespace and remove that part; // from NewName if it has an identical prefix.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp:23,redund,redundant,23,interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/Lookup.cpp,1,['redund'],['redundant']
Safety,"// Otherwise take the unions of the known bit sets of the operands,; // taking conservative care to avoid excessive recursion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:100,avoid,avoid,100,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,2,['avoid'],['avoid']
Safety,// Otherwise try to use VLREP or VLVGP to start the sequence in order to; // avoid a false dependency on any previous contents of the vector; // register.; // Use a VLREP if at least one element is a load. Make sure to replicate; // the load with the most elements having its value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:77,avoid,avoid,77,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Otherwise use an AVL of 1 to avoid depending on previous vl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['avoid'],['avoid']
Safety,// Otherwise we can defer to the generic legalizer which will widen; // the input as well. This will be further widened during op; // legalization to v8i32<-v8f64.; // For strict nodes we'll need to widen ourselves.; // FIXME: Fix the type legalizer to safely widen strict nodes?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:253,safe,safely,253,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['safe'],['safely']
Safety,// Otherwise we can't safely widen the elements used in this shuffle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:22,safe,safely,22,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['safe'],['safely']
Safety,// Otherwise we have a call. We need to handle transferring the predicate; // state into a call and recovering it after the call returns (unless this; // is a tail call).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:100,recover,recovering,100,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['recover'],['recovering']
Safety,"// Otherwise, align 'ShAmt' to the exponent part and add it into the exponent; // part directly to emulate the multiplication of 2^ShAmt. That 8-bit; // exponent is enough to avoid overflowing into the sign bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:175,avoid,avoid,175,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Otherwise, do some simple heuristics to try to avoid it:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp:50,avoid,avoid,50,interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGAtomic.cpp,1,['avoid'],['avoid']
Safety,"// Otherwise, if all else failed, try to hoist the xor-by-constant:; // (X ^ C) ^ Y --> (X ^ Y) ^ C; // Just like we do in other places, we completely avoid the fold; // for constantexprs, at least to avoid endless combine loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:151,avoid,avoid,151,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,2,['avoid'],['avoid']
Safety,"// Otherwise, if we don't consume this token, we are going to emit an; // error anyway. Try to recover from various common problems. Check; // to see if this was a reference to a tag name without a tag specified.; // This is a common problem in C (saying 'foo' instead of 'struct foo').; //; // C++ doesn't need this, and isTagName doesn't take SS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:95,recover,recover,95,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Safety,"// Otherwise, initialize it with zero buckets to avoid the allocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp:49,avoid,avoid,49,interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringMap.cpp,1,['avoid'],['avoid']
Safety,"// Otherwise, just append the token. Do some gymnastics to get the token; // in place and avoid copies where possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp:90,avoid,avoid,90,interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/MacroArgs.cpp,1,['avoid'],['avoid']
Safety,"// Otherwise, the only unsafe ""definition"" is a live-in, so insert the; // fixup at the start of the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp:23,unsafe,unsafe,23,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,1,['unsafe'],['unsafe']
Safety,"// Otherwise, the transform is safe. Remember the copy instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:31,safe,safe,31,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['safe'],['safe']
Safety,"// Otherwise, this is a hard case. Fall back on getAndAdvanceChar to; // properly decode the character. Read it in raw mode to avoid emitting; // diagnostics about things like trigraphs. If we see an escaped newline,; // we'll handle it below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:127,avoid,avoid,127,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['avoid'],['avoid']
Safety,"// Otherwise, this is a narrow character or string. If the *identifier*; // is a literal 'L', 'u8', 'u' or 'U', avoid pasting L ""foo"" -> L""foo"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:112,avoid,avoid,112,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,1,['avoid'],['avoid']
Safety,"// Otherwise, this is safe to transform!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:22,safe,safe,22,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['safe'],['safe']
Safety,"// Otherwise, this is safe to transform. Insert PHI nodes for each operand; // that is variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:22,safe,safe,22,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['safe'],['safe']
Safety,"// Otherwise, try folds that improve codegen but may interfere with; // early IR canonicalizations.; // The type checking is for run-time efficiency. We can avoid wasting time; // dispatching to folding functions if there's no chance of matching.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:157,avoid,avoid,157,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['avoid'],['avoid']
Safety,"// Otherwise, use the normal scalar-expression emission. The; // exception machinery doesn't do anything special with the; // exception like retaining it, so there's no safety associated with; // only running cleanups after the throw has started, and when it; // matters it tends to be substantially inferior code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:169,safe,safety,169,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['safe'],['safety']
Safety,"// Otherwise, we *can* safely rewrite this load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:23,safe,safely,23,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['safe'],['safely']
Safety,"// Otherwise, we have no instructions to issue and we have instructions; // that will fault if we don't do this right. This is the case for; // processors without pipeline interlocks and other cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:172,interlock,interlocks,172,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['interlock'],['interlocks']
Safety,"// Otherwise, we have something. Add it and let semantic analysis try; // to grok it and add the result to the ParamInfo we are building.; // Last chance to recover from a misplaced ellipsis in an attempted; // parameter pack declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:157,recover,recover,157,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Safety,"// Otherwise, we have to make a memcpy to get a safe alignment. This is bad; // for code quality, but rarely happens and is required for correctness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:48,safe,safe,48,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,1,['safe'],['safe']
Safety,"// Otherwise, we know the RHS is not a NaN. Simplify the node to drop the; // constant if knowing that the operand is non-nan is enough. We prefer to; // have SETO(x,x) instead of SETO(x, 0.0) because this avoids having to; // materialize 0.0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:206,avoid,avoids,206,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoids']
Safety,"// Otherwise, we need to make a new block. If the normal cleanup; // isn't being used at all, we could actually reuse the normal; // entry block, but this is simpler, and it avoids conflicts with; // dead optimistic fixup branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:174,avoid,avoids,174,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,1,['avoid'],['avoids']
Safety,"// Otherwise, we're growing or shrinking the elements. To avoid having to; // handle annoying details of growing/shrinking FP values, we convert them to; // int first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:58,avoid,avoid,58,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// Our error recovery purges the cache of the FileEntry, but keeps; // the FileEntry's pointer so that if it was used by smb (like the; // SourceManager) it wouldn't be dangling. In that case we shouldn't; // print the FileName, because semantically it is not there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClangInternalState.cpp:13,recover,recovery,13,interpreter/cling/lib/Interpreter/ClangInternalState.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ClangInternalState.cpp,1,['recover'],['recovery']
Safety,"// Our tree has just 3 nodes: the root and two operands.; // It is therefore trivial to get the APO. We only need to check the; // opcode of VL[Lane] and whether the operand at OpIdx is the LHS or; // RHS operand. The LHS operand of both add and sub is never attached; // to an inversese operation in the linearized form, therefore its APO; // is false. The RHS is true only if VL[Lane] is an inverse operation.; // Since operand reordering is performed on groups of commutative; // operations or alternating sequences (e.g., +, -), we can safely; // tell the inverse operations by checking commutativity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:540,safe,safely,540,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safely']
Safety,"// Outlined helpers called by the EH runtime need to know the offset of the EH; // registration in order to recover the parent frame pointer. Now that we know; // we've code generated the parent, we can emit the label assignment that; // those helpers use to get the offset of the registration node.; // Compute the parent frame offset. The EHRegNodeFrameIndex will be invalid if; // after optimization all the invokes were eliminated. We still need to emit; // the parent frame offset label, but it should be garbage and should never be; // used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp:108,recover,recover,108,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.cpp,1,['recover'],['recover']
Safety,"// Outlining from functions with redzones is unsafe since the outliner may; // modify the stack. Check if hasRedZone is true or unknown; if yes, don't; // outline from it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:45,unsafe,unsafe,45,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['unsafe'],['unsafe']
Safety,"// Output file may need to be set to 'Binary', to avoid converting Unix style; // line feeds (<LF>) to Microsoft style line feeds (<CR><LF>) on Windows.; //; // Look to see what type of line endings the file uses. If there's a; // CRLF, then we won't open the file up in binary mode. If there is; // just an LF or CR, then we will open the file up in binary mode.; // In this fashion, the output format should match the input format, unless; // the input format has inconsistent line endings.; //; // This should be a relatively fast operation since most files won't have; // all of their source code on a single line. However, that is still a; // concern, so if we scan for too long, we'll just assume the file should; // be opened in binary mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp:50,avoid,avoid,50,interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendActions.cpp,1,['avoid'],['avoid']
Safety,"// Output text position and angle. The text position is computed; // using Double_t to avoid precision problems.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx:87,avoid,avoid,87,graf2d/postscript/src/TPostScript.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/postscript/src/TPostScript.cxx,1,['avoid'],['avoid']
Safety,"// Output to the right file...; // Add any arguments intended for CC. We locate them here because this is; // most likely -L and -l options that need to come before other libraries but; // after the source. Other options won't be sensitive to placement on the; // command line, so this should be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:296,safe,safe,296,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['safe'],['safe']
Safety,"// OutputPossibleOverflows - We've found a possible overflow earlier,; // now check whether Body might contain a comparison which might be; // preventing the overflow.; // This doesn't do flow analysis, range analysis, or points-to analysis; it's; // just a dumb ""is there a comparison"" scan. The aim here is to; // detect the most blatent cases of overflow and educate the; // programmer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp:316,detect,detect,316,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MallocOverflowSecurityChecker.cpp,1,['detect'],['detect']
Safety,"// Outside a constant context, eagerly evaluate to false in the presence; // of side-effects in order to avoid -Wunsequenced false-positives in; // a branch on __builtin_constant_p(expr).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:105,avoid,avoid,105,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['avoid'],['avoid']
Safety,"// Overload resolution failed, try to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:38,recover,recover,38,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recover']
Safety,"// Overload resolution fails, try to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:37,recover,recover,37,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recover']
Safety,"// Overload to avoid confusion between this signature and the template instance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:15,avoid,avoid,15,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,3,['avoid'],['avoid']
Safety,"// Override endianness detection in RColumnElement.hxx; assume big-endian machine; // These tests are simulating a big endian machine; we will turn them off on an actual big endian node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_endian.cxx:23,detect,detection,23,tree/ntuple/v7/test/ntuple_endian.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_endian.cxx,1,['detect'],['detection']
Safety,"// Override for ADDI and ADDI8 to set the correct register class; // on RHS operand 0. The automatic infrastructure naively assumes; // GPRC for i32 and G8RC for i64; the concept of ""no R0"" is lost; // for these cases. At the moment, none of the other automatically; // generated RI instructions require special treatment. However, once; // SelectSelect is implemented, ""isel"" requires similar handling.; //; // Also be conservative about the output register class. Avoid; // assigning R0 or X0 to the output register for GPRC and G8RC; // register classes, as any such result could be used in ADDI, etc.,; // where those regs have another meaning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:466,Avoid,Avoid,466,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['Avoid'],['Avoid']
Safety,// Override for instructions with one register operand to avoid use of; // R0/X0. The automatic infrastructure isn't aware of the context so; // we must be conservative.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:58,avoid,avoid,58,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['avoid'],['avoid']
Safety,// Override for instructions with two register operands to avoid use; // of R0/X0. The automatic infrastructure isn't aware of the context; // so we must be conservative.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp:59,avoid,avoid,59,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFastISel.cpp,1,['avoid'],['avoid']
Safety,// Override only those variables that can be captured to avoid re-emission; // of the variables declared within the loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:57,avoid,avoid,57,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['avoid'],['avoid']
Safety,// Override this function to avoid calling hasFP before CSI is set; // (the default implementation calls hasFP).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h:29,avoid,avoid,29,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.h,1,['avoid'],['avoid']
Safety,"// OverrideSearch will return as ""overridden"" the same method in the; // interface. For hasOverriddenMethodsInBaseOrProtocol, we need to; // check whether a category of a base class introduced a method with the; // same selector, after the interface method declaration.; // To avoid unnecessary lookups in the majority of cases, we use the; // extra info bits in GlobalMethodPool to check whether there were any; // category methods with this selector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:277,avoid,avoid,277,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['avoid'],['avoid']
Safety,// Overriding these functions allows us to avoid recording of these labels; // in EmitLabel and later marking them as microMIPS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFStreamer.h:43,avoid,avoid,43,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsELFStreamer.h,1,['avoid'],['avoid']
Safety,// Overwrite our input TemplateArgumentLoc so that we can recover; // properly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:58,recover,recover,58,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Safety,"// PCH files don't have a signature field in the control block,; // but LLVM detects DWO CUs by looking for a non-zero DWO id.; // We use the lower 64 bits for debug info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp:77,detect,detects,77,interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ObjectFilePCHContainerOperations.cpp,1,['detect'],['detects']
Safety,"// PCH files don't have a signature field in the control block,; // but LLVM detects skeleton CUs by looking for a non-zero DWO id.; // We use the lower 64 bits for debug info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:77,detect,detects,77,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['detect'],['detects']
Safety,"// PHIs are often mutually cyclic, so we keep track of a whole set of PHI; // nodes which are extracted from. PHIsToSlice is a set we use to avoid; // revisiting PHIs, PHIsInspected is a ordered list of PHIs that we need to; // check the uses of (to ensure they are all extracts).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:141,avoid,avoid,141,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['avoid'],['avoid']
Safety,"// PLT; // lea %dst, func@plt_lo(-24); // and %dst, %dst, (32)0; // sic %plt ; FIXME: is it safe to use %plt here?; // lea.sl %dst, func@plt_hi(%plt, %dst)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp:92,safe,safe,92,interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEAsmPrinter.cpp,1,['safe'],['safe']
Safety,"// PPCEarlyReturn pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp:125,avoid,avoid,125,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCEarlyReturn.cpp,1,['avoid'],['avoid']
Safety,"// PPCTOCRegDeps pass - For simple functions without epilogue code, move; // returns up, and create conditional returns, to avoid unnecessary; // branch-to-blr sequences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp:124,avoid,avoid,124,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTOCRegDeps.cpp,1,['avoid'],['avoid']
Safety,"// PR27903: slots with multiple start or end lifetime ops are not; // safe to enable for ""lifetime-start-on-first-use"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:70,safe,safe,70,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['safe'],['safe']
Safety,"// PR35338; // TODO: assert(From != To && ""Redundant dbg value transfer"");; // TODO: assert(FromNode != ToNode && ""Intranode dbg value transfer"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:43,Redund,Redundant,43,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['Redund'],['Redundant']
Safety,// PR37130: transformations prior to stack coloring can; // sometimes leave behind statically unreachable blocks; these; // can be safely skipped here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:131,safe,safely,131,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['safe'],['safely']
Safety,"// PR9614. Avoid cases where the source code is lying to us. An available; // externally function should have an equivalent function somewhere else,; // but a function that calls itself through asm label/`__builtin_` trickery is; // clearly not equivalent to the real implementation.; // This happens in glibc's btowc and in some configure checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:11,Avoid,Avoid,11,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['Avoid'],['Avoid']
Safety,// PXOR is safe to use because it doesn't affect flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:11,safe,safe,11,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safe']
Safety,// Parameters are guaranteed to be safe for the duration of the call; // by another checker.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp:35,safe,safe,35,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp,1,['safe'],['safe']
Safety,// Parse -fsanitize-recover= arguments.; // FIXME: Report unrecoverable sanitizers incorrectly specified here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:20,recover,recover,20,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['recover'],['recover']
Safety,// Parse a braced-init-list here for error recovery purposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:43,recover,recovery,43,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['recover'],['recovery']
Safety,"// Parse decltype-specifier; // tok == kw_decltype is just error recovery, it can only happen when SS; // isn't empty",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:65,recover,recovery,65,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recovery']
Safety,// Parse the attributes even if they are rejected to ensure that error; // recovery is graceful.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,recover,recovery,75,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recovery']
Safety,// Parse the contents of the namespace. This includes parsing recovery on; // any improperly nested namespaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:62,recover,recovery,62,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recovery']
Safety,// Parse the static_assert declaration to improve error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:56,recover,recovery,56,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['recover'],['recovery']
Safety,// ParseObjcopyOptions returns the config and sets the input arguments. If a; // help flag is set then ParseObjcopyOptions will print the help messege and; // exit. ErrorCallback is used to handle recoverable errors. An Error returned; // by the callback aborts the parsing and is then returned by this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h:197,recover,recoverable,197,interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h,2,"['abort', 'recover']","['aborts', 'recoverable']"
Safety,// ParseStripOptions returns the config and sets the input arguments. If a; // help flag is set then ParseStripOptions will print the help messege and; // exit. ErrorCallback is used to handle recoverable errors. An Error returned; // by the callback aborts the parsing and is then returned by this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h:193,recover,recoverable,193,interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.h,2,"['abort', 'recover']","['aborts', 'recoverable']"
Safety,"// ParseTemplateArgValueList - Parse a template argument list with the syntax; // shown, filling in the Result vector. The open angle has been consumed.; // An empty argument list is allowed. Return false if okay, true if an; // error was detected.; //; // ArgValueList ::= '<' PostionalArgValueList [','] NamedArgValueList '>'; // PostionalArgValueList ::= [Value {',' Value}*]; // NamedArgValueList ::= [NameValue '=' Value {',' NameValue '=' Value}*]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp:239,detect,detected,239,interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGParser.cpp,1,['detect'],['detected']
Safety,"// ParseUnqualifiedId might have parsed a scope specifier during error; // recovery. If it did so, enter that scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,recover,recovery,75,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recovery']
Safety,"// Pass 'this' value directly from the argument to return value, to avoid; // reg unit interference",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:68,avoid,avoid,68,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// Pass option to Snapshot to avoid the type conversion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx:30,avoid,avoid,30,tree/dataframe/test/dataframe_snapshot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_snapshot.cxx,1,['avoid'],['avoid']
Safety,// Pass the computed GEP to the runtime to avoid emitting poisoned arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:43,avoid,avoid,43,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['avoid'],['avoid']
Safety,"// Passing pointer through launder.invariant.group to avoid propagation of; // vptrs information which may be included in previous type.; // To not break LTO with different optimizations levels, we do it regardless; // of optimization level.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp:54,avoid,avoid,54,interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprCXX.cpp,1,['avoid'],['avoid']
Safety,// Paths via a default initializer can only occur during error recovery; // (there's no other way that a default initializer can refer to a; // local). Don't produce a bogus warning on those cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:63,recover,recovery,63,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['recover'],['recovery']
Safety,"// Pattern depends on endian because we expect lower index is inserted first.; // Big endian:; // inselt (inselt BaseVec, (trunc (lshr X, BW/2), Index0), (trunc X), Index1; // Little endian:; // inselt (inselt BaseVec, (trunc X), Index0), (trunc (lshr X, BW/2)), Index1; // Note: It is not safe to do this transform with an arbitrary base vector; // because the bitcast of that vector to fewer/larger elements could; // allow poison to spill into an element that was not poison before.; // TODO: Detect smaller fractions of the scalar.; // TODO: One-use checks are conservative.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:290,safe,safe,290,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,"['Detect', 'safe']","['Detect', 'safe']"
Safety,// Peel the loop after determining that fusion is legal. The Loops; // will still be safe to fuse after the peeling is performed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:85,safe,safe,85,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['safe'],['safe']
Safety,"// Perform all scalar logic operations as 16-byte vectors because there are no; // scalar FP logic instructions in SSE.; // TODO: This isn't necessary. If we used scalar types, we might avoid some; // unnecessary splats, but we might miss load folding opportunities. Should; // this decision be based on OptimizeForSize?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:186,avoid,avoid,186,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Perform builtin lookup to avoid redeclaring it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:29,avoid,avoid,29,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['avoid'],['avoid']
Safety,// Perform integer type conversion; // Note: Safe to skip updating bitwidth because this must terminate,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h:45,Safe,Safe,45,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,1,['Safe'],['Safe']
Safety,// Perform partial redundancy elimination of vsetvli transitions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:19,redund,redundancy,19,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['redund'],['redundancy']
Safety,"// Perform the full multiplication and downscale to get the same scale.; //; // Note that the right shifts here perform an implicit downwards rounding.; // This rounding could discard bits that would technically place the result; // outside the representable range. We interpret the spec as allowing us to; // perform the rounding step first, avoiding the overflow case that would; // arise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp:343,avoid,avoiding,343,interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,1,['avoid'],['avoiding']
Safety,// Perform the safety regclass copy mentioned above.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp:15,safe,safety,15,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEISelLowering.cpp,1,['safe'],['safety']
Safety,"// Perform the store, so that the uninitialized value detection happens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:54,detect,detection,54,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,1,['detect'],['detection']
Safety,// Perform unsafe buffer usage analysis:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:11,unsafe,unsafe,11,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['unsafe'],['unsafe']
Safety,"// Performance optimization: avoid compressing tiny source buffers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/RZip.cxx:29,avoid,avoid,29,core/zip/src/RZip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/zip/src/RZip.cxx,1,['avoid'],['avoid']
Safety,// Performs the following for a >> b:; // unsigned r_high = a_high >> b;; // r_high = (32 - b <= 0) ? 0 : r_high;; //; // unsigned r_low = a_low >> b;; // r_low = (32 - b <= 0) ? r_high : r_low;; // r_low = (b == 0) ? r_low : r_low | (a_high << (32 - b));; // return (unsigned long long)r_high << 32 | r_low;; // Note: This takes advantage of Lanai's shift behavior to avoid needing to; // mask the shift amount.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:369,avoid,avoid,369,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Permuting loads are marked as both load and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:65,safe,safe,65,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['safe'],['safe']
Safety,"// Permuting stores are marked as both store and swap, and are; // safe for optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:67,safe,safe,67,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['safe'],['safe']
Safety,// Persistent buffer to avoid allocs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp:24,avoid,avoid,24,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Clustering.cpp,1,['avoid'],['avoid']
Safety,// Phase 3 - add any vsetvli instructions needed in the block. Use the; // Phase 2 information to avoid adding vsetvlis before the first vector; // instruction in the block if the VL/VTYPE is satisfied by its; // predecessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:98,avoid,avoid,98,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['avoid'],['avoid']
Safety,"// Phi nodes may contain the same predecessor multiple times, in which; // case the incoming value must be identical. Directly reuse the already; // seen value here, to avoid expanding a constant expression multiple; // times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:169,avoid,avoid,169,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['avoid'],['avoid']
Safety,// Place PHIs into a set to avoid invalidating the iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:28,avoid,avoid,28,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,1,['avoid'],['avoid']
Safety,// Place Unknown to map to avoid infinite recursion. Such; // cycles can never stop on an invariant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,1,['avoid'],['avoid']
Safety,"// Place the locations not optimised out in the list first, avoiding; // inserts later. The map is used to update the DIExpression's; // DW_OP_LLVM_arg arguments as the expression is updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:60,avoid,avoiding,60,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['avoid'],['avoiding']
Safety,"// Placing the latch block before the header may introduce an extra branch; // that skips this block the first time the loop is executed, which we want; // to avoid when optimising for size.; // FIXME: in theory there is a case that does not introduce a new branch,; // i.e. when the layout predecessor does not fallthrough to the loop header.; // In practice this never happens though: there always seems to be a preheader; // that can fallthrough and that is also placed before the header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:159,avoid,avoid,159,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['avoid'],['avoid']
Safety,"// Plot ""physics"" slice of simultaneous pdf.; // NBL You _must_ project the sample index category with data using ProjWData; // as a RooSimultaneous makes no prediction on the shape in the index category; // and can thus not be integrated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h:158,predict,prediction,158,roofit/roofitcore/test/stressRooFit_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/stressRooFit_tests.h,1,['predict'],['prediction']
Safety,"// Plotting engine for asymmetries. Implements the functionality if plotOn(frame,Asymmetry(...))); //; // Plot asymmetry of ourselves, defined as; //; // asym = f(asymCat=-1) - f(asymCat=+1) / ( f(asymCat=-1) + f(asymCat=+1) ); //; // on frame. If frame contains a histogram, all dimensions of the plotted; // asymmetry function that occur in the previously plotted dataset are projected via partial integration.; // Otherwise no projections are performed,; //; // The asymmetry function can be multiplied with an optional scale factor. The default projection; // behaviour can be overridden by supplying an optional set of dependents to project.; // Sanity checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:651,Sanity check,Sanity checks,651,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['Sanity check'],['Sanity checks']
Safety,// Pointer information was discarded. We'll need to coerce some register types; // to avoid violating type constraints.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,1,['avoid'],['avoid']
Safety,"// Poison-safe 'or' takes the form: select X, true, Y; // To make that work with the normal operand processing, we skip the; // true value operand.; // TODO: Change the code and data structures to handle this without a hack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:10,safe,safe,10,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safe']
Safety,// Poisoned defs are skipped since they are always safe by itself by; // definition (for details see comment to this class).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:51,safe,safe,51,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['safe'],['safe']
Safety,// Pop the guard-abort cleanup if we pushed one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:17,abort,abort,17,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['abort'],['abort']
Safety,"// Populate the VRX map (VR to extension-type).; // Go over all the formal parameters of the function. If a given parameter; // P is sign- or zero-extended, locate the virtual register holding that; // parameter and create an entry in the VRX map indicating the type of ex-; // tension (and the source type).; // This is a bit complicated to do accurately, since the memory layout in-; // formation is necessary to precisely determine whether an aggregate para-; // meter will be passed in a register or in memory. What is given in MRI; // is the association between the physical register that is live-in (i.e.; // holds an argument), and the virtual register that this value will be; // copied into. This, by itself, is not sufficient to map back the virtual; // register to a formal parameter from Function (since consecutive live-ins; // from MRI may not correspond to consecutive formal parameters from Func-; // tion). To avoid the complications with in-memory arguments, only consi-; // der the initial sequence of formal parameters that are known to be; // passed via registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp:927,avoid,avoid,927,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBitTracker.cpp,1,['avoid'],['avoid']
Safety,// Positive and negative strides have different safety conditions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:48,safe,safety,48,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['safe'],['safety']
Safety,"// Positive distance bigger than max vectorization factor.; // FIXME: Should use max factor instead of max distance in bytes, which could; // not handle different types.; // E.g. Assume one char is 1 byte in memory and one int is 4 bytes.; // void foo (int *A, char *B) {; // for (unsigned i = 0; i < 1024; i++) {; // A[i+2] = A[i] + 1;; // B[i+2] = B[i] + 1;; // }; // }; //; // This case is currently unsafe according to the max safe distance. If we; // analyze the two accesses on array B, the max safe dependence distance; // is 2. Then we analyze the accesses on array A, the minimum distance needed; // is 8, which is less than 2 and forbidden vectorization, But actually; // both A and B could be vectorized by 2 iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:403,unsafe,unsafe,403,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,3,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"// Post-processing: Convert lea(,%reg,2) to lea(%reg,%reg), which has; // a smaller encoding and avoids a scaled-index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:97,avoid,avoids,97,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['avoid'],['avoids']
Safety,// Postpone emission of PHIs operands to avoid cyclic dependencies issues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:41,avoid,avoid,41,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// Postpone until legalization completed to avoid interference with bswap; // folding,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:44,avoid,avoid,44,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['avoid'],['avoid']
Safety,"// Potential missed optimization opportunity: we saw a different virtual; // register get a copy of the non-allocatable physical register, and we only; // track one such copy. Avoid getting confused by this new non-allocatable; // physical register definition, and remove it from the tracked copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:176,Avoid,Avoid,176,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['Avoid'],['Avoid']
Safety,// PowerPC64 prefers TOC indirection to avoid copy relocations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:40,avoid,avoid,40,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['avoid'],['avoid']
Safety,"// Pre-promote (i1 (truncate (srl X, Y))) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,safe,safe,97,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,"['recover', 'safe']","['recover', 'safe']"
Safety,"// Pre-promote (i32 (and (srl X, Y), 1)) on RV64 with Zbs without zero; // extending X. This is safe since we only need the LSB after the shift and; // shift amounts larger than 31 would produce poison. If we wait until; // type legalization, we'll create RISCVISD::SRLW and we can't recover it; // to use a BEXT instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:96,safe,safe,96,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,"['recover', 'safe']","['recover', 'safe']"
Safety,"// Pre-promote (i32 (xor (shl -1, X), ~0)) on RV64 with Zbs so we can use; // (ADDI (BSET X0, X), -1). If we wait until/ type legalization, we'll create; // RISCVISD:::SLLW and we can't recover it to use a BSET instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:186,recover,recover,186,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['recover'],['recover']
Safety,// Pre-promote these to vXi16 to avoid op legalization thinking all 16; // elements are needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:33,avoid,avoid,33,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Pre-regalloc, only forward if all subregisters agree (or there are no; // subregs at all). More analysis might recover some forwardable copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:114,recover,recover,114,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['recover'],['recover']
Safety,// PredValues - This is a temporary used when rewriting PHI nodes. It is; // hoisted out here to avoid construction/destruction thrashing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:97,avoid,avoid,97,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['avoid'],['avoid']
Safety,"// Predicated store requires some form of masking:; // 1) masked store HW instruction,; // 2) emulation via load-blend-store (only if safe and legal to do so,; // be aware on the race conditions), or; // 3) element-by-element predicate check and scalar store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:134,safe,safe,134,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['safe'],['safe']
Safety,// Predict register usage after this instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:3,Predict,Predict,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['Predict'],['Predict']
Safety,// Predict use-list order for this one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp:3,Predict,Predict,3,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.cpp,3,['Predict'],['Predict']
Safety,// Prediction Restriction aliases,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp:3,Predict,Prediction,3,interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/MCTargetDesc/AArch64InstPrinter.cpp,1,['Predict'],['Prediction']
Safety,"// Prefer i8 for non-zero memset as it allows us to avoid materializing; // a large scalar constant and instead use vmv.v.x/i to do the; // broadcast. For everything else, prefer ELenVT to minimize VL and thus; // maximize the chance we can encode the size in the vsetvli.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:52,avoid,avoid,52,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Prefer likely predicted branches to selects on out-of-order cores.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:17,predict,predicted,17,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['predict'],['predicted']
Safety,"// Prefer simplifying to the splat-shuffle, if possible. This is legal if; // every undef mask element in the splat-shuffle has a corresponding undef; // element in the user-shuffle's mask or if the composition of mask elements; // would result in undef.; // Examples for (shuffle (shuffle v, undef, SplatMask), undef, UserMask):; // * UserMask=[0,2,u,u], SplatMask=[2,u,2,u] -> [2,2,u,u]; // In this case it is not legal to simplify to the splat-shuffle because we; // may be exposing the users of the shuffle an undef element at index 1; // which was not there before the combine.; // * UserMask=[0,u,2,u], SplatMask=[2,u,2,u] -> [2,u,2,u]; // In this case the composition of masks yields SplatMask, so it's ok to; // simplify to the splat-shuffle.; // * UserMask=[3,u,2,u], SplatMask=[2,u,2,u] -> [u,u,2,u]; // In this case the composed mask includes all undef elements of SplatMask; // and in addition sets element zero to undef. It is safe to simplify to; // the splat-shuffle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:940,safe,safe,940,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,"// Prefer to promote the comparison operand with zero extension.; // If the width of OpL/OpR excluding the duplicated sign bits is no greater; // than the width of LHS/RHS, we can avoid/ inserting a zext_inreg operation; // that we might not be able to remove.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:180,avoid,avoid,180,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['avoid'],['avoid']
Safety,// Prefer to promote to s32 before lowering if we don't have 16-bit; // shifts. This avoid a lot of intermediate truncate and extend operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:85,avoid,avoid,85,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['avoid'],['avoid']
Safety,"// Preincrement iterator to avoid invalidation issues.; // This is for CET enhancement.; //; // ENDBR32 and ENDBR64 have specific opcodes:; // ENDBR32: F3 0F 1E FB; // ENDBR64: F3 0F 1E FA; // And we want that attackers won’t find unintended ENDBR32/64; // opcode matches in the binary; // Here’s an example:; // If the compiler had to generate asm for the following code:; // a = 0xF30F1EFA; // it could, for example, generate:; // mov 0xF30F1EFA, dword ptr[a]; // In such a case, the binary would include a gadget that starts; // with a fake ENDBR64 opcode. Therefore, we split such generation; // into multiple operations, let it not shows in the binary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:28,avoid,avoid,28,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// Prepare a list of all forward declarations for cling; // For some experiments it is easily as big as 500k characters. To be on the; // safe side, we go for 1M.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:138,safe,safe,138,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['safe'],['safe']
Safety,// Prepare to special-case multidimensional array initialization: we avoid; // emitting multiple destructor loops in that case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:69,avoid,avoid,69,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['avoid'],['avoid']
Safety,"// Prevent redundant declarations for control statements (e.g., for, if, while); // that have already been annotated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:11,redund,redundant,11,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['redund'],['redundant']
Safety,"// Prevent redundant register copies due to reads and writes of physical; // registers. The original motivation for this was the code generated; // between two calls, which are caused both the return value and the; // argument for the next call being in %r0.; // Example:; // 1: <call1>; // 2: %vreg = COPY %r0; // 3: <use of %vreg>; // 4: %r0 = ...; // 5: <call2>; // The scheduler would often swap 3 and 4, so an additional register is; // needed. This code inserts a Barrier dependence between 3 & 4 to prevent; // this.; // The code below checks for all the physical registers, not just R0/D0/V0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['redund'],['redundant']
Safety,"// Prevent the ROOT-PCMs hitting this during auto-load during; // JITting - which will cause recursive compilation.; // Avoid to call the plugin manager at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:120,Avoid,Avoid,120,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['Avoid'],['Avoid']
Safety,"// Prevent us turning:; // declare void @takes_i32_inalloca(i32* inalloca); // call void bitcast (void (i32*)* @takes_i32_inalloca to void (i32)*)(i32 0); //; // into:; // call void @takes_i32_inalloca(i32* null); //; // Similarly, avoid folding away bitcasts of byval calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:232,avoid,avoid,232,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['avoid'],['avoid']
Safety,"// Previously clang did not attach the necessary type metadata to; // available_externally vtables, in which case there would not; // be any vtable functions listed in the summary and we need; // to treat this case conservatively (in case the bitcode is old).; // However, we will also not have any vtable functions in the; // case of a pure virtual base class. In that case we do want; // to set VS to avoid treating it conservatively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:403,avoid,avoid,403,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['avoid'],['avoid']
Safety,// Print a message here so that we know addModule() did not abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp:60,abort,abort,60,interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-lto/llvm-lto.cpp,1,['abort'],['abort']
Safety,// Print in a deterministic order by sorting CallGraphNodes by name. We do; // this here to avoid slowing down the non-printing fast path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp:92,avoid,avoid,92,interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraph.cpp,1,['avoid'],['avoid']
Safety,"// Print out the stack in reverse order. To avoid recursion (which is likely; // to fail if we crashed due to stack overflow), we do an up-front pass to; // reverse the stack, then print it, then reverse it again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/PrettyStackTrace.cpp:44,avoid,avoid,44,interpreter/llvm-project/llvm/lib/Support/PrettyStackTrace.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/PrettyStackTrace.cpp,1,['avoid'],['avoid']
Safety,// Print the information about how we detected the GCC installation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:38,detect,detected,38,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['detect'],['detected']
Safety,// Print the offending instruction unconditionally as we are about to; // abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:74,abort,abort,74,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,1,['abort'],['abort']
Safety,// Print the safe SEH table if present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/COFFDumper.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/tools/llvm-readobj/COFFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/COFFDumper.cpp,1,['safe'],['safe']
Safety,"// Pro-actively check that argument types are safe to do arithmetic upon.; // We do not want to crash if someone accidentally passes a structure; // into, say, a C++ overload of any of these functions. We could not check; // that for std::copy because they may have arguments of other types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp:46,safe,safe,46,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CStringChecker.cpp,1,['safe'],['safe']
Safety,"// Process abort statements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooArgSet.cxx:11,abort,abort,11,roofit/roofitcore/src/RooArgSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooArgSet.cxx,1,['abort'],['abort']
Safety,"// Process the near-misses in reverse order, so that we see more general ones; // first, and so can avoid emitting more specific ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:100,avoid,avoid,100,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['avoid'],['avoid']
Safety,"// Processing steps done per block. E.g. emitting jump tables, stack; // protectors etc. Returns true if no errors, false if there was a problem; // that caused an abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h:164,abort,abort,164,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/IRTranslator.h,1,['abort'],['abort']
Safety,"// Produce a CompileCommand for \p filename, based on this one.; // (This consumes the TransferableCommand just to avoid copying Cmd).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp:115,avoid,avoid,115,interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/InterpolatingCompilationDatabase.cpp,1,['avoid'],['avoid']
Safety,"// Produce files forward compatible with (unpatched) version older than; // v6.30 by recording the internal bits kIsOnHeap and kNotDeleted; Older; // releases were not explicitly setting those bits to the correct value; // but instead used verbatim the value stored in the file.; // Note that to avoid a circular dependency, this value is used; // hard coded in TObject.cxx.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:296,avoid,avoid,296,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,1,['avoid'],['avoid']
Safety,// Profitability check - avoid increasing instruction count.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:25,avoid,avoid,25,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['avoid'],['avoid']
Safety,"// Program to check a TGeo geometry; // The first time you run this program, the geometry files will be taken; // from http://root.cern/files; //; // How the program works; // If the file <geom_name>_ref.root does not exist, it is generated. The file; // contains a TTree with Npoints (default=100000) obtained with the following; // algorithm:; // -a point is generated with a uniform distribution x,y,z in the master volume; // -a direction theta, phi is generated uniformly in -2pi<phi<2pi and 0<theta<pi; // -gGeoManager finds the geometry path for the point; // -the number of boundaries (nbound), total length (length), safety distance; // from the starting point (safe) and number of radiation lengths (rad) from x,y,z; // is calculated to the exit of the detector. The total number of crossings, detector; // weight and total number of radiation lengths for all tracks are stored as user info in the tree.; //; // Using the file <geom_name>_ref.root (generated typically with a previous version; // of the TGeo classes), the Npoints in the Tree are used to perform the; // same operation with the new version.; // In case of a disagreement, an error message is reported.; //; // The ReadRef case is also used as a benchmark; // The ROOTMARKS reported are relative to a Linux/P IV 2.8 GHz gcc3.2.3 machine; // normalized at 800 ROOTMARKS when running with CINT.; //; // To run this script, do; // stressGeometry; // or stressGeometry *; // or stressGeometry alice; // or from the ROOT command line; // root > .L stressGeometry.cxx or .L stressGeometry.cxx+; // root > stressGeometry(exp_name); // where exp_name is the geometry file name without .root; // OR simply: stressGeometry(); to run tests for a set of geometries; //; // Authors: Rene Brun, Andrei Gheata, 22 march 2005",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressGeometry.cxx:626,safe,safety,626,test/stressGeometry.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressGeometry.cxx,4,"['detect', 'safe']","['detector', 'safe', 'safety']"
Safety,// Prohibit function address recording if the function is both internal and; // COMDAT. This avoids the profile data variable referencing internal symbols; // in COMDAT.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:93,avoid,avoids,93,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['avoid'],['avoids']
Safety,// Promotion aliases are used only in inline assembly. It's safe to; // simply skip unusual names. Subset of MCAsmInfo::isAcceptableChar(); // and MCAsmInfoXCOFF::isAcceptableChar().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp:60,safe,safe,60,interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ThinLTOBitcodeWriter.cpp,1,['safe'],['safe']
Safety,// Propagate MinVisitNum to parent so we can detect the SCC starting node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h:45,detect,detect,45,interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,1,['detect'],['detect']
Safety,"// Propagate both errors and recovered types, which return ExprEmpty.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:29,recover,recovered,29,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['recover'],['recovered']
Safety,"// Propagate to the classes map only if this is not a template.; // The header is then used as autoload key and we want to avoid duplicates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:123,avoid,avoid,123,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['avoid'],['avoid']
Safety,"// Propagate values to eliminate redundant PHIs. At the same time, this; // produces the table of Block x Location => Value for the entry to each; // block.; // The kind of PHIs we can eliminate are, for example, where one path in a; // conditional spills and restores a register, and the register still has; // the same value once control flow joins, unbeknowns to the PHI placement; // code. Propagating values allows us to identify such un-necessary PHIs and; // remove them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:33,redund,redundant,33,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['redund'],['redundant']
Safety,// Propagating undef is unsafe. Clamp undef elements to -1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:24,unsafe,unsafe,24,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['unsafe'],['unsafe']
Safety,"// Provide DenseMapInfo for all pointers. Come up with sentinel pointer values; // that are aligned to alignof(T) bytes, but try to avoid requiring T to be; // complete. This allows clients to instantiate DenseMap<T*, ...> with forward; // declared key types. Assume that no pointer key type requires more than 4096; // bytes of alignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h:132,avoid,avoid,132,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMapInfo.h,1,['avoid'],['avoid']
Safety,// Provide a fallback path when we do not want to abort on; // not-yet-supported input.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:50,abort,abort,50,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['abort'],['abort']
Safety,// Provide a global flag for disabling the PreRA hazard recognizer that targets; // may choose to honor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp:49,hazard,hazard,49,interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetInstrInfo.cpp,1,['hazard'],['hazard']
Safety,"// Prune list computed above to only include values defined in the exporting; // module. We do this after the above insertion since we may hit the same; // ref/call target multiple times in above loop, and it is more efficient to; // avoid a set lookup each time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:234,avoid,avoid,234,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,1,['avoid'],['avoid']
Safety,"// Prune the solution space aggressively by checking that both IV operands; // are expressions that operate on the same unscaled SCEVUnknown. This; // ""base"" will be canceled by the subsequent getMinusSCEV call. Checking; // first avoids creating extra SCEV expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:231,avoid,avoids,231,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['avoid'],['avoids']
Safety,"// Pull forward slightly (0.85) to avoid to sharp a cutoff",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLightSet.cxx:35,avoid,avoid,35,graf3d/gl/src/TGLLightSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLightSet.cxx,1,['avoid'],['avoid']
Safety,"// Purposely ignore all unsupported bits; TIOFeatures implementation already warned the user about the; // error of their ways; this is just a safety check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:143,safe,safety,143,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['safe'],['safety']
Safety,// Push '};' onto the token stream to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:38,recover,recover,38,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recover']
Safety,// Push an empty operand info so that we can detect 0 as not finding one,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:45,detect,detect,45,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,1,['detect'],['detect']
Safety,"// Push casts through vector builds. This helps avoid emitting a large; // number of copies when materializing floating point vector constants.; //; // vNt1 bitcast (vNt0 (build_vector t0:x, t0:y)) =>; // vnt1 = build_vector (t1 (bitcast t0:x)), (t1 (bitcast t0:y))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:48,avoid,avoid,48,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Push event of WatcherGotInvalidated kind to the Queue to stop the loop.; // Both InitialScan and EventReceivingLoop use Receiver which isn't; // necessarily thread-safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp:167,safe,safe,167,interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,1,['safe'],['safe']
Safety,"// Push lpt to avoid a bad boundary condition",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBoolNode.cxx:15,avoid,avoid,15,geom/geom/src/TGeoBoolNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBoolNode.cxx,1,['avoid'],['avoid']
Safety,"// Push rpt to avoid a bad boundary condition",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBoolNode.cxx:15,avoid,avoid,15,geom/geom/src/TGeoBoolNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBoolNode.cxx,1,['avoid'],['avoid']
Safety,"// Push the MachineInstr to OpsToUpdate.; // If it is safe to remove CmpInstr, the condition code of these; // instructions will be modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:54,safe,safe,54,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safe']
Safety,// Push this token back into the preprocessor and change our current token; // to ';' so that the rest of the code recovers as though there were an; // ';' after the definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:115,recover,recovers,115,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['recover'],['recovers']
Safety,"// Push-Pop Acceleration (PPX) hint is used to indicate that the POP reads the; // value written by the PUSH from the stack. The processor tracks these marked; // instructions internally and fast-forwards register data between matching PUSH; // and POP instructions, without going through memory or through the training; // loop of the Fast Store Forwarding Predictor (FSFP). Instead, a more efficient; // memory-renaming optimization can be used.; //; // The PPX hint is purely a performance hint. Instructions with this hint have; // the same functional semantics as those without. PPX hints set by the; // compiler that violate the balancing rule may turn off the PPX optimization,; // but they will not affect program semantics.; //; // Hence, PPX is used for balanced spill/reloads (Exceptions and setjmp/longjmp; // are not considered).; //; // PUSH2 and POP2 are instructions for (respectively) pushing/popping 2; // GPRs at a time to/from the stack.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:358,Predict,Predictor,358,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['Predict'],['Predictor']
Safety,"// Put all exports together in a block.; // The block will naturally end up being scheduled last,; // thus putting exports at the end of the schedule, which; // is better for performance.; // However we must ensure, for safety, the exports can be put; // together in the same block without any other instruction.; // This could happen, for example, when scheduling after regalloc; // if reloading a spilled register from memory using the same; // register than used in a previous export.; // If that happens, do not regroup the exports.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp:220,safe,safety,220,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp,1,['safe'],['safety']
Safety,// Put all functions into anonymous namespace so they have internal linkage.; // The device-only function here must be internal in order to avoid ODR; // violations in case they are used from the files compiled with; // -fgpu-rdc. E.g. a library and an app using it may be built with a different; // version of this header file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h:140,avoid,avoid,140,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_texture_intrinsics.h,1,['avoid'],['avoid']
Safety,"// Put dummy return here to avoid compiler warnings",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNovosibirsk.cxx:28,avoid,avoid,28,roofit/roofit/src/RooNovosibirsk.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNovosibirsk.cxx,1,['avoid'],['avoid']
Safety,"// Put target and mode arguments at the start of argument list so that; // arguments specified in command line could override them. Avoid putting; // them at index 0, as an option like '-cc1' must remain the first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp:132,Avoid,Avoid,132,interpreter/llvm-project/clang/tools/driver/driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/driver.cpp,1,['Avoid'],['Avoid']
Safety,"// Put the loads/stores without dependency into the same group with some; // heuristic if the DAG is too complex to avoid compiling time blow up.; // Notice that, some fusion pair could be lost with this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:116,avoid,avoid,116,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['avoid'],['avoid']
Safety,"// QueryAnalysis allowed to transform the IR source, one such example is; // Simplify CFG helps the static branch prediction heuristics!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp:114,predict,prediction,114,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/Speculation.cpp,1,['predict'],['prediction']
Safety,"// R may be undef at run-time, but (shl R, 1) must be an even number (LSB; // must be 0). (add undef, undef) however can be any value. To make this; // safe, we must freeze R to ensure that register allocation uses the same; // register for an undefined value. This ensures that the result will; // still be even and preserves the original semantics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:152,safe,safe,152,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['safe'],['safe']
Safety,// RET is generated as part of epilogue generation and hence we know; // what the two instructions preceding it are and that it is safe to; // insert RET above them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp:131,safe,safe,131,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiDelaySlotFiller.cpp,1,['safe'],['safe']
Safety,"// ROOT-7647: res is allocated with `safemalloc` by colormap_asimage",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx:37,safe,safemalloc,37,graf2d/asimage/src/TASImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx,1,['safe'],['safemalloc']
Safety,"// RVec does not guarantee exception safety, but we still want to test; // that we don't segfault or otherwise crash if element construction or move throws.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/test/vecops_rvec.cxx:37,safe,safety,37,math/vecops/test/vecops_rvec.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/test/vecops_rvec.cxx,1,['safe'],['safety']
Safety,// Raycaster temp variables to avoid one per frame allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:31,avoid,avoid,31,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// Re-consider control flow based optimizations after redundancy elimination,; // redo DCE, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:54,redund,redundancy,54,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['redund'],['redundancy']
Safety,"// Re-evaluate this RooAbsReal with the central parameters just to be; // extra-safe that a call to `getPropagatedError()` doesn't change any state.; // It should not be necessary because thanks to the dirty flag propagation; // the RooAbsReal is re-evaluated anyway the next time getVal() is called.; // Still there are imaginable corner cases where it would not be triggered,; // for example if the user changes the RooFit operation more after the error; // propagation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:80,safe,safe,80,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,2,['safe'],['safe']
Safety,"// Re-running hazard recognizer on the modified instruction is not necessary,; // inserted V_SWAP_B32 has already both read and write new registers so; // hazards related to these register has already been handled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:14,hazard,hazard,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,2,['hazard'],"['hazard', 'hazards']"
Safety,"// Reacquire lock to avoid race conditions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TWin32Condition.cxx:21,avoid,avoid,21,core/thread/src/TWin32Condition.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TWin32Condition.cxx,2,['avoid'],['avoid']
Safety,"// Read arguments as unexpanded tokens. This avoids issues, e.g., where; // an argument value in a macro could expand to ',' or '(' or ')'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:45,avoid,avoids,45,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,2,['avoid'],['avoids']
Safety,// Read control register 0 (XCR0). Used to detect features such as AVX.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:43,detect,detect,43,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,1,['detect'],['detect']
Safety,"// Read in a TNamed object part.; // Since the TNamed streamer is solely delegating back to the StreamerInfo we; // can skip the streamer.; // Idea: We could extract the code from ReadClassBuffer and avoid one function; // code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:200,avoid,avoid,200,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['avoid'],['avoid']
Safety,"// Read in a TObject object part.; // Idea: We could separate the TObject Streamer in its two parts and; // avoid the if (buf.IsReading()).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:108,avoid,avoid,108,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['avoid'],['avoid']
Safety,"// Read in a TString object.; // Idea: We could separate the TString Streamer in its two parts and; // avoid the if (buf.IsReading()) and try having it inlined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:103,avoid,avoid,103,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['avoid'],['avoid']
Safety,// Read in the code in case the filename alone isn't enough to detect the; // language.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:63,detect,detect,63,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,1,['detect'],['detect']
Safety,"// Read specified byte range asynchronously. Actually we tell the kernel; // which blocks we are going to read so it can start loading these blocks; // in the buffer cache.; // Shortcut to avoid having to implement dummy ReadBufferAsync() in all; // I/O plugins. Override ReadBufferAsync() in plugins if async is supported.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:189,avoid,avoid,189,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['avoid'],['avoid']
Safety,"// Read the next token to poison. While doing this, pretend that we are; // skipping while reading the identifier to poison.; // This avoids errors on code like:; // #pragma GCC poison X; // #pragma GCC poison X",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:134,avoid,avoids,134,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['avoid'],['avoids']
Safety,// Read the signature eagerly now so that we can check it. Avoid calling; // ReadSignature unless there's something to check though.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:59,Avoid,Avoid,59,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,1,['Avoid'],['Avoid']
Safety,"// Reading a validation counter will only return a single value, so it is; // safe to only append the first value here. Also assert that this is true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp:78,safe,safe,78,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/PerfHelper.cpp,1,['safe'],['safe']
Safety,"// Readjusts the bins' minimum edge by shifting it slightly lower; // to avoid overlapping with the data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTreeBinning.cxx:73,avoid,avoid,73,math/mathcore/src/TKDTreeBinning.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TKDTreeBinning.cxx,1,['avoid'],['avoid']
Safety,// Really a scalar input. Just select from the low half of the register to; // avoid packing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:79,avoid,avoid,79,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,// Rebuild the argv without the arguments llvm-mc-fuzzer consumed so that; // the driver can parse its arguments.; //; // FuzzerArgs cannot provide the non-const pointer that OriginalArgv needs.; // Re-use the strings from OriginalArgv instead of copying FuzzerArg to a; // non-const buffer to avoid the need to clean up when the fuzzer terminates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp:294,avoid,avoid,294,interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp,2,['avoid'],['avoid']
Safety,// Rebuild the template name.; // TODO: avoid TemplateName abstraction,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:40,avoid,avoid,40,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['avoid'],['avoid']
Safety,"// Receive result of checking offset; // But only for recent servers; // NB: not backward compatible with dev version 4.00.02: switch; // off 'reuse' for such servers to avoid hanging at this point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:170,avoid,avoid,170,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['avoid'],['avoid']
Safety,// Record all debug intrinsics preceding LoopEntryBranch to avoid; // duplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:60,avoid,avoid,60,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['avoid'],['avoid']
Safety,"// Record if the value is defined in the same basic block.; //; // This information is crucial to know whether or not folding an; // operand is valid.; // Indeed, FastISel generates or reuses a virtual register for all; // operands of all instructions it selects. Obviously, the definition and; // its uses must use the same virtual register otherwise the produced; // code is incorrect.; // Before instruction selection, FunctionLoweringInfo::set sets the virtual; // registers for values that are alive across basic blocks. This ensures; // that the values are consistently set between across basic block, even; // if different instruction selection mechanisms are used (e.g., a mix of; // SDISel and FastISel).; // For values local to a basic block, the instruction selection process; // generates these virtual registers with whatever method is appropriate; // for its needs. In particular, FastISel and SDISel do not share the way; // local virtual registers are set.; // Therefore, this is impossible (or at least unsafe) to share values; // between basic blocks unless they use the same instruction selection; // method, which is not guarantee for X86.; // Moreover, things like hasOneUse could not be used accurately, if we; // allow to reference values across basic blocks whereas they are not; // alive across basic blocks initially.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp:1020,unsafe,unsafe,1020,interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FastISel.cpp,1,['unsafe'],['unsafe']
Safety,// Record that the file was not found to avoid future reverse lookup for; // the same file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp:41,avoid,avoid,41,interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/ExtractAPIConsumer.cpp,1,['avoid'],['avoid']
Safety,// Record that this unwrap is *not* provably safe.; // FIXME: include either the name of the optional (if applicable) or a source; // range of the access for easier interpretation of the result.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp:45,safe,safe,45,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.cpp,1,['safe'],['safe']
Safety,// Record the fact we need a parsable state at the runtime call contained in; // the poll function. This is required so that the runtime knows how to; // parse the last frame when we actually take the safepoint (i.e. execute; // the slow path),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:201,safe,safepoint,201,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,"// Record the missed hint, we may be able to recover; // at the end if the surrounding allocation changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:45,recover,recover,45,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['recover'],['recover']
Safety,"// Record the variable for any DBG_VALUE, to avoid re-ordering any of them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['avoid'],['avoid']
Safety,// Record which swap instructions can be safely removed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:41,safe,safely,41,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['safe'],['safely']
Safety,// Recover,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['Recover'],['Recover']
Safety,"// Recover CFG block via reverse lookup.; // TODO: If we were to keep CFG element information as part of the CallEvent; // instead of doing this reverse lookup, we would be able to build the stack; // frame for non-expression-based calls, and also we wouldn't need the reverse; // lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CallEvent.cpp,1,['Recover'],['Recover']
Safety,// Recover as if it were an explicit specialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['Recover'],['Recover']
Safety,// Recover as if the tilde had been written before the identifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['Recover'],['Recover']
Safety,// Recover as if the user wrote '::'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['Recover'],['Recover']
Safety,// Recover by adding 'static'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Safety,// Recover by adding misplaced attributes to the attribute list; // of the class so they can be applied on the class later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['Recover'],['Recover']
Safety,// Recover by assuming we had the right type all along.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,['Recover'],['Recover']
Safety,"// Recover by creating a K&R-style function type, if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['Recover'],['Recover']
Safety,"// Recover by creating a compound statement with what we parsed so far,; // instead of dropping everything and returning StmtError().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['Recover'],['Recover']
Safety,// Recover by discarding the default argument.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Recover'],['Recover']
Safety,// Recover by dropping this type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['Recover'],['Recover']
Safety,// Recover by entering the module (Sema will diagnose).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Recover'],['Recover']
Safety,// Recover by faking up an empty template argument list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Safety,// Recover by falling back to int.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Safety,"// Recover by ignoring the 'typedef'. This was probably supposed to be; // the 'typename' keyword, which we should have already suggested adding; // if it's appropriate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['Recover'],['Recover']
Safety,// Recover by ignoring the old declaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['Recover'],['Recover']
Safety,// Recover by ignoring the partition name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Recover'],['Recover']
Safety,"// Recover by incorporating the other type chunks into the result type.; // Note, this does *not* change the name of the function. This is compatible; // with the GCC extension:; // struct S { &operator int(); } s;; // int &r = s.operator int(); // ok in GCC; // S::operator int&() {} // error in GCC, function name is 'operator int'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['Recover'],['Recover']
Safety,// Recover by leaving immediately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPLexerChange.cpp,2,['Recover'],['Recover']
Safety,// Recover by leaving partition empty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Recover'],['Recover']
Safety,// Recover by making this an anonymous redefinition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Safety,"// Recover by making this an anonymous redefinition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:3,Recover,Recover,3,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['Recover'],['Recover']
Safety,"// Recover by marking the field invalid, unless we're in a SFINAE context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Recover'],['Recover']
Safety,// Recover by pretending this was an elaborated type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Recover'],['Recover']
Safety,// Recover by removing the name,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Safety,// Recover by removing the storage specifier.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Safety,// Recover by setting the destructed type to the object type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,2,['Recover'],['Recover']
Safety,// Recover by setting the object type to the destructed type and the; // operator to '->'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['Recover'],['Recover']
Safety,// Recover by synthesizing a type using the location information that we; // already have.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Recover'],['Recover']
Safety,// Recover by taking the template that we found in the object; // expression's type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Recover'],['Recover']
Safety,// Recover by treating the 'typedef' as spurious.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,2,['Recover'],['Recover']
Safety,"// Recover from arrow accesses to records, e.g.:; // struct MyRecord foo;; // foo->bar; // This is actually well-formed in C++ if MyRecord has an; // overloaded operator->, but that should have been dealt with; // by now--or a diagnostic message already issued if a problem; // was encountered while looking for the overloaded operator->.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['Recover'],['Recover']
Safety,"// Recover from dot accesses to pointers, e.g.:; // type *foo;; // foo.bar; // This is actually well-formed in two cases:; // - 'type' is an Objective C type; // - 'bar' is a pseudo-destructor name which happens to refer to; // the appropriate pointer type",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprMember.cpp,1,['Recover'],['Recover']
Safety,// Recover from error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['Recover'],['Recover']
Safety,// Recover from errors reading the symbol table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/COFFObjectFile.cpp,1,['Recover'],['Recover']
Safety,// Recover from misplaced ellipsis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,3,['Recover'],['Recover']
Safety,// Recover from not-fully-formed macro invocation during code-completion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['Recover'],['Recover']
Safety,// Recover from the common mistake of using 'set' instead of 'put'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['Recover'],['Recover']
Safety,"// Recover from type-hiding ambiguities by hiding the type. We'll; // do the lookup again when looking for an object, and we can; // diagnose the error then. If we don't do this, then the error; // about hiding the type will be immediately followed by an error; // that only makes sense if the identifier was treated like a type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Safety,// Recover gracefully from an invalid redeclaration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,['Recover'],['Recover']
Safety,// Recover location if it was changed in the above loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['Recover'],['Recover']
Safety,// Recover location info for the operand if we know which was the problem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['Recover'],['Recover']
Safety,"// Recover old genreflex behaviour, i.e. do not print warnings due to glitches; // in the headers at runtime. This is not synonym of ignoring warnings as they; // will be printed at dictionary generation time.; // In order to do this we leverage the diagnostic pragmas and, since there is no; // way to express as a pragma the option ""-Wno-deprecated"" the; // _BACKWARD_BACKWARD_WARNING_H macro, used to avoid to go through; // backward/backward_warning.h.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/TModuleGenerator.cxx:3,Recover,Recover,3,core/dictgen/src/TModuleGenerator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/TModuleGenerator.cxx,2,"['Recover', 'avoid']","['Recover', 'avoid']"
Safety,// Recover parsing as a case statement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['Recover'],['Recover']
Safety,// Recover resources if we crash before exiting this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,5,['Recover'],['Recover']
Safety,// Recover resources if we crash before exiting this method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,19,['Recover'],['Recover']
Safety,"// Recover resources if we crash before exiting this method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp:3,Recover,Recover,3,interpreter/cling/lib/Interpreter/IncrementalParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/IncrementalParser.cpp,2,['Recover'],['Recover']
Safety,// Recover some path-sensitivity if a scalar value evaluated to; // UnknownVal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineC.cpp,1,['Recover'],['Recover']
Safety,// Recover the QualType of an APSInt.; // TODO: Refactor to put elsewhere,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h:3,Recover,Recover,3,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h,1,['Recover'],['Recover']
Safety,// Recover the call stack,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['Recover'],['Recover']
Safety,// Recover the default target destination for each Switch statement; // reserved.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['Recover'],['Recover']
Safety,// Recover the old value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,1,['Recover'],['Recover']
Safety,// Recover triple.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp:3,Recover,Recover,3,interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/DirectX/DXILWriter/DXILWriterPass.cpp,1,['Recover'],['Recover']
Safety,// Recover with 'int',MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Safety,// Recover with an 'int' type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:3,Recover,Recover,3,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['Recover'],['Recover']
Safety,"// Recovering from a bad clause is really difficult, so we just give up on; // error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:3,Recover,Recovering,3,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['Recover'],['Recovering']
Safety,"// Recovery from invalid cases (e.g. D is an invalid Decl).; // We use the dependent type for the RecoveryExpr to prevent bogus follow-up; // diagnostics, as invalid decls use int as a fallback type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:3,Recover,Recovery,3,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['Recover'],"['Recovery', 'RecoveryExpr']"
Safety,"// RecoveryExpr is; // - always value-dependent, and therefore instantiation dependent; // - contains errors (ExprDependence::Error), by definition; // - type-dependent if we don't know the type (fallback to an opaque; // dependent type), or the type is known and dependent, or it has; // type-dependent subexpressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp:3,Recover,RecoveryExpr,3,interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ComputeDependence.cpp,1,['Recover'],['RecoveryExpr']
Safety,"// Recurse, but cap the recursion to two levels, because we don't want; // to waste time spinning around in loops. We need at least depth 2 to; // detect known sign bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:147,detect,detect,147,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['detect'],['detect']
Safety,"// Recursively emit the RHS.; // For __block safety, do this before emitting the LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:45,safe,safety,45,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['safe'],['safety']
Safety,// Reduce the list of Named Metadata nodes. We keep this as a list of; // names to avoid having to convert back and forth every time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:83,avoid,avoid,83,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['avoid'],['avoid']
Safety,"// Reduce the risk of the files or sockets being closed after the; // end of 'main' (or more exactly before the library start being; // unloaded).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:14,risk,risk,14,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['risk'],['risk']
Safety,// Reducing lgkmcnt count to 0 always mitigates the hazard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:52,hazard,hazard,52,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// Redundant def found: throw it away. Since the wedge of defs is being; // rebuilt, doing nothing is the same as deleting an entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:3,Redund,Redundant,3,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['Redund'],['Redundant']
Safety,// Redundant switch so I don't have to repeat the code above; // for each case. There are more clever ways to avoid this; // extra switch and anyone can feel free to implement one of them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp:3,Redund,Redundant,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCA/AMDGPUCustomBehaviour.cpp,2,"['Redund', 'avoid']","['Redundant', 'avoid']"
Safety,"// Reference fit results. We are building them manually in this code in; // order to avoid binary reference files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooMinimizer.cxx:85,avoid,avoid,85,roofit/roofitcore/test/testRooMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooMinimizer.cxx,1,['avoid'],['avoid']
Safety,"// Register (L, R) as diffing pair. Note that we could directly emit a; // block diff here, but this way we ensure all diffs are emitted in one; // consistent order, independent of whether the diffs were detected; // immediately or via invalid assumptions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp:204,detect,detected,204,interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-diff/lib/DifferenceEngine.cpp,1,['detect'],['detected']
Safety,// Registers a target. Not thread safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h:34,safe,safe,34,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/Target.h,1,['safe'],['safe']
Safety,// Regular instruction.; // Abort early if we will have to insert non-free instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:28,Abort,Abort,28,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['Abort'],['Abort']
Safety,"// Reinit selector (with multi-sessioning we must do this until; // TSelector::GetSelector() is optimized to i) avoid reloading of an; // unchanged selector and ii) invalidate existing instances of; // reloaded selector)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:112,avoid,avoid,112,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,2,['avoid'],['avoid']
Safety,// Reject constants that would be truncated if they were converted to; // the floating point type. Test by simple to/from conversion.; // FIXME: Ideally the conversion to an APFloat and from an APFloat; // could be avoided if there was a convertFromAPInt method; // which could signal back if implicit truncation occurred.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:215,avoid,avoided,215,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoided']
Safety,// Relax the strict type matching for property type in continuation class.; // Allow property object type of continuation class to be different as long; // as it narrows the object type in its primary class property. Note that; // this conversion is safe only because the wider type is for a 'readonly'; // property in primary class and 'narrowed' type for a 'readwrite' property; // in continuation class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp:250,safe,safe,250,interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaObjCProperty.cpp,1,['safe'],['safe']
Safety,"// Release the uncompressed page. This works because the ""page allocator must be thread-safe.""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:88,safe,safe,88,tree/ntuple/v7/src/RPageSinkBuf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx,1,['safe'],['safe']
Safety,// Releases a slot from every buffered resource in mask `ConsumedBuffers`.; // ConsumedBuffers is a bitmask of previously acquired buffers (using method; // `reserveBuffers`). Units that are dispatch hazards (i.e. BufferSize=0) are; // not automatically unreserved by this method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:200,hazard,hazards,200,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['hazard'],['hazards']
Safety,// Remember if the buffer is nul terminated or not so we can avoid a copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp:61,avoid,avoid,61,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinterInlineAsm.cpp,1,['avoid'],['avoid']
Safety,// Remember if this is a noop hazard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:30,hazard,hazard,30,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['hazard'],['hazard']
Safety,// Remember that this was shadowed so we can avoid the warning if; // the shadowed decl isn't captured and the warning settings allow; // it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:45,avoid,avoid,45,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,// Remember the greatest possible stall as an upper bound on the number of; // times we should retry the pending queue because of a hazard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:132,hazard,hazard,132,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['hazard'],['hazard']
Safety,"// Remember the local noalias scope declarations in the header. After the; // rotation, they must be duplicated and the scope must be cloned. This; // avoids unwanted interaction across iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:151,avoid,avoids,151,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['avoid'],['avoids']
Safety,// Remember to try and delete this function afterward. This both avoids; // re-walking the rest of the module and avoids dealing with any; // iterator invalidation issues while deleting functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp:65,avoid,avoids,65,interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,2,['avoid'],['avoids']
Safety,// Remember visited blocks to avoid infinite loop,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:30,avoid,avoid,30,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['avoid'],['avoid']
Safety,"// Remove PHI nodes that did not have any uses rewritten or add them to; // PHIsToRemove, so the caller can remove them after some additional cleanup.; // We need to redo the use_empty() check here, because even if the PHI node; // wasn't used when added to LocalPHIsToRemove, later added PHI nodes can be; // using it. This cleanup is not guaranteed to handle trees/cycles of PHI; // nodes that only are used by each other. Such situations has only been; // noticed when the input IR contains unreachable code, and leaving some extra; // redundant PHI nodes in such situations is considered a minor problem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:539,redund,redundant,539,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,1,['redund'],['redundant']
Safety,// Remove SU from Available set and update HazardRec.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:43,Hazard,HazardRec,43,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,1,['Hazard'],['HazardRec']
Safety,"// Remove a `FixableGadget` if the associated variable is not in the graph; // computed above. We do not want to generate fix-its for such variables,; // since they are neither warned nor reachable from a warned one.; //; // Note a variable is not warned if it is not directly used in any unsafe; // operation. A variable `v` is NOT reachable from an unsafe variable, if it; // does not exist another variable `u` such that `u` is warned and fixing `u`; // (transitively) implicates fixing `v`.; //; // For example,; // ```; // void f(int * p) {; // int * a = p; *p = 0;; // }; // ```; // `*p = 0` is a fixable gadget associated with a variable `p` that is neither; // warned nor reachable from a warned one. If we add `a[5] = 0` to the end of; // the function above, `p` becomes reachable from a warned variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:289,unsafe,unsafe,289,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,2,['unsafe'],['unsafe']
Safety,"// Remove aborted queries from the list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:10,abort,aborted,10,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,2,['abort'],['aborted']
Safety,"// Remove all but one edge to the retained block and all unswitched; // blocks. This is to avoid having duplicate entries in the cloned Phis,; // when we know we only keep a single edge for each case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:91,avoid,avoid,91,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['avoid'],['avoid']
Safety,"// Remove an assume if it is followed by an identical assume.; // TODO: Do we need this? Unless there are conflicting assumptions, the; // computeKnownBits(IIOperand) below here eliminates redundant assumes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:189,redund,redundant,189,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['redund'],['redundant']
Safety,"// Remove and delete the events lists object to avoid spoiling iteration; // during next steps",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:48,avoid,avoid,48,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['avoid'],['avoid']
Safety,// Remove any and instructions that are now redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:44,redund,redundant,44,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['redund'],['redundant']
Safety,"// Remove any user specified output. Claim any unclaimed arguments, so as; // to avoid emitting warnings about unused args.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp:81,avoid,avoid,81,interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Compilation.cpp,1,['avoid'],['avoid']
Safety,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,redund,redundant,60,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,3,['redund'],['redundant']
Safety,"// Remove debug intrinsics which describe the value contained within the; // alloca. In addition to removing dbg.{declare,addr} which simply point to; // the alloca, remove dbg.value(<alloca>, ..., DW_OP_deref)'s as well, e.g.:; //; // ```; // define void @foo(i32 %0) {; // %a = alloca i32 ; Deleted.; // store i32 %0, i32* %a; // dbg.value(i32 %0, ""arg0"") ; Not deleted.; // dbg.value(i32* %a, ""arg0"", DW_OP_deref) ; Deleted.; // call void @trivially_inlinable_no_op(i32* %a); // ret void; // }; // ```; //; // This may not be required if we stop describing the contents of allocas; // using dbg.value(<alloca>, ..., DW_OP_deref), but we currently do this in; // the LowerDbgDeclare utility.; //; // If there is a dead store to `%a` in @trivially_inlinable_no_op, the; // ""arg0"" dbg.value may be stale after the call. However, failing to remove; // the DW_OP_deref dbg.value causes large gaps in location coverage.; //; // FIXME: the Assignment Tracking project has now likely made this; // redundant (and it's sometimes harmful).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:993,redund,redundant,993,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['redund'],['redundant']
Safety,"// Remove input and signal handlers to avoid spurious ""signals""; // for closing activities executed upon exit()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx:39,avoid,avoid,39,proof/proof/src/TProofServLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServLite.cxx,1,['avoid'],['avoid']
Safety,"// Remove input handler to avoid spurious signals in socket; // selection for closing activities executed upon exit()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:27,avoid,avoid,27,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,2,['avoid'],['avoid']
Safety,"// Remove it from the pending list: we need to do it at this level to avoid; // recursive calls in the standard TFile::Open",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:70,avoid,avoid,70,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['avoid'],['avoid']
Safety,// Remove redundant Copy instructions unless TargetReg is modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRedundantCopyElimination.cpp,1,['redund'],['redundant']
Safety,// Remove redundant DBG_VALUEs first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['redund'],['redundant']
Safety,// Remove redundant LEA instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['redund'],['redundant']
Safety,// Remove redundant SI_END_CF instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerControlFlow.cpp,1,['redund'],['redundant']
Safety,// Remove redundant address calculations. Do it only for -Os/-Oz since only; // a code size gain is expected from this part of the pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['redund'],['redundant']
Safety,// Remove redundant back-copies that are now known to be dominated by another; // def with the same value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['redund'],['redundant']
Safety,// Remove redundant call to the outlined function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,2,['redund'],['redundant']
Safety,// Remove redundant case,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['redund'],['redundant']
Safety,// Remove redundant copy instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,1,['redund'],['redundant']
Safety,// Remove redundant copy/move instructions unless KnownReg is modified.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64RedundantCopyElimination.cpp,1,['redund'],['redundant']
Safety,"// Remove redundant entries. As well as reducing memory consumption and; // avoiding waiting cycles later by burning some now, this has another; // important job. That is to work around some SelectionDAG quirks. See; // removeRedundantDbgLocsUsingForwardScan comments for more info on that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,2,"['avoid', 'redund']","['avoiding', 'redundant']"
Safety,// Remove redundant induction instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['redund'],['redundant']
Safety,// Remove redundant insertions:; // (insert_vector_elt x (extract_vector_elt x idx) idx) -> x,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['redund'],['redundant']
Safety,"// Remove redundant leading ""./"" pieces and consecutive separators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileCollector.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/Support/FileCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/FileCollector.cpp,1,['redund'],['redundant']
Safety,// Remove redundant physreg dead defs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,2,['redund'],['redundant']
Safety,// Remove redundant spills or change them to dead instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:10,redund,redundant,10,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['redund'],['redundant']
Safety,// Remove the 'volatile' from the type to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:42,recover,recover,42,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recover']
Safety,// Remove the Safe functions from the Test module,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:14,Safe,Safe,14,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,1,['Safe'],['Safe']
Safety,"// Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; // this RecursiveRemove while we delete our content.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:73,avoid,avoid,73,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['avoid'],['avoid']
Safety,// Remove the Test functions from the Safe module,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp:38,Safe,Safe,38,interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExtractFunction.cpp,1,['Safe'],['Safe']
Safety,// Remove the new created node to avoid the side effect to the DAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:34,avoid,avoid,34,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['avoid'],['avoid']
Safety,// Remove the original instruction to avoid potentially confusing the; // waterfall loop logic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:38,avoid,avoid,38,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,2,['avoid'],['avoid']
Safety,// Remove the ref qualifier to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:31,recover,recover,31,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recover']
Safety,"// Remove to avoid deprecation warnings during root build; //ClassImp(TStringLong);; ////////////////////////////////////////////////////////////////////////////////; ///constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TStringLong.cxx:13,avoid,avoid,13,core/base/src/TStringLong.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TStringLong.cxx,1,['avoid'],['avoid']
Safety,// Remove viewport from camera to avoid nested render calls resetting viewport to it (e.g Reflector).; // Transmission render pass requires viewport to match the transmissionRenderTarget.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:34,avoid,avoid,34,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// RemoveUnusedGlobalValue - Loop over all of the uses of the specified; // GlobalValue, looking for the constant pointer ref that may be pointing to; // it. If found, check to see if the constant pointer ref is safe to; // destroy, and if so, nuke it. This will reduce the reference count on the; // global value, which might make it deader.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:212,safe,safe,212,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['safe'],['safe']
Safety,"// Removing branches from both blocks is safe, because we have already; // determined that both blocks have the same branch instructions. The branch; // will be added back at the end, unpredicated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:41,safe,safe,41,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['safe'],['safe']
Safety,"// Reorder operands of bool logical op in the natural order to avoid; // possible problem with poison propagation. If not possible to reorder; // (both operands are originally RHS), emit an extra freeze instruction; // for the LHS operand.; // I.e., if we have original code like this:; // RedOp1 = select i1 ?, i1 LHS, i1 false; // RedOp2 = select i1 RHS, i1 ?, i1 false; // Then, we swap LHS/RHS to create a new op that matches the poison; // semantics of the original code.; // If we have original code like this and both values could be poison:; // RedOp1 = select i1 ?, i1 LHS, i1 false; // RedOp2 = select i1 ?, i1 RHS, i1 false; // Then, we must freeze LHS in the new op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:63,avoid,avoid,63,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// Repeated catch clause - drop the redundant copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:36,redund,redundant,36,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['redund'],['redundant']
Safety,// Replace -mcpu=native with detected GPU.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp:29,detect,detected,29,interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/AMDGPU.cpp,1,['detect'],['detected']
Safety,"// Replace 8-bit loads with the zero-extending version if not optimizing; // for size. The extending op is cheaper across a wide range of uarch and; // it avoids a potentially expensive partial register stall. It takes an; // extra byte to encode, however, so don't do this when optimizing for size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:155,avoid,avoids,155,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['avoid'],['avoids']
Safety,"// Replace Op with the gathered form of the components in CV. Defer the; // deletion of Op and creation of the gathered form to the end of the pass,; // so that we can avoid creating the gathered form if all uses of Op are; // replaced with uses of CV.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:168,avoid,avoid,168,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,1,['avoid'],['avoid']
Safety,// Replace an existing gc.statepoint with a new one and a set of gc.relocates; // which make the relocations happening at this safepoint explicit.; //; // WARNING: Does not do any fixup to adjust users of the original live; // values. That's the callers responsibility.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:127,safe,safepoint,127,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safepoint']
Safety,"// Replace frees with stackrestores. This is safe because; // alloca.alloc is required to obey a stack discipline, although we; // don't enforce that structurally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:45,safe,safe,45,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['safe'],['safe']
Safety,"// Replace integer addition by subtraction and vice versa if it allows; // folding the immediate to an inline constant.; //; // We should only ever get here for SrcIdx == 1 due to canonicalization; // earlier in the pipeline, but we double-check here to be safe / fully; // general.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:257,safe,safe,257,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['safe'],['safe']
Safety,// Replace sret attribute with noalias. This reduces register pressure by; // avoiding a register copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:78,avoid,avoiding,78,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['avoid'],['avoiding']
Safety,// Replace the chain to avoid dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:24,avoid,avoid,24,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// Replace unary minus to avoid compilation error on Windows:; // ""unary minus operator applied to unsigned type, result still unsigned""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h:26,avoid,avoid,26,interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,1,['avoid'],['avoid']
Safety,"// Replace uses of Cond with ToVal when safe to do so. If all uses are; // replaced, we can remove Cond. We cannot blindly replace all uses of Cond; // because we may incorrectly replace uses when guards/assumes are uses of; // of `Cond` and we used the guards/assume to reason about the `Cond` value; // at the end of block. RAUW unconditionally replaces all uses; // including the guards/assumes themselves and the uses before the; // guard/assume.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:40,safe,safe,40,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['safe'],['safe']
Safety,"// Replaceable builtins provide their own implementation of a builtin. If we; // are in an inline builtin implementation, avoid trivial infinite; // recursion. Honor __attribute__((no_builtin(""foo""))) or; // __attribute__((no_builtin)) on the current function unless foo is; // not a predefined library function which means we must generate the; // builtin no matter what.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:122,avoid,avoid,122,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['avoid'],['avoid']
Safety,"// Replacing results may cause a different MERGE_VALUES to suddenly; // be CSE'd with N, and carry its uses with it. Iterate until no; // uses remain, to ensure that the node can be safely deleted.; // First add the users of this node to the work list so that they; // can be tried again once they have new operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:182,safe,safely,182,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safely']
Safety,"// Replacing the congruent phi is sufficient because acyclic; // redundancy elimination, CSE/GVN, should handle the; // rest. However, once SCEV proves that a phi is congruent,; // it's often the head of an IV user cycle that is isomorphic; // with the original phi. It's worth eagerly cleaning up the; // common case of a single IV increment so that DeleteDeadPHIs; // can remove cycles that had postinc uses.; // Because we may potentially introduce a new use of OrigIV that didn't; // exist before at this point, its poison flags need readjustment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:65,redund,redundancy,65,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['redund'],['redundancy']
Safety,"// Report an error the target doesn't support Mips32r2 or later.; // The epilogue relies on the use of the ""ehb"" to clear execution; // hazards. Pre R2 Mips relies on an implementation defined number; // of ""ssnop""s to clear the execution hazard. Support for ssnop hazard; // clearing is not provided so reject that configuration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp:136,hazard,hazards,136,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEFrameLowering.cpp,3,['hazard'],"['hazard', 'hazards']"
Safety,// Report as many errors as possible before aborting the compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp:44,abort,aborting,44,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVModuleAnalysis.cpp,1,['abort'],['aborting']
Safety,// Report deallocator mismatch. Remove the region from tracking - reporting a; // missing free error after this one is redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp:119,redund,redundant,119,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MacOSKeychainAPIChecker.cpp,1,['redund'],['redundant']
Safety,// Report error if user explicitly tries to disable recovery from; // always recoverable sanitizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:52,recover,recovery,52,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,2,['recover'],"['recoverable', 'recovery']"
Safety,// Report error if user explicitly tries to recover from unrecoverable; // sanitizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:44,recover,recover,44,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['recover'],['recover']
Safety,// Represent predicates as i8 rather than i1 to avoid any layout issues.; // The type is bitcasted to a scalable predicate type when casting between; // scalable and fixed-length vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:48,avoid,avoid,48,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,1,['avoid'],['avoid']
Safety,"// Require at least version 7, which should be present in all PDBs; // produced in the last decade and allows us to avoid having to; // special case all kinds of complicated arcane formats.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/DbiStream.cpp:116,avoid,avoid,116,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/DbiStream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/DbiStream.cpp,1,['avoid'],['avoid']
Safety,// Require either the replacement or the simplification result to be a; // constant to avoid infinite loops.; // FIXME: Make this check more precise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:87,avoid,avoid,87,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['avoid'],['avoid']
Safety,// Require one-use on the multiply to avoid increasing the number of; // multiplications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:38,avoid,avoid,38,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['avoid'],['avoid']
Safety,// Require that the new offset is larger than the existing one to avoid; // infinite loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PreLegalizerCombiner.cpp:66,avoid,avoid,66,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PreLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PreLegalizerCombiner.cpp,1,['avoid'],['avoid']
Safety,// Require the address to be in a register. That is safe for all ARM; // variants and it is hard to do anything much smarter without knowing; // how the operand is used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:52,safe,safe,52,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,// Required to avoid conflict with the MachineVerifier during testing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:15,avoid,avoid,15,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Rerunning safepoint insertion after safepoints are already; // inserted is not supported. It could probably be made to work,; // but why are you doing this? There's no good reason.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:13,safe,safepoint,13,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,2,['safe'],"['safepoint', 'safepoints']"
Safety,// Reserve a source location entry chunk for the length of the macro; // definition. Tokens that get lexed directly from the definition will; // have their locations pointing inside this chunk. This is to avoid; // creating separate source location entries for each token.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:205,avoid,avoid,205,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['avoid'],['avoid']
Safety,"// Reserve the final size to avoid allocations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:29,avoid,avoid,29,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['avoid'],['avoid']
Safety,// Reserve this newly identified VGPR (for AGPR copy); // reserved registers should already be frozen at this point; // so we can avoid calling MRI.freezeReservedRegs and just use; // MRI.reserveReg,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:130,avoid,avoid,130,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// Reset ""benign"" options with implied values (Options.td ImpliedBy relations); // rather than their defaults. This avoids unexpected combinations and; // invocations that cannot be round-tripped to arguments.; // FIXME: we should derive this automatically from ImpliedBy in tablegen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp:116,avoid,avoids,116,interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/LangOptions.cpp,1,['avoid'],['avoids']
Safety,// Reset LastSeenModule to avoid overriding the hash unexpectedly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['avoid'],['avoid']
Safety,"// Reset fH0, if already added, to avoid double counting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:35,avoid,avoid,35,hist/hist/src/TH1Merger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx,1,['avoid'],['avoid']
Safety,"// Reset optimized on users of this store, and reset the uses.; // A few notes:; // 1. This is a slightly modified version of RAUW to avoid walking the; // uses twice here.; // 2. If we wanted to be complete, we would have to reset the optimized; // flags on users of phi nodes if doing the below makes a phi node have all; // the same arguments. Instead, we prefer users to removeMemoryAccess those; // phi nodes, because doing it here would be N^3.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:134,avoid,avoid,134,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['avoid'],['avoid']
Safety,"// Reset the abort status.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:13,abort,abort,13,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['abort'],['abort']
Safety,// Reset the hazard recognizer and anti-dep breaker.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:13,hazard,hazard,13,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['hazard'],['hazard']
Safety,"// Reset the input list to avoid double streaming and related problems (saving; // the TQueryResult)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:27,avoid,avoid,27,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['avoid'],['avoid']
Safety,"// Reset the iterator to avoid missing the entry next to the new one (bug in TIter?)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListArray.cxx:25,avoid,avoid,25,tree/tree/src/TEntryListArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryListArray.cxx,1,['avoid'],['avoid']
Safety,// Reset token type in case we have already looked at it and then; // recovered from an error (e.g. failure to find the matching >).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp:70,recover,recovered,70,interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/TokenAnnotator.cpp,1,['recover'],['recovered']
Safety,"// Resource leaks can result in multiple warning that describe the same kind; // of programming error:; // void f() {; // FILE *F = fopen(""a.txt"");; // if (rand()) // state split; // return; // warning; // } // warning; // While this isn't necessarily true (leaking the same stream could result; // from a different kinds of errors), the reduction in redundant reports; // makes this a worthwhile heuristic.; // FIXME: Add a checker option to turn this uniqueing feature off.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:351,redund,redundant,351,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['redund'],['redundant']
Safety,"// Respect the original bufsize and splitlevel arguments; // In particular, by keeping splitlevel equal to 0 if this was the case for `inputBranch`, we avoid; // writing garbage when unsplit objects cannot be written as split objects (e.g. in case of a polymorphic; // TObject branch, see https://bit.ly/2EjLMId ).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:152,avoid,avoid,152,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['avoid'],['avoid']
Safety,"// Restore from fp only in ARM mode: e.g. sub sp, r7, #24; // Note it's not safe to do this in Thumb2 mode because it would have; // taken two instructions:; // mov sp, r7; // sub sp, #24; // If an interrupt is taken between the two instructions, then sp is in; // an inconsistent state (pointing to the middle of callee-saved area).; // The interrupt handler can end up clobbering the registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp:76,safe,safe,76,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFrameLowering.cpp,1,['safe'],['safe']
Safety,// Restore the operand of Ext (which has been replaced by the previous call; // to replaceAllUsesWith) to avoid creating a cycle trunc <-> sext.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:106,avoid,avoid,106,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,// Restore the unsafe stack pointer before each return.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:15,unsafe,unsafe,15,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['unsafe'],['unsafe']
Safety,// Return a MachO::segment_command_64 that holds the same values as the passed; // MachO::segment_command. We do that to avoid having to duplicate the logic; // for 32bits and 64bits segments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp:121,avoid,avoid,121,interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachOUtils.cpp,1,['avoid'],['avoid']
Safety,"// Return a nul-terminated string even for an empty Slice. This is; // safe because all existing SimplifyLibcalls callers require string; // arguments and the behavior of the functions they fold is undefined; // otherwise. Folding the calls this way is preferable to making; // the undefined library calls, even though it prevents sanitizers; // from reporting such calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:71,safe,safe,71,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['safe'],['safe']
Safety,"// Return a signed ext_vector_type that is of identical size and number of; // elements. For floating point vectors, return an integer type of identical; // size and number of elements. In the non ext_vector_type case, search from; // the largest type to the smallest type to avoid cases where long long == long,; // where long gets picked over long long.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:276,avoid,avoid,276,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,// Return a version of MachineOperand that can be safely used before the; // final use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:50,safe,safely,50,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['safe'],['safely']
Safety,// Return an LoopICmp describing a latch check equivlent to LatchCheck but with; // the requested type if safe to do so. May involve the use of a new IV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:106,safe,safe,106,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['safe'],['safe']
Safety,"// Return an empty Slice for undersized constants to let callers; // transform even undefined library calls into simpler, well-defined; // expressions. This is preferable to making the calls although it; // prevents sanitizers from detecting such calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:232,detect,detecting,232,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['detect'],['detecting']
Safety,"// Return an iterator in the (inclusive) range [First, Last] at which; // instructions can be safely inserted, keeping in mind that some of the; // instructions we want to add necessarily clobber SCC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:94,safe,safely,94,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['safe'],['safely']
Safety,// Return false (unmergable) if the call before the parallel; // region calls an explicit affinity (proc_bind) or number of; // threads (num_threads) compiler-generated function. Those settings; // may be incompatible with following parallel regions.; // TODO: ICV tracking to detect compatibility.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:277,detect,detect,277,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['detect'],['detect']
Safety,// Return if target type is a safe conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:30,safe,safe,30,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['safe'],['safe']
Safety,// Return if the target has not implemented a hazard recognizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:46,hazard,hazard,46,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// Return the logical operation, or abort if none exists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp:36,abort,abort,36,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVInstructionSelector.cpp,1,['abort'],['abort']
Safety,"// Return the new alloca, addrspacecasted if required to avoid changing the; // addrspace of a volatile access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:57,avoid,avoid,57,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['avoid'],['avoid']
Safety,// Return the node at index \p N to avoid problems with vectors reallocating.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,1,['avoid'],['avoid']
Safety,"// Return the non-redundant list of WriteProcRes used by the given sched class.; // The scheduling model for LLVM is such that each instruction has a certain; // number of uops which consume resources which are described by WriteProcRes; // entries. Each entry describe how many cycles are spent on a specific ProcRes; // kind.; // For example, an instruction might have 3 uOps, one dispatching on P0; // (ProcResIdx=1) and two on P06 (ProcResIdx = 7).; // Note that LLVM additionally denormalizes resource consumption to include; // usage of super resources by subresources. So in practice if there exists a; // P016 (ProcResIdx=10), then the cycles consumed by P0 are also consumed by; // P06 (ProcResIdx = 7) and P016 (ProcResIdx = 10), and the resources consumed; // by P06 are also consumed by P016. In the figure below, parenthesized cycles; // denote implied usage of superresources by subresources:; // P0 P06 P016; // uOp1 1 (1) (1); // uOp2 1 (1); // uOp3 1 (1); // =============================; // 1 3 3; // Eventually we end up with three entries for the WriteProcRes of the; // instruction:; // {ProcResIdx=1, Cycles=1} // P0; // {ProcResIdx=7, Cycles=3} // P06; // {ProcResIdx=10, Cycles=3} // P016; //; // Note that in this case, P016 does not contribute any cycles, so it would; // be removed by this function.; // FIXME: Merge this with the equivalent in llvm-mca.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp:18,redund,redundant,18,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SchedClassResolution.cpp,1,['redund'],['redundant']
Safety,"// Return true if Load and Store are loads and stores of the same size; // and are guaranteed not to overlap. Such operations can be implemented; // using block (SS-format) instructions.; //; // Partial overlap would lead to incorrect code, since the block operations; // are logically bytewise, even though they have a fast path for the; // non-overlapping case. We also need to avoid full overlap (i.e. two; // addresses that might be equal at run time) because although that case; // would be handled correctly, it might be implemented by millicode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:380,avoid,avoid,380,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// Return true if MBB is safe to outline from, and return any target-specific; // information in Flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h:25,safe,safe,25,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,1,['safe'],['safe']
Safety,"// Return true if N is conditionally 0 or all ones.; // Detects these expressions where cc is an i1 value:; //; // (select cc 0, y) [AllOnes=0]; // (select cc y, 0) [AllOnes=0]; // (zext cc) [AllOnes=0]; // (sext cc) [AllOnes=0/1]; // (select cc -1, y) [AllOnes=1]; // (select cc y, -1) [AllOnes=1]; //; // * AllOnes determines whether to check for an all zero (AllOnes false) or an; // all ones operand (AllOnes true).; // * Invert is set when N is the all zero/ones constant when CC is false.; // * OtherOp is set to the alternative value of N.; //; // For example, for (select cc X, Y) and AllOnes = 0 if:; // * X = 0, Invert = False and OtherOp = Y; // * Y = 0, Invert = True and OtherOp = X",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:56,Detect,Detects,56,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,1,['Detect'],['Detects']
Safety,"// Return true if N is conditionally 0 or all ones.; // Detects these expressions where cc is an i1 value:; //; // (select cc 0, y) [AllOnes=0]; // (select cc y, 0) [AllOnes=0]; // (zext cc) [AllOnes=0]; // (sext cc) [AllOnes=0/1]; // (select cc -1, y) [AllOnes=1]; // (select cc y, -1) [AllOnes=1]; //; // Invert is set when N is the null/all ones constant when CC is false.; // OtherOp is set to the alternative value of N.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:56,Detect,Detects,56,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['Detect'],['Detects']
Safety,"// Return true if all users of this SDNode* only consume the lower \p Bits.; // This can be used to form W instructions for add/sub/mul/shl even when the; // root isn't a sext_inreg. This can allow the ADDW/SUBW/MULW/SLLIW to CSE if; // SimplifyDemandedBits has made it so some users see a sext_inreg and some; // don't. The sext_inreg+add/sub/mul/shl will get selected, but still leave; // the add/sub/mul/shl to become non-W instructions. By checking the users we; // may be able to use a W instruction and CSE with the other instruction if; // this has happened. We could try to detect that the CSE opportunity exists; // before doing this, but that would be more complicated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:582,detect,detect,582,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['detect'],['detect']
Safety,"// Return true if delete changes/poisons/taints the memory.; //; // Detect whether operator delete taints the memory. If it does, we can not rely; // on TestBit(kNotDeleted) to check if the memory has been deleted (but in case,; // like TClonesArray, where we know the destructor will be called but not operator; // delete, we can still use it to detect the cases where the destructor was called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx:68,Detect,Detect,68,core/base/src/TObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx,2,"['Detect', 'detect']","['Detect', 'detect']"
Safety,// Return true if it is safe to transfer the given metadata tag from; // vector to scalar instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:24,safe,safe,24,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,1,['safe'],['safe']
Safety,// Return true if the function can safely be outlined from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h:35,safe,safely,35,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInstrInfo.h,1,['safe'],['safely']
Safety,"// Return true if the inner loop \p Lp is uniform with regard to the outer loop; // \p OuterLp (i.e., if the outer loop is vectorized, all the vector lanes; // executing the inner loop will execute the same iterations). This check is; // very constrained for now but it will be relaxed in the future. \p Lp is; // considered uniform if it meets all the following conditions:; // 1) it has a canonical IV (starting from 0 and with stride 1),; // 2) its latch terminator is a conditional branch and,; // 3) its latch condition is a compare instruction whose operands are the; // canonical IV and an OuterLp invariant.; // This check doesn't take into account the uniformity of other conditions not; // related to the loop latch because they don't affect the loop uniformity.; //; // NOTE: We decided to keep all these checks and its associated documentation; // together so that we can easily have a picture of the current supported loop; // nests. However, some of the current checks don't depend on \p OuterLp and; // would be redundantly executed for each \p Lp if we invoked this function for; // different candidate outer loops. This is not the case for now because we; // don't currently have the infrastructure to evaluate multiple candidate outer; // loops and \p OuterLp will be a fixed parameter while we only support explicit; // outer loop vectorization. It's also very likely that these checks go away; // before introducing the aforementioned infrastructure. However, if this is not; // the case, we should move the \p OuterLp independent checks to a separate; // function that is only executed once for each \p Lp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:1027,redund,redundantly,1027,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['redund'],['redundantly']
Safety,// Return true if the instruction should be sunk by MachineSink.; // MachineSink determines on its own whether the instruction is safe to sink;; // this gives the target a hook to override the default behavior with regards; // to which instructions should be sunk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:130,safe,safe,130,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,1,['safe'],['safe']
Safety,"// Return true if this is a bundled retainRV/claimRV call, which is always; // redundant with the attachedcall in the bundle, and is going to be erased; // at the end of this pass. This avoids undoing objc-arc-expand and; // replacing uses of the retainRV/claimRV call's argument with its result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:79,redund,redundant,79,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,2,"['avoid', 'redund']","['avoids', 'redundant']"
Safety,"// Return true if this is an atomic which has an ordering stronger than; // unordered. Note that this is different than the predicate we use in; // Attributor. Here we chose to be conservative and consider monotonic; // operations potentially synchronizing. We generally don't do much with; // monotonic operations, so this is simply risk reduction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:334,risk,risk,334,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['risk'],['risk']
Safety,"// Return true if this operand will be safe to use for phi of ops.; //; // The reason some operands are unsafe is that we are not trying to recursively; // translate everything back through phi nodes. We actually expect some lookups; // of expressions to fail. In particular, a lookup where the expression cannot; // exist in the predecessor. This is true even if the expression, as shown, can; // be determined to be constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:39,safe,safe,39,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,// Return true if we can safely remove the select instruction for std::bit_ceil; // pattern.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:25,safe,safely,25,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['safe'],['safely']
Safety,"// Return true is there is a nearyby consecutive load to the one provided; // (regardless of alignment). We search up and down the chain, looking though; // token factors and other loads (but nothing else). As a result, a true result; // indicates that it is safe to create a new consecutive load adjacent to the; // load provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:259,safe,safe,259,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['safe'],['safe']
Safety,// Return true when it is safe to hoist a memory load or store U from OldPt; // to NewPt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,safe,safe,26,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['safe'],['safe']
Safety,// Return true when it is safe to hoist scalar instructions from all blocks in; // WL to HoistBB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:26,safe,safe,26,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['safe'],['safe']
Safety,// Returns a minimum wait states since \p I walking all predecessors.; // Only scans until \p IsExpired does not return true.; // Can only be run in a hazard recognizer mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:151,hazard,hazard,151,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// Returns a safe bitcast between two scalable vector predicates, where; // any newly created lanes from a widening bitcast are defined as zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['safe'],['safe']
Safety,"// Returns estimated size of the mathematical expression represented by this; // SCEV. The rules of its calculation are following:; // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;; // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:; // (1 + Size(Op1) + ... + Size(OpN)).; // This value gives us an estimation of time we need to traverse through this; // SCEV and all its operands recursively. We may use it to avoid performing; // heavy transformations on SCEVs of excessive size for sake of saving the; // compilation time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:463,avoid,avoid,463,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['avoid'],['avoid']
Safety,// Returns the cost of a branch when the prediction is correct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:41,predict,prediction,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['predict'],['prediction']
Safety,// Returns the cost of a branch when the prediction is correct.; // TrueCost * TrueProbability + FalseCost * FalseProbability.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:41,predict,prediction,41,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['predict'],['prediction']
Safety,"// Returns the fix-its that create bounds-safe function overloads for the; // function `D`, if `D`'s parameters will be changed to safe-types through; // fix-its in `FixItsForVariable`.; //; // NOTE: In case `D`'s parameters will be changed but bounds-safe function; // overloads cannot created, the whole group that contains the parameters will; // be erased from `FixItsForVariable`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:42,safe,safe,42,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,3,['safe'],"['safe', 'safe-types']"
Safety,"// Returns the name of the branch type; will be used when the TBranch version to; // detect between the compile-time and runtime type names.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx:85,detect,detect,85,tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/ROOT/TTreeReaderValueFast.hxx,1,['detect'],['detect']
Safety,"// Returns the offset of the last #include directive after which a new; // #include can be inserted. This ignores #include's after the #include block(s); // in the beginning of a file to avoid inserting headers into code sections; // where new #include's should not be added by default.; // These code sections include:; // - raw string literals (containing #include).; // - #if blocks.; // - Special #include's among declarations (e.g. functions).; //; // If no #include after which a new #include can be inserted, this returns the; // offset after skipping all comments from the start of the code.; // Inserting after an #include is not allowed if it comes after code that is not; // #include (e.g. pre-processing directive that is not #include, declarations).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderIncludes.cpp:187,avoid,avoid,187,interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderIncludes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderIncludes.cpp,1,['avoid'],['avoid']
Safety,"// Returns the type used for LHS[RHS], given one of LHS, RHS is type-dependent.; // Typically this is DependentTy, but can sometimes be more precise.; //; // There are cases when we could determine a non-dependent type:; // - LHS and RHS may have non-dependent types despite being type-dependent; // (e.g. unbounded array static members of the current instantiation); // - one may be a dependent-sized array with known element type; // - one may be a dependent-typed valid index (enum in current instantiation); //; // We *always* return a dependent type, in such cases it is DependentTy.; // This avoids creating type-dependent expressions with non-dependent types.; // FIXME: is this important to avoid? See https://reviews.llvm.org/D107275",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:598,avoid,avoids,598,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['avoid'],"['avoid', 'avoids']"
Safety,"// Returns true for glob pattern ""*"". Can be used to avoid expensive; // preparation/acquisition of the input for match().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GlobPattern.h:53,avoid,avoid,53,interpreter/llvm-project/llvm/include/llvm/Support/GlobPattern.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GlobPattern.h,1,['avoid'],['avoid']
Safety,"// Returns true if an instructions is safe to fix up, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:38,safe,safe,38,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['safe'],['safe']
Safety,// Returns true if it is safe to reorder an instruction across preceding; // instructions in a basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:25,safe,safe,25,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,"// Returns true if its safe to truncate the IV to RangeCheckType.; // When the IV type is wider than the range operand type, we can still do loop; // predication, by generating SCEVs for the range and latch that are of the; // same type. We achieve this by generating a SCEV truncate expression for the; // latch IV. This is done iff truncation of the IV is a safe operation,; // without loss of information.; // Another way to achieve this is by generating a wider type SCEV for the; // range check operand, however, this needs a more involved check that; // operands do not overflow. This can lead to loss of information when the; // range operand is of the form: add i32 %offset, %iv. We need to prove that; // sext(x + y) is same as sext(x) + sext(y).; // This function returns true if we can safely represent the IV type in; // the RangeCheckType without loss of information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:23,safe,safe,23,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,3,['safe'],"['safe', 'safely']"
Safety,// Returns true if the condition of the select is highly predictable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:57,predict,predictable,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['predict'],['predictable']
Safety,// Returns true if the instruction \p I can be hoisted to the end of the; // preheader of \p FC0. \p SafeToHoist contains the instructions that are; // known to be safe to hoist. The instructions encountered that cannot be; // hoisted are in \p NotHoisting.; // TODO: Move functionality into CodeMoverUtils,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:101,Safe,SafeToHoist,101,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,2,"['Safe', 'safe']","['SafeToHoist', 'safe']"
Safety,"// Returns true if we should continue scanning for entries, false if this is the; // last (sentinel) entry). In case of a parsing error we also return false, as; // it's not possible to recover this entry list (but the other lists may still; // parse OK).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp:186,recover,recover,186,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFAcceleratorTable.cpp,1,['recover'],['recover']
Safety,"// Returns whether an ancestor of \p Node matches \p Matcher.; //; // The order of matching (which can lead to different nodes being bound in; // case there are multiple matches) is breadth first search.; //; // To allow memoization in the very common case of having deeply nested; // expressions inside a template function, we first walk up the AST, memoizing; // the result of the match along the way, as long as there is only a single; // parent.; //; // Once there are multiple parents, the breadth first search order does not; // allow simple memoization on the ancestors. Thus, we only memoize as long; // as there is a single parent.; //; // We avoid a recursive implementation to prevent excessive stack use on; // very deep ASTs (similarly to RecursiveASTVisitor's data recursion).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:652,avoid,avoid,652,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,1,['avoid'],['avoid']
Safety,// Returns whether the instruction can safely move past a DMB instruction; // The current implementation allows this iif MI does not have any possible; // memory access,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp:39,safe,safely,39,interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMOptimizeBarriersPass.cpp,1,['safe'],['safely']
Safety,// Reuse signatures to avoid unnecessary duplicates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp:23,avoid,avoid,23,interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangOpenCLBuiltinEmitter.cpp,1,['avoid'],['avoid']
Safety,// Reverse the branch prediction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:22,predict,prediction,22,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['predict'],['prediction']
Safety,"// Rewrite all instructions based on the collected cell information.; //; // Traverse the instructions in a post-order, so that rewriting an; // instruction can make changes ""downstream"" in terms of control-flow; // without affecting the rewriting process. (We should not change; // instructions that have not yet been visited by the rewriter.); // The reason for this is that the rewriter can introduce new vregs,; // and replace uses of old vregs (which had corresponding cells; // computed during propagation) with these new vregs (which at this; // point would not have any cells, and would appear to be ""top"").; // If an attempt was made to evaluate an instruction with a fresh; // ""top"" vreg, it would cause an error (abend) in the evaluator.; // Collect the post-order-traversal block ordering. The subsequent; // traversal/rewrite will update block successors, so it's safer; // if the visiting order it computed ahead of time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:877,safe,safer,877,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,1,['safe'],['safer']
Safety,"// Rewriting XNext is more complicated, however, because `X << LoopTripCount`; // will be poison iff `LoopTripCount == bitwidth(X)` (which will happen; // iff `BitPos` is `bitwidth(x) - 1` and `X` is `1`). So unless we know; // that isn't the case, we'll need to emit an alternative, safe IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:284,safe,safe,284,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['safe'],['safe']
Safety,"// Risk evaluation for all tau",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h:3,Risk,Risk,3,tmva/tmva/inc/TMVA/RuleFitParams.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h,1,['Risk'],['Risk']
Safety,"// Risk evaluation for fPathIdx and fPerfInd",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h:3,Risk,Risk,3,tmva/tmva/inc/TMVA/RuleFitParams.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RuleFitParams.h,1,['Risk'],['Risk']
Safety,"// RooFit-internal helper struct to build a map object that only uses; // std::vector, which can be implicitly converted to std::map in C++. Used to; // avoid std::map in pythonizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooGlobalFunc.h:153,avoid,avoid,153,roofit/roofitcore/inc/RooGlobalFunc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooGlobalFunc.h,1,['avoid'],['avoid']
Safety,"// Rotate right only if any divisor was even. We avoid rotates for all-odd; // divisors as a performance improvement, since rotating by 0 is a no-op.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:49,avoid,avoid,49,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,2,['avoid'],['avoid']
Safety,"// Rotating a loop exit to the bottom when there is a fallthrough to top; // trades the entry fallthrough for an exit fallthrough.; // If there is no bottom->top edge, but the chosen exit block does have; // a fallthrough, we break that fallthrough for nothing in return.; // Let's consider an example. We have a built chain of basic blocks; // B1, B2, ..., Bn, where Bk is a ExitingBB - chosen exit block.; // By doing a rotation we get; // Bk+1, ..., Bn, B1, ..., Bk; // Break of fallthrough to B1 is compensated by a fallthrough from Bk.; // If we had a fallthrough Bk -> Bk+1 it is broken now.; // It might be compensated by fallthrough Bn -> B1.; // So we have a condition to avoid creation of extra branch by loop rotation.; // All below must be true to avoid loop rotation:; // If there is a fallthrough to top (B1); // There was fallthrough from chosen exit block (Bk) to next one (Bk+1); // There is no fallthrough from bottom (Bn) to top (B1).; // Please note that there is no exit fallthrough from Bn because we checked it; // above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:681,avoid,avoid,681,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,2,['avoid'],['avoid']
Safety,// Round small factors to 0 to avoid over-counting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PseudoProbe.cpp:31,avoid,avoid,31,interpreter/llvm-project/llvm/lib/IR/PseudoProbe.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/PseudoProbe.cpp,1,['avoid'],['avoid']
Safety,"// Round the integral value and scale back. This makes the; // overflow calculations below work properly. If we do not round here,; // we risk checking for overflow with a value that is outside the; // representable range of the fixed-point semantic even though no overflow; // would occur had we rounded first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp:138,risk,risk,138,interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFixedPoint.cpp,1,['risk'],['risk']
Safety,// Round up to register pair alignment to avoid additional SP adjustment; // instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// Rules for division.; // We are going to perform some comparisons with Denominator and its; // derivative expressions. In general case, creating a SCEV for it may; // lead to a complex analysis of the entire graph, and in particular it; // can request trip count recalculation for the same loop. This would; // cache as SCEVCouldNotCompute to avoid the infinite recursion. To avoid; // this, we only want to create SCEVs that are constants in this section.; // So we bail if Denominator is not a constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:345,avoid,avoid,345,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['avoid'],['avoid']
Safety,// Run OptimizeSequences until it either stops making changes or; // no retain+release pair nesting is detected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:103,detect,detected,103,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['detect'],['detected']
Safety,// Run instcombine after redundancy and dead bit elimination to exploit; // opportunities opened up by them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:25,redund,redundancy,25,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['redund'],['redundancy']
Safety,// Run on an individual instruction in hazard recognizer mode. This can be; // used on a newly inserted instruction before returning from PreEmitNoops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h:39,hazard,hazard,39,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.h,1,['hazard'],['hazard']
Safety,"// Run this once before building the forest. Set initial prediction to the weightedMean",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx:57,predict,prediction,57,tmva/tmva/src/LossFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx,1,['predict'],['prediction']
Safety,"// Run this once before building the forest. Set initial prediction to weightedMedian.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx:57,predict,prediction,57,tmva/tmva/src/LossFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx,2,['predict'],['prediction']
Safety,"// S is dereferenceable so it's safe to load from it and fold; // memchr(S, C, N) == S to N && *S == C for any C and N.; // TODO: This is safe even for nonconstant S.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:32,safe,safe,32,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,2,['safe'],['safe']
Safety,"// SETCCCARRY can detect < and >= directly. For > and <=, flip; // operands and condition code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:18,detect,detect,18,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['detect'],['detect']
Safety,"// SI has a hardware bug in the LDS / GDS bounds checking: if the base; // address is negative, then the instruction is incorrectly treated as; // out-of-bounds even if base + offsets is in bounds. Split vectorized; // loads here to avoid emitting ds_read2_b32. We may re-combine the; // load later in the SILoadStoreOptimizer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:233,avoid,avoid,233,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// SI_RETURN_TO_EPILOG is a fallthrough to code outside of the function. The; // hazard, even if one exist, won't really be visible. Should we handle it?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:81,hazard,hazard,81,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['hazard'],['hazard']
Safety,// SLSR is currently unsafe if i * S may overflow.; // GEP = Base + sext(LHS *nsw RHS) * ElementSize,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:21,unsafe,unsafe,21,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,1,['unsafe'],['unsafe']
Safety,// SOPP instructions cannot mitigate the hazard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:41,hazard,hazard,41,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,// STEP 1 - Insert the safepoint polling locations. We do not need to; // actually insert parse points yet. That will be done for all polls and; // calls in a single pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:23,safe,safepoint,23,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,// Safe Buffers pragmas,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:3,Safe,Safe,3,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['Safe'],['Safe']
Safety,"// Safe because of the break stmt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Transaction.cpp:3,Safe,Safe,3,interpreter/cling/lib/Interpreter/Transaction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Transaction.cpp,1,['Safe'],['Safe']
Safety,// Safe bitcasting between unpacked vector types of different element counts; // is currently unsupported because the following is missing the necessary; // work to ensure the result's elements live where they're supposed to within; // an SVE register.; // 01234567; // e.g. nxv2i32 = XX??XX??; // nxv4f16 = X?X?X?X?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Safe,Safe,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Safe'],['Safe']
Safety,"// Safe indexing of the coordinates when using with matrices, arrays, etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h:3,Safe,Safe,3,math/physics/inc/TLorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/physics/inc/TLorentzVector.h,1,['Safe'],['Safe']
Safety,// Safe scalar characters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:3,Safe,Safe,3,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['Safe'],['Safe']
Safety,"// Safe stack object that stores the current unsafe stack top. It is updated; // as unsafe dynamic (non-constant-sized) allocas are allocated and freed.; // This is only needed if we need to restore stack pointer after longjmp; // or exceptions, and we have dynamic allocations.; // FIXME: a better alternative might be to store the unsafe stack pointer; // before setjmp / invoke instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Safe,Safe,3,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,4,"['Safe', 'unsafe']","['Safe', 'unsafe']"
Safety,// Safe to change the instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:3,Safe,Safe,3,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,2,['Safe'],['Safe']
Safety,"// Safe to change the instruction.; // Don't set src flags, as we don't know if we're also killing the superreg.; // However, the superregister might not be defined; make it explicit that; // we don't care about the higher bits by reading it as Undef, and adding; // an imp-use on the original subregister.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:3,Safe,Safe,3,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['Safe'],['Safe']
Safety,// Safe to delete llvm.stacksave and launder.invariant.group if dead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Safe,Safe,3,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['Safe'],['Safe']
Safety,// Safe to use a larger than specified operand because by promoting the; // value nothing has changed from an arithmetic point of view.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Safe,Safe,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Safe'],['Safe']
Safety,// Safe to use a larger than specified result since an fp_to_int where the; // result doesn't fit into the destination is undefined.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Safe,Safe,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Safe'],['Safe']
Safety,// SafeSEH is a feature specific to 32-bit x86. It does not exist (and is; // unnecessary) on all platforms which use table-based exception dispatch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWinCOFFStreamer.cpp:3,Safe,SafeSEH,3,interpreter/llvm-project/llvm/lib/MC/MCWinCOFFStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWinCOFFStreamer.cpp,1,['Safe'],['SafeSEH']
Safety,// SafeStack runtime is built into the system on Android and Fuchsia.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:3,Safe,SafeStack,3,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['Safe'],['SafeStack']
Safety,// Safeguard adding of edges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp:3,Safe,Safeguard,3,interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,1,['Safe'],['Safeguard']
Safety,// Safeguards if bevels are not enabled,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,Safe,Safeguards,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Safe'],['Safeguards']
Safety,"// Safety distance for the initial location",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressGeometry.cxx:3,Safe,Safety,3,test/stressGeometry.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressGeometry.cxx,1,['Safe'],['Safety']
Safety,"// Safety to current node",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:3,Safe,Safety,3,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,2,['Safe'],['Safety']
Safety,"// Safety to inner part",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx:3,Safe,Safety,3,geom/geom/src/TGeoCone.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx,1,['Safe'],['Safety']
Safety,"// Safety: Insertion at the end of a deque never invalidates references; // to existing elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx:3,Safe,Safety,3,tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSinkBuf.hxx,1,['Safe'],['Safety']
Safety,"// Safety: References are guaranteed to be valid until the element is destroyed. In other words, all buffered page; // elements are valid until DropBufferedPages().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:3,Safe,Safety,3,tree/ntuple/v7/src/RPageSinkBuf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx,1,['Safe'],['Safety']
Safety,"// Same as nsw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,"// Same as nuw case above - duplicated here to avoid a compile time; // issue. It's not clear that the order of checks does matter, but; // it's one of two issue possible causes for a change which was; // reverted. Be conservative for the moment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,"// Same, keep the order to avoid non-determinism.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"// Samsung Electronics Co., Ltd.; // The Exynos chips have a convoluted ID scheme that doesn't seem to follow; // any predictive pattern across variants and parts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:118,predict,predictive,118,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,1,['predict'],['predictive']
Safety,"// Sanity check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:3,Sanity check,Sanity check,3,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,8,['Sanity check'],['Sanity check']
Safety,"// Sanity check - making sure leaf of LBR aligns with leaf of stack sample; // Stack sample sometimes can be unreliable, so filter out bogus ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:3,Sanity check,Sanity check,3,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['Sanity check'],['Sanity check']
Safety,// Sanity check generated instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h:3,Sanity check,Sanity check,3,interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-exegesis/lib/SnippetGenerator.h,1,['Sanity check'],['Sanity check']
Safety,"// Sanity check if all the indices are NOT in range.; // If mask is `poison`, `Mask` may be a vector of -1s.; // If all of them are `poison`, OOB read will happen later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:3,Sanity check,Sanity check,3,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['Sanity check'],['Sanity check']
Safety,"// Sanity check that clang delivered the language standard requested",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:3,Sanity check,Sanity check,3,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['Sanity check'],['Sanity check']
Safety,// Sanity check that no alloc types on clone or its edges are None.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Sanity check,Sanity check,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['Sanity check'],['Sanity check']
Safety,// Sanity check that the MIB stack ids match between the summary and; // instruction metadata.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Sanity check,Sanity check,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['Sanity check'],['Sanity check']
Safety,"// Sanity check that the holder really is fundamental",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx:3,Sanity check,Sanity check,3,roofit/roofitcore/src/RooTreeDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooTreeDataStore.cxx,2,['Sanity check'],['Sanity check']
Safety,// Sanity check that the stack ids match between the summary and; // instruction metadata.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Sanity check,Sanity check,3,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['Sanity check'],['Sanity check']
Safety,// Sanity check that we didn't update MinDepDistBytes when calling; // couldPreventStoreLoadForward,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Sanity check,Sanity check,3,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['Sanity check'],['Sanity check']
Safety,"// Sanity check the current data member.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx:3,Sanity check,Sanity check,3,core/metacling/src/TClingDataMemberInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingDataMemberInfo.cxx,3,['Sanity check'],['Sanity check']
Safety,"// Sanity check to ensure that the .xdata header is present.; // A header is one or two words, followed by at least one word to describe; // the unwind codes. Applicable to both ARM and AArch64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMWinEHPrinter.cpp:3,Sanity check,Sanity check,3,interpreter/llvm-project/llvm/tools/llvm-readobj/ARMWinEHPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMWinEHPrinter.cpp,1,['Sanity check'],['Sanity check']
Safety,// Sanity check use of remote-jit: LLI currently only supports use of the; // remote JIT on Unix platforms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp:3,Sanity check,Sanity check,3,interpreter/llvm-project/llvm/tools/lli/lli.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/lli/lli.cpp,1,['Sanity check'],['Sanity check']
Safety,"// Sanity check, ensure all result sets have the expected number of events",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataSet.cxx:3,Sanity check,Sanity check,3,tmva/tmva/src/DataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/DataSet.cxx,1,['Sanity check'],['Sanity check']
Safety,"// Sanity check. XY plotting only applies to weighted datasets if no YVar is specified",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx:3,Sanity check,Sanity check,3,roofit/roofitcore/src/RooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx,1,['Sanity check'],['Sanity check']
Safety,// Sanity check: the map should point to the same data as the Pattern.; // Both strings are allocated in the pool using insertStrRef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:3,Sanity check,Sanity check,3,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['Sanity check'],['Sanity check']
Safety,"// Sanity check; // Do not cache a basket if it is bigger than the cache size!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx:3,Sanity check,Sanity check,3,tree/tree/src/TTreeCache.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCache.cxx,1,['Sanity check'],['Sanity check']
Safety,"// Sanity checking macros.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h:3,Sanity check,Sanity checking,3,gui/guihtml/inc/TGHtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/inc/TGHtml.h,1,['Sanity check'],['Sanity checking']
Safety,"// Sanity checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:3,Sanity check,Sanity checks,3,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,7,['Sanity check'],['Sanity checks']
Safety,"// Sanity checks: data sets must have the same size",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx:3,Sanity check,Sanity checks,3,roofit/roofitcore/src/RooDataSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataSet.cxx,1,['Sanity check'],['Sanity checks']
Safety,"// Save ""Succ"" in BackpatchBlocks. In the backpatch processing, ""Succ"" is; // used to avoid adding ""Succ"" again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:86,avoid,avoid,86,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['avoid'],['avoid']
Safety,// Save 'store' instructions. Abort if other instructions write to memory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:30,Abort,Abort,30,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['Abort'],['Abort']
Safety,// Save the BB nodes on the path from the first BB node containing; // non-redundant spill to the Root node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:75,redund,redundant,75,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['redund'],['redundant']
Safety,"// Save the data set into the TQueryResult (should be done after Process to avoid; // improper deletion during collection)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx:76,avoid,avoid,76,proof/proof/src/TProofLite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofLite.cxx,1,['avoid'],['avoid']
Safety,// Save the exception pointer. It's safe to use a single exception; // pointer per function because EH cleanups can never have nested; // try/catches.; // Build the landingpad instruction.; // Accumulate all the handlers in scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:36,safe,safe,36,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['safe'],['safe']
Safety,// Save the so-called Initial-SP (i.e. the value of the stack pointer; // immediately after the prolog) into the PSPSlot so that funclets; // and the GC can recover it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:157,recover,recover,157,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['recover'],['recover']
Safety,// Save the stack depth. Try to avoid doing this if the stackrestore; // is going to immediately precede a return or something.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['avoid'],['avoid']
Safety,// Save the trip count so we don't have to regenerate it in the; // vec.epilog.iter.check. This is safe to do because the trip count; // generated here dominates the vector epilog iter check.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:99,safe,safe,99,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['safe'],['safe']
Safety,// Save unique users to avoid processing operand replacement; // more than once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:24,avoid,avoid,24,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['avoid'],['avoid']
Safety,"// Say that we can handle the situation. Clang should try to recover",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:61,recover,recover,61,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,2,['recover'],['recover']
Safety,"// Scale to avoid under/overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixDSymEigen.cxx:12,avoid,avoid,12,math/matrix/src/TMatrixDSymEigen.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixDSymEigen.cxx,1,['avoid'],['avoid']
Safety,"// Scan all of the blocks in the function, except for the entry block.; // Use a temporary array to avoid iterator being invalidated when; // deleting blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:100,avoid,avoid,100,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"// Scan forward for the use of CPSR; // When checking against MI: if it's a conditional code that requires; // checking of the V bit or C bit, then this is not safe to do.; // It is safe to remove CmpInstr if CPSR is redefined or killed.; // If we are done with the basic block, we need to check whether CPSR is; // live-out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:160,safe,safe,160,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,2,['safe'],['safe']
Safety,"// Scan forward from the instruction after CmpInstr for uses of EFLAGS.; // It is safe to remove CmpInstr if EFLAGS is redefined or killed.; // If we are done with the basic block, we need to check whether EFLAGS is; // live-out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:82,safe,safe,82,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safe']
Safety,// Scan only up to 32 instructions ahead (to avoid n^2 complexity).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonSubtarget.cpp,1,['avoid'],['avoid']
Safety,"// Scan over the body of the comment. The common case, when scanning, is that; // the comment contains normal ascii characters with nothing interesting in; // them. As such, optimize for this case with the inner loop.; //; // This loop terminates with CurPtr pointing at the newline (or end of buffer); // character that ends the line comment.; // C++23 [lex.phases] p1; // Diagnose invalid UTF-8 if the corresponding warning is enabled, emitting a; // diagnostic only once per entire ill-formed subsequence to avoid; // emiting to many diagnostics (see http://unicode.org/review/pr-121.html).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:511,avoid,avoid,511,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['avoid'],['avoid']
Safety,// Scan the BB and collect legal loads and stores. Also detect any; // convergent instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:56,detect,detect,56,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['detect'],['detect']
Safety,"// Scan the chunks one at a time, seeing whether each is entirely in,; // entirely out, or overlapping the rectangle. If an overlap is; // detected, return immediately; otherwise wait until all chunks have; // been processed and see if they were all inside or all outside.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:139,detect,detected,139,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['detect'],['detected']
Safety,// Scan the instructions in the block and look for hazards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:51,hazard,hazards,51,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['hazard'],['hazards']
Safety,"// Scan the whole block to get the instruction. This accumulates; // information for every interesting instruction in the block, in order to; // avoid gratuitus rescans.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:145,avoid,avoid,145,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['avoid'],['avoid']
Safety,"// Schedule ""replace all uses with"" to happen after materializing is; // done. It is not safe to do it now, since ValueMapper may be holding; // pointers to constants that will get deleted if RAUW runs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:89,safe,safe,89,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['safe'],['safe']
Safety,"// Schedule PushPop Optimization before expansion of Pseudo instruction,; // ensuring return instruction is detected correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:108,detect,detected,108,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,1,['detect'],['detected']
Safety,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LL/SC block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp:63,avoid,avoiding,63,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTargetMachine.cpp,1,['avoid'],['avoiding']
Safety,"// Schedule the expansion of AMOs at the last possible moment, avoiding the; // possibility for other passes to break the requirements for forward; // progress in the LR/SC block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp:63,avoid,avoiding,63,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp,1,['avoid'],['avoiding']
Safety,"// Schedule the expansion of AtomicPseudos at the last possible moment,; // avoiding the possibility for other passes to break the requirements for; // forward progress in the LL/SC block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp:76,avoid,avoiding,76,interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/LoongArchTargetMachine.cpp,1,['avoid'],['avoiding']
Safety,"// Scratch is allocated in 256 dword per wave blocks for the entire; // wavefront. When viewed from the perspective of an arbitrary workitem, this; // is 4-byte aligned.; //; // Only 4-byte alignment is really needed to access anything. Transformations; // on the pointer value itself may rely on the alignment / known low bits of; // the pointer. Set this to something above the minimum to avoid needing; // dynamic realignment in common cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:391,avoid,avoid,391,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['avoid'],['avoid']
Safety,// Scratch space. Allocated here to avoid repeated malloc calls in; // selectOrSplit().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocBasic.cpp,1,['avoid'],['avoid']
Safety,"// Seal the page right now, avoiding the allocation and copy, but making sure that the page buffer is not aliased.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:28,avoid,avoiding,28,tree/ntuple/v7/src/RPageSinkBuf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx,1,['avoid'],['avoiding']
Safety,// Search [NumSubElts] spans for RHS sequence.; // TODO: Can we avoid nested loops to increase performance?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:64,avoid,avoid,64,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// Search backwards in the block for ""Reg = A2_addi BP, RealOffset"".; // This will give us a chance to avoid creating a new register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp:103,avoid,avoid,103,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonRegisterInfo.cpp,1,['avoid'],['avoid']
Safety,"// Search for a SCEV subexpression that is not safe to expand. Any expression; // that may expand to a !isSafeToSpeculativelyExecute value is unsafe, namely; // UDiv expressions. We don't know if the UDiv is derived from an IR divide; // instruction, but the important thing is that we prove the denominator is; // nonzero before expansion.; //; // IVUsers already checks that IV-derived expressions are safe. So this check is; // only needed when the expression includes some subexpression that is not IV; // derived.; //; // Currently, we only allow division by a value provably non-zero here.; //; // We cannot generally expand recurrences unless the step dominates the loop; // header. The expander handles the special case of affine recurrences by; // scaling the recurrence outside the loop, but this technique isn't generally; // applicable. Expanding a nested recurrence outside a loop requires computing; // binomial coefficients. This could be done, but the recurrence has to be in a; // perfectly reduced form, which can't be guaranteed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:47,safe,safe,47,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,3,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,// Search for a hazard in a block and its predecessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:16,hazard,hazard,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// Search for the first nul character. Return a conservative result even; // when there is no nul. This is safe since otherwise the string function; // being folded such as strlen is undefined, and can be preferable to; // making the undefined library call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:107,safe,safe,107,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['safe'],['safe']
Safety,"// Search through the requirements, and see if any have a RecoveryExpr in it,; // which means this RequiresExpr ALSO needs to be invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp:58,Recover,RecoveryExpr,58,interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConcepts.cpp,1,['Recover'],['RecoveryExpr']
Safety,"// See ARM ARM v7 B1.8.3. On exception entry LR is set to a possibly offset; // version of the ""preferred return address"". These offsets affect the return; // instruction if this is a return from PL1 without hypervisor extensions.; // IRQ/FIQ: +4 ""subs pc, lr, #4""; // SWI: 0 ""subs pc, lr, #0""; // ABORT: +4 ""subs pc, lr, #4""; // UNDEF: +4/+2 ""subs pc, lr, #0""; // UNDEF varies depending on where the exception came from ARM or Thumb; // mode. Alongside GCC, we throw our hands up in disgust and pretend it's 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:298,ABORT,ABORT,298,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['ABORT'],['ABORT']
Safety,"// See AsmPrinter::getSymbolPreferLocal(). For a deduplicate comdat kind,; // references to a discarded local symbol from outside the group are not; // allowed, so avoid the local alias.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp:164,avoid,avoid,164,interpreter/llvm-project/llvm/lib/IR/Globals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Globals.cpp,1,['avoid'],['avoid']
Safety,// See comment in below overload for why it's safe to compute the linkage; // of the new declaration here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:46,safe,safe,46,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['safe'],['safe']
Safety,"// See createPGOFuncNameVar for more details. To avoid link errors, profile; // counters for function with available_externally linkage needs to be changed; // to linkonce linkage. On ELF based systems, this leads to weak symbols to be; // created. Without using comdat, duplicate entries won't be removed by the; // linker leading to increased data segement size and raw profile size. Even; // worse, since the referenced counter from profile per-function data object; // will be resolved to the common strong definition, the profile counts for; // available_externally functions will end up being duplicated in raw profile; // data. This can result in distorted profile as the counts of those dups; // will be accumulated by the profile merger.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:49,avoid,avoid,49,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,1,['avoid'],['avoid']
Safety,// See description in the base class. This interface is designed; // to be used by llvm-profdata (for dumping). Avoid using this when; // the client is the compiler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h:112,Avoid,Avoid,112,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProfReader.h,1,['Avoid'],['Avoid']
Safety,"// See if Sym is known to be within [min/4, max/4], where min and max; // are the bounds of the symbol's integral type. With such symbols,; // some manipulations can be performed without the risk of overflow.; // assume() doesn't cause infinite recursion because we should be dealing; // with simpler symbols on every recursive call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp:191,risk,risk,191,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SimpleSValBuilder.cpp,1,['risk'],['risk']
Safety,"// See if a warning is needed by checking the first difference in index; // numbers. If field being used has index less than the field being; // initialized, then the use is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:174,safe,safe,174,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['safe'],['safe']
Safety,"// See if a widened result type would be legal, if so widen the node.; // FIXME: This isn't safe for StrictFP. Other optimization here is needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:92,safe,safe,92,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['safe'],['safe']
Safety,// See if it would be better to reorganize NewMask to avoid using VPERM.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:54,avoid,avoid,54,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// See if the transformation is safe. Specifically, see if there are any; // calls in between Save and CallInstr. They can potenitally resume the; // coroutine rendering this optimization unsafe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp:32,safe,safe,32,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroSplit.cpp,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"// See if theFn was internalized, by checking index directly with; // original name (this avoids the name adjustment done by getGUID() for; // internal symbols).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:90,avoid,avoids,90,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['avoid'],['avoids']
Safety,// See if there is an unsafe dependency between a load to a uniform address and; // store to the same uniform address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:22,unsafe,unsafe,22,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['unsafe'],['unsafe']
Safety,// See if this BO is reachable from this Phi by walking forward through single; // use BinaryOperators with the same opcode. If we get back then we know we've; // found a loop and it is safe to step through this Add to find more leaves.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp:186,safe,safe,186,interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,1,['safe'],['safe']
Safety,// See if we can avoid a PACKSS by calling MOVMSK on the sources.; // For vXi16 cases we can use a v2Xi8 PMOVMSKB. We must mask out; // sign bits prior to the comparison with zero unless we know that; // the vXi16 splats the sign bit down to the lower i8 half.; // TODO: Handle all_of patterns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:17,avoid,avoid,17,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// See if we can avoid creating the buffer, for now we just look for; // simple indentifier, constructor and destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:17,avoid,avoid,17,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['avoid'],['avoid']
Safety,// See if we can avoid the phi by simplifying it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:17,avoid,avoid,17,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['avoid'],['avoid']
Safety,"// See if we can create this constant as (ADD (SLLI X, C), X) where X is at; // worst an LUI+ADDIW. This will require an extra register, but avoids a; // constant pool.; // If we have Zba we can use (ADD_UW X, (SLLI X, 32)) to handle cases where; // low and high 32 bits are the same and bit 31 and 63 are set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:141,avoid,avoids,141,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['avoid'],['avoids']
Safety,"// See if we can peek through to a vector with a wider element type, if the; // signbits extend down to all the sub-elements as well.; // Calling MOVMSK with the wider type, avoiding the bitcast, helps expose; // potential SimplifyDemandedBits/Elts cases.; // If we looked through a truncate that discard bits, we can't do this; // transform.; // FIXME: We could do this transform for truncates that discarded bits by; // inserting an AND mask between the new MOVMSK and the CMP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:174,avoid,avoiding,174,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoiding']
Safety,"// See if we can recurse into each shuffle source op (if it's a target; // shuffle). The source op should only be generally combined if it either has; // a single use (i.e. current Op) or all its users have already been combined,; // if not then we can still combine but should prevent generation of variable; // shuffles to avoid constant pool bloat.; // Don't recurse if we already have more source ops than we can combine in; // the remaining recursion depth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:325,avoid,avoid,325,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// See if we can use vXi8 PSADBW add reduction for larger zext types.; // If the source vector values are 0-255, then we can use PSADBW to; // sum+zext v8i8 subvectors to vXi64, then perform the reduction.; // TODO: See if its worth avoiding vXi16/i32 truncations?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:233,avoid,avoiding,233,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoiding']
Safety,// See whether the comparison argument contains a redundant AND; // and remove it if so. This sometimes happens due to the generic; // BRCOND expansion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:50,redund,redundant,50,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['redund'],['redundant']
Safety,// See whether we can avoid an AND in the first operand by converting; // ROSBG to RISBG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:22,avoid,avoid,22,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// Seed our PRNG with simple additive sum of ModuleID. We're looking to; // simply avoid always having the same function names, and we need to; // remain deterministic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:83,avoid,avoid,83,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,1,['avoid'],['avoid']
Safety,// Seek a loop which actually contains the block being split (to avoid; // adjacent loops).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:65,avoid,avoid,65,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['avoid'],['avoid']
Safety,// Select the default CPU if none was given (or detection failed).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp:48,detect,detection,48,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,1,['detect'],['detection']
Safety,"// SelectionDAG (but not FastISel) inserts a copy of ESP into a virtual; // register. If it's there, use that virtual register as stack pointer; // instead. Also, we need to locate this instruction so that we can later; // safely ignore it while doing the conservative processing of the call chain.; // The COPY can be located anywhere between the call-frame setup; // instruction and its first use. We use the call instruction as a boundary; // because it is usually cheaper to check if an instruction is a call than; // checking if an instruction uses a register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp:223,safe,safely,223,interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86CallFrameOptimization.cpp,1,['safe'],['safely']
Safety,// Self dependencies are ignored because they are redundant and; // uninteresting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:50,redund,redundant,50,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,1,['redund'],['redundant']
Safety,"// Separate storage assumptions apply to the underlying allocations, not any; // particular pointer within them. When evaluating the hints for AA purposes; // we getUnderlyingObject them; by precomputing the answers here we can; // avoid having to do so repeatedly there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:232,avoid,avoid,232,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['avoid'],['avoid']
Safety,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:94,redund,redundant,94,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,2,['redund'],['redundant']
Safety,"// Serializing loads here may result in excessive register pressure, and; // TokenFactor places arbitrary choke points on the scheduler. SD scheduling; // could recover a bit by hoisting nodes upward in the chain by recognizing; // they are side-effect free or do not alias. The optimizer should really; // avoid this case by converting large object/array copies to llvm.memcpy; // (MaxParallelChains should always remain as failsafe).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:161,recover,recover,161,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,"['avoid', 'recover']","['avoid', 'recover']"
Safety,// Set FADD/FSUB as libcall to avoid the legalizer to expand the; // fp_to_uint and int_to_fp.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:31,avoid,avoid,31,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Set IdenfitierInfo to null to avoid confusing code that handles both; // identifiers and completion tokens.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:33,avoid,avoid,33,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['avoid'],['avoid']
Safety,"// Set MFFS and MTFSF as scheduling boundary to avoid unexpected code motion; // across them, since some FP operations may change content of FPSCR.; // TODO: Model FPSCR in PPC instruction definitions and remove the workaround",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:48,avoid,avoid,48,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// Set isVRegCycle for a node with only live in opers and live out uses. Also; // set isVRegCycle for its CopyFromReg operands.; //; // This is only relevant for single-block loops, in which case the VRegCycle; // node is likely an induction variable in which the operand and target virtual; // registers should be coalesced (e.g. pre/post increment values). Setting the; // isVRegCycle flag helps the scheduler prioritize other uses of the same; // CopyFromReg so that this node becomes the virtual register ""kill"". This; // avoids interference between the values live in and out of the block and; // eliminates a copy inside the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:526,avoid,avoids,526,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avoid'],['avoids']
Safety,"// Set light states every time - must be deferred until now when we know we; // are in the correct thread for GL context; // TODO: Could detect state change and only adjust if a change",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLightSet.cxx:137,detect,detect,137,graf3d/gl/src/TGLLightSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLLightSet.cxx,1,['detect'],['detect']
Safety,// Set linkage as ExternalLinkage to avoid erasing unreachable functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BlockExtractor.cpp:37,avoid,avoid,37,interpreter/llvm-project/llvm/lib/Transforms/IPO/BlockExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BlockExtractor.cpp,1,['avoid'],['avoid']
Safety,"// Set max response time to 2 minutes to avoid timeout; // in TGWin32ProxyBase::ForwardCallBack during RequestLocator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:41,avoid,avoid,41,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,2,"['avoid', 'timeout']","['avoid', 'timeout']"
Safety,"// Set max response time to 2 minutes to avoid timeout; // in TGWin32ProxyBase::ForwardCallBack during RequestString",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:41,avoid,avoid,41,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,2,"['avoid', 'timeout']","['avoid', 'timeout']"
Safety,// Set of dispatch hazard buffer resources that are currently unavailable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:19,hazard,hazard,19,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['hazard'],['hazard']
Safety,// Set of extensions which have been enabled or disabled at any point. Used; // to avoid cluttering the cc1 command-line with lots of unneeded features.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/AArch64TargetParser.h:83,avoid,avoid,83,interpreter/llvm-project/llvm/include/llvm/TargetParser/AArch64TargetParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/AArch64TargetParser.h,1,['avoid'],['avoid']
Safety,// Set of failed immediate invocations to avoid double diagnosing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:42,avoid,avoid,42,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avoid'],['avoid']
Safety,// Set of invariantstart instructions that we need to remove.; // Use this to avoid invalidating the instruction iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:78,avoid,avoid,78,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['avoid'],['avoid']
Safety,// Set operands in order of their index to match use-list-order; // prediction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp:68,predict,prediction,68,interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Instructions.cpp,3,['predict'],['prediction']
Safety,"// Set reg to FP0, avoid hitting asserts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:19,avoid,avoid,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,4,['avoid'],['avoid']
Safety,"// Set reg to FP1, avoid hitting asserts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:19,avoid,avoid,19,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,2,['avoid'],['avoid']
Safety,// Set the 'operator delete' directly to avoid emitting another update; // record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:41,avoid,avoid,41,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['avoid'],['avoid']
Safety,"// Set the alignment of the frame object to 4, to avoid having to generate; // more than one ADD",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:50,avoid,avoid,50,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,// Set the default argument. It should be no problem if it was already done.; // Do not import the default expression before GetImportedOrCreateDecl call; // to avoid possible infinite import loop because circular dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:161,avoid,avoid,161,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['avoid'],['avoid']
Safety,// Set the detected binding on each alias with this aliasee.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/RecordStreamer.cpp:11,detect,detected,11,interpreter/llvm-project/llvm/lib/Object/RecordStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/RecordStreamer.cpp,1,['detect'],['detected']
Safety,// Set the flag below to avoid merging the profile again in; // computeSummaryAndThreshold,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp:25,avoid,avoid,25,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.cpp,1,['avoid'],['avoid']
Safety,// Set the minimum score for splat-like sequence to avoid setting; // failed state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:52,avoid,avoid,52,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// Set the reachingDef for UseNode under consideration; // after updating the Add use. This local change is; // to avoid rebuilding of the RDF graph after update.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:115,avoid,avoid,115,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,1,['avoid'],['avoid']
Safety,// Set the vector length to only the number of elements we care about. This; // avoids sliding down elements we're going to discard straight away.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:80,avoid,avoids,80,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoids']
Safety,// Set timeout to 15000ms = 15s,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp:7,timeout,timeout,7,interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Z3Solver.cpp,1,['timeout'],['timeout']
Safety,// Set to avoid adding duplicate entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:10,avoid,avoid,10,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,1,['avoid'],['avoid']
Safety,"// Set to true if we do not import the type of the function as is. There are; // cases when the original type would result in an infinite recursion during; // the import. To avoid an infinite recursion when importing, we create the; // FunctionDecl with a simplified function type and update it only after the; // relevant AST nodes are already imported.; // The type is related to TypeSourceInfo (it references the type), so we must; // do the same with TypeSourceInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:174,avoid,avoid,174,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['avoid'],['avoid']
Safety,// Set up a crash recovery context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:18,recover,recovery,18,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,1,['recover'],['recovery']
Safety,"// Setup the predict method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:13,predict,predict,13,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,1,['predict'],['predict']
Safety,"// Several consecutive ranges may operate on the same file (each with their own page source clone).; // We can detect a change of file when the first entry number jumps back to 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:111,detect,detect,111,tree/dataframe/src/RNTupleDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx,1,['detect'],['detect']
Safety,"// Shadow variables and their properties must be registered with CUDA; // runtime. Skip Extern global variables, which will be registered in; // the TU where they are defined.; //; // Don't register a C++17 inline variable. The local symbol can be; // discarded and referencing a discarded local symbol from outside the; // comdat (__cuda_register_globals) is disallowed by the ELF spec.; //; // HIP managed variables need to be always recorded in device and host; // compilations for transformation.; //; // HIP managed variables and variables in CUDADeviceVarODRUsedByHost are; // added to llvm.compiler-used, therefore they are safe to be registered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:631,safe,safe,631,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['safe'],['safe']
Safety,"// Shift cannot use a min/max expansion, we can't detect overflow if all of; // the bits have been shifted out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:50,detect,detect,50,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['detect'],['detect']
Safety,"// Shifts and add instructions in M68000 and M68010 support; // up to 32 bits, but mul only has 16-bit variant. So it's almost; // certainly beneficial to lower 8/16/32-bit mul to their; // add / shifts counterparts. But for 64-bits mul, it might be; // safer to just leave it to compiler runtime implementations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:254,safe,safer,254,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['safe'],['safer']
Safety,// Shifts on vXi64/vXi32 on AVX2 is legal even though we declare to; // customize them to detect the cases where shift amount is a scalar one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:90,detect,detect,90,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['detect'],['detect']
Safety,// Short cut to avoid string find is possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp:16,avoid,avoid,16,interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/PerfReader.cpp,1,['avoid'],['avoid']
Safety,"// Shortcut, if there is only a single predecessor it must be BB and merging; // is always safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:91,safe,safe,91,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['safe'],['safe']
Safety,"// Should we enter the source file? Set to Skip if either the source file is; // known to have no effect beyond its effect on module visibility -- that is,; // if it's got an include guard that is already defined, set to Import if it; // is a modular header we've already built and should import.; // For C++20 Modules; // [cpp.include]/7 If the header identified by the header-name denotes an; // importable header, it is implementation-defined whether the #include; // preprocessing directive is instead replaced by an import directive.; // For this implementation, the translation is permitted when we are parsing; // the Global Module Fragment, and not otherwise (the cases where it would be; // valid to replace an include with an import are highly constrained once in; // named module purview; this choice avoids considerable complexity in; // determining valid cases).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:812,avoid,avoids,812,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['avoid'],['avoids']
Safety,"// Show signatures of constructors as they are declared:; // vector(int n) rather than vector<string>(int n); // This is less noisy without being less clear, and avoids tricky cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:162,avoid,avoids,162,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['avoid'],['avoids']
Safety,// Shrink any sign/zero extends from 32 or smaller to larger than 32 if; // there are sufficient sign bits. Only do this before legalize types to; // avoid creating illegal types in truncate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:150,avoid,avoid,150,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Shrink constant indices if they are larger than 32-bits.; // Only do this before legalize types since v2i64 could become v2i32.; // FIXME: We could check that the type is legal if we're after legalize; // types, but then we would need to construct test cases where that happens.; // FIXME: We could support more than just constant vectors, but we need to; // careful with costing. A truncate that can be optimized out would be fine.; // Otherwise we might only want to create a truncate if it avoids a split.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:496,avoid,avoids,496,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// Shrink in-memory buffers to fit.; // This incurs a copy, but preambles tend to be long-lived.; // Only safe to call once nothing can alias the buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:106,safe,safe,106,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,1,['safe'],['safe']
Safety,// Shuffle mask widening should not interfere with a broadcast opportunity; // by obfuscating the operands with bitcasts.; // TODO: Avoid lowering directly from this top-level function: make this; // a query (canLowerAsBroadcast) and defer lowering to the type-based calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:132,Avoid,Avoid,132,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// Sibcalls are automatically detected tailcalls which do not require; // ABI changes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:30,detect,detected,30,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,2,['detect'],['detected']
Safety,// SignBits may be out-of-sync with Known.countMinSignBits(). Mask out; // high bits of Known.Zero to avoid conflicts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:102,avoid,avoid,102,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['avoid'],['avoid']
Safety,// Signal-safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Signals.cpp:10,safe,safe,10,interpreter/llvm-project/llvm/lib/Support/Signals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Signals.cpp,2,['safe'],['safe']
Safety,"// Signed addition of immediate. If adding a positive immediate; // overflows, the result must be less than zero. If adding a negative; // immediate overflows, the result must be larger than zero (except in; // the special case of adding the minimum value of the result range, in; // which case we cannot predict whether the result is larger than or; // equal to zero).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:305,predict,predict,305,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,1,['predict'],['predict']
Safety,"// Signed integers can be safely byteswapped if they are reinterpret_cast'ed to unsigned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Byteswap.h:26,safe,safely,26,core/base/inc/Byteswap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Byteswap.h,1,['safe'],['safely']
Safety,"// Simple branch support.; // If we can, avoid recomputing the compare - redoing it could lead to wonky; // behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:41,avoid,avoid,41,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['avoid'],['avoid']
Safety,// Simple detection of a call through a block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp:10,detect,detection,10,interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CallGraph.cpp,1,['detect'],['detection']
Safety,// Simple optimization when Cond is a constant to avoid generating; // M68kISD::CMOV if possible.; // TODO: Generalize this to use SelectionDAG::computeKnownBits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp:50,avoid,avoid,50,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Simple sanity check to make sure weights are respected.; // Simple in the sense it only uses 4 non-random datapoints.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx:10,sanity check,sanity check,10,tmva/tmva/test/ROC/testRocWeights.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/ROC/testRocWeights.cxx,1,['sanity check'],['sanity check']
Safety,"// Simplify FMUL recurrences starting with 0.0 to 0.0 if nnan and nsz are set.; // Given a phi node with entry value as 0 and it used in fmul operation,; // we can replace fmul with 0 safely and eleminate loop operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:184,safe,safely,184,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['safe'],['safely']
Safety,"// Simplify the 1-into-3 and 3-into-1 cases with a single pshufd. For all; // such inputs we can swap two of the dwords across the half mark and end up; // with <=2 inputs to each half in each half. Once there, we can fall through; // to the generic code below. For example:; //; // Input: [a, b, c, d, e, f, g, h] -PSHUFD[0,2,1,3]-> [a, b, e, f, c, d, g, h]; // Mask: [0, 1, 2, 7, 4, 5, 6, 3] -----------------> [0, 1, 4, 7, 2, 3, 6, 5]; //; // However in some very rare cases we have a 1-into-3 or 3-into-1 on one half; // and an existing 2-into-2 on the other half. In this case we may have to; // pre-shuffle the 2-into-2 half to avoid turning it into a 3-into-1 or; // 1-into-3 which could cause us to cycle endlessly fixing each side in turn.; // Fortunately, we don't have to handle anything but a 2-into-2 pattern; // because any other situation (including a 3-into-1 or 1-into-3 in the other; // half than the one we target for fixing) will be fixed when we re-enter this; // path. We will also combine away any sequence of PSHUFD instructions that; // result into a single instruction. Here is an example of the tricky case:; //; // Input: [a, b, c, d, e, f, g, h] -PSHUFD[0,2,1,3]-> [a, b, e, f, c, d, g, h]; // Mask: [3, 7, 1, 0, 2, 7, 3, 5] -THIS-IS-BAD!!!!-> [5, 7, 1, 0, 4, 7, 5, 3]; //; // This now has a 1-into-3 in the high half! Instead, we do two shuffles:; //; // Input: [a, b, c, d, e, f, g, h] PSHUFHW[0,2,1,3]-> [a, b, c, d, e, g, f, h]; // Mask: [3, 7, 1, 0, 2, 7, 3, 5] -----------------> [3, 7, 1, 0, 2, 7, 3, 6]; //; // Input: [a, b, c, d, e, g, f, h] -PSHUFD[0,2,1,3]-> [a, b, e, g, c, d, f, h]; // Mask: [3, 7, 1, 0, 2, 7, 3, 6] -----------------> [5, 7, 1, 0, 4, 7, 5, 6]; //; // The result is fine to be handled by the generic logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:634,avoid,avoid,634,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Simplify the argument operand explicitly and check if the result is; // valid in the current scope. This avoids refering to simplified values; // in other functions, e.g., we don't want to say a an argument in a; // static function is actually an argument in a different function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:108,avoid,avoids,108,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['avoid'],['avoids']
Safety,"// SimplifyDemandedBits has the annoying habit of turning useful zero_extends; // in the source into any_extends if the result of the mul is truncated. Since; // we can assume the high bits are whatever we want, use the underlying value; // to avoid the unknown high bits from interfering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:244,avoid,avoid,244,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// Since CTR is a volatile register and current shrinkwrap implementation; // won't choose an MBB in a loop as the PrologMBB, it's safe to synthesize a; // CTR loop to probe.; // Calculate trip count and stores it in CTRReg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:131,safe,safe,131,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['safe'],['safe']
Safety,"// Since MMX types are special and don't usually play with other vector types,; // it's better to handle them early to be sure we emit efficient code by; // avoiding store-load conversions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:157,avoid,avoiding,157,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoiding']
Safety,"// Since ModuleCache takes care of correctness, we try waiting for; // another process to complete the build so clang does not do it done; // twice. If case of timeout, build it ourselves.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:160,timeout,timeout,160,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['timeout'],['timeout']
Safety,"// Since Pseudo instruction lowering happen later in the pipeline,; // this will detect all ret instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp:81,detect,detect,81,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVPushPopOptimizer.cpp,1,['detect'],['detect']
Safety,"// Since SCEVs are immutable, ScalarEvolution allocates operand; // arrays with its SCEVAllocator, so this class just needs a simple; // pointer rather than a more elaborate vector-like data structure.; // This also avoids the need for a non-trivial destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:216,avoid,avoids,216,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,1,['avoid'],['avoids']
Safety,"// Since SETCC_CARRY gives output based on R = CF ? ~0 : 0, it's unsafe to; // simplify it if the result of SETCC_CARRY is not canonicalized to 0 or 1,; // i.e. it's a comparison against true but the result of SETCC_CARRY is not; // truncated to i1 using 'and'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:65,unsafe,unsafe,65,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['unsafe'],['unsafe']
Safety,"// Since SPIR-V cannot represent constant expression, constant expressions; // in LLVM IR need to be lowered to instructions. For each function,; // the constant expressions used by instructions of the function are replaced; // by instructions placed in the entry block since it dominates all other BBs.; // Each constant expression only needs to be lowered once in each function; // and all uses of it by instructions in that function are replaced by; // one instruction.; // TODO: remove redundant instructions for common subexpression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp:490,redund,redundant,490,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegularizer.cpp,1,['redund'],['redundant']
Safety,"// Since StringMap iteration order isn't guaranteed, order by path string; // first.; // FIXME: Make this a vector of StringMapEntry instead to avoid the later; // map lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp:144,avoid,avoid,144,interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp,1,['avoid'],['avoid']
Safety,"// Since cross-section conditional branches to the cold section are rarely; // taken, try to avoid inverting the condition. Instead, add a ""trampoline; // branch"", which unconditionally branches to the branch destination. Place; // the trampoline branch at the end of the function and retarget the; // conditional branch to the trampoline.; // tbz L1; // =>; // tbz L1Trampoline; // ...; // L1Trampoline: b L1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchRelaxation.cpp,1,['avoid'],['avoid']
Safety,"// Since emitPrologue and emitEpilogue will handle spilling and restoring of; // the frame register, we can delete it from CSI list and not have to worry; // about avoiding it later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp:164,avoid,avoiding,164,interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kFrameLowering.cpp,2,['avoid'],['avoiding']
Safety,"// Since glibc 2.34, the installed .so file is not symlink anymore. But we can; // still safely assume it's newer than 2.32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp:89,safe,safely,89,interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/PPCLinux.cpp,1,['safe'],['safely']
Safety,"// Since linkers are allowed to clobber R12 on function calls, the above; // mitigation only works if the original indirect call instruction was not; // using R12. Code generation before must make sure that no indirect call; // using R12 was produced if the mitigation is enabled.; // Also, the transformation is incorrect if the indirect call uses LR, so; // also have to avoid that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp:373,avoid,avoid,373,interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMSLSHardening.cpp,1,['avoid'],['avoid']
Safety,"// Since loop passes like SCEV are allowed to key analysis results off of; // `Loop` pointers, we cannot re-use pointers within a loop pass manager.; // This means loop passes should not be `delete` ing `Loop` objects directly; // (and risk a later `Loop` allocation re-using the address of a previous one); // but should be using LoopInfo::markAsRemoved, which keeps around the `Loop`; // pointer till the end of the lifetime of the `LoopInfo` object.; //; // To make it easier to follow this rule, we mark the destructor as; // non-public.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h:236,risk,risk,236,interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericLoopInfo.h,1,['risk'],['risk']
Safety,"// Since lowerConstant already folded and got rid of all IR pointer and; // integer casts, detect GOT equivalent accesses by looking into the MCExpr; // directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:91,detect,detect,91,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['detect'],['detect']
Safety,"// Since pointer argument are never emitted as LValue, it is safe to emit; // non-null argument check for r-value only.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:61,safe,safe,61,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['safe'],['safe']
Safety,"// Since shift produces a poison value if RHS is equal to or larger than the; // bit width, we can safely assume that RHS is less than the bit width.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:99,safe,safely,99,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['safe'],['safely']
Safety,"// Since the NBits is identical for all shifts, if the outermost and; // innermost shifts are identical, then outermost shifts are redundant.; // If we had truncation, do keep it though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:131,redund,redundant,131,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,1,['redund'],['redundant']
Safety,"// Since the cached buffer is reused, it is safe to close the file; // descriptor that was opened while stat()ing the PCM in; // lookupModuleFile() above, it won't be needed any longer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp:44,safe,safe,44,interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ModuleManager.cpp,1,['safe'],['safe']
Safety,"// Since the user does not want this branch to be loaded anyway, we just; // skip it. This prevents us from warning the user that the method might; // be on a disabled branch. However, and more usefully, this allows the; // user to avoid error messages from branches that cannot be currently; // read without warnings/errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:232,avoid,avoid,232,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['avoid'],['avoid']
Safety,"// Since we allow local split results to be split again, there is a risk of; // creating infinite loops. It is tempting to require that the new live; // ranges have less instructions than the original. That would guarantee; // convergence, but it is too strict. A live range with 3 instructions can be; // split 2+3 (including the COPY), and we want to allow that.; //; // Instead we use these rules:; //; // 1. Allow any split for ranges with getStage() < RS_Split2. (Except for the; // noop split, of course).; // 2. Require progress be made for ranges with getStage() == RS_Split2. All; // the new ranges must have fewer instructions than before the split.; // 3. New ranges with the same number of instructions are marked RS_Split2,; // smaller ranges are marked RS_New.; //; // These rules allow a 3 -> 2+3 split once, which we need. They also prevent; // excessive splitting and infinite loops.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:68,risk,risk,68,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['risk'],['risk']
Safety,"// Since we are not checking for AA here, conservatively abort if the chain; // writes to memory. It's not safe to move the callee (a load) across a store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:57,abort,abort,57,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,"['abort', 'safe']","['abort', 'safe']"
Safety,"// Since we can assume the conversion won't overflow, our decision as to; // whether the input will fit in the float should depend on the minimum; // of the input range and output range.; // This means this is also safe for a signed input and unsigned output, since; // a negative input would lead to undefined behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:215,safe,safe,215,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['safe'],['safe']
Safety,"// Since we clobber the destination of a copy, the semantic of Src's; // ""DefRegs"" to contain Def is no longer effectual. We will also need; // to remove the record from the copy maps that indicates Src defined; // Def. Failing to do so might cause the target to miss some; // opportunities to further eliminate redundant copy instructions.; // Consider the following sequence during the; // ForwardCopyPropagateBlock procedure:; // L1: r0 = COPY r9 <- TrackMI; // L2: r0 = COPY r8 <- TrackMI (Remove r9 defined r0 from tracker); // L3: use r0 <- Remove L2 from MaybeDeadCopies; // L4: early-clobber r9 <- Clobber r9 (L2 is still valid in tracker); // L5: r0 = COPY r8 <- Remove NopCopy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:312,redund,redundant,312,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['redund'],['redundant']
Safety,"// Since we have been stripping underscores to avoid trampling on the; // reserved namespace, we may have inadvertently created duplicate; // enumerant names. These duplicates are not considered part of the; // semantic spelling, and can be elided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:47,avoid,avoid,47,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['avoid'],['avoid']
Safety,"// Since we have no exact knowledge of code layout, allow some safety buffer; // for jump target. This is measured in bytes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp:63,safe,safety,63,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonBranchRelaxation.cpp,1,['safe'],['safety']
Safety,"// Since we know that this either implicit int (which is rare) or an; // error, do lookahead to try to do better recovery. This never applies; // within a type specifier. Outside of C++, we allow this even if the; // language doesn't ""officially"" support implicit int -- we support; // implicit int as an extension in some language modes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:113,recover,recovery,113,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recovery']
Safety,"// Since we may have split edges and changed the number of successors,; // normalize the probabilities. This avoids doing it each time we split an; // edge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:109,avoid,avoids,109,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['avoid'],['avoids']
Safety,"// Since we'll be extending the live range of Rt in the following example,; // make sure that is safe. another definition of Rt doesn't exist between 'add'; // and load/store instruction.; //; // Ex: Rx= add(Rt,#10); // memw(Rx+#0) = Rs; // will be replaced with => memw(Rt+#10) = Rs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp:97,safe,safe,97,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptAddrMode.cpp,1,['safe'],['safe']
Safety,// Single liverange (used to avoid creation of LiveIntervalUnion).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp:29,avoid,avoid,29,interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackSlotColoring.cpp,1,['avoid'],['avoid']
Safety,// Single-bit booleans don't need to be checked. Special-case this to avoid; // a bit width mismatch when handling bitfield values. This is handled by; // EmitFromMemory for the non-bitfield case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:70,avoid,avoid,70,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['avoid'],['avoid']
Safety,"// Single-element vectors are scalarized, so we should generally avoid having; // any memory operations on such types, as they would get scalarized too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp:65,avoid,avoid,65,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringBase.cpp,1,['avoid'],['avoid']
Safety,// Sink expensive instructions into the conditional blocks to avoid executing; // them speculatively.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:62,avoid,avoid,62,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"// Skip ObjCMethodDecl, wait for the objc container to avoid; // analyzing twice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:55,avoid,avoid,55,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,1,['avoid'],['avoid']
Safety,"// Skip any function with unreachable blocks. It's somewhat difficult to; // avoid producing invalid IR without deleting them.; //; // We also do not want to unconditionally delete them, as doing so would; // break the invariant of changing the number of chunks during counting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceBasicBlocks.cpp:77,avoid,avoid,77,interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceBasicBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/deltas/ReduceBasicBlocks.cpp,1,['avoid'],['avoid']
Safety,"// Skip any whitespaces starting from CurPtr. The method is used; // only in the lines-skipping mode to find the first non-whitespace; // symbol after or at CurPtr. Allowed whitespaces are ' ', '\t', '\n'; // and '\r'. The method skips C-style comments as well, because; // it is used to find the beginning of the preprocessing directive.; // If we do not handle C-style comments the following code would; // result in incorrect detection of a preprocessing directive:; // /*; // #ifdef NAME; // */; // As long as we skip C-style comments, the following code is correctly; // recognized as a preprocessing directive:; // /* first line comment; // second line comment */ #ifdef NAME; //; // The method returns true upon reaching the first non-whitespace symbol; // or EOF, CurPtr is set to point to this symbol. The method returns false,; // if an error occurred during skipping of a C-style comment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h:429,detect,detection,429,interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TableGen/TGLexer.h,1,['detect'],['detection']
Safety,// Skip code until we get to #endif. This helps with recovery by not; // emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,recover,recovery,53,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['recover'],['recovery']
Safety,// Skip code until we get to #endif. This helps with recovery by; // not emitting an error when the #endif is reached.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp:53,recover,recovery,53,interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPDirectives.cpp,1,['recover'],['recovery']
Safety,"// Skip functions that are not address taken, to avoid bloating the table",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:49,avoid,avoid,49,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['avoid'],['avoid']
Safety,"// Skip if any of the ExitBlocks contains a ret instruction.; // This is to prevent dumping of incomplete profile -- if the; // the loop is a long running loop and dump is called in the middle; // of the loop, the result profile is incomplete.; // FIXME: add other heuristics to detect long running loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:279,detect,detect,279,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['detect'],['detect']
Safety,"// Skip if the incoming block is the current BB for now. Also, bypass; // unreachable IR for efficiency and to avoid crashing.; // TODO: Collect the skipped incoming values and try to vectorize them; // after processing BB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:111,avoid,avoid,111,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// Skip mapping symbols to avoid possible ambiguity as they; // do not allow uniquely identifying the target address.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,1,['avoid'],['avoid']
Safety,// Skip over any whitespace we see here; we're looking for; // another bit of interesting text.; // FIXME: Detect non-ASCII whitespace characters too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:107,Detect,Detect,107,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,2,['Detect'],['Detect']
Safety,// Skip redundant include stacks altogether.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp:8,redund,redundant,8,interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DiagnosticRenderer.cpp,1,['redund'],['redundant']
Safety,// Skip the Slerp for tiny steps to avoid numeric problems:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:36,avoid,avoid,36,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// Skip the entire loop if we don't meet the precondition.; // If the condition constant folds and can be elided, avoid emitting the; // whole loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:114,avoid,avoid,114,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,2,['avoid'],['avoid']
Safety,"// Skip the first (value) operand to a store instruction (except if the store; // offset is zero) in order to avoid an incorrect transformation.; // e.g. sd a0, 808(a0) to addi a2, a0, 768; sd a2, 40(a2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp:110,avoid,avoid,110,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMakeCompressible.cpp,1,['avoid'],['avoid']
Safety,"// Skip the switch body.; // FIXME: This is not optimal recovery, but parsing the body is more; // dangerous due to the presence of case and default statements, which; // will have no place to connect back with the switch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:56,recover,recovery,56,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['recover'],['recovery']
Safety,"// Skip the symbols which are part of the C/C++ runtime and have a; // fixed library version. See binutils ld VERSION. Those reside in; // 'system' libraries, which we avoid in FindLibraryForSymbol.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:168,avoid,avoid,168,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avoid'],['avoid']
Safety,// Skip to end of block or statement to avoid ext-warning on extra ';'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:40,avoid,avoid,40,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['avoid'],['avoid']
Safety,// Skip token for error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp:24,recover,recovery,24,interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/BuildingAJIT/Chapter1/toy.cpp,54,['recover'],['recovery']
Safety,// Skipping the check for SP writes in the base implementation. The reason it; // was added was apparently due to compile time concerns.; //; // TODO: Do we really want this barrier? It triggers unnecessary hazard nops; // but is probably avoidable.; // Copied from base implementation.; // Terminators and labels can't be scheduled around.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:207,hazard,hazard,207,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,2,"['avoid', 'hazard']","['avoidable', 'hazard']"
Safety,"// Small helper to match special cases in range-for loops.; //; // It is possible that containers do not provide a const-overload for their; // iterator accessors. If this is the case, the variable is used non-const; // no matter what happens in the loop. This requires special detection as it; // is then faster to find all mutations of the loop variable.; // It aims at a different modification as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp:278,detect,detection,278,interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ExprMutationAnalyzer.cpp,1,['detect'],['detection']
Safety,"// So we can 'and' all the checks together, and still get 'false',; // if at least one of the checks detected an issue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp:101,detect,detected,101,interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprScalar.cpp,1,['detect'],['detected']
Safety,"// Solve for the ""predictions""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:18,predict,predictions,18,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['predict'],['predictions']
Safety,"// Some compiler-generated accesses are known racy, to avoid false positives; // in data-race analysis pretend they're atomic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:55,avoid,avoid,55,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,1,['avoid'],['avoid']
Safety,"// Some early-returns here to avoid the search if we deleted the node or; // if the update comes from MorphNodeTo (MorphNodeTo is the last thing we; // do, so it's unnecessary to update matching state at that point).; // Neither of these can occur currently because we only install this; // update listener during matching a complex patterns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:30,avoid,avoid,30,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['avoid'],['avoid']
Safety,"// Some formulas are instant losers. For example, they may depend on; // nonexistent AddRecs from other loops. These need to be filtered; // immediately, otherwise heuristics could choose them over others leading; // to an unsatisfactory solution. Passing LoserRegs into RateFormula here; // avoids the need to recompute this information across formulae using the; // same bad AddRec. Passing LoserRegs is also essential unless we remove; // the corresponding bad register from the Regs set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:292,avoid,avoids,292,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['avoid'],['avoids']
Safety,"// Some hack to avoid const-ness",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TEmulatedCollectionProxy.h:16,avoid,avoid,16,io/io/inc/TEmulatedCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TEmulatedCollectionProxy.h,1,['avoid'],['avoid']
Safety,"// Some hack to avoid const-ness.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h:16,avoid,avoid,16,io/io/inc/TGenCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TGenCollectionProxy.h,1,['avoid'],['avoid']
Safety,"// Some instructions can be handled but are rejected above. Catch; // those cases by falling through to here.; // TODO: Mark globals as being constant earlier, so; // TODO: wouldInstructionBeTriviallyDead() knows that atomic loads; // TODO: are safe to remove.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:245,safe,safe,245,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,1,['safe'],['safe']
Safety,"// Some instructions can be ignored even if they read or write memory.; // Detect these now, skipping to the next instruction if one is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:75,Detect,Detect,75,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['Detect'],['Detect']
Safety,"// Some instructions may declare a number of uOps which exceeds the size; // of the reorder buffer. To avoid problems, cap the amount of slots to; // the size of the reorder buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h:103,avoid,avoid,103,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/RetireControlUnit.h,1,['avoid'],['avoid']
Safety,"// Some instructions which ""load"" are trivially safe or unimportant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:48,safe,safe,48,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['safe'],['safe']
Safety,"// Some interesting folding opportunity is present, so its worthwhile to; // re-generate the operands list. Group the operands by constant scale,; // to avoid multiplying by the same constant scale multiple times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:153,avoid,avoid,153,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,// Some left shift instructions can be turned into LEA instructions but only; // if their flags aren't used. Avoid transforming such instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:109,Avoid,Avoid,109,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['Avoid'],['Avoid']
Safety,"// Some loads of floating point data have implicit defs/uses on a; // super register of that floating point data. Some examples:; // $s0 = LDRSui $sp, 22, implicit-def $q0; // $q0 = LD1i64 $q0, 1, renamable $x0; // We need to filter out these uses for non-GPR register which occur; // because the load partially fills a non-GPR register with the loaded; // data. Just skipping all non-GPR registers is safe (for now) as all; // AArch64 load instructions only use GPR registers to perform the; // address calculation. FIXME: However that might change once we can; // produce SVE gather instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp:402,safe,safe,402,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SpeculationHardening.cpp,1,['safe'],['safe']
Safety,"// Some mask scalar intrinsics rely on checking if only one bit is set; // and implement it in C code like this:; // A[0] = (U & 1) ? A[0] : W[0];; // This creates some redundant instructions that break pattern matching.; // fold (select (setcc (and (X, 1), 0, seteq), Y, Z)) -> select(and(X, 1),Z,Y)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:169,redund,redundant,169,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['redund'],['redundant']
Safety,// Some of the following optimization can safely work on the unfrozen cond.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:42,safe,safely,42,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['safe'],['safely']
Safety,"// Some of the function template arguments cannot be deduced from a; // function call, so we introduce an explicit template argument list; // containing all of the arguments up to the first deducible argument.; //; // Or, if this isn't a call, emit all the template arguments; // to disambiguate the (potential) overloads.; //; // FIXME: Detect cases where the function parameters can be deduced from; // the surrounding context, as per [temp.deduct.funcaddr].; // e.g.,; // template <class T> void foo(T);; // void (*f)(int) = foo;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:338,Detect,Detect,338,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['Detect'],['Detect']
Safety,"// Some of the users, e.g. CloneFunctionInto / CloneModule, need to set up a; // ValueMap containing identity mappings for all of the DICompileUnit's, not; // just DISubprogram's, referenced from anywhere within the Function being; // cloned prior to calling MapMetadata / RemapInstruction to avoid their; // duplication later as DICompileUnit's are also directly referenced by; // llvm.dbg.cu list. Thefore we need to collect DICompileUnit's here as well.; // Also, DICompileUnit's may reference DISubprogram's too and therefore need; // to be at least looked through.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:293,avoid,avoid,293,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['avoid'],['avoid']
Safety,"// Some subtargets cannot do an AGPR to AGPR copy directly, and need an; // intermdiate temporary VGPR register. Try to find the defining; // accvgpr_write to avoid temporary registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNPreRAOptimizations.cpp:159,avoid,avoid,159,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNPreRAOptimizations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNPreRAOptimizations.cpp,1,['avoid'],['avoid']
Safety,"// Some transformations (e.g. instcombine) may decide to turn a Fortran; // character object into an integer, and later ones (e.g. SROA) may; // further inject a constant integer in a llvm.dbg.value call to track; // the object's value. Here we trust the transformations are doing the; // right thing, and treat the constant as unsigned to preserve that value; // (i.e. avoid sign extension).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp:370,avoid,avoid,370,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DebugHandlerBase.cpp,1,['avoid'],['avoid']
Safety,"// Some users (such as 3-operand FMA/MAD) must use a VOP3 encoding, and thus; // it is truly free to use a source modifier in all cases. If there are; // multiple users but for each one will necessitate using VOP3, there will be; // a code size increase. Try to avoid increasing code size unless we know it; // will save on the instruction count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCombinerHelper.cpp:262,avoid,avoid,262,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCombinerHelper.cpp,2,['avoid'],['avoid']
Safety,"// Some vregs can be deleted as redundant in the meantime. Mark those; // as DBG_VALUE $noreg. Additionally, some normal instructions are; // quickly deleted, leaving dangling references to vregs with no def.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp:32,redund,redundant,32,interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineFunction.cpp,1,['redund'],['redundant']
Safety,"// Some zexts will now have become redundant, along with their trunc; // operands, so remove them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:35,redund,redundant,35,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,1,['redund'],['redundant']
Safety,// Something does not match: abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:29,abort,abort,29,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['abort'],['abort']
Safety,// Something has changed. It's no longer safe to predicate these blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:41,safe,safe,41,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['safe'],['safe']
Safety,// Something has changed. It's no longer safe to predicate this block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:41,safe,safe,41,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,2,['safe'],['safe']
Safety,"// Something has gone wrong, abort",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp:29,abort,abort,29,interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MVEGatherScatterLowering.cpp,1,['abort'],['abort']
Safety,"// Something's wrong if the path starts with ""\..\"", abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:53,abort,abort,53,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['abort'],['abort']
Safety,"// Something's wrong, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:22,abort,abort,22,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['abort'],['abort']
Safety,"// Sometime a null pointer can look an int, avoid complaining in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:44,avoid,avoid,44,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['avoid'],['avoid']
Safety,"// Sometimes a dynamic alloca could be converted into a static alloca; // after this constant prop, and become a huge static alloca on an; // unconditional CFG path. Avoid inlining if this is going to happen above; // a threshold.; // FIXME: If the threshold is removed or lowered too much, we could end up; // being too pessimistic and prevent inlining non-problematic code. This; // could result in unintended perf regressions. A better overall strategy; // is needed to track stack usage during inlining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:166,Avoid,Avoid,166,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['Avoid'],['Avoid']
Safety,"// Sometimes in a loop we have a branch whose condition is made false by; // taking it. This is typically something like; // int n = 0;; // while (...) {; // if (++n >= MAX) {; // n = 0;; // }; // }; // In this sort of situation taking the branch means that at the very least it; // won't be taken again in the next iteration of the loop, so we should; // consider it less likely than a typical branch.; //; // We detect this by looking back through the graph of PHI nodes that sets the; // value that the condition depends on, and seeing if we can reach a successor; // block which can be determined to make the condition false.; //; // FIXME: We currently consider unlikely blocks to be half as likely as other; // blocks, but if we consider the example above the likelyhood is actually; // 1/MAX. We could therefore be more precise in how unlikely we consider; // blocks to be, but it would require more careful examination of the form; // of the comparison expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:414,detect,detect,414,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,1,['detect'],['detect']
Safety,// Sort all the case ranges by their low value so we can easily detect; // overlaps between ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:64,detect,detect,64,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['detect'],['detect']
Safety,// Sort all the scalar case values so we can easily detect duplicates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:52,detect,detect,52,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['detect'],['detect']
Safety,"// Sort by (Addr,Size,Name). If several SymbolDescs share the same Addr,; // pick the one with the largest Size. This helps us avoid symbols with no; // size information (Size=0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp:127,avoid,avoid,127,interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/Symbolize/SymbolizableObjectFile.cpp,1,['avoid'],['avoid']
Safety,"// Sort here, so we handle the features in a predictable order. (This matters; // when we're dealing with features that overlap.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp:45,predict,predictable,45,interpreter/llvm-project/clang/lib/Basic/Targets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets.cpp,1,['predict'],['predictable']
Safety,// Sort options by key to avoid relying on StringMap iteration order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:26,avoid,avoid,26,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['avoid'],['avoid']
Safety,// Sort to detect continuous offsets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:11,detect,detect,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['detect'],['detect']
Safety,"// Source is used to lookup the value + expression in the debug program if; // the stack slot gets assigned a value earlier than expected. Because; // we're only tracking the one dbg.assign, we can't capture debug PHIs.; // It's unlikely that we're losing out on much coverage by avoiding that; // extra work.; // The Source may differ in this situation:; // Pred.1:; // dbg.assign i32 0, ..., !1, ...; // Pred.2:; // dbg.assign i32 1, ..., !1, ...; // Here the same assignment (!1) was performed in both preds in the source,; // but we can't use either one unless they are identical (e.g. .we don't; // want to arbitrarily pick between constant values).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:280,avoid,avoiding,280,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['avoid'],['avoiding']
Safety,"// Special case 1, all registers used by ISEL are the same one.; // The non-redundant isel 0, 0, 0, N would not satisfy these conditions; // as it would be ISEL %R0, %ZERO, %R0, %CRN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:76,redund,redundant,76,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,1,['redund'],['redundant']
Safety,"// Special case 2, the two input registers used by ISEL are the same.; // Note: the non-foldable isel RX, 0, 0, N would not satisfy this; // condition as it would be ISEL %RX, %ZERO, %R0, %CRN, which makes it; // safe to fold ISEL to MR(OR) instead of ADDI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp:213,safe,safe,213,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCExpandISEL.cpp,1,['safe'],['safe']
Safety,"// Special case for a select of 2 constants that have a diffence of 1.; // Normally this is done by DAGCombine, but if the select is introduced by; // type legalization or op legalization, we miss it. Restricting to SETLT; // case for now because that is what signed saturating add/sub need.; // FIXME: We don't need the condition to be SETLT or even a SETCC,; // but we would probably want to swap the true/false values if the condition; // is SETGE/SETLE to avoid an XORI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:460,avoid,avoid,460,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Special case for calculating (mul (and X, C2), C1) where the full product; // fits in XLen bits. We can shift X left by the number of leading zeros in; // C2 and shift C1 left by XLen-lzcnt(C2). This will ensure the final; // product has XLen trailing zeros, putting it in the output of MULHU. This; // can avoid materializing a constant in a register for C2.; // RHS should be a constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:310,avoid,avoid,310,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,// Special case for s_fmac_f32 if we are trying to fold into Src0 or Src1.; // By changing into fmamk we can untie Src2.; // If folding for Src0 happens first and it is identical operand to Src1 we; // should avoid transforming into fmamk which requires commuting as it would; // cause folding into Src1 to fail later on due to wrong OpNo used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:209,avoid,avoid,209,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['avoid'],['avoid']
Safety,"// Special case i386/ppc ObjC data structures in magic sections:; // The issue is that the old ObjC object format did some strange; // contortions to avoid real linker symbols. For instance, the; // ObjC class data structure is allocated statically in the executable; // that defines that class. That data structures contains a pointer to; // its superclass. But instead of just initializing that part of the; // struct to the address of its superclass, and letting the static and; // dynamic linkers do the rest, the runtime works by having that field; // instead point to a C-string that is the name of the superclass.; // At runtime the objc initialization updates that pointer and sets; // it to point to the actual super class. As far as the linker; // knows it is just a pointer to a string. But then someone wanted the; // linker to issue errors at build time if the superclass was not found.; // So they figured out a way in mach-o object format to use an absolute; // symbols (.objc_class_name_Foo = 0) and a floating reference; // (.reference .objc_class_name_Bar) to cause the linker into erroring when; // a class was missing.; // The following synthesizes the implicit .objc_* symbols for the linker; // from the ObjC data structures generated by the front end.; // special case if this data blob is an ObjC class definition",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp:150,avoid,avoid,150,interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTOModule.cpp,1,['avoid'],['avoid']
Safety,"// Special case std::pair to detect when both types are viable and when there; // is no alignment-derived padding in the pair. This is a bit of a lie because; // std::pair isn't truly POD, but it's close enough in all reasonable; // implementations for our use case of hashing the underlying data.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:29,detect,detect,29,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['detect'],['detect']
Safety,// Special case that we cannot easily detect in RetCC_SystemZ since; // i128 may not be a legal type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:38,detect,detect,38,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['detect'],['detect']
Safety,"// Special case. See if we can build the constant as (ADD (SLLI X, C), X) do; // that if it will avoid a constant pool.; // It will require an extra temporary register though.; // If we have Zba we can use (ADD_UW X, (SLLI X, 32)) to handle cases where; // low and high 32 bits are the same and bit 31 and 63 are set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:97,avoid,avoid,97,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Special case: check for comparisons against literals that can be exactly; // represented by APFloat. In such cases, do not emit a warning. This; // is a heuristic: often comparison against such literals are used to; // detect if a value in a variable has not changed. This clearly can; // lead to false negatives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:222,detect,detect,222,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['detect'],['detect']
Safety,"// Special case: uaddo X, 1 overflowed if X+1 == 0. We can detect this; // with (Lo | Hi) == 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp:59,detect,detect,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp,1,['detect'],['detect']
Safety,"// Special handing of DIArgList is required in the RemoveDIs project, see; // commentry in DIArgList::handleChangedOperand for details. Hidden behind; // conditional compilation to avoid a compile time regression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp:181,avoid,avoid,181,interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Metadata.cpp,1,['avoid'],['avoid']
Safety,// Special handling of FunctionDecl to avoid de-serializing the body from PCH.; // FunctionDecl stores EndRangeLoc for this purpose.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp:39,avoid,avoid,39,interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclBase.cpp,1,['avoid'],['avoid']
Safety,// Special optimizations to the combination of ext and trunc.; // (ext ... (select ... (trunc ...))) is safe to avoid truncate here; // since this truncate instruction clears higher 32 bits which is filled; // by one of ext instructions later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp:104,safe,safe,104,interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelLowering.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// Special type for the hook to the TSlave constructor, needed to avoid; // using the plugin manager",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TSlave.h:66,avoid,avoid,66,proof/proof/inc/TSlave.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TSlave.h,1,['avoid'],['avoid']
Safety,"// Special type for the hook to the TXProofServ constructor, needed to avoid; // using the plugin manager",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/src/pmain.cxx:71,avoid,avoid,71,main/src/pmain.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/src/pmain.cxx,1,['avoid'],['avoid']
Safety,// Special value means that no detection was performed yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Distro.h:31,detect,detection,31,interpreter/llvm-project/clang/include/clang/Driver/Distro.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Distro.h,1,['detect'],['detection']
Safety,"// Special-case Step of one. Potentially-costly `umul_with_overflow` isn't; // needed, there is never an overflow, so to avoid artificially inflating; // the cost of the check, directly emit the optimized IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:121,avoid,avoid,121,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['avoid'],['avoid']
Safety,// Specializations of `addPass` for `RepeatedPass`. These are necessary since; // `RepeatedPass` has a templated `run` method that will result in incorrect; // detection of `HasRunOnLoopT`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:160,detect,detection,160,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,1,['detect'],['detection']
Safety,// Specialize FoldingSetTrait for SCEV to avoid needing to compute; // temporary FoldingSetNodeID values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:42,avoid,avoid,42,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['avoid'],['avoid']
Safety,// Specialize FoldingSetTrait for SCEVPredicate to avoid needing to compute; // temporary FoldingSetNodeID values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:51,avoid,avoid,51,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['avoid'],['avoid']
Safety,"// Splats don't change the order, so can be safely ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:44,safe,safely,44,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['safe'],['safely']
Safety,// Split a store of a VMOVDRR into two integer stores to avoid mixing NEON and; // ARM stores of arguments in the same cache line.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:57,avoid,avoid,57,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Split indirectbr critical edges here before computing the MST rather than; // later in getInstrBB() to avoid invalidating it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:106,avoid,avoid,106,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,1,['avoid'],['avoid']
Safety,// Split indirectbr critical edges here before computing the MST rather; // than later in getInstrBB() to avoid invalidating it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:106,avoid,avoid,106,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,2,['avoid'],['avoid']
Safety,// Split locations referring to OldReg. Iterate backwards so splitLocation can; // safely erase unused locations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:83,safe,safely,83,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['safe'],['safely']
Safety,// Split out cold code. Splitting is done late to avoid hiding context from; // other optimizations and inadvertently regressing performance. The tradeoff; // is that this has a higher code size cost than splitting early.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:50,avoid,avoid,50,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['avoid'],['avoid']
Safety,"// Split the VirtReg may generate COPY instructions in multiple cold basic; // blocks, and increase code size. So we avoid it when the function is; // optimized for size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp:117,avoid,avoid,117,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocGreedy.cpp,1,['avoid'],['avoid']
Safety,"// Split the preheader, so that we know that there is a safe place to insert; // the conditional branch. We will change the preheader to have a conditional; // branch on LoopCond.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:56,safe,safe,56,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['safe'],['safe']
Safety,"// Split the preheader, so that we know that there is a safe place to insert; // the conditional branch. We will change the preheader to have a conditional; // branch on LoopCond. The original preheader will become the split point; // between the unswitched versions, and we will have a new preheader for the; // original loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:56,safe,safe,56,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['safe'],['safe']
Safety,"// Split the preheader, so that we know that there is a safe place to insert; // the switch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:56,safe,safe,56,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['safe'],['safe']
Safety,"// Split unaligned 16B stores. They are terrible for performance.; // Don't split stores with alignment of 1 or 2. Code that uses clang vector; // extensions can use this to mark that it does not want splitting to happen; // (by underspecifying alignment to be 1 or 2). Furthermore, the chance of; // eliminating alignment hazards is only 1 in 8 for alignment of 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:323,hazard,hazards,323,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['hazard'],['hazards']
Safety,"// Splitting a normal class.; // FIXME: We are eliding the class we are splitting here,; // i.e., we do not create a branch for it, so the; // branch hierarchy does not match the class hierarchy.; // Note: clParent is the class which contains a data member of; // the class type which we are splitting.; // Note: We can use parent class (clParent) != branch class (elemClass) to detection elision.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:379,detect,detection,379,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['detect'],['detection']
Safety,"// Splitting is required to support out parameters,; // as out parameters might be created only on the ""success"" branch.; // We want to avoid eagerly splitting unless out parameters are actually; // needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp:136,avoid,avoid,136,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.cpp,1,['avoid'],['avoid']
Safety,// Splitting the attributes into a BeforeJam and an AfterJam part will; // stop 'llvm.loop.isvectorized' (generated by vectorization in BeforeJam); // to be forwarded to the AfterJam part. We detect the situation here and; // add it manually.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.cpp:192,detect,detect,192,interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGLoopInfo.cpp,1,['detect'],['detect']
Safety,// SpvScalConst should be created before SpvVecConst to avoid undefined ID; // error on validation.; // TODO: can moved below once sorting of types/consts/defs is implemented.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp:56,avoid,avoid,56,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVGlobalRegistry.cpp,1,['avoid'],['avoid']
Safety,// Squelch any detected load of an uninitialized value if; // we cast it to void.; // e.g. (void) x;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:15,detect,detected,15,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,1,['detect'],['detected']
Safety,// Stack information never change in safe points! Only print info from the; // first call-site.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp:37,safe,safe,37,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/ErlangGCPrinter.cpp,1,['safe'],['safe']
Safety,"// Standard scheduler algorithms will recompute the depth of the successor; // here as such:; // SuccSU->setDepthToAtLeast(SU->getDepth() + SuccEdge->getLatency());; //; // However, we lazily compute node depth instead. Note that; // ScheduleNodeTopDown has already updated the depth of this node which causes; // all descendents to be marked dirty. Setting the successor depth explicitly; // here would cause depth to be recomputed for all its ancestors. If the; // successor is not yet ready (because of a transitively redundant edge) then; // this causes depth computation to be quadratic in the size of the DAG.; // If all the node's predecessors are scheduled, this node is ready; // to be scheduled. Ignore the special ExitSU node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:521,redund,redundant,521,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,1,['redund'],['redundant']
Safety,"// Start by generating ""pessimistic"" code that explicitly loads the function; // pointer from the vtable and performs the type check. If possible, we will; // eliminate the load and the type check later.; // If possible, only generate the load at the point where it is used.; // This helps avoid unnecessary spills.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:290,avoid,avoid,290,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['avoid'],['avoid']
Safety,// Start with the highest factor to avoid combining and recombining.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['avoid'],['avoid']
Safety,// StartPt points to the first place where all unsafe registers; // are dead (if there is any such point). Begin partitioning the MBB into; // ranges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:47,unsafe,unsafe,47,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['unsafe'],['unsafe']
Safety,"// Starting with a code fragment like:; //; // test %rax, %rax; // jne LblNotNull; //; // LblNull:; // callq throw_NullPointerException; //; // LblNotNull:; // Inst0; // Inst1; // ...; // Def = Load (%rax + <offset>); // ...; //; //; // we want to end up with; //; // Def = FaultingLoad (%rax + <offset>), LblNull; // jmp LblNotNull ;; explicit or fallthrough; //; // LblNotNull:; // Inst0; // Inst1; // ...; //; // LblNull:; // callq throw_NullPointerException; //; //; // To see why this is legal, consider the two possibilities:; //; // 1. %rax is null: since we constrain <offset> to be less than PageSize, the; // load instruction dereferences the null page, causing a segmentation; // fault.; //; // 2. %rax is not null: in this case we know that the load cannot fault, as; // otherwise the load would've faulted in the original program too and the; // original program would've been undefined.; //; // This reasoning cannot be extended to justify hoisting through arbitrary; // control flow. For instance, in the example below (in pseudo-C); //; // if (ptr == null) { throw_npe(); unreachable; }; // if (some_cond) { return 42; }; // v = ptr->field; // LD; // ...; //; // we cannot (without code duplication) use the load marked ""LD"" to null check; // ptr -- clause (2) above does not apply in this case. In the above program; // the safety of ptr->field can be dependent on some_cond; and, for instance,; // ptr could be some non-null invalid reference that never gets loaded from; // because some_cond is always true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:1341,safe,safety,1341,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['safe'],['safety']
Safety,"// Stash the value of the frame pointer relative to the base pointer for; // Win32 EH. This supports Win32 EH, which does the inverse of the above:; // it recovers the frame pointer from the base pointer rather than the; // other way around.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:155,recover,recovers,155,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['recover'],['recovers']
Safety,"// State internal to DAG building.; // -------------------------------; /// Defs, Uses - Remember where defs and uses of each register are as we; /// iterate upward through the instructions. This is allocated here instead; /// of inside BuildSchedGraph to avoid the need for it to be initialized and; /// destructed for each block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:256,avoid,avoid,256,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['avoid'],['avoid']
Safety,"// Static archives can contain multiple object files with identical names, in; // which case the timestamp is used to disambiguate. However, if both are; // identical, there's no way to tell them apart. Detect this and skip; // duplicate debug map objects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp:203,Detect,Detect,203,interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/MachODebugMapParser.cpp,1,['Detect'],['Detect']
Safety,"// Static indexing does not lower to stack access, and hence there is no need; // for special custom lowering to avoid stack access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:113,avoid,avoid,113,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Statically check that the array bounds are in-range. The first subscript we; // don't have a size for and it cannot overflow into another subscript, so is; // always safe. The others need to be 0 <= subscript[i] < bound, for both src; // and dst.; // FIXME: It may be better to record these sizes and add them as constraints; // to the dependency checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:169,safe,safe,169,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['safe'],['safe']
Safety,"// Status kind is basically the main part of parameter's status.; // The kind represents our knowledge (so far) about a tracked parameter; // in the context of this analysis.; //; // Since we want to report on missing and extraneous calls, we need to; // track the fact whether paramater was called or not. This automatically; // decides two kinds: `NotCalled` and `Called`.; //; // One of the erroneous situations is the case when parameter is called only; // on some of the paths. We could've considered it `NotCalled`, but we want; // to report double call warnings even if these two calls are not guaranteed; // to happen in every execution. We also don't want to have it as `Called`; // because not calling tracked parameter on all of the paths is an error; // on its own. For these reasons, we need to have a separate kind,; // `MaybeCalled`, and change `Called` to `DefinitelyCalled` to avoid; // confusion.; //; // Two violations of calling parameter more than once and not calling it on; // every path are not, however, mutually exclusive. In situations where both; // violations take place, we prefer to report ONLY double call. It's always; // harder to pinpoint a bug that has arisen when a user neglects to take the; // right action (and therefore, no action is taken), than when a user takes; // the wrong action. And, in order to remember that we already reported; // a double call, we need another kind: `Reported`.; //; // Our analysis is intra-procedural and, while in the perfect world,; // developers only use tracked parameters to call them, in the real world,; // the picture might be different. Parameters can be stored in global; // variables or leaked into other functions that we know nothing about.; // We try to be lenient and trust users. Another kind `Escaped` reflects; // such situations. We don't know if it gets called there or not, but we; // should always think of `Escaped` as the best possible option.; //; // Some of the paths in the analyzed functions might end",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp:894,avoid,avoid,894,interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CalledOnceCheck.cpp,1,['avoid'],['avoid']
Safety,"// Stay safe and don't move past macros, also don't bother with sorting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp:8,safe,safe,8,interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/QualifierAlignmentFixer.cpp,2,['safe'],['safe']
Safety,"// Stein's unbiased risk estimator; // access input parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h:20,risk,risk,20,hist/unfold/inc/TUnfold.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h,1,['risk'],['risk']
Safety,"// Step 2: Compute the recurrence's final value without a loop.; // NewX is always safe to compute, because `LoopBackedgeTakenCount`; // will always be smaller than `bitwidth(X)`, i.e. we never get poison.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:83,safe,safe,83,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['safe'],['safe']
Safety,"// Step 3: Eliminate fully redundancy.; //; // If all of the instructions we depend on produce a known value for this; // load, then it is fully redundant and we can use PHI insertion to compute; // its value. Insert PHIs and remove the fully redundant value now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:27,redund,redundancy,27,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,3,['redund'],"['redundancy', 'redundant']"
Safety,"// Step 3: Note that the population count is exactly the trip count of the; // loop in question, which enable us to convert the loop from noncountable; // loop into a countable one. The benefit is twofold:; //; // - If the loop only counts population, the entire loop becomes dead after; // the transformation. It is a lot easier to prove a countable loop dead; // than to prove a noncountable one. (In some C dialects, an infinite loop; // isn't dead even if it computes nothing useful. In general, DCE needs; // to prove a noncountable loop finite before safely delete it.); //; // - If the loop also performs something else, it remains alive.; // Since it is transformed to countable form, it can be aggressively; // optimized by some optimizations which are in general not applicable; // to a noncountable loop.; //; // After this step, this loop (conceptually) would look like following:; // newcnt = __builtin_ctpop(x);; // t = newcnt;; // if (x); // do { cnt++; x &= x-1; t--) } while (t > 0);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:557,safe,safely,557,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['safe'],['safely']
Safety,// Step 4: Eliminate partial redundancy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:29,redund,redundancy,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['redund'],['redundancy']
Safety,"// Step through all machine locations, look at each predecessor and test; // whether we can eliminate redundant PHIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:102,redund,redundant,102,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['redund'],['redundant']
Safety,// Step through the partitions and create equivalence between partitions; // that contain the same load. Also put partitions in between them in the; // same equivalence class to avoid reordering of memory operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:178,avoid,avoid,178,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['avoid'],['avoid']
Safety,"// Stop any blocking 'Collect' request; on masters we do this only if; // aborting; when stopping, we still need to receive the results",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:74,abort,aborting,74,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['abort'],['aborting']
Safety,"// Stop calculating at the current function, but always regard it as; // modifying, so we can avoid notes like this:; // void f(Foo &F) {; // F.field = 0; // note: 0 assigned to 'F.field'; // // note: returning without writing to 'F.field'; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp:94,avoid,avoid,94,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporterVisitors.cpp,1,['avoid'],['avoid']
Safety,// Stop now if we find an unsafe operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:26,unsafe,unsafe,26,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['unsafe'],['unsafe']
Safety,"// Stop or abort any remote processing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:11,abort,abort,11,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['abort'],['abort']
Safety,"// Stop the search at any type declaration to avoid returning true for; // expressions in type declarations in functions, like:; // function foo() { struct X {; // int m = /*selection:*/ 1 + 2 /*selection end*/; }; };",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp:46,avoid,avoid,46,interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Refactoring/ASTSelection.cpp,1,['avoid'],['avoid']
Safety,// Store (what we currently believe to be) the key function to avoid; // deserializing every method so we can compute it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp:63,avoid,avoid,63,interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriterDecl.cpp,1,['avoid'],['avoid']
Safety,"// Store any delayed AutoreleaseRV intrinsics, so they can be easily paired; // with RetainRV and UnsafeClaimRV.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:98,Unsafe,UnsafeClaimRV,98,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['Unsafe'],['UnsafeClaimRV']
Safety,// Store name outside of loop to avoid redundant calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:33,avoid,avoid,33,interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/LegacyPassManager.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// Store the descriptions in a separate table to avoid pointers that need to; // be relocated, and also decrease the amount of data needed on 64-bit; // platforms. See ""How To Write Shared Libraries"" by Ulrich Drepper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp:49,avoid,avoid,49,interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/DiagnosticIDs.cpp,1,['avoid'],['avoid']
Safety,// Stored the pointer - conservatively assume it may be unsafe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:56,unsafe,unsafe,56,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,2,['unsafe'],['unsafe']
Safety,"// Strange use of reinterpret_cast can give us paths we don't reason; // about well, by putting in ElementRegions where we'd expect; // CXXBaseObjectRegions. If it's a valid reinterpret_cast (i.e. if the; // derived class has a zero offset from the base class), then it's safe; // to strip the cast; if it's invalid, -Wreinterpret-base-class should; // catch it. In the interest of performance, the analyzer will silently; // do the wrong thing in the invalid case (because offsets for subregions; // will be wrong).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp:272,safe,safe,272,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/Store.cpp,1,['safe'],['safe']
Safety,"// Strftime is particular as it always uses a single 'time' argument,; // so it is safe to pass a non-literal string.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:83,safe,safe,83,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['safe'],['safe']
Safety,// StringSet does not allow empty key so avoid adding sections with; // no name (such as the section with index 0) here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp:41,avoid,avoid,41,interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objdump/llvm-objdump.cpp,1,['avoid'],['avoid']
Safety,// Strip kindeofness to correctly detect subtyping relationships.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp:34,detect,detect,34,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypeChecker.cpp,1,['detect'],['detect']
Safety,"// Strip off all memprof metadata as it is no longer needed.; // Importantly, this avoids the addition of new memprof attributes; // after inlining propagation.; // TODO: If we support additional types of MemProf metadata beyond hot; // and cold, we will need to update the metadata based on the allocator; // APIs supported instead of completely stripping all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:83,avoid,avoids,83,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['avoid'],['avoids']
Safety,"// Strip off any constant offsets so that we can reason about them.; // It's tempting to use getUnderlyingObject or even just stripInBoundsOffsets; // here and compare base addresses like AliasAnalysis does, however there are; // numerous hazards. AliasAnalysis and its utilities rely on special rules; // governing loads and stores which don't apply to icmps. Also, AliasAnalysis; // doesn't need to guarantee pointer inequality when it says NoAlias.; // Even if an non-inbounds GEP occurs along the path we can still optimize; // equality comparisons concerning the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:239,hazard,hazards,239,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['hazard'],['hazards']
Safety,"// Strip off whitespace and comment markers to avoid confusion. This isn't; // fully-compatible with IWYU, which splits into whitespace-delimited tokens.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp:47,avoid,avoid,47,interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Inclusions/HeaderAnalysis.cpp,1,['avoid'],['avoid']
Safety,"// Strip pointer casts to avoid creating unnecessary ptrtoint expression; // if the only ""reduction"" is combining a bitcast + ptrtoint.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:26,avoid,avoid,26,interpreter/llvm-project/llvm/lib/IR/Value.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp,1,['avoid'],['avoid']
Safety,"// Strip potential, somewhat redundant '/.' from the pathname ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:29,redund,redundant,29,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['redund'],['redundant']
Safety,"// Strong dependencies must be respected by the scheduler. Artificial; // dependencies may be removed only if they are redundant with another; // strong dependence.; //; // Weak dependencies may be violated by the scheduling strategy, but only if; // the strategy can prove it is correct to do so.; //; // Strong OrderKinds must occur before ""Weak"".; // Weak OrderKinds must occur after ""Weak"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h:119,redund,redundant,119,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAG.h,1,['redund'],['redundant']
Safety,// Structural hazard info.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:14,hazard,hazard,14,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,1,['hazard'],['hazard']
Safety,// Structure returns are safe since the compiler zeroes them out.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:25,safe,safe,25,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,1,['safe'],['safe']
Safety,// Subclass to avoid any overhead when not using this feature,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h:15,avoid,avoid,15,interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-libtool-darwin/DependencyInfo.h,1,['avoid'],['avoid']
Safety,"// Subtlety: If we load from a pointer, the pointer must be valid; // regardless of whether the element is demanded. Doing otherwise risks; // segfaults which didn't exist in the original program.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:133,risk,risks,133,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['risk'],['risks']
Safety,"// Subtlety: We need all the values to be *invariant* across all iterations,; // but we only need to check expansion safety for those which *aren't*; // already guaranteed to dominate the guard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:117,safe,safety,117,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,2,['safe'],['safety']
Safety,// Subtract error margin and bias from register limits and avoid overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp:59,avoid,avoid,59,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp,1,['avoid'],['avoid']
Safety,// Suggest adding a space between the '<=' and the '>' to avoid a; // change in semantics if this turns up in C++ <=17 mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:58,avoid,avoid,58,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['avoid'],['avoid']
Safety,"// Suggest the (potentially) correct interface name. Don't provide a; // code-modification hint or use the typo name for recovery, because; // this is just a warning. The program may actually be correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:121,recover,recovery,121,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['recover'],['recovery']
Safety,"// Summary tells us to avoid performing eval::Call. The function is possibly; // evaluated by another checker, or evaluated conservatively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:23,avoid,avoid,23,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['avoid'],['avoid']
Safety,"// Support the ""unified sources"" compilation method (eg. WebKit) that; // involves producing non-header files that include other non-header files.; // We should be included directly from a UnifiedSource* file; // and we shouldn't be a header - which is a very safe defensive check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/AnalysisManager.h:260,safe,safe,260,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/AnalysisManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/AnalysisManager.h,1,['safe'],['safe']
Safety,// Supporting the hazard barrier method of dealing with indirect; // jumps requires MIPSR2 support.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp:18,hazard,hazard,18,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/Mips.cpp,1,['hazard'],['hazard']
Safety,"// Suppress error dialogs to avoid hangs on build nodes.; // One can use an environment variable (Cling_GuiOnAssert) to enable; // the error dialogs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:29,avoid,avoid,29,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,2,['avoid'],['avoid']
Safety,// Suppress the redundant tag keyword if we just printed one.; // We don't have to worry about ElaboratedTypes here because you can't; // refer to an anonymous type with one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp:16,redund,redundant,16,interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/TypePrinter.cpp,1,['redund'],['redundant']
Safety,"// Swap elements j and j - inc, implicitly use the fact; // that ktemp hold element j to avoid having to assign to; // element j-inc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTBase.cxx:89,avoid,avoid,89,math/matrix/src/TMatrixTBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/src/TMatrixTBase.cxx,1,['avoid'],['avoid']
Safety,"// Swap-and-pop for fast removal.; // 1) Update the adj index of the edge currently at back().; // 2) Move last Edge down to Idx.; // 3) pop_back(); // If Idx == size() - 1 then the setAdjEdgeIdx and swap are; // redundant, but both operations are cheap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h:213,redund,redundant,213,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,1,['redund'],['redundant']
Safety,// Switch back to the lexical context. The safety of this is; // enforced by an assert in EnterDeclaratorContext.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:43,safe,safety,43,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['safe'],['safety']
Safety,// Symbol table is in a safe order.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:24,safe,safe,24,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['safe'],['safe']
Safety,"// T can be different from the actual parameter of the underlying function.; // If we know already the function signature, make sure we create the; // cling::Value with the proper type and representation to avoid; // re-adjusting at the time we execute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.h:207,avoid,avoid,207,core/metacling/src/TClingCallFunc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.h,1,['avoid'],['avoid']
Safety,"// TClass::GetClass explicitly calls gInterpreter->AutoLoad. When called from; // rootcling (in *_rdict.pcm file generation) it is a no op.; // FIXME: We should avoid calling autoload when we know we are not supposed; // to and transform this check into an assert.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:161,avoid,avoid,161,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avoid'],['avoid']
Safety,"// TH1::Clone relies on ::Copy to implemented by the derived class.; // Until this is implemented, revert to the much slower default version; // (and possibly non-thread safe).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:170,safe,safe,170,hist/hist/src/TH2Poly.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx,1,['safe'],['safe']
Safety,"// TODO Maybe there's cases where the target doesn't have to be the header,; // but for now be safe and revert.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp:95,safe,safe,95,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLowOverheadLoops.cpp,1,['safe'],['safe']
Safety,"// TODO add more static sanity checks on Helper",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:24,sanity check,sanity checks,24,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['sanity check'],['sanity checks']
Safety,"// TODO avoid frequent (de)allocations by holding on to allocated buffers in RColumnBuf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:8,avoid,avoid,8,tree/ntuple/v7/src/RPageSinkBuf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx,1,['avoid'],['avoid']
Safety,"// TODO remove; // statistics can be preserved only in case of positive coefficients; // otherwise with negative c1 (histogram subtraction) one risks to get negative variances; // also in case of scaling with the width we cannot preserve the statistics",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:144,risk,risks,144,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['risk'],['risks']
Safety,"// TODO(courbet): Right now we abort the whole chain. We could be; // merging only the blocks that don't do other work and resume the; // chain from there. For example:; // if (a[0] == b[0]) { // bb1; // if (a[1] == b[1]) { // bb2; // some_value = 3; //bb3; // if (a[2] == b[2]) { //bb3; // do a ton of stuff //bb4; // }; // }; // }; //; // This is:; //; // bb1 --eq--> bb2 --eq--> bb3* -eq--> bb4 --+; // \ \ \ \; // ne ne ne \; // \ \ \ v; // +------------+-----------+----------> bb_phi; //; // We can only merge the first two comparisons, because bb3* does; // ""other work"" (setting some_value to 3).; // We could still merge bb1 and bb2 though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:31,abort,abort,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['abort'],['abort']
Safety,"// TODO(gparolini): avoid this allocation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:20,avoid,avoid,20,tree/ntuple/v7/src/RColumnElement.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx,1,['avoid'],['avoid']
Safety,"// TODO(gparolini): see if we can avoid this allocation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:34,avoid,avoid,34,tree/ntuple/v7/src/RColumnElement.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx,2,['avoid'],['avoid']
Safety,"// TODO(gparolini): to avoid this extra allocation we might want to perform byte swapping; // directly in the Pack/UnpackBits functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:23,avoid,avoid,23,tree/ntuple/v7/src/RColumnElement.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx,2,['avoid'],['avoid']
Safety,"// TODO: Add conjugated or fold, check whether it is safe for logical and/or.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:53,safe,safe,53,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safe']
Safety,// TODO: Add heuristic that the frame index might not fit in the addressing mode; // immediate offset to avoid materializing in loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:105,avoid,avoid,105,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['avoid'],['avoid']
Safety,// TODO: Add nsw/nuw probably safe if integer type exceeds exponent; // width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:30,safe,safe,30,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['safe'],['safe']
Safety,"// TODO: Also use VPDerivedIVRecipe when only the step needs truncating, to; // avoid separate truncate here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp:80,avoid,avoid,80,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanRecipes.cpp,1,['avoid'],['avoid']
Safety,// TODO: Are these all needed?; // unsafe/inf/nan/nsz are handled by instruction-level FastMathFlags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:35,unsafe,unsafe,35,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['unsafe'],['unsafe']
Safety,// TODO: Avoid clearing the high bits if we know workitem id y/z are always; // 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:9,Avoid,Avoid,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['Avoid'],['Avoid']
Safety,// TODO: Avoid handleModuleDependency even being called for modules; // we've already seen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp:9,Avoid,Avoid,9,interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DependencyScanning/DependencyScanningTool.cpp,2,['Avoid'],['Avoid']
Safety,// TODO: Avoid ptrtoint conversion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:9,Avoid,Avoid,9,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['Avoid'],['Avoid']
Safety,"// TODO: Avoid reloading from the queue ptr for each cast, or at least each; // vector element.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:9,Avoid,Avoid,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['Avoid'],['Avoid']
Safety,// TODO: Avoid some calling conventions?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:9,Avoid,Avoid,9,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['Avoid'],['Avoid']
Safety,"// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:9,Avoid,Avoid,9,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['Avoid'],['Avoid']
Safety,"// TODO: Build a wrapper around the expression to avoid decompilation and; // compilation and other string operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx:50,avoid,avoid,50,core/metacling/src/TClingCallFunc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallFunc.cxx,1,['avoid'],['avoid']
Safety,"// TODO: Check for MethodArgInfo thread-safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TFunction.cxx:40,safe,safety,40,core/meta/src/TFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TFunction.cxx,1,['safe'],['safety']
Safety,// TODO: Contents is present in several classes of the hierarchy.; // This needs to be refactored to avoid duplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h:101,avoid,avoid,101,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h,1,['avoid'],['avoid']
Safety,"// TODO: Cost model for emulated masked load/store is completely; // broken. This hack guides the cost model to use an artificially; // high enough value to practically disable vectorization with such; // operations, except where previously deployed legality hack allowed; // using very low cost values. This is to avoid regressions coming simply; // from moving ""masked load/store"" check from legality to cost model.; // Masked Load/Gather emulation was previously never allowed.; // Limited number of Masked Store/Scatter emulation was allowed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:315,avoid,avoid,315,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avoid'],['avoid']
Safety,"// TODO: Could inject an invalid typedef decl in an enclosing scope to; // avoid rippling error messages on subsequent uses of the same type,; // could be useful if #include was forgotten.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:75,avoid,avoid,75,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['avoid'],['avoid']
Safety,// TODO: Detect overflow in ubsan or max-out with current tripcount.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:9,Detect,Detect,9,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['Detect'],['Detect']
Safety,// TODO: Detect when the allocator returns a null pointer.; // Constructor shall not be called in this case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:9,Detect,Detect,9,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['Detect'],['Detect']
Safety,// TODO: Disallow overlapping masks to avoid copy paste errors,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['avoid'],['avoid']
Safety,"// TODO: Figure out a way to avoid passing in wrong source locations; // of the symbol being replaced. This is important when we calculate the; // size of the memory buffers and may lead to creation of wrong wrappers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:29,avoid,avoid,29,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['avoid'],['avoid']
Safety,"// TODO: Find a way to avoid creating new types, if the input is already; // fully qualified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp:23,avoid,avoid,23,interpreter/cling/lib/Utils/AST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp,1,['avoid'],['avoid']
Safety,"// TODO: For dynamic 64-bit vector inserts/extracts, should emit a pseudo that; // is expanded to avoid having two separate loops in case the index is a VGPR.; // Most operations are naturally 32-bit vector operations. We only support; // load and store of i64 vectors, so promote v2i64 vector operations to v4i32.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:98,avoid,avoid,98,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avoid'],['avoid']
Safety,// TODO: Handle aggregates and vectors; // TODO: Support multiple indices.; // TODO: Try to avoid meaningless accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:92,avoid,avoid,92,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,1,['avoid'],['avoid']
Safety,// TODO: How to use branch immediate and avoid register+add?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMCInstLower.cpp:41,avoid,avoid,41,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMCInstLower.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMCInstLower.cpp,1,['avoid'],['avoid']
Safety,"// TODO: Ideally this would be controlled automatically by detecting that we; // are linking with an allocator that supports these interfaces, rather than; // an internal option (which would still be needed for tests, however). For; // example, if the library exported a symbol like __malloc_hot_cold the linker; // could recognize that and set a flag in the lto::Config.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:59,detect,detecting,59,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['detect'],['detecting']
Safety,"// TODO: If SADDSAT/SSUBSAT is legal, compare results to detect overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:57,detect,detect,57,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['detect'],['detect']
Safety,"// TODO: If operand didn't match, sub in a dummy one and run target; // predicate, so that we can avoid reporting near-misses that are invalid?; // TODO: Many operand types dont have SuperClasses set, so we report; // redundant ones.; // TODO: Some operands are superclasses of registers (e.g.; // MCK_RegShiftedImm), we don't have any way to represent that currently.; // TODO: This is not all ARM-specific, can some of it be factored out?; // Record some information about near-misses that we have already seen, so; // that we can avoid reporting redundant ones. For example, if there are; // variants of an instruction that take 8- and 16-bit immediates, we want; // to only report the widest one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:98,avoid,avoid,98,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,4,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// TODO: If the input isn't denormal, and we know the input exponent isn't; // big enough to introduce a denormal we can avoid the scaling.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:121,avoid,avoid,121,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,// TODO: Insert at correct position and avoid sort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp:40,avoid,avoid,40,interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Attributes.cpp,1,['avoid'],['avoid']
Safety,"// TODO: Is this true? kill flag appears to work OK below; // Register kill flags have been cleared by the time we get to this; // pass, but it is safe to assume that all uses of this register; // occur in the same basic block as its definition, because; // it is illegal for the scheduler to schedule them in; // different blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp:147,safe,safe,147,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp,1,['safe'],['safe']
Safety,"// TODO: It may be possible to actually avoid the copy.; // If we repair something where the source is defined by a copy; // and the source of that copy is on the right bank, we can reuse; // it for free.; // E.g.,; // RegToRepair<BankA> = copy AlternativeSrc<BankB>; // = op RegToRepair<BankA>; // We can simply propagate AlternativeSrc instead of copying RegToRepair; // into a new virtual register.; // We would also need to propagate this information in the; // repairing placement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:40,avoid,avoid,40,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['avoid'],['avoid']
Safety,// TODO: It might be worth using a pseudo here to avoid scc clobber and; // register class constraints.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:50,avoid,avoid,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['avoid'],['avoid']
Safety,"// TODO: It turns out we need a decent amount of plumbing for the target; // specific bits to determine number of prefixes its safe to add. Various; // targets (older chips mostly, but also Atom family) encounter decoder; // stalls with too many prefixes. For testing purposes, we set the value; // externally for the moment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp:127,safe,safe,127,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86AsmBackend.cpp,1,['safe'],['safe']
Safety,"// TODO: Look at the uses to avoid the copy. This may require rescheduling; // to avoid interfering with other uses, so probably requires a new; // optimization pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:29,avoid,avoid,29,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// TODO: Looking at the user(s) to determine if this insert is a; // fold-to-shuffle opportunity does not match the usual instcombine; // constraints. We should decide if the transform is worthy based only; // on this instruction and its operands, but that may not work currently.; //; // Here, we are trying to avoid creating shuffles before reaching; // the end of a chain of extract-insert pairs. This is complicated because; // we do not generally form arbitrary shuffle masks in instcombine; // (because those may codegen poorly), but collectShuffleElements() does; // exactly that.; //; // The rules for determining what is an acceptable target-independent; // shuffle mask are fuzzy because they evolve based on the backend's; // capabilities and real-world impact.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:312,avoid,avoid,312,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['avoid'],['avoid']
Safety,// TODO: MCRegUnits; // Handle boundaries at the end of basic block separately to avoid; // false positives. If they are live at the end of a basic block then; // assume it has more uses later on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertSingleUseVDST.cpp:82,avoid,avoid,82,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertSingleUseVDST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInsertSingleUseVDST.cpp,1,['avoid'],['avoid']
Safety,"// TODO: Make this const, if it's safe...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h:34,safe,safe,34,interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallString.h,1,['safe'],['safe']
Safety,"// TODO: Model this case as well. At least, avoid invalidation of; // globals.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:44,avoid,avoid,44,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,1,['avoid'],['avoid']
Safety,// TODO: Move this right after structurizeCFG to avoid extra divergence; // analysis. This depends on stopping SIAnnotateControlFlow from making; // control flow modifications.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:49,avoid,avoid,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,1,['avoid'],['avoid']
Safety,// TODO: On GFX12 the hazard should expire on S_WAIT_LOADCNT/SAMPLECNT/BVHCNT; // according to the type of VMEM instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:22,hazard,hazard,22,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,// TODO: Once we detect the regions to be offloaded we should use the; // alias analysis manager to check if CurrentI may modify one of; // the offloaded regions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:17,detect,detect,17,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['detect'],['detect']
Safety,// TODO: Pick a killed regiter to avoid save/reload. There is problem; // to get live interval in this stage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp:34,avoid,avoid,34,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerTileCopy.cpp,1,['avoid'],['avoid']
Safety,"// TODO: Post-processing: Convert lea(,%reg,2) to lea(%reg,%reg), which has; // a smaller encoding and avoids a scaled-index.; // And make sure it is an indexed mode; // TODO: Post-processing: Convert foo to foo(%pc), even in non-PIC mode,; // because it has a smaller encoding.; // Make sure this must be done only if PC* modes are currently being matched",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp:103,avoid,avoids,103,interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kISelDAGToDAG.cpp,1,['avoid'],['avoids']
Safety,// TODO: Provide a helper to determine the implied ABI alignment and check in; // the existing manifest method and a new one for AAAlignImpl that value; // to avoid making the alignment explicit if it did not improve.; /// See AbstractAttribute::getDeducedAttributes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:159,avoid,avoid,159,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['avoid'],['avoid']
Safety,// TODO: Refine this. This should avoid cases like turning constant memcpy sizes; // into variables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:34,avoid,avoid,34,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"// TODO: Remove fully-redundant expressions.; // Get instruction from the Map, assume that all the Instructions; // with same VNs have same rank (this is an approximation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:22,redund,redundant,22,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['redund'],['redundant']
Safety,// TODO: Setting the minimum jump table entries needed before a; // switch is transformed to a jump table to 100 to avoid creating jump tables; // as this was causing bad performance compared to a large group of if; // statements. Re-evaluate this on new benchmarks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp:116,avoid,avoid,116,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiISelLowering.cpp,1,['avoid'],['avoid']
Safety,// TODO: Should return converted value / extension source and avoid introducing; // intermediate fptruncs in the apply function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCombinerHelper.cpp:62,avoid,avoid,62,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCombinerHelper.cpp,1,['avoid'],['avoid']
Safety,// TODO: Should we allow mismatched types but matching sizes in merges to; // avoid the ptrtoint?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:78,avoid,avoid,78,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['avoid'],['avoid']
Safety,"// TODO: The checksum followed by the decompression means we iterate through the buffer twice.; // We should perform some performance tests to see whether we can interleave the two -- i.e., at; // what size of chunks does interleaving (avoiding two fetches from RAM) improve enough for the; // extra function call costs? NOTE that ROOT limits the buffer size to 16MB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/lz4/src/ZipLZ4.cxx:236,avoid,avoiding,236,core/lz4/src/ZipLZ4.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/lz4/src/ZipLZ4.cxx,1,['avoid'],['avoiding']
Safety,// TODO: The default entry number is set to 64. This stops most jump table; // generation on PPC. But it is good for current PPC HWs because the indirect; // branch instruction mtctr to the jump table may lead to bad branch predict.; // Re-evaluate this value on future HWs that can do better with mtctr.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:224,predict,predict,224,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['predict'],['predict']
Safety,"// TODO: The motivating case for this transform is an x86 AVX1 target. That; // target has temptingly almost legal versions of bitwise logic ops in 256-bit; // flavors, but no other 256-bit integer support. This could be extended to; // handle any binop, but that may require fixing/adding other folds to avoid; // codegen regressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:305,avoid,avoid,305,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// TODO: The result of the intrinsics above is two-complement. However when; // IV inc is expressed as add or sub, iv.next is potentially a poison value.; // If it has nuw or nsw flags, we need to make sure that these flags are; // inferrable at the point of memory instruction. Otherwise we are replacing; // well-defined two-complement computation with poison. Currently, to avoid; // potentially complex analysis needed to prove this, we reject such cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:377,avoid,avoid,377,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"// TODO: These intrinsics are not safe to remove, because this may remove; // a well-defined trap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:34,safe,safe,34,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['safe'],['safe']
Safety,// TODO: This check could be tightened to only apply to binops (div/rem) that; // are not safe to speculatively execute. But that could allow hoisting; // potentially expensive instructions (fdiv for example).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:90,safe,safe,90,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['safe'],['safe']
Safety,"// TODO: This check for stride values other than 1 and -1 can be eliminated.; // However, doing so may cause the LoopAccessAnalysis to overcompensate,; // generating numerous non-wrap runtime checks that may undermine the; // benefits of load elimination. To safely implement support for non-unit; // strides, we would need to ensure either that the processed case does not; // require these additional checks, or improve the LAA to handle them more; // efficiently, or potentially both.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp:259,safe,safely,259,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopLoadElimination.cpp,1,['safe'],['safely']
Safety,// TODO: This could be optimized to avoid all the copying.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['avoid'],['avoid']
Safety,// TODO: This could be refined a lot. The attribute is a poor way of; // detecting calls or stack objects that may require it before argument; // lowering.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp:73,detect,detecting,73,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUSubtarget.cpp,1,['detect'],['detecting']
Safety,"// TODO: This is a specific form of a much more general pattern.; // We could detect a select with any binop identity constant, or we; // could use SimplifyBinOp to see if either arm of the select reduces.; // But that needs to be done carefully and/or while removing potential; // reverse canonicalizations as in InstCombiner::foldSelectIntoOp().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:78,detect,detect,78,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['detect'],['detect']
Safety,"// TODO: This is a workaround to avoid the unmodelled liveness computed with; // whole-wave virtual registers when allocated together with the regular VGPR; // virtual registers. Presently, the liveness computed during the regalloc is; // only uniform (or single lane aware) and it doesn't take account of the; // divergent control flow that exists for our GPUs. Since the WWM registers; // can modify inactive lanes, the wave-aware liveness should be computed for; // the virtual registers to accurately plot their interferences. Without; // having the divergent CFG for the function, it is difficult to implement the; // wave-aware liveness info. Until then, we conservatively extend the liveness; // of the wwm registers into the entire function so that they won't be reused; // without first spilling/splitting their liveranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp:33,avoid,avoid,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerSGPRSpills.cpp,1,['avoid'],['avoid']
Safety,"// TODO: This is more complicated, unsafe flags etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:35,unsafe,unsafe,35,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['unsafe'],['unsafe']
Safety,// TODO: This limitation exists for compile-time reasons. Relax it if we; // can avoid exponential pathological cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:81,avoid,avoid,81,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['avoid'],['avoid']
Safety,// TODO: This part needs additional work in order to set properly the; // correct filename in order to detect changes between filenames.; // AbstractFunction->setFilename(Filename);,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:103,detect,detect,103,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,1,['detect'],['detect']
Safety,// TODO: This part needs additional work in order to set properly the; // correct filename in order to detect changes between filenames.; // Line->setFilename(Filename);,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:103,detect,detect,103,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,1,['detect'],['detect']
Safety,// TODO: This redundantly records nodes with both glues and chains.; // Record the node and remember it in our chained nodes list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:14,redund,redundantly,14,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,1,['redund'],['redundantly']
Safety,"// TODO: This should be extended to handle other intrinsics like fshl, ctpop,; // etc. Use llvm::isTriviallyVectorizable() and related to determine; // which intrinsics are safe to shuffle?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:173,safe,safe,173,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['safe'],['safe']
Safety,"// TODO: This switch could include FNEG and the x86-specific FP logic ops; // (FAND, FANDN, FOR, FXOR). But that may require enhancements to avoid; // missed load folding and fma+fneg combining.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:141,avoid,avoid,141,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// TODO: Try to avoid undefined accesses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp:16,avoid,avoid,16,interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FuzzMutate/Operations.cpp,2,['avoid'],['avoid']
Safety,"// TODO: Ugly - should use quaternions to avoid compound rounding errors and; // triple multiplication",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx:42,avoid,avoid,42,graf3d/gl/src/TGLUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx,1,['avoid'],['avoid']
Safety,// TODO: Use IndentTracker to avoid loop?; // Find the last line with lower level.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp:30,avoid,avoid,30,interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineFormatter.cpp,1,['avoid'],['avoid']
Safety,// TODO: Use small-string optimization to avoid allocating.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:42,avoid,avoid,42,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,1,['avoid'],['avoid']
Safety,// TODO: Verify whether this is safe for logical and/or.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:32,safe,safe,32,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safe']
Safety,"// TODO: We already restricted this to pre-legalization, but for vectors; // we are extra cautious to not create an unsupported operation.; // Target-specific changes are likely needed to avoid regressions here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:188,avoid,avoid,188,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// TODO: We can add more logic to computeInfo to improve performance.; // Example: For aggregate arguments that fit in a register, we could; // use getDirectInReg (as is done below for structs containing a single; // floating-point value) to avoid pushing them to memory on function; // entry. This would require changing the logic in PPCISelLowering; // when lowering the parameters in the caller and args in the callee.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:242,avoid,avoid,242,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,1,['avoid'],['avoid']
Safety,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:118,safe,safepoint,118,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,3,"['Safe', 'safe']","['Safepoint', 'safepoint']"
Safety,"// TODO: We can do better for PHI nodes. In cases like this:; // ptr = phi(relocated_pointer, not_relocated_pointer); // statepoint(ptr); // We will return that stack slot for ptr is unknown. And later we might; // assign different stack slots for ptr and relocated_pointer. This limits; // llvm's ability to remove redundant stores.; // Unfortunately it's hard to accomplish in current infrastructure.; // We use this function to eliminate spill store completely, while; // in example we still need to emit store, but instead of any location; // we need to use special ""preferred"" location.; // TODO: handle simple updates. If a value is modified and the original; // value is no longer live, it would be nice to put the modified value in the; // same slot. This allows folding of the memory accesses for some; // instructions types (like an increment).; // statepoint (i); // i1 = i+1; // statepoint (i1); // However we need to be careful for cases like this:; // statepoint(i); // i1 = i+1; // statepoint(i, i1); // Here we want to reserve spill slot for 'i', but not for 'i+1'. If we just; // put handling of simple modifications in this function like it's done; // for bitcasts we might end up reserving i's slot for 'i+1' because order in; // which we visit values is unspecified.; // Don't know any information about this instruction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:316,redund,redundant,316,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['redund'],['redundant']
Safety,"// TODO: We could have a clean-up method to tidy the instruction.; // E.g., v0 = INSERT_SUBREG v1, v1.sub0, sub0; // => v0 = COPY v1; // Currently we haven't seen motivating example for that and we; // want to avoid untested code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:210,avoid,avoid,210,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['avoid'],['avoid']
Safety,// TODO: We could possibly avoid a 64-bit shift and use a simpler table if we; // knew only one mode was demanded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// TODO: We drop ""nsw"" if shift is converted into multiply because it may; // not be correct when the shift amount is BitWidth - 1. We could examine; // each vector element to determine if it is safe to keep that flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:195,safe,safe,195,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['safe'],['safe']
Safety,// TODO: We might be able to relax the VT check but we don't currently; // have any isBinOp() that has different result/ops VTs so play safe until; // we have test coverage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:136,safe,safe,136,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,// TODO: We should also detect FP min/max.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:24,detect,detect,24,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['detect'],['detect']
Safety,// TODO: We should avoid simplification duplication to begin with.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:19,avoid,avoid,19,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['avoid'],['avoid']
Safety,// TODO: We should avoid using host float here. It would be better to; // check the float bit values which is what a few other places do.; // We've had bot failures before due to weird NaN support on mips hosts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp:19,avoid,avoid,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AsmParser/AMDGPUAsmParser.cpp,1,['avoid'],['avoid']
Safety,// TODO: `__constant__` memory may be a limited resource for certain targets.; // A safeguard may be needed at the end of compilation pipeline if; // `__constant__` memory usage goes beyond limit.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp:84,safe,safeguard,84,interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCUDA.cpp,1,['safe'],['safeguard']
Safety,// TODO: attributes.; // if ((*P)->hasAttr<SafeRefCntblRawPtrAttr>()); // continue;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedCallArgsChecker.cpp:43,Safe,SafeRefCntblRawPtrAttr,43,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedCallArgsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedCallArgsChecker.cpp,1,['Safe'],['SafeRefCntblRawPtrAttr']
Safety,// TODO: avoid copy,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp:9,avoid,avoid,9,interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAccess.cpp,1,['avoid'],['avoid']
Safety,"// TODO: avoid creation of a new SVEvent every time (Joerg)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodSVM.cxx:9,avoid,avoid,9,tmva/tmva/src/MethodSVM.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodSVM.cxx,1,['avoid'],['avoid']
Safety,// TODO: avoid making this TemplateName.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:9,avoid,avoid,9,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['avoid'],['avoid']
Safety,// TODO: avoid this copy,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:9,avoid,avoid,9,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['avoid'],['avoid']
Safety,// TODO: avoid this copy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:9,avoid,avoid,9,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['avoid'],['avoid']
Safety,// TODO: avoid!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:9,avoid,avoid,9,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['avoid'],['avoid']
Safety,// TODO: check for other requires clauses.; // The requires directive takes effect only when a target region is; // present in the compilation unit. Otherwise it is ignored and not; // passed to the runtime. This avoids the runtime from throwing an error; // for mismatching requires clauses across compilation units that don't; // contain at least 1 target region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:213,avoid,avoids,213,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['avoid'],['avoids']
Safety,"// TODO: data members should have a unique identifier, just like methods,; // so that reflection information can be recovered post-initialization",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.h:116,recover,recovered,116,bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPDataMember.h,1,['recover'],['recovered']
Safety,// TODO: detect and diagnose the full richness of const mismatches.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:9,detect,detect,9,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['detect'],['detect']
Safety,"// TODO: else we should assert that there was, in fact, a policy choice to; // not insert a entry safepoint poll.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:98,safe,safepoint,98,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,"// TODO: move this back into ThreadSafety.cpp; // This is specific to thread safety. It is here because; // translateAttrExpr needs it, but that should be moved too.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyCommon.h:77,safe,safety,77,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyCommon.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyCommon.h,1,['safe'],['safety']
Safety,"// TODO: once the constraint manager is smart enough to handle non simplified; // symbolic expressions remove this function. Note that this can not be used in; // the constraint manager as is, since this does not handle overflows. It is; // safe to assume, however, that memory offsets will not overflow.; // NOTE: callers of this function need to be aware of the effects of overflows; // and signed<->unsigned conversions!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp:241,safe,safe,241,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ArrayBoundCheckerV2.cpp,1,['safe'],['safe']
Safety,"// TODO: passing a scalar root to toYAML() asserts:; // (PolymorphicTraits<T>::getKind(Val) != NodeKind::Scalar &&; // ""plain scalar documents are not supported""); // To avoid this crash we print the raw data instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp:170,avoid,avoid,170,interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp,1,['avoid'],['avoid']
Safety,// TODO: recover from mistakenly-qualified operator declarations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:9,recover,recover,9,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recover']
Safety,// TODO: should be moved into Ged controller - it must be able to detect canvas painter itself,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:66,detect,detect,66,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['detect'],['detect']
Safety,// TODO: this implementation is now likely redundant with; // DefaultABIInfo::EmitVAArg.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:43,redund,redundant,43,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,1,['redund'],['redundant']
Safety,// TODO: this possibly can be reworked to avoid this cast at all.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['avoid'],['avoid']
Safety,// TODO: use getKnownUndefForVectorBinop?; // Attempt to avoid multi-use ops if we don't need anything from them.; // TODO - use KnownUndef to relax the demandedelts?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:57,avoid,avoid,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,// TODO; // This helps avoid infinite loop with SimplifyCondBranchToCondBranch which; // may undo the transform done here.; // TODO: There might be a more fine-grained solution to this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:23,avoid,avoid,23,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"// TROOT sets the error ignore level handler, the system error message handler, and the error abort handler on; // construction such that the ""Root.ErrorIgnoreLevel"" environment variable is used for the ignore level; // and gSystem is used to generate a stack trace on abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TError.h:94,abort,abort,94,core/foundation/inc/TError.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/TError.h,2,['abort'],['abort']
Safety,// Table to map instructions safe to broadcast using a different width from the; // element width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp:29,safe,safe,29,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrFoldTables.cpp,1,['safe'],['safe']
Safety,"// Tail is allowed to have many predecessors, but we can't handle PHIs yet.; //; // FIXME: Real PHIs could be if-converted as long as the CmpBB values are; // defined before The CmpBB cmp clobbers the flags. Alternatively, it should; // always be safe to sink the ccmp down to immediately before the CmpBB; // terminators.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp:247,safe,safe,247,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,1,['safe'],['safe']
Safety,"// Take 512-bit type, unless we are avoiding 512-bit types and have the; // 256-bit operation available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,avoid,avoiding,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avoid'],['avoiding']
Safety,// Take address space attr if any and mark as invalid to avoid adding; // them later while creating QualType.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:57,avoid,avoid,57,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['avoid'],['avoid']
Safety,"// Take all (SDValue, RLAmt) pairs and sort them by the number of groups; // associated with each. If the number of groups are same, we prefer a group; // which does not require rotate, i.e. RLAmt is 0, to avoid the first rotate; // instruction. If there is a degeneracy, pick the one that occurs; // first (in the final value).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:206,avoid,avoid,206,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// Take note of if we have any non-trivial AddrModes, as we need to detect; // when all AddrModes are trivial as then we would introduce a phi or select; // which just duplicates what's already there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:68,detect,detect,68,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['detect'],['detect']
Safety,// Take the fast path for a single update and avoid running the batch update; // machinery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:46,avoid,avoid,46,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['avoid'],['avoid']
Safety,// Take tokens to avoid allocations,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:18,avoid,avoid,18,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['avoid'],['avoid']
Safety,// Target specific intrinsic became redundant,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:36,redund,redundant,36,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,2,['redund'],['redundant']
Safety,// TargetMachine does not support llvm-style cast. Use C++-style cast.; // This is safe since TM is always of type AMDGPUTargetMachine or its; // derived class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMCInstLower.h:83,safe,safe,83,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMCInstLower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUMCInstLower.h,1,['safe'],['safe']
Safety,// Targets may want to avoid this to prevent an expensive register transfer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:23,avoid,avoid,23,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// Tarjan's SCC finding algorithm with Nuutila's improvements; // SCCIterator is actually fairly complex for the simple thing we want.; // It also wants to hand us SCC's that are unrelated to the phi node we ask; // about, and have us process them there or risk redoing work.; // Graph traits over a filter iterator also doesn't work that well here.; // This SCC finder is specialized to walk use-def chains, and only follows; // instructions,; // not generic values (arguments, etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:257,risk,risk,257,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['risk'],['risk']
Safety,"// Technically a valid configuration that just wants to use libClangs; // internal header detection, but for now give a hint about why.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp:90,detect,detection,90,interpreter/cling/lib/Interpreter/CIFactory.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/CIFactory.cpp,1,['detect'],['detection']
Safety,// Tell MemorySanitizer that zlib output buffer is fully initialized.; // This avoids a false report when running LLVM with uninstrumented ZLib.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Compression.cpp:79,avoid,avoids,79,interpreter/llvm-project/llvm/lib/Support/Compression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Compression.cpp,2,['avoid'],['avoids']
Safety,// Tell MemorySanitizer that zstd output buffer is fully initialized.; // This avoids a false report when running LLVM with uninstrumented ZLib.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Compression.cpp:79,avoid,avoids,79,interpreter/llvm-project/llvm/lib/Support/Compression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Compression.cpp,2,['avoid'],['avoids']
Safety,// Tell the callee to try to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:29,recover,recover,29,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Safety,// Tell the callee whether to try to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:37,recover,recover,37,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Safety,"// Tell the user interleaving was avoided up-front, despite being explicitly; // requested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:34,avoid,avoided,34,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avoid'],['avoided']
Safety,"// Temporarily mark it as built to avoid the BuildCheck from removing; // Technically we only need to do this for the 'current' StreamerInfo",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:35,avoid,avoid,35,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['avoid'],['avoid']
Safety,"// Temporarily redundant, see comment on lock early in the function.; // R__LOCKGUARD(gROOTMutex);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx:15,redund,redundant,15,io/io/src/TDirectoryFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx,1,['redund'],['redundant']
Safety,// Temporary approach to make everything at least word-aligned and allow for; // safely casting between pointers with different alignment requirements.; // TODO: Remove this when there are no more cast align warnings on the; // firmware.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Lanai.h:81,safe,safely,81,interpreter/llvm-project/clang/lib/Basic/Targets/Lanai.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Targets/Lanai.h,1,['safe'],['safely']
Safety,"// Temporary change to target user ID to avoid NFS squashing problems",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:41,avoid,avoid,41,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['avoid'],['avoid']
Safety,"// Temporary destructors have a predictable control flow, thus we want to; // look into the next block for the return statement.; // We look into the false branch, as we know the true branch only contains; // the call to the destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp:32,predict,predictable,32,interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ReachableCode.cpp,1,['predict'],['predictable']
Safety,"// Temporary hack: disable high vectorization factors with integer; // division/remainder, which will get scalarized and handled with; // GR128 registers. The mischeduler is not clever enough to avoid; // spilling yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp:195,avoid,avoid,195,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZTargetTransformInfo.cpp,1,['avoid'],['avoid']
Safety,"// Tensor_t xInput;; // for (size_t i = 0; i < n0; ++i); // xInput.emplace_back(Matrix_t(n1,n2));; // create pointer to output matrix used for the predictions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:147,predict,predictions,147,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['predict'],['predictions']
Safety,"// Terminate also if a high memory footprint was detected before the related; // exception was thrwon",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:49,detect,detected,49,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['detect'],['detected']
Safety,"// Terminate the draw if over opaque fraction timeout.; // Only test every 2000 objects as this is somewhat costly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx:46,timeout,timeout,46,graf3d/gl/src/TGLScene.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx,1,['timeout'],['timeout']
Safety,"// Termination has been detected by the status check; print; // appropriate message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx:24,detect,detected,24,math/quadp/src/TGondzioSolver.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx,2,['detect'],['detected']
Safety,// Test all regunits of the super register that are not part of the; // sub register. If none of them are live then the super register is safe to; // use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:138,safe,safe,138,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['safe'],['safe']
Safety,"// Test for a zero-shift-guard-op around rotates. These are used to; // avoid UB from oversized shifts in raw IR rotate patterns, but the; // intrinsics do not have that problem.; // We do not allow this transform for the general funnel shift case because; // that would not preserve the poison safety of the original code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:72,avoid,avoid,72,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,"['avoid', 'safe']","['avoid', 'safety']"
Safety,"// Test if we can pack floats into NaNs, and recover them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:45,recover,recover,45,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,1,['recover'],['recover']
Safety,"// Test integral in the high tails.; // Implementation should switch to cdf_c here to avoid catastrophic cancellation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooPoisson.cxx:86,avoid,avoid,86,roofit/roofit/test/testRooPoisson.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/testRooPoisson.cxx,1,['avoid'],['avoid']
Safety,// Test whether Def is safe and profitable to rematerialize.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:23,safe,safe,23,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,1,['safe'],['safe']
Safety,// Test whether it's safe to move Def to just before Insert.; // TODO: Compute memory dependencies in a way that doesn't require always; // walking the block.; // TODO: Compute memory dependencies in a way that uses AliasAnalysis to be; // more precise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:21,safe,safe,21,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,1,['safe'],['safe']
Safety,"// Test whether the given instance can safely return to C++",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx:39,safe,safely,39,bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,1,['safe'],['safely']
Safety,// Testing it with denormal inputs to avoid wrong estimate.; //; // Test = fabs(X) < SmallestNormal,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:38,avoid,avoid,38,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// That index is not tracked. This is suprising, and unlikely to ever; // occur, but the safe action is to indicate the variable is optimised out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:89,safe,safe,89,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['safe'],['safe']
Safety,"// That is very tricky to store a value into an AGPR. v_accvgpr_write_b32; // can only accept VGPR or inline immediate. Recreate a reg_sequence with; // its initializers right here, so we will rematerialize immediates and; // avoid copies via different reg classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp:226,avoid,avoid,226,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFoldOperands.cpp,1,['avoid'],['avoid']
Safety,"// The ""default"" for integer RMW operations is to expand to an LL/SC loop.; // However, with the LSE instructions (or outline-atomics mode, which provides; // library routines in place of the LSE-instructions), we can directly emit many; // operations instead.; //; // Floating-point operations are always emitted to a cmpxchg loop, because they; // may trigger a trap which aborts an LLSC sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:375,abort,aborts,375,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['abort'],['aborts']
Safety,"// The '_node_get' helper function is used to avoid dependency on onnx submodule; // (for the subscript operator of torch._C.Node), as done in https://github.com/pytorch/pytorch/pull/82628",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/RModelParser_PyTorch.cxx:46,avoid,avoid,46,tmva/pymva/src/RModelParser_PyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/RModelParser_PyTorch.cxx,1,['avoid'],['avoid']
Safety,"// The 'g' groups options involve a somewhat intricate sequence of decisions; // about what to pass from the driver to the frontend, but by the time they; // reach cc1 they've been factored into three well-defined orthogonal choices:; // * what level of debug info to generate; // * what dwarf version to write; // * what debugger tuning to use; // This avoids having to monkey around further in cc1 other than to disable; // codeview if not running in a Windows environment. Perhaps even that; // decision should be made in the driver as well though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:354,avoid,avoids,354,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['avoid'],['avoids']
Safety,"// The -fmodule-name option tells the compiler to textually include headers in; // the specified module, meaning Clang won't build the specified module. This; // is useful in a number of situations, for instance, when building a library; // that vends a module map, one might want to avoid hitting intermediate build; // products containing the module map or avoid finding the system installed; // modulemap for that library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp:284,avoid,avoid,284,interpreter/llvm-project/clang/lib/Basic/Module.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Module.cpp,2,['avoid'],['avoid']
Safety,// The .bind here is in order to compose the error message more accurately.; // Also avoid intptr_t and uintptr_t because they were specifically created; // for storing pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:85,avoid,avoid,85,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,1,['avoid'],['avoid']
Safety,"// The .n qualifier is always discarded as that is what the tables; // and matcher expect. In ARM mode the .w qualifier has no effect,; // so discard it to avoid errors that can be caused by the matcher.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:156,avoid,avoid,156,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['avoid'],['avoid']
Safety,// The .new store version uses different resources so check if it; // causes a hazard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:79,hazard,hazard,79,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// The AArch64SpeculationHardeningPass destroys dominator tree and natural; // loop info, which is needed for the FalkorHWPFFixPass and also later on.; // Therefore, run the AArch64SpeculationHardeningPass before the; // FalkorHWPFFixPass to avoid recomputing dominator tree and natural loop; // info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp:242,avoid,avoid,242,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp,1,['avoid'],['avoid']
Safety,"// The AUTIASP instruction assembles to a hint instruction before v8.3a so; // this instruction can safely used for any v8a architecture.; // From v8.3a onwards there are optimised authenticate LR and return; // instructions, namely RETA{A,B}, that can be used instead. In this case the; // DW_CFA_AARCH64_negate_ra_state can't be emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp:100,safe,safely,100,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,1,['safe'],['safely']
Safety,"// The Basket was written so we can now safely reuse it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:40,safe,safely,40,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['safe'],['safely']
Safety,"// The CFG Simplifier pass may delete one of the basic blocks we are; // interested in. If it does we need to take the block out of the list. Make; // a ""persistent mapping"" by turning basic blocks into <function, name> pairs.; // This won't work well if blocks are unnamed, but that is just the risk we; // have to take. FIXME: Can we just name the blocks?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp:296,risk,risk,296,interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/CrashDebugger.cpp,1,['risk'],['risk']
Safety,// The Cyclone CPU and early successors didn't execute the zero-cycle zeroing; // instruction for FP registers correctly in some rare circumstances. Convert; // it to a safe instruction and warn (because silently changing someone's; // assembly is rude).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp:169,safe,safe,169,interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AsmParser/AArch64AsmParser.cpp,1,['safe'],['safe']
Safety,"// The DAG can change (due to CSE) during selection, so cache all the; // unselected nodes first to avoid traversing a mutating DAG.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:100,avoid,avoid,100,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['avoid'],['avoid']
Safety,"// The DeclRefExpr of CXXOperatorCallExpr referring to the custom operator is; // visited before the arguments to the operator call. For the Call and; // Subscript operator the range of this DeclRefExpr includes the whole call; // expression, so that all tokens in that range would be mapped to the; // operator function, including the tokens of the arguments. To avoid that,; // ensure to visit this DeclRefExpr as last node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:364,avoid,avoid,364,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['avoid'],['avoid']
Safety,// The DefaultBitN is here only to avoid frequent reallocation of the; // memory in the vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h:35,avoid,avoid,35,interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/BitTracker.h,1,['avoid'],['avoid']
Safety,// The DominatorTree needs to be rebuilt by any consumers after this; // transformation. We simply reset here rather than setting the ModifiedDT; // flag to avoid restarting the function walk in runOnFunction for each; // select optimized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:157,avoid,avoid,157,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,// The GCC runtime's personality function inherently doesn't support; // mixed EH. Use the ObjC personality just to avoid returning null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:116,avoid,avoid,116,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['avoid'],['avoid']
Safety,// The GNU headers like to define 'toupper' and 'tolower' redundantly. This is; // necessary to prevent it from doing that and remapping our implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h:58,redund,redundantly,58,interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/llvm_libc_wrappers/ctype.h,1,['redund'],['redundantly']
Safety,"// The IO bits flag is to provide improved forward-compatibility detection.; // Any new non-forward compatibility flags related serialization should be; // added here. When a new flag is added, set it in the kSupported field;; //; // The values and names of this (and EUnsupportedIOBits) enum need not be aligned; // with the values of the various TIOFeatures enums, as there's a clean separation; // between these two interfaces. Practically, it is reasonable to keep them as aligned; // as possible in order to avoid confusion.; //; // If (fIOBits & ~kSupported) is non-zero -- i.e., an unknown IO flag is set; // in the fIOBits -- then the zombie flag will be set for this object.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h:65,detect,detection,65,tree/tree/inc/TBasket.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TBasket.h,2,"['avoid', 'detect']","['avoid', 'detection']"
Safety,// The LastUseMask is queried from the liveness information of instruction; // which may be further down the schedule. Some lanes may actually not be; // last uses for the current position.; // FIXME: allow the caller to pass in the list of vreg uses that remain; // to be bottom-scheduled to avoid searching uses at each query.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp:293,avoid,avoid,293,interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterPressure.cpp,1,['avoid'],['avoid']
Safety,// The Mips N64 ABI allows up to three operations to be specified per; // relocation record. Unfortunately there's no easy way to test for the; // presence of N64 ELFs as they have no special flag that identifies them; // as being N64. We can safely assume at the moment that all Mips; // ELFCLASS64 ELFs are N64. New Mips64 ABIs should provide enough; // information to disambiguate between old vs new ABIs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h:243,safe,safely,243,interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELF.h,1,['safe'],['safely']
Safety,"// The ParseOpenACCCacheVarList function manages to recover from failures,; // so we can always consume the close.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp:52,recover,recover,52,interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenACC.cpp,1,['recover'],['recover']
Safety,// The PatFrags that call this may run before RISCVGenDAGISel.inc has checked; // the VT. Ensure the type is scalar to avoid wasting time on vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:119,avoid,avoid,119,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// The Preprocessor will try to set the NumCreatedFIDs but we are; // reparsing and this value was already set. Force reset it to avoid; // triggering an assertion in the setNumCreatedFIDsForFileID routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:130,avoid,avoid,130,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['avoid'],['avoid']
Safety,"// The ProcessLine might throw an 'exception'. In this case,; // GetLinem(kInit,""Root >"") is called and we are jump back; // to RETRY ... and we have to avoid the Getlinem(kInit, GetPrompt());",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TRint.cxx:153,avoid,avoid,153,core/rint/src/TRint.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TRint.cxx,1,['avoid'],['avoid']
Safety,// The RPC client symbol is defined in `libc` and indicates that something; // required an RPC server. If its users were all optimized out then we can; // safely remove it.; // TODO: This should be somewhere more common in the future.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:155,safe,safely,155,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['safe'],['safely']
Safety,"// The Reader is the module that creates the logical view using the debug; // information contained in the binary file specified in the command line.; // This is the main entry point for the Reader and performs the following; // steps:; // - Process any patterns collected from the '--select' options.; // - For each compile unit in the debug information:; // * Create the logical elements (scopes, symbols, types, lines).; // * Collect debug ranges and debug locations.; // * Move the collected logical lines to their associated scopes.; // - Once all the compile units have been processed, traverse the scopes; // tree in order to:; // * Calculate symbol coverage.; // * Detect invalid ranges and locations.; // * ""resolve"" the logical elements. During this pass, the names and; // file information are updated, to reflect any dependency with other; // logical elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp:673,Detect,Detect,673,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVReader.cpp,1,['Detect'],['Detect']
Safety,// The SYM64 format is used when an archive's member offsets are larger than; // 32-bits can hold. The need for this shift in format is detected by; // writeArchive. To test this we need to generate a file with a member that; // has an offset larger than 32-bits but this demands a very slow test. To; // speed the test up we use this environment variable to pretend like the; // cutoff happens before 32-bits and instead happens at some much smaller; // value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp:136,detect,detected,136,interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,1,['detect'],['detected']
Safety,"// The TBranch destructor is using fDirectory to detect whether it; // owns the TFile that contains its data (See TBranch::~TBranch)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:49,detect,detect,49,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['detect'],['detect']
Safety,"// The TfrI does not access memory, but DefI could. Check if it's safe; // to move DefI down to TfrI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:66,safe,safe,66,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['safe'],['safe']
Safety,// The XPACLRI instruction assembles to a hint-space instruction before; // Armv8.3-A therefore this instruction can be safely used for any pre; // Armv8.3-A architectures. On Armv8.3-A and onwards XPACI is available so use; // that instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:120,safe,safely,120,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['safe'],['safely']
Safety,"// The Z(2) axis of frustum (near->far plane) can be quite shallow c.f. X(0)/Y(1); // For interest box we want to expand to ensure it is at least size; // of smaller X/Y to avoid excessive interest box recalculations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx:173,avoid,avoid,173,graf3d/gl/src/TGLCamera.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLCamera.cxx,1,['avoid'],['avoid']
Safety,"// The __unsafe_unretained qualifier is *not* mangled, so that; // __unsafe_unretained types in ARC produce the same manglings as the; // equivalent (but, naturally, unqualified) types in non-ARC, providing; // better ABI compatibility.; //; // It's safe to do this because unqualified 'id' won't show up; // in any type signatures that need to be mangled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:250,safe,safe,250,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['safe'],['safe']
Safety,// The above case covers all the enumerators so it can't have a default clause; // to avoid compiler warnings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,// The active bits should be less than the bits in the RangeCheckType. This; // guarantees that truncating the latch check to RangeCheckType is a safe; // operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:146,safe,safe,146,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['safe'],['safe']
Safety,"// The actual information about the decl may have been loaded via an; // external source that created a new AST node/decl for the definition; // rather than reusing the one we had (DC) like the ASTReader does.; // To avoid the caller to continue using the still incomplete decl, let's; // set it to the definition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:217,avoid,avoid,217,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['avoid'],['avoid']
Safety,// The additional cast to unsigned long long is required to avoid the; // Visual C++ warning C4805: '!=' : unsafe mix of type 'bool' and type; // 'unsigned __int64' when instantiating getAsInteger with T = bool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:60,avoid,avoid,60,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,2,"['avoid', 'unsafe']","['avoid', 'unsafe']"
Safety,"// The amdgpu-unsafe-fp-atomics attribute enables generation of unsafe; // floating point atomic instructions. May generate more efficient code,; // but may not respect rounding and denormal modes, and may give incorrect; // results for certain memory destinations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:14,unsafe,unsafe-fp-atomics,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,2,['unsafe'],"['unsafe', 'unsafe-fp-atomics']"
Safety,"// The assembler has relaxed rules for accepting identifiers, in particular we; // allow things like '.globl $foo' and '.def @feat.00', which would normally be; // separate tokens. At this level, we have already lexed so we cannot (currently); // handle this as a context dependent token, instead we detect adjacent tokens; // and return the combined identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:300,detect,detect,300,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['detect'],['detect']
Safety,"// The assembler has relaxed rules for accepting identifiers, in particular we; // allow things like '.globl $foo' and '.def @feat.00', which would normally; // be separate tokens. At this level, we have already lexed so we cannot; // (currently) handle this as a context dependent token, instead we detect; // adjacent tokens and return the combined identifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp:300,detect,detect,300,interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/MasmParser.cpp,1,['detect'],['detect']
Safety,"// The assert above should make this ""safer"" to satisfy the YAMLTraits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkSerializer.cpp:38,safe,safer,38,interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkSerializer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Remarks/YAMLRemarkSerializer.cpp,1,['safe'],['safer']
Safety,"// The automatic conversion of ordinary obejcts to smart pointers is disabled; // for PyROOT because it can cause trouble with overload resolution. If a; // function has overloads for both ordinary objects and smart pointers, then; // the implicit conversion to smart pointers can result in the smart pointer; // overload being hit, even though there would be an overload for the regular; // object. Since PyROOT didn't have this feature before 6.32 anyway, disabling; // it was the safest option.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:483,safe,safest,483,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['safe'],['safest']
Safety,// The base costs are comparable so we may only keep the relative; // value to increase our chances of avoiding overflows.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp:103,avoid,avoiding,103,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/RegBankSelect.cpp,1,['avoid'],['avoiding']
Safety,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:41,safe,safepoint,41,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,6,['safe'],['safepoint']
Safety,"// The basic algorithm here is:; // 1. Mark registers of def operands as free; // 2. Allocate registers to use operands and place reload instructions for; // registers displaced by the allocation.; //; // However we need to handle some corner cases:; // - pre-assigned defs and uses need to be handled before the other def/use; // operands are processed to avoid the allocation heuristics clashing with; // the pre-assignment.; // - The ""free def operands"" step has to come last instead of first for tied; // operands and early-clobbers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:357,avoid,avoid,357,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['avoid'],['avoid']
Safety,"// The basic scheme here is that information about both the original call and; // the safepoint is encoded in the CallInst. We create a temporary call and; // lower it, then reverse engineer the calling sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:86,safe,safepoint,86,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,1,['safe'],['safepoint']
Safety,// The below methods are protected to encourage subclasses to provide a more; // type-safe API.; /// reserve - Increase the number of buckets such that adding the; /// EltCount-th node won't cause a rebucket operation. reserve is permitted; /// to allocate more space than requested by EltCount.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:86,safe,safe,86,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['safe'],['safe']
Safety,// The bitcast source is a direct mmx result.; // Detect bitcasts between i32 to x86mmx,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:50,Detect,Detect,50,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,// The blocks that have terminators with constant condition that can be; // folded. Note: fold candidates should be in L but not in any of its; // subloops to avoid complex LI updates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:159,avoid,avoid,159,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"// The branches have been checked to match, so it is safe to remove the; // branch in BB1 and rely on the copy in BB2. The complication is that; // the blocks may end with a return instruction, which may or may not; // be marked as ""branch"". If it's not, then it could be included in; // ""dups1"", leaving the blocks potentially empty after moving the common; // duplicates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:53,safe,safe,53,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['safe'],['safe']
Safety,"// The byte offset is relative to the start of the string table.; // A byte offset value of 0 is a null or zero-length symbol; // name. A byte offset in the range 1 to 3 (inclusive) points into the length; // field; as a soft-error recovery mechanism, we treat such cases as having an; // offset of 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp:232,recover,recovery,232,interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/XCOFFObjectFile.cpp,1,['recover'],['recovery']
Safety,"// The call to TChain::BuildIndex does much more than just copying; // the indices that may have been already present in the trees of the; // chain. Notably, it calls `LoadTree` for every tree in the chain; // making sure that all branches, indices and relationships are; // properly set. In order to avoid unexpected behaviours, we always; // let the task-local friend chain rebuild its index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:301,avoid,avoid,301,tree/tree/src/InternalTreeUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx,1,['avoid'],['avoid']
Safety,"// The canonical declaration of every specialization is registered with; // the FunctionTemplateDecl.; // Note this might unload too much in the case:; // template<typename T> T f(){ return T();}; // template<> int f();; // template<> int f() { return 0;}; // when the template specialization was forward declared the canonical; // becomes the first forward declaration. If the canonical forward; // declaration was declared outside the set of the decls to unload we have; // to keep it registered as a template specialization.; //; // In order to diagnose mismatches of the specializations, clang 'injects'; // a implicit forward declaration making it very hard distinguish between; // the explicit and the implicit forward declaration. So far the only way; // to distinguish is by source location comparison.; // FIXME: When the misbehavior of clang is fixed we must avoid relying on; // source locations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp:869,avoid,avoid,869,interpreter/cling/lib/Interpreter/DeclUnloader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclUnloader.cpp,1,['avoid'],['avoid']
Safety,"// The case of Width == 0 is handled above, which makes this transformation; // safe. If Width == 0, then the ashr and lshr instructions become poison; // value since the shift amount would be equal to the bit size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:80,safe,safe,80,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['safe'],['safe']
Safety,// The cast avoids undefined behavior if the constant is INT64_MIN.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:12,avoid,avoids,12,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,1,['avoid'],['avoids']
Safety,"// The character is not safe, at least simple quoting needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h:24,safe,safe,24,interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/YAMLTraits.h,1,['safe'],['safe']
Safety,// The clang AST has several methods on base classes which are overriden; // pseudo-virtually by derived classes.; // We record only the pseudo-virtual methods on the base classes to; // avoid duplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ASTSrcLocProcessor.cpp:187,avoid,avoid,187,interpreter/llvm-project/clang/lib/Tooling/DumpTool/ASTSrcLocProcessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/DumpTool/ASTSrcLocProcessor.cpp,1,['avoid'],['avoid']
Safety,"// The code region for a whole macro is created in handleFileExit() when; // it detects exiting of the virtual file of that macro. If we visited; // statements in non-source order, we might already have such a region; // added, for example, if a body of a loop is divided among multiple; // macros. Avoid adding duplicate regions in such case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp:80,detect,detects,80,interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,2,"['Avoid', 'detect']","['Avoid', 'detects']"
Safety,"// The code transformation here is a modified version of the sinking; // transformation in CodeGenPrepare::optimizeSelectInst with a more; // aggressive strategy of which instructions to sink.; //; // TODO: eliminate the redundancy of logic transforming selects to branches; // by removing CodeGenPrepare::optimizeSelectInst and optimizing here; // selects for all cases (with and without profile information).; // Transform a sequence like this:; // start:; // %cmp = cmp uge i32 %a, %b; // %sel = select i1 %cmp, i32 %c, i32 %d; //; // Into:; // start:; // %cmp = cmp uge i32 %a, %b; // %cmp.frozen = freeze %cmp; // br i1 %cmp.frozen, label %select.true, label %select.false; // select.true:; // br label %select.end; // select.false:; // br label %select.end; // select.end:; // %sel = phi i32 [ %c, %select.true ], [ %d, %select.false ]; //; // %cmp should be frozen, otherwise it may introduce undefined behavior.; // In addition, we may sink instructions that produce %c or %d into the; // destination(s) of the new branch.; // If the true or false blocks do not contain a sunken instruction, that; // block and its branch may be optimized away. In that case, one side of the; // first branch will point directly to select.end, and the corresponding PHI; // predecessor block will be the start block.; // Find all the instructions that can be soundly sunk to the true/false; // blocks. These are instructions that are computed solely for producing the; // operands of the select instructions in the group and can be sunk without; // breaking the semantics of the LLVM IR (e.g., cannot sink instructions; // with side effects).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp:221,redund,redundancy,221,interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectOptimize.cpp,1,['redund'],['redundancy']
Safety,"// The code-generator is currently not able to handle scalable vectors; // of <vscale x 1 x eltty> yet, so return an invalid cost to avoid selecting; // it. This change will be removed when code-generation for these types is; // sufficiently reliable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:133,avoid,avoid,133,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,4,['avoid'],['avoid']
Safety,"// The command line is unusual compared to other fuzzers due to the need to; // specify the target. Options like -triple, -mcpu, and -mattr work like; // their counterparts in llvm-mc, while -fuzzer-args collects options for the; // fuzzer itself.; //; // Examples:; //; // Fuzz the big-endian MIPS32R6 disassembler using 100,000 inputs of up to; // 4-bytes each and use the contents of ./corpus as the test corpus:; // llvm-mc-fuzzer -triple mips-linux-gnu -mcpu=mips32r6 -disassemble \; // -fuzzer-args -max_len=4 -runs=100000 ./corpus; //; // Infinitely fuzz the little-endian MIPS64R2 disassembler with the MSA; // feature enabled using up to 64-byte inputs:; // llvm-mc-fuzzer -triple mipsel-linux-gnu -mcpu=mips64r2 -mattr=msa \; // -disassemble -fuzzer-args ./corpus; //; // If your aim is to find instructions that are not tested, then it is; // advisable to constrain the maximum input size to a single instruction; // using -max_len as in the first example. This results in a test corpus of; // individual instructions that test unique paths. Without this constraint,; // there will be considerable redundancy in the corpus.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp:1109,redund,redundancy,1109,interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-mc-assemble-fuzzer/llvm-mc-assemble-fuzzer.cpp,2,['redund'],['redundancy']
Safety,"// The common successor has to be dominated by the branch, as otherwise; // there will be some other path to the successor that will not be; // controlled by this branch so any phi we hoist would be controlled by the; // wrong condition. This also takes care of avoiding hoisting of loop back; // edges.; // TODO: In some cases this could be relaxed if the successor is dominated; // by another block that's been hoisted and we can guarantee that the; // control flow has been replicated exactly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:262,avoid,avoiding,262,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['avoid'],['avoiding']
Safety,"// The constant 25 instructions is added to avoid depending too much on; // accidental SlotIndex gaps for small intervals. The effect is that small; // intervals have a spill weight that is mostly proportional to the number; // of uses, while large intervals get a spill weight that is closer to a use; // density.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h:44,avoid,avoid,44,interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h,1,['avoid'],['avoid']
Safety,"// The constructor has to initialize a APFloat, which is unnecessary for; // most addends which have coefficient either 1 or -1. So, the constructor; // is expensive. In order to avoid the cost of the constructor, we should; // reuse some instances whenever possible. The pre-created instances; // FAddCombine::Add[0-5] embodies this idea.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:179,avoid,avoid,179,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['avoid'],['avoid']
Safety,"// The context comes first, but they're both in the same block.; // Make sure there is nothing in between that might interrupt; // the control flow, not even CxtI itself.; // We limit the scan distance between the assume and its context instruction; // to avoid a compile-time explosion. This limit is chosen arbitrarily, so; // it can be adjusted if needed (could be turned into a cl::opt).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:256,avoid,avoid,256,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['avoid'],['avoid']
Safety,// The cost of materializing the constants (defined in; // `TargetTransformInfo::getIntImmCostInst`) for instructions which only; // take constant variables is lower than `TargetTransformInfo::TCC_Basic`.; // So it's safe for us to collect constant candidates from all; // IntrinsicInsts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp:217,safe,safe,217,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ConstantHoisting.cpp,1,['safe'],['safe']
Safety,"// The cycle savings expressed as the sum of InstrCost; // multiplied by the estimated dynamic count of each instruction we can; // avoid. Savings come from the call site cost, such as argument setup and; // the call instruction, as well as the instructions that are folded.; //; // We use 128-bit APInt here to avoid potential overflow. This variable; // should stay well below 10^^24 (or 2^^80) in practice. This ""worst"" case; // assumes that we can avoid or fold a billion instructions, each with a; // profile count of 10^^15 -- roughly the number of cycles for a 24-hour; // period on a 4GHz machine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:132,avoid,avoid,132,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,3,['avoid'],['avoid']
Safety,"// The data member of this class is an RVec, to avoid an extra copy; // but we need to return the array buffer as the reader expects; // a std::array",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx:48,avoid,avoid,48,tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RTreeColumnReader.hxx,1,['avoid'],['avoid']
Safety,"// The debug_entry describes the source line information. It is defined as; // follows in order:; // * uint64_t code_addr: address of function for which the debug information; // is generated; // * uint32_t line : source file line number (starting at 1); // * uint32_t discrim : column discriminator, 0 is default; // * char name[n] : source file name in ASCII, including null termination; // avoid interspersing output",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:393,avoid,avoid,393,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,1,['avoid'],['avoid']
Safety,"// The declaration won't be seen outside of the statement, so we don't; // have to wrap the uses of any declared variables in if (@available).; // Therefore we can avoid setting Scope here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp:164,avoid,avoid,164,interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAvailability.cpp,1,['avoid'],['avoid']
Safety,"// The deduction failure is diagnosed and marked, try to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:57,recover,recover,57,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['recover'],['recover']
Safety,"// The default assumption needs to be ecc is enabled, but no directly; // exposed operations depend on it, so it can be safely inlined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp:120,safe,safely,120,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetTransformInfo.cpp,1,['safe'],['safely']
Safety,"// The default is to transform llvm.ctlz(x, false) (where false indicates that; // x == 0 is not undefined behavior) into a branch that checks whether x is 0; // and avoids calling ctlz in that case. We have a dedicated ctlz; // instruction, so we say that ctlz is cheap to speculate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h:166,avoid,avoids,166,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.h,1,['avoid'],['avoids']
Safety,// The default stack probe size is 4096 if the function has no; // stack-probe-size attribute. This is a safe default because it is the; // smallest possible guard page size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.cpp:105,safe,safe,105,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.cpp,1,['safe'],['safe']
Safety,// The default value safely does nothing. Option value printing is only; // best-effort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:21,safe,safely,21,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['safe'],['safely']
Safety,// The delay slot filler pass can potientially create forbidden slot hazards; // for MIPSR6 and therefore it should go before MipsBranchExpansion pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:69,hazard,hazards,69,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,1,['hazard'],['hazards']
Safety,// The dynamically detected SIMD degree of the current platform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_dispatch.c:19,detect,detected,19,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_dispatch.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3_dispatch.c,1,['detect'],['detected']
Safety,"// The ellipsis was put in the wrong place. Recover, and explain to; // the user what they should have done.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:44,Recover,Recover,44,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['Recover'],['Recover']
Safety,// The emitted value is guaranteed to have the same size as the; // destination but can have a different type. Just do a bitcast in this; // case to avoid incorrect GEPs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:149,avoid,avoid,149,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['avoid'],['avoid']
Safety,// The enum could be incomplete if we're parsing its definition or; // recovering from an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:71,recover,recovering,71,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['recover'],['recovering']
Safety,"// The enumerants are automatically generated based on the variety,; // namespace (if present) and name for each attribute spelling. However,; // care is taken to avoid trampling on the reserved namespace due to; // underscores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:163,avoid,avoid,163,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['avoid'],['avoid']
Safety,"// The evaluation of this constraint resulted in us trying to re-evaluate it; // recursively. This isn't really possible, except we try to form a; // RecoveryExpr as a part of the evaluation. If this is the case, just; // return the 'cached' version (which will have the same result), and save; // ourselves the extra-insert. If it ever becomes possible to legitimately; // recursively check a constraint, we should skip checking the 'inner' one; // above, and replace the cached version with this one, as it would be more; // specific.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:150,Recover,RecoveryExpr,150,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,1,['Recover'],['RecoveryExpr']
Safety,// The explicit zeroing is redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:27,redund,redundant,27,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['redund'],['redundant']
Safety,"// The exponent is an ""unspecified value"" for inf/nan. We use zero to avoid; // using undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:70,avoid,avoid,70,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['avoid'],['avoid']
Safety,"// The file cache was restored to its previous value at the end of Exec,; // we can safely delete our cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx:84,safe,safely,84,tree/tree/src/TTreeCloner.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCloner.cxx,1,['safe'],['safely']
Safety,"// The file information is used to show the source file for any element; // and display any new source file in relation to its parent element.; // a) Elements that are not inlined.; // - We record the DW_AT_decl_line and DW_AT_decl_file.; // b) Elements that are inlined.; // - We record the DW_AT_decl_line and DW_AT_decl_file.; // - We record the DW_AT_call_line and DW_AT_call_file.; // For both cases, we use the DW_AT_decl_file value to detect any changes; // in the source filename containing the element. Changes on this value; // indicates that the element being printed is not contained in the; // previous printed filename.; // The source files are indexed starting at 0, but DW_AT_decl_file defines; // that 0 means no file; a value of 1 means the 0th entry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVElement.cpp:442,detect,detect,442,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVElement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Core/LVElement.cpp,1,['detect'],['detect']
Safety,"// The file is supposed to be small enough to allow for quick scanning by the patching done later.; // Let's put 4KB as a safe limit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx:122,safe,safe,122,tree/ntuple/v7/test/ntuple_compat.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_compat.cxx,1,['safe'],['safe']
Safety,"// The first element must be a TList instead of a TSelector List, to avoid duplicate problems with merging",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMP.cxx:69,avoid,avoid,69,tree/treeplayer/src/TTreeProcessorMP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMP.cxx,3,['avoid'],['avoid']
Safety,"// The following are overriding methods from the base visitor class.; // They are public only to allow CRTP to work. They are *not *part; // of the public API of this class.; // For the matchers so far used in safe buffers, we only need to match; // `Stmt`s. To override more as needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:210,safe,safe,210,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['safe'],['safe']
Safety,"// The following code may create a signing oracle:; //; // <authenticate LR>; // TCRETURN ; the callee may sign and spill the LR in its prologue; //; // To avoid generating a signing oracle, check the authenticated value; // before possibly re-signing it in the callee, as follows:; //; // <authenticate LR>; // <check if LR contains a valid address>; // b.<cond> break_block; // ret_block:; // TCRETURN; // break_block:; // brk <BrkOperand>; //; // or just; //; // <authenticate LR>; // ldr tmp, [lr]; // TCRETURN; // TmpReg is chosen assuming X16 and X17 are dead after TI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp:156,avoid,avoid,156,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64PointerAuth.cpp,1,['avoid'],['avoid']
Safety,"// The following code pattern is handled:; // %3 = call i8* @llvm.stacksave(); // store i8* %3, i8** %saved_stack, align 8; // ...; // %4 = load i8*, i8** %saved_stack, align 8; // call void @llvm.stackrestore(i8* %4); // ...; // The goal is to remove the above four instructions,; // so we won't have instructions with r11 (stack pointer); // if eventually there is no variable length stack allocation.; // InstrCombine also tries to remove the above instructions,; // if it is proven safe (constant alloca etc.), but depending; // on code pattern, it may still miss some.; //; // With unconditionally removing these instructions, if alloca is; // constant, we are okay then. Otherwise, SelectionDag will complain; // since BPF does not support dynamic allocation yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp:486,safe,safe,486,interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFIRPeephole.cpp,1,['safe'],['safe']
Safety,"// The following function is not memory safe, because it takes ownership of var; // without moving it. It is not publicly available in the memory safe; // interfaces mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCollectionProxy.h:40,safe,safe,40,roofit/roofitcore/inc/RooCollectionProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooCollectionProxy.h,2,['safe'],['safe']
Safety,// The following is safe because we only use this method for; // non-overloadable operands.; // C++ [expr.log.and]p1; // C++ [expr.log.or]p1; // The operands are both contextually converted to type bool.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:20,safe,safe,20,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['safe'],['safe']
Safety,// The following section will be LFENCEing before groups of terminators; // that include branches. This will close the branch prediction side; // channels since we will prevent code executing after misspeculation as; // a result of the LFENCEs placed with this logic.; // Keep track of the first terminator in a basic block since if we need; // to LFENCE the terminators in this basic block we must add the; // instruction before the first terminator in the basic block (as; // opposed to before the terminator that indicates an LFENCE is; // required). An example of why this is necessary is that the; // X86InstrInfo::analyzeBranch method assumes all terminators are grouped; // together and terminates it's analysis once the first non-termintor; // instruction is found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp:126,predict,prediction,126,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp,1,['predict'],['prediction']
Safety,// The following semantically builds up a fixed length concat_vector; // of the component build_vectors. We eagerly lower to scalable and; // insert_subvector here to avoid DAG combining it back to a large; // build_vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:167,avoid,avoid,167,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,// The following semantically builds up a fixed length concat_vector; // of the component shuffle_vectors. We eagerly lower to scalable here; // to avoid DAG combining it back to a large shuffle_vector again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:148,avoid,avoid,148,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,// The following transforms are only safe if the ptrtoint cast; // doesn't truncate the pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:37,safe,safe,37,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['safe'],['safe']
Safety,"// The friend is a TTree. It's safe to add to the chain the filename directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:31,safe,safe,31,tree/tree/src/InternalTreeUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx,1,['safe'],['safe']
Safety,"// The function is not used by a trampoline intrinsic, so it is safe; // to remove the 'nest' attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:64,safe,safe,64,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['safe'],['safe']
Safety,// The function label could have already been emitted if two symbols end up; // conflicting due to asm renaming. Detect this and emit an error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:113,Detect,Detect,113,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['Detect'],['Detect']
Safety,"// The gMainDict is borrowed, i.e. we are not calling Py_INCREF(gMainDict).; // Like this, we avoid unexpectedly affecting how long __main__ is kept; // alive. The gMainDict is only used in Exec(), ExecScript(), and Eval(),; // which should not be called after __main__ is garbage collected anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx:94,avoid,avoid,94,bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/API.cxx,2,['avoid'],['avoid']
Safety,// The general strategy of the algorithm implemented below is to map each; // of the sub-values in `Vals` to a unique variable and use these variables in; // the resulting CNF expression to avoid exponential blow up. The number of; // literals in the resulting formula is guaranteed to be linear in the number; // of sub-formulas in `Vals`.; // Map each sub-formula in `Vals` to a unique variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp:190,avoid,avoid,190,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/WatchedLiteralsSolver.cpp,1,['avoid'],['avoid']
Safety,// The generic legalizer will try to widen the input type to the same; // number of elements as the widened result type. But this isn't always; // the best thing so do some custom legalization to avoid some cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:196,avoid,avoid,196,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// The gnu_debuglink's target is expected to not change or else its CRC would; // become invalidated and get rejected. We can avoid recalculating the; // checksum for every target file inside an archive by precomputing the CRC; // here. This prevents a significant amount of I/O.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.cpp:126,avoid,avoid,126,interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-objcopy/ObjcopyOptions.cpp,1,['avoid'],['avoid']
Safety,"// The hazard recognizer that runs as part of the post-ra scheduler does not; // guarantee to be able handle all hazards correctly. This is because if there; // are multiple scheduling regions in a basic block, the regions are scheduled; // bottom up, so when we begin to schedule a region we don't know what; // instructions were emitted directly before it.; //; // Here we add a stand-alone hazard recognizer pass which can handle all; // cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp:7,hazard,hazard,7,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUTargetMachine.cpp,3,['hazard'],"['hazard', 'hazards']"
Safety,"// The hazard sequence is three instructions:; // 1. VALU reads SGPR as mask; // 2. SALU writes SGPR; // 3. SALU reads SGPR; // The hazard can expire if the distance between 2 and 3 is sufficient.; // In practice this happens <10% of the time, hence this always assumes; // the hazard exists if 1 and 2 are present to avoid searching.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:7,hazard,hazard,7,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,4,"['avoid', 'hazard']","['avoid', 'hazard']"
Safety,"// The idea of the RooGenProdProj is that we divide two integral objects each; // created with this makeIntegral() function to get the normalized integral of; // a product. Therefore, we don't need to normalize the numerater and; // denominator integrals themselves. Doing the normalization would be; // expensive and it would cancel out anyway. However, if we don't specify an; // explicit normalization integral in createIntegral(), the last-used; // normalization set might be used to normalize the pdf, resulting in; // redundant computations.; //; // For this reason, the normalization set of the integrated pdfs is fixed to; // an empty set in this case. Note that in RooFit, a nullptr normalization; // set and an empty normalization set is not equivalent. The former implies; // taking the last-used normalization set, and the latter means explicitly no; // normalization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx:524,redund,redundant,524,roofit/roofitcore/src/RooGenProdProj.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenProdProj.cxx,1,['redund'],['redundant']
Safety,"// The idle timeout guard: stops the timer and restarts when we return from here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:12,timeout,timeout,12,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['timeout'],['timeout']
Safety,"// The imm operand of ADDS is an unsigned immediate, in the range 0 to 4095.; // For the i8 operand, the largest immediate is 255, so this can be easily; // encoded in the compare instruction. For the i16 operand, however, the; // largest immediate cannot be encoded in the compare.; // Therefore, use a sign extending load and cmn to avoid materializing the; // -1 constant. For example,; // movz w1, #65535; // ldrh w0, [x0, #0]; // cmp w0, w1; // >; // ldrsh w0, [x0, #0]; // cmn w0, #1; // Fundamental, we're relying on the property that (zext LHS) == (zext RHS); // if and only if (sext LHS) == (sext RHS). The checks are in place to; // ensure both the LHS and RHS are truly zero extended and to make sure the; // transformation is profitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:335,avoid,avoid,335,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// The incoming block with our source operand must be the ""guard"" block.; // That must contain a cmp+branch to avoid the funnel/rotate when the shift; // amount is equal to 0. The other incoming block is the block with the; // funnel/rotate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:111,avoid,avoid,111,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['avoid'],['avoid']
Safety,"// The induction itself.; // Note that while NUW is always safe, while NSW is only for bitwidths != 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:59,safe,safe,59,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['safe'],['safe']
Safety,// The infrastructure for normal calling convention lowering is essentially; // useless for kernels. We want to avoid any kind of legalization or argument; // splitting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp:112,avoid,avoid,112,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCallLowering.cpp,1,['avoid'],['avoid']
Safety,"// The inline deferral logic is used to avoid losing some; // inlining chance in future. It is helpful in SCC inliner, in which; // inlining is processed in bottom-up order.; // While in module inliner, the inlining order is a priority-based order; // by default. The inline deferral is unnecessary there. So we disable the; // inline deferral logic in module inliner.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:40,avoid,avoid,40,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['avoid'],['avoid']
Safety,"// The inner loop exit block does flow to the outer loop latch and not some; // other BBs, now make sure it contains safe instructions, since it will be; // moved into the (new) inner loop after interchange.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:117,safe,safe,117,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['safe'],['safe']
Safety,// The inner op must match. Check for constants to avoid infinite loops.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['avoid'],['avoid']
Safety,"// The instance typically gets created by some Job. Once all Jobs are gone, the; // JM will get destroyed. In this case, the job_objects map should have; // been emptied.; // The second case is when the program ends, at which time the static instance; // is destroyed. Jobs may still be present, for instance, the Job subclass; // RooFit::TestStatistics::LikelihoodGradientJob, will have; // been put into RooMinimizer::_theFitter->fObjFunction, as the gradient; // member. Because _theFitter is also a global static member, we cannot; // guarantee destruction order, and so the JobManager may be destroyed before; // all Jobs are destroyed. We cannot therefore make sure that the first; // condition is met. However, the Job objects stuck in _theFitter are not; // meant to be run again, because the program is ending anyway. So also in this; // case, we can safely shut down.; // There used to be an assert statement that checked whether the job_objects; // map was empty at destruction time, but that neglected the second possibility; // and led to assertion failures, which left the Messenger and ProcessManager; // objects intact, leading to the forked processes and their ZeroMQ resources; // to remain after exiting the main/master/parent process.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/JobManager.cxx:860,safe,safely,860,roofit/multiprocess/src/JobManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/JobManager.cxx,1,['safe'],['safely']
Safety,"// The instance wants to take ownership, however DisableFree frontend option; // is set to true to avoid double free issues",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.cpp:99,avoid,avoid,99,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/ModelInjector.cpp,1,['avoid'],['avoid']
Safety,// The instruction clobbers EFLAGS. Re-materialize as MOV32ri to avoid side; // effects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:65,avoid,avoid,65,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// The interpreter does not know about this class yet (or a problem; // occurred that prevented the proper updating of fClassInfo).; // So this decl can not possibly be part of this class.; // [In addition calling GetClassInfo would trigger a late parsing; // of the header which we want to avoid].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfDataMembers.cxx:291,avoid,avoid,291,core/meta/src/TListOfDataMembers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TListOfDataMembers.cxx,3,['avoid'],['avoid']
Safety,"// The interpreter needs to know about RQ_OBJECTTester and using this trick avoids moving this non-reusable class into; // its own header file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/test/TQObjectTests.cxx:76,avoid,avoids,76,core/base/test/TQObjectTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/test/TQObjectTests.cxx,1,['avoid'],['avoids']
Safety,"// The intrinsic call will detect overflow when the value is > UINT_MAX,; // however, since the original builtin had a signed result, we need to report; // an overflow when the result is greater than INT_MAX.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:27,detect,detect,27,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['detect'],['detect']
Safety,"// The inverse of the live set is the dead set. These are those instructions; // that have no side effects and do not influence the control flow or return; // value of the function, and may therefore be deleted safely.; // NOTE: We reuse the Worklist vector here for memory efficiency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp:211,safe,safely,211,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ADCE.cpp,1,['safe'],['safely']
Safety,// The iteration count is required to recover location values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:38,recover,recover,38,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['recover'],['recover']
Safety,"// The largest power of 2 that divides both A and B.; //; // Replace ""-Value"" by ""1+~Value"" in the following commented code to avoid; // MSVC warning C4146; // return (A | B) & -(A | B);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h:127,avoid,avoid,127,interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,1,['avoid'],['avoid']
Safety,// The last number that can fit in Type's TC.; // Avoids conflict with an existing Type class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/LocInfoType.h:50,Avoid,Avoids,50,interpreter/llvm-project/clang/include/clang/AST/LocInfoType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/LocInfoType.h,1,['Avoid'],['Avoids']
Safety,"// The legalize process is inherently a bottom-up recursive process (users; // legalize their uses before themselves). Given infinite stack space, we; // could just start legalizing on the root and traverse the whole graph. In; // practice however, this causes us to run out of stack space on large basic; // blocks. To avoid this problem, compute an ordering of the nodes where each; // node is only legalized after all of its operands are legalized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:320,avoid,avoid,320,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['avoid'],['avoid']
Safety,"// The list contains fHClone, so let's clear it first to avoid; // accessing deleted memory later [we 'could' have just removed; // fHClone from the list]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h:57,avoid,avoid,57,hist/hist/src/TH1Merger.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.h,1,['avoid'],['avoid']
Safety,"// The list of friends needs to be accessed via GetTree()->GetListOfFriends(); // (and not directly GetListOfFriends()), otherwise when `main` is a TChain we; // might not recover the list correctly (see #6993 for the TTreeReader issue; // and #6741 for a more complete discussion/explanation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFriendProxy.cxx:172,recover,recover,172,tree/treeplayer/src/TFriendProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFriendProxy.cxx,1,['recover'],['recover']
Safety,"// The list of friends needs to be accessed via GetTree()->GetListOfFriends(); // (and not via GetListOfFriends() directly), otherwise when `t` is a TChain we; // might not recover the list correctly (https://github.com/root-project/root/issues/6741).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:173,recover,recover,173,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['recover'],['recover']
Safety,// The list of pointers that we can safely read and write to remains empty.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:36,safe,safely,36,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['safe'],['safely']
Safety,"// The livein has no non-dbg uses. Drop it.; //; // It would be preferable to have isel avoid creating live-in; // records for unused arguments in the first place, but it's; // complicated by the debug info code for arguments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp:88,avoid,avoid,88,interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineRegisterInfo.cpp,1,['avoid'],['avoid']
Safety,// The llvm Support classes don't handle reading from stdout of a child; // process; otherwise we could avoid using a temp file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/llvm-rc.cpp:104,avoid,avoid,104,interpreter/llvm-project/llvm/tools/llvm-rc/llvm-rc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/llvm-rc.cpp,1,['avoid'],['avoid']
Safety,// The load must be used exclusively to store into other pointers for; // us to be able to arbitrarily pre-split it. The stores must also be; // simple to avoid changing semantics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:155,avoid,avoid,155,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['avoid'],['avoid']
Safety,// The location has a recovery expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:22,recover,recovery,22,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['recover'],['recovery']
Safety,"// The lock above does not work, so at least; // minimize the risk",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:62,risk,risk,62,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,1,['risk'],['risk']
Safety,// The loop-rotate pass can be helpful to avoid this in many cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,2,['avoid'],['avoid']
Safety,"// The low PC must be less than the high PC. Many linkers don't remove; // DWARF for functions that don't get linked into the final executable.; // If both the high and low pc have relocations, linkers will often set; // the address values for both to the same value to indicate the function; // has been remove. Other linkers have been known to set the one or both; // PC values to a UINT32_MAX for 4 byte addresses and UINT64_MAX for 8; // byte addresses to indicate the function isn't valid. The check below; // tries to watch for these cases and abort if it runs into them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp:550,abort,abort,550,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,1,['abort'],['abort']
Safety,"// The machine scheduler may accidentally create disconnected components; // when moving subregister definitions around, avoid this by splitting them to; // separate vregs before. Splitting can also improve reg. allocation quality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:121,avoid,avoid,121,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['avoid'],['avoid']
Safety,"// The main pain point with multi-exit loop unrolling is that once unrolled,; // we will not be able to merge all blocks into a straight line code.; // There are branches within the unrolled loop that go to the OtherExits.; // The second point is the increase in code size, but this is true; // irrespective of multiple exits.; // Note: Both the heuristics below are coarse grained. We are essentially; // enabling unrolling of loops that have a single side exit other than the; // normal LatchExit (i.e. exiting into a deoptimize block).; // The heuristics considered are:; // 1. low number of branches in the unrolled version.; // 2. high predictability of these extra branches.; // We avoid unrolling loops that have more than two exiting blocks. This; // limits the total number of branches in the unrolled loop to be atmost; // the unroll factor (since one of the exiting blocks is the latch block).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:641,predict,predictability,641,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,2,"['avoid', 'predict']","['avoid', 'predictability']"
Safety,"// The main purpose of iterators is to abstract away from different; // containers and provide a (maybe limited) uniform access to them.; // This implies that any correctly written template function that; // works on multiple containers using iterators takes different; // template parameters for different containers. So we can safely; // assume that passing iterators of different containers as arguments; // whose type replaces the same template parameter is a bug.; //; // Example:; // template<typename I1, typename I2>; // void f(I1 first1, I1 last1, I2 first2, I2 last2);; //; // In this case the first two arguments to f() must be iterators must belong; // to the same container and the last to also to the same container but; // not necessarily to the same as the first two.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp:329,safe,safely,329,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MismatchedIteratorChecker.cpp,1,['safe'],['safely']
Safety,"// The mask value may be a vector constant that has undefined elements. But it; // may not be safe to propagate those undefs into the new compare, so replace; // those elements by copying an existing, defined, and safe scalar constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:94,safe,safe,94,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,2,['safe'],['safe']
Safety,"// The mask variants have different operand list. Scan from the third; // operand to avoid emitting incorrect warning.; // VFMULCPHZrr Dest, Src1, Src2; // VFMULCPHZrrk Dest, Dest, Mask, Src1, Src2; // VFMULCPHZrrkz Dest, Mask, Src1, Src2",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp:85,avoid,avoid,85,interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/AsmParser/X86AsmParser.cpp,1,['avoid'],['avoid']
Safety,// The maximum bit width required to represent all the values that can be; // demoted without loss of precision. It would be safe to truncate the roots; // of the expression to this width.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:125,safe,safe,125,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safe']
Safety,// The maximum distance between two consecutive tokens in a partition.; // This is an important trick to avoid using too much SourceLocation address; // space!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:105,avoid,avoid,105,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['avoid'],['avoid']
Safety,// The maximum number of cycles monitored by the Scoreboard. This; // value is determined based on the target itineraries to ensure; // that all hazards can be tracked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h:145,hazard,hazards,145,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScoreboardHazardRecognizer.h,1,['hazard'],['hazards']
Safety,// The memory intrinsics do not have a 1:1 correspondence of the original; // call arguments to the produced statepoint. Do not transfer the argument; // attributes to avoid putting them on incorrect arguments.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:168,avoid,avoid,168,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['avoid'],['avoid']
Safety,"// The method CatchTimeOut will be called at timeout",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:45,timeout,timeout,45,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['timeout'],['timeout']
Safety,"// The mix of execute-only and non-execute-only at link time is; // non-execute-only. To avoid the empty implicitly created .text; // section from making the whole .text section non-execute-only, we; // mark it execute-only if it is empty and there is at least one; // execute-only section in the object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFObjectWriter.cpp:89,avoid,avoid,89,interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFObjectWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/MCTargetDesc/ARMELFObjectWriter.cpp,1,['avoid'],['avoid']
Safety,// The model learns to pick one of the mask == 1 interferences. This is the; // name of the output tensor. The contract with the model is that the output; // will be guaranteed to be to a mask == 1 position. Using a macro here to; // avoid 'not used' warnings (and keep cond compilation to a minimum),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp:234,avoid,avoid,234,interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MLRegAllocEvictAdvisor.cpp,1,['avoid'],['avoid']
Safety,// The most nested region for each start location is the one with the; // correct count. We avoid creating redundant regions by stopping once; // we've seen this region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp:92,avoid,avoid,92,interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// The narrow shift must only shift out zero bits (it must be 'nuw').; // That makes it safe to widen to the destination type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:88,safe,safe,88,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,"// The natural definition of instructions which could introduce safe points; // are:; //; // - call, invoke (AfterCall, BeforeCall); // - phis (Loops); // - invoke, ret, unwind (Exit); //; // However, instructions as seemingly inoccuous as arithmetic can become; // libcalls upon lowering (e.g., div i64 on a 32-bit platform), so instead; // it is necessary to take a conservative approach.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:64,safe,safe,64,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,1,['safe'],['safe']
Safety,// The nearbyint variants are not allowed to raise the inexact exception; // so we can only code-gen them with unsafe math.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:111,unsafe,unsafe,111,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['unsafe'],['unsafe']
Safety,"// The next bits of code handle stuff like ""struct {int x;} a,b""; we're; // forced to merge the declarations because there's no other way to; // refer to the struct in question. When that struct is named instead, we; // also need to merge to avoid splitting off a stand-alone struct; // declaration that produces the warning ext_no_declarators in some; // contexts.; //; // This limited merging is safe without a bunch of other checks because it; // only merges declarations directly referring to the tag, not typedefs.; //; // Check whether the current declaration should be grouped with a previous; // non-free-standing tag declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp:242,avoid,avoid,242,interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclPrinter.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,// The node was analyzed while reanalyzing an earlier node - it is safe; // to skip. Note that this is not a morphing node - otherwise it would; // still be marked NewNode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp:67,safe,safe,67,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeTypes.cpp,1,['safe'],['safe']
Safety,"// The normal PW mode (without declaring overlaps) does detect them",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:56,detect,detect,56,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['detect'],['detect']
Safety,"// The number of bits in a SVE register is architecturally defined; // to be a multiple of this value. If <M x t> has this number of bits,; // a <n x M x t> vector can be stored in a SVE register without any; // redundant bits. If <M x t> has this number of bits divided by P,; // a <n x M x t> vector is stored in a SVE register by placing index i; // in index i*P of a <n x (M*P) x t> vector. The other elements of the; // <n x (M*P) x t> vector (such as index 1) are undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h:212,redund,redundant,212,interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64BaseInfo.h,1,['redund'],['redundant']
Safety,"// The number of outstanding events for this type, T, can be calculated; // as (UB - LB). If the current Count is greater than or equal to the number; // of outstanding events, then the wait for this counter is redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:211,redund,redundant,211,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['redund'],['redundant']
Safety,"// The number of times specified; // Occurrences, HiddenFlag, and Formatting are all enum types but to avoid; // problems with signed enums in bitfields.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:103,avoid,avoid,103,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['avoid'],['avoid']
Safety,// The number of unsafe uses is initially the number of uses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:17,unsafe,unsafe,17,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['unsafe'],['unsafe']
Safety,// The offset value has non zero bits in both %hi and %lo parts.; // Detect an ADDI that feeds from a LUI instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp:69,Detect,Detect,69,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVMergeBaseOffset.cpp,1,['Detect'],['Detect']
Safety,"// The older versions do not support a profile summary. This just computes; // an empty summary, which will not result in accurate hot/cold detection.; // We would need to call addRecord for all NamedInstrProfRecords to get the; // correct summary. However, this version is old (prior to early 2016) and; // has not been supporting an accurate summary for several years.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp:140,detect,detection,140,interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProfReader.cpp,1,['detect'],['detection']
Safety,"// The only addition to fCacheReadMap is via an interface that takes; // a TFileCacheRead* so the C-cast is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:108,safe,safe,108,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['safe'],['safe']
Safety,"// The operand is expected to be zero extended from i8; // (verified in detectZextAbsDiff).; // In order to convert to i64 and above, additional any/zero/sign; // extend is expected.; // The zero extend from 32 bit has no mathematical effect on the result.; // Also the sign extend is basically zero extend; // (extends the sign bit which is zero).; // So it is correct to skip the sign/zero extend instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:72,detect,detectZextAbsDiff,72,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detectZextAbsDiff']
Safety,"// The operand of CONST32 can be a blockaddress, e.g.; // %0 = CONST32 <blockaddress(@eat, %l)>; // Do this check for all instructions for safety.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:139,safe,safety,139,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,1,['safe'],['safety']
Safety,"// The optimised property functions omit the GC check, and so are not; // safe to use in GC mode. The standard functions are fast in GC mode,; // so there is less advantage in using them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:74,safe,safe,74,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['safe'],['safe']
Safety,"// The optimization cannot be applied for all the predicates because; // of the way FMINNUM/FMAXNUM and FMINNUM_IEEE/FMAXNUM_IEEE handle; // NaNs. For FMINNUM_IEEE/FMAXNUM_IEEE, the optimization cannot be; // applied at all if one of the operands is a signaling NaN.; // It is safe to use FMINNUM_IEEE/FMAXNUM_IEEE if all the operands; // are non NaN values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:277,safe,safe,277,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,"// The optimization removes store aspect of the atomicrmw. Therefore, cache; // must be flushed if the atomic ordering had a release semantics. This is; // not necessary a fence, a release fence just coincides to do that flush.; // Avoid replacing of an atomicrmw with a release semantics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:232,Avoid,Avoid,232,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// The overflow may be detected via the add wrapping round.; // This is only valid for strict comparison!,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:23,detect,detected,23,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['detect'],['detected']
Safety,"// The parameter must be a live-in of all alternatives for this to work.; // Otherwise, we risk having unbound parameters being used (= crashes).; //; // Examples:; //; // in (ins $y), (patterns (G_FNEG $dst, $y), ""return matchFnegOp(${y})""); // even if $y is unbound, we'll lazily bind it when emitting the G_FNEG.; //; // in (ins $y), (patterns ""return matchFnegOp(${y})""); // if $y is unbound when this fragment is emitted, C++ code expansion will; // fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/Patterns.cpp:91,risk,risk,91,interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/Patterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/Patterns.cpp,1,['risk'],['risk']
Safety,"// The pattern is detected, emit X86ISD::AVG instruction(s).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,detect,detected,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detected']
Safety,"// The pattern is detected. Subtract one from the constant vector, then; // demote it and emit X86ISD::AVG instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,detect,detected,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detected']
Safety,"// The pipe signal handler must be installed before any other handlers are; // registered. This is because the Unix \ref RegisterHandlers function does; // not perform a sigaction() for SIGPIPE unless a one-shot handler is; // present, to allow long-lived processes (like lldb) to fully opt-out of; // llvm's SIGPIPE handling and ignore the signal safely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp:348,safe,safely,348,interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp,1,['safe'],['safely']
Safety,"// The point is inside 2 or more daughters, check safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx:50,safe,safety,50,geom/geompainter/src/TGeoChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx,1,['safe'],['safety']
Safety,"// The pointers to call/move/destroy functions are determined for each; // callable type (and called-as type, which determines the overload chosen).; // (definitions are out-of-line).; // By default, we need an object that contains all the different; // type erased behaviors needed. Create a static instance of the struct type; // here and each instance will contain a pointer to it.; // Wrap in a struct to avoid https://gcc.gnu.org/PR71954",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:409,avoid,avoid,409,interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h,1,['avoid'],['avoid']
Safety,"// The predicate for the default mode needs to be constructed for each; // pattern separately.; // Since not all modes must be present in each pattern, if a mode m is; // absent, then there is no point in constructing a check for m. If such; // a check was created, it would be equivalent to checking the default; // mode, except not all modes' predicates would be a part of the checking; // code. The subsequently generated check for the default mode would then; // have the exact same patterns, but a different predicate code. To avoid; // duplicated patterns with different predicate checks, construct the; // default check as a negation of all predicates that are actually present; // in the source/destination patterns.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:532,avoid,avoid,532,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['avoid'],['avoid']
Safety,// The preprocessor gets confused when the DEBUG macro is passed larger; // chunks of code. Use this function to detect debugging.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp:113,detect,detect,113,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenInsert.cpp,1,['detect'],['detect']
Safety,"// The prior attempts to handle this shuffle may have left a bunch of; // dead nodes in the DAG (such as constants). These nodes will be added; // at the end of DAG's node list, which at that point had already been; // sorted topologically. In the main selection loop, the node list is; // traversed backwards from the root node, which means that any new; // nodes (from the end of the list) will not be visited.; // Scalarization will replace the shuffle node with the scalarized; // expression, and if that expression reused any if the leftoever (dead); // nodes, these nodes would not be selected (since the ""local"" selection; // only visits nodes that are not in AllNodes).; // To avoid this issue, remove all dead nodes from the DAG now.; // DAG.RemoveDeadNodes();",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp:685,avoid,avoid,685,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAGHVX.cpp,1,['avoid'],['avoid']
Safety,"// The problem with updating live intervals is that we can move one def; // past another def. In particular, this can happen when moving an A2_tfrt; // over an A2_tfrf defining the same register. From the point of view of; // live intervals, these two instructions are two separate definitions,; // and each one starts another live segment. LiveIntervals's ""handleMove""; // does not allow such moves, so we need to handle it ourselves. To avoid; // invalidating liveness data while we are using it, the move will be; // implemented in 4 steps: (1) add a clone of the instruction MI at the; // target location, (2) update liveness, (3) delete the old instruction,; // and (4) update liveness again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:439,avoid,avoid,439,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['avoid'],['avoid']
Safety,"// The query was aborted: let's add some info in the output list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:17,abort,aborted,17,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['abort'],['aborted']
Safety,"// The raw CompoundVal is essentially a symbolic InitListExpr: an (immutable); // list of other values. It appears pretty much only when there's an actual; // initializer list expression in the program, and the analyzer tries to; // unwrap it as soon as possible.; // This code is where such unwrap happens: when the compound value is put into; // the object that it was supposed to initialize (it's an *initializer* list,; // after all), instead of binding the whole value to the whole object, we bind; // sub-values to sub-objects. Sub-values may themselves be compound values,; // and in this case the procedure becomes recursive.; // FIXME: The annoying part about compound values is that they don't carry; // any sort of information about which value corresponds to which sub-object.; // It's simply a list of values in the middle of nowhere; we expect to match; // them to sub-objects, essentially, ""by index"": first value binds to; // the first field, second value binds to the second field, etc.; // It would have been much safer to organize non-lazy compound values as; // a mapping from fields/bases to values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:1032,safe,safer,1032,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['safe'],['safer']
Safety,// The reassociate transformation for FP operations is performed only; // if unsafe algebra is permitted by FastMathFlags. Propagate those flags; // to the newly generated operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:77,unsafe,unsafe,77,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['unsafe'],['unsafe']
Safety,// The register-offset variant of LDRD mandates that the register; // allocated to RegOffset is not reused in any of the remaining operands.; // This restriction is currently not enforced. Therefore emitting this; // variant is explicitly avoided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:239,avoid,avoided,239,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['avoid'],['avoided']
Safety,// The register-offset variant of STRD mandates that the register; // allocated to RegOffset is not reused in any of the remaining operands.; // This restriction is currently not enforced. Therefore emitting this; // variant is explicitly avoided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:239,avoid,avoided,239,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['avoid'],['avoided']
Safety,"// The remaining cases are:; // External GOT: lw $tmp, %got(symbol)($gp); // >addiu $tmp, $tmp, offset; // >addiu $rd, $tmp, $rs; // Local GOT: lw $tmp, %got(symbol+offset)($gp); // addiu $tmp, $tmp, %lo(symbol+offset)($gp); // >addiu $rd, $tmp, $rs; // The addiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:311,redund,redundant,311,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['redund'],['redundant']
Safety,"// The remaining cases are:; // Small offset: ld $tmp, %got_disp(symbol)($gp); // >daddiu $tmp, $tmp, offset; // >daddu $rd, $tmp, $rs; // The daddiu's marked with a '>' may be omitted if they are redundant. If; // this happens then the last instruction must use $rd as the result; // register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:197,redund,redundant,197,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['redund'],['redundant']
Safety,"// The remaining subtract is not ""nuw"" any more.; // If there's one use of the subtract (no other use than the use we are; // about to replace), then we know that the sub is ""nsw"" in this context; // even if it was only ""nuw"" before. If there's another use, then we can't; // add ""nsw"" to the existing instruction because it may not be safe in the; // other user's context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:336,safe,safe,336,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['safe'],['safe']
Safety,// The renamer uses the Visited set to avoid infinite loops. Clear it now.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['avoid'],['avoid']
Safety,// The resources are owned by AST when the current file is AST.; // So we reset the resources here to avoid users accessing it; // accidently.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp:102,avoid,avoid,102,interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/FrontendAction.cpp,1,['avoid'],['avoid']
Safety,// The rest of these may not be safe if the exec may not be the same between; // the def and use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp:32,safe,safe,32,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstCombineIntrinsic.cpp,1,['safe'],['safe']
Safety,"// The risk that speculation will not pay off increases with the; // number of instructions speculated, so we put a limit on that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:7,risk,risk,7,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,1,['risk'],['risk']
Safety,"// The safest is to open in raw mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFileStager.cxx:7,safe,safest,7,net/net/src/TFileStager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TFileStager.cxx,1,['safe'],['safest']
Safety,// The safety net against poison.; // FIXME: this is broken.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:7,safe,safety,7,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['safe'],['safety']
Safety,// The safety of all this is checked by checkWFRetconPrototype.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h:7,safe,safety,7,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroInternal.h,2,['safe'],['safety']
Safety,"// The second heuristic is that L has one exit other than the latchexit and; // that exit is a deoptimize block. We know that deoptimize blocks are rarely; // taken, which also implies the branch leading to the deoptimize block is; // highly predictable. When UnrollRuntimeOtherExitPredictable is specified, we; // assume the other exit branch is predictable even if it has no deoptimize; // call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:242,predict,predictable,242,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,2,['predict'],['predictable']
Safety,"// The second nasty issue we must deal with in the JIT is that the Safe; // module cannot directly reference any functions defined in the test; // module. Instead, we use a JIT API call to dynamically resolve the; // symbol.; // Add the resolver to the Safe module.; // Prototype: void *getPointerToNamedFunction(const char* Name)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp:67,Safe,Safe,67,interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/Miscompilation.cpp,2,['Safe'],['Safe']
Safety,"// The semantics of dynamic initialization of variables with static or thread; // storage duration depends on whether they are declared at block-scope. The; // initialization of such variables at block-scope can be aborted with an; // exception and later retried (per C++20 [stmt.dcl]p4), and recursive entry; // to their initialization has undefined behavior (also per C++20; // [stmt.dcl]p4). For such variables declared at non-block scope, exceptions; // lead to termination (per C++20 [except.terminate]p1), and recursive; // references to the variables are governed only by the lifetime rules (per; // C++20 [class.cdtor]p2), which means such references are perfectly fine as; // long as they avoid touching memory. As a result, block-scope variables must; // not be marked as initialized until after initialization completes (unless; // the mark is reverted following an exception), but non-block-scope variables; // must be marked prior to initialization so that recursive accesses during; // initialization do not restart initialization.; // Variables used when coping with thread-safe statics and exceptions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:215,abort,aborted,215,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,3,"['abort', 'avoid', 'safe']","['aborted', 'avoid', 'safe']"
Safety,"// The separator of C++20 modules partitions (':') is not good for file; // systems, here clang and gcc choose '-' by default since it is not a; // valid character of C++ indentifiers. So we could avoid conflicts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp:197,avoid,avoid,197,interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/HeaderSearch.cpp,1,['avoid'],['avoid']
Safety,// The sequence for detecting a sysroot here should be kept in sync with; // the testTriple function below.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp:20,detect,detecting,20,interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/MinGW.cpp,1,['detect'],['detecting']
Safety,"// The sequence will be XLenVT, not the type of Index. Tell; // isSimpleVIDSequence this so we avoid overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:95,avoid,avoid,95,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,// The set of blocks that are reachable while avoiding BB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp:46,avoid,avoiding,46,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp,1,['avoid'],['avoiding']
Safety,// The set of chars that can potentially follow an <encoding> (none of which; // can start a <type>). Enumerating these allows us to avoid speculative; // parsing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h:133,avoid,avoid,133,interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,1,['avoid'],['avoid']
Safety,"// The set of ranges rarely contains more than one element, and is unlikely; // to contain more than say four elements. So we find the middle-ground with; // a sorted vector. This avoids hard-coding a rarely used number like ""four""; // into every instance of a SmallSet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:180,avoid,avoids,180,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['avoid'],['avoids']
Safety,"// The setting is for now a global one, must be decided before running the; // program by setting the appropriate environment variable. Make sure that; // option configuration is thread-safe and happens only once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx:186,safe,safe,186,tree/dataframe/src/RNTupleDS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RNTupleDS.cxx,1,['safe'],['safe']
Safety,"// The shift amount is interpreted as modulo the bitwidth. If the shift; // amount is effectively 0, avoid UB due to oversized inverse shift below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:101,avoid,avoid,101,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['avoid'],['avoid']
Safety,// The shift must be valid.; // TODO: This restricts the fold to constant shift amounts. Is there a way to; // handle variable shifts safely? PR47012,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:134,safe,safely,134,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['safe'],['safely']
Safety,"// The significant bits are calculated including the sign bit. This may; // add an extra bit for zero-extended values, e.g. (zext i32 to i64) may; // result in 33 significant bits. To avoid extra words, skip the extra; // sign bit, but keep information that the value is to be treated as; // unsigned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:184,avoid,avoid,184,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['avoid'],['avoid']
Safety,"// The slave name is a special one in PROOF-Lite: avoid blocking on the DNS; // for non existing names",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:50,avoid,avoid,50,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,1,['avoid'],['avoid']
Safety,"// The small model guarantees static code/data size < 4GB, but not where it; // will be in memory. Most of these could end up >2GB away so even a signed; // pc-relative 32-bit address is insufficient, theoretically.; //; // Use DW_EH_PE_indirect even for -fno-pic to avoid copy relocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:267,avoid,avoid,267,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['avoid'],['avoid']
Safety,"// The stack id gives an indication of whether the object is scalable or; // not, so it's safe to pass in the minimum size here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:90,safe,safe,90,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['safe'],['safe']
Safety,// The stackFrames dictionary substantially reduces size of the output file by; // avoiding repeating the entire call stack of function names for each entry.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-converter.cpp:83,avoid,avoiding,83,interpreter/llvm-project/llvm/tools/llvm-xray/xray-converter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-xray/xray-converter.cpp,1,['avoid'],['avoiding']
Safety,"// The start of the branch name is identical to the content; // of 'aname' before the first '/'.; // Let's make sure that it is not longer (we are trying; // to avoid having jet2/value match the branch jet23",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:161,avoid,avoid,161,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['avoid'],['avoid']
Safety,"// The tag name clashes with something else in the target scope,; // issue an error and recover by making this tag be anonymous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:88,recover,recover,88,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recover']
Safety,"// The tag name clashes with something else in the target scope,; // issue an error and recover by making this tag be anonymous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp:88,recover,recover,88,interpreter/cling/lib/Interpreter/DeclExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclExtractor.cpp,1,['recover'],['recover']
Safety,"// The test 'fMethod[keep] == 0' fails to detect a variable size array; // if the counter happens to have an offset of zero, so let's explicitly; // prevent for here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:42,detect,detect,42,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['detect'],['detect']
Safety,// The top of the unsafe stack after all unsafe static allocas are; // allocated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:18,unsafe,unsafe,18,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,2,['unsafe'],['unsafe']
Safety,// The top of the worklist may *also* be the same SCC we just ran over; // (and invalidated for). Keep track of that last SCC we processed due; // to SCC update to avoid redundant processing when an SCC is both just; // updated itself and at the top of the worklist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:164,avoid,avoid,164,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// The total execution count of the chain. Since the execution count of; // a basic block is uint64_t, using doubles here to avoid overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:125,avoid,avoid,125,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['avoid'],['avoid']
Safety,"// The transformation performed here aims to widen a widenable condition; // above the loop such that all analyzeable exit leading to deopt are dead.; // It assumes that the latch is the dominant exit for profitability and that; // exits branching to deoptimizing blocks are rarely taken. It relies on the; // semantics of widenable expressions for legality. (i.e. being able to fall; // down the widenable path spuriously allows us to ignore exit order,; // unanalyzeable exits, side effects, exceptional exits, and other challenges; // which restrict the applicability of the non-WC based version of this; // transform in IndVarSimplify.); //; // NOTE ON POISON/UNDEF - We're hoisting an expression above guards which may; // imply flags on the expression being hoisted and inserting new uses (flags; // are only correct for current uses). The result is that we may be; // inserting a branch on the value which can be either poison or undef. In; // this case, the branch can legally go either way; we just need to avoid; // introducing UB. This is achieved through the use of the freeze; // instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:1016,avoid,avoid,1016,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['avoid'],['avoid']
Safety,"// The trivial phi inserted by the previous CHR scope could replace a; // non-phi in HoistStops. Note that since this phi is at the exit of a; // previous CHR scope, which dominates this scope, it's safe to stop; // hoisting there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:199,safe,safe,199,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['safe'],['safe']
Safety,"// The truncation error in the r4 approximation itself is O(h^3).; // However, for safety, we estimate the error from r4-r2, which is; // O(h). By scaling h we will minimise this estimated error, not; // the actual truncation error in r4.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RichardsonDerivator.cxx:83,safe,safety,83,math/mathcore/src/RichardsonDerivator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/RichardsonDerivator.cxx,1,['safe'],['safety']
Safety,"// The types didn't match, but we know we got a null pointer; complain,; // then recover as if the types were correct.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:81,recover,recover,81,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Safety,"// The types we specifically need to rebuild are:; // - typenames, typeofs, and decltypes; // - types which will become injected class names; // Of course, we also need to rebuild any type referencing such a; // type. It's safest to just say ""dependent"", but we call out a; // few cases here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:223,safe,safest,223,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['safe'],['safest']
Safety,"// The unversioned loop will not be changed, so we inherit all attributes; // from the original loop, but remove the loop distribution metadata to; // avoid to distribute it again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:151,avoid,avoid,151,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['avoid'],['avoid']
Safety,"// The use of umin(all analyzeable exits) instead of latch is subtle, but; // important for profitability. We may have a loop which hasn't been fully; // canonicalized just yet. If the exit we chose to widen is provably never; // taken, we want the widened form to *also* be provably never taken. We; // can't guarantee this as a current unanalyzeable exit may later become; // analyzeable, but we can at least avoid the obvious cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:411,avoid,avoid,411,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['avoid'],['avoid']
Safety,"// The users of this class want to replace all function references except; // for aliases and llvm.used/llvm.compiler.used with references to a jump; // table. We avoid replacing aliases in order to avoid introducing a double; // indirection (or an alias pointing to a declaration in ThinLTO mode), and; // we avoid replacing llvm.used/llvm.compiler.used because these global; // variables describe properties of the global, not the jump table (besides,; // offseted references to the jump table in llvm.used are invalid).; // Unfortunately, LLVM doesn't have a ""RAUW except for these (possibly; // indirect) users"", so what we do is save the list of globals referenced by; // llvm.used/llvm.compiler.used and aliases, erase the used lists, let RAUW; // replace the aliasees and then set them back to their original values at; // the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:163,avoid,avoid,163,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,3,['avoid'],['avoid']
Safety,"// The value d is expressed by the ""shift"" value above since we avoided; // multiplication by d by using a shift left. So, all we have to do is; // shift right here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:64,avoid,avoided,64,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['avoid'],['avoided']
Safety,"// The value is never null, pointer instead of reference to avoid disabling; // implicit assignment operator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:60,avoid,avoid,60,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,1,['avoid'],['avoid']
Safety,"// The value printers of TTreeReaderValue and TTreeReaderArray rely on the; // one of TTreeReaderValueBase, from which they both inherit.; // This is why we use RTTI inside the function, avoiding to duplicate code.; // The performance penalty is irrelevant because we are already printing; // the objects in an interactive environment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:187,avoid,avoiding,187,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['avoid'],['avoiding']
Safety,// The vectorizer may have significantly shortened a loop body; unroll; // again. Unroll small loops to hide loop backedge latency and saturate any; // parallel execution resources of an out-of-order processor. We also then; // need to clean up redundancies and loop invariant code.; // FIXME: It would be really good to use a loop-integrated instruction; // combiner for cleanup here so that the unrolling and LICM can be pipelined; // across the loop nests.; // We do UnrollAndJam in a separate LPM to ensure it happens before unroll,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:245,redund,redundancies,245,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['redund'],['redundancies']
Safety,"// The viewer and analysis passes do not modify anything, so we can safely; // remove the const qualifier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp:68,safe,safely,68,interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/RegionPrinter.cpp,1,['safe'],['safely']
Safety,"// The wide helper function returns (writes out) an array of chaining values; // and returns the length of that array. The number of chaining values returned; // is the dyanmically detected SIMD degree, at most MAX_SIMD_DEGREE. Or fewer,; // if the input is shorter than that many chunks. The reason for maintaining a; // wide array of chaining values going back up the tree, is to allow the; // implementation to hash as many parents in parallel as possible.; //; // As a special case when the SIMD degree is 1, this function will still return; // at least 2 outputs. This guarantees that this function doesn't perform the; // root compression. (If it did, it would use the wrong flags, and also we; // wouldn't be able to implement exendable ouput.) Note that this function is; // not used when the whole input is only 1 chunk long; that's a different; // codepath.; //; // Why not just have the caller split the input on the first update(), instead; // of implementing this special rule? Because we don't want to limit SIMD or; // multi-threading parallelism for that update().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c:181,detect,detected,181,interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/blake3.c,1,['detect'],['detected']
Safety,"// The widenIVUse avoids generating trunc by evaluating the use as AddRec, this; // will not work when:; // 1) SCEV traces back to an instruction inside the loop that SCEV can not; // expand, eg. add %indvar, (load %addr); // 2) SCEV finds a loop variant, eg. add %indvar, %loopvariant; // While SCEV fails to avoid trunc, we can still try to use instruction; // combining approach to prove trunc is not required. This can be further; // extended with other instruction combining checks, but for now we handle the; // following case (sub can be ""add"" and ""mul"", ""nsw + sext"" can be ""nus + zext""); //; // Src:; // %c = sub nsw %b, %indvar; // %d = sext %c to i64; // Dst:; // %indvar.ext1 = sext %indvar to i64; // %m = sext %b to i64; // %d = sub nsw i64 %m, %indvar.ext1; // Therefore, as long as the result of add/sub/mul is extended to wide type, no; // trunc is required regardless of how %b is generated. This pattern is common; // when calculating address in 64 bit architecture",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:18,avoid,avoids,18,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,2,['avoid'],"['avoid', 'avoids']"
Safety,"// The worklist of live basic blocks in the callee *after* inlining. We avoid; // adding basic blocks of the callee which can be proven to be dead for this; // particular call site in order to get more accurate cost estimates. This; // requires a somewhat heavyweight iteration pattern: we need to walk the; // basic blocks in a breadth-first order as we insert live successors. To; // accomplish this, prioritizing for small iterations because we exit after; // crossing our threshold, we use a small-size optimized SetVector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:72,avoid,avoid,72,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['avoid'],['avoid']
Safety,"// Then update the basic block, inserting nops between the detected sequences.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A53Fix835769.cpp:59,detect,detected,59,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A53Fix835769.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A53Fix835769.cpp,1,['detect'],['detected']
Safety,"// There are MOVMSK flavors for types v16i8, v32i8, v4f32, v8f32, v4f64 and; // v8f64. So all legal 128-bit and 256-bit vectors are covered except for; // v8i16 and v16i16.; // For these two cases, we can shuffle the upper element bytes to a; // consecutive sequence at the start of the vector and treat the results as; // v16i8 or v32i8, and for v16i8 this is the preferable solution. However,; // for v16i16 this is not the case, because the shuffle is expensive, so we; // avoid sign-extending to this type entirely.; // For example, t0 := (v8i16 sext(v8i1 x)) needs to be shuffled as:; // (v16i8 shuffle <0,2,4,6,8,10,12,14,u,u,...,u> (v16i8 bitcast t0), undef)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:476,avoid,avoid,476,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// There are few operations which truly have vector input operands. Any vector; // operation is going to involve operations on each component, and a; // build_vector will be a copy per element, so it always makes sense to use a; // build_vector input in place of the extracted element to avoid a copy into a; // super register.; //; // We should probably only do this if all users are extracts only, but this; // should be the common case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:288,avoid,avoid,288,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['avoid'],['avoid']
Safety,// There are five cases here.; // - There's no scope specifier and we're in a local class. Only look; // for functions declared in the immediately-enclosing block scope.; // We recover from invalid scope qualifiers as if they just weren't there.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:177,recover,recover,177,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recover']
Safety,"// There are five possible optimizations we can do for memcpy:; // a) memcpy-memcpy xform which exposes redundance for DSE.; // b) call-memcpy xform for return slot optimization.; // c) memcpy from freshly alloca'd space or space that has just started; // its lifetime copies undefined data, and we can therefore eliminate; // the memcpy in favor of the data that was already at the destination.; // d) memcpy from a just-memset'd source can be turned into memset.; // e) elimination of memcpy via stack-move optimization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:104,redund,redundance,104,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['redund'],['redundance']
Safety,"// There are four options here.; // - If we are in a trailing return type, this is always just a reference,; // and we must not try to parse a definition. For instance,; // [] () -> struct S { };; // does not define a type.; // - If we have 'struct foo {...', 'struct foo :...',; // 'struct foo final :' or 'struct foo final {', then this is a definition.; // - If we have 'struct foo;', then this is either a forward declaration; // or a friend declaration, which have to be treated differently.; // - Otherwise we have something like 'struct foo xyz', a reference.; //; // We also detect these erroneous cases to provide better diagnostic for; // C++11 attributes parsing.; // - attributes follow class name:; // struct foo [[]] {};; // - attributes appear before or after 'final':; // struct foo [[]] final [[]] {};; //; // However, in type-specifier-seq's, things look like declarations but are; // just references, e.g.; // new struct s;; // or; // &T::operator struct s;; // For these, DSC is DeclSpecContext::DSC_type_specifier or; // DeclSpecContext::DSC_alias_declaration.; // If there are attributes after class name, parse them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:583,detect,detect,583,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['detect'],['detect']
Safety,"// There are no intrinsic functions that leak arguments.; // If the called function does not return, the current function; // does not return as well, so no possibility of use-after-return.; // Sanitizer function also don't leak or don't return.; // It's safe to both pass pointers to local variables to them; // and to tail-call them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:255,safe,safe,255,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,1,['safe'],['safe']
Safety,"// There are no standard conversions for class types in C++, so; // abort early. When overloading in C, however, we do permit them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:68,abort,abort,68,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['abort'],['abort']
Safety,"// There are noalias scope declarations:; // (general):; // Original: OrigPre { OrigHeader NewHeader ... Latch }; // after: (OrigPre+OrigHeader') { NewHeader ... Latch OrigHeader }; //; // with D: llvm.experimental.noalias.scope.decl,; // U: !noalias or !alias.scope depending on D; // ... { D U1 U2 } can transform into:; // (0) : ... { D U1 U2 } // no relevant rotation for this part; // (1) : ... D' { U1 U2 D } // D is part of OrigHeader; // (2) : ... D' U1' { U2 D U1 } // D, U1 are part of OrigHeader; //; // We now want to transform:; // (1) -> : ... D' { D U1 U2 D'' }; // (2) -> : ... D' U1' { D U2 D'' U1'' }; // D: original llvm.experimental.noalias.scope.decl; // D', U1': duplicate with replaced scopes; // D'', U1'': different duplicate with replaced scopes; // This ensures a safe fallback to 'may_alias' introduced by the rotate,; // as U1'' and U1' scopes will not be compatible wrt to the local restrict; // Clone the llvm.experimental.noalias.decl again for the NewHeader.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:791,safe,safe,791,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['safe'],['safe']
Safety,"// There are only two legal forms of epilogue:; // - add SEHAllocationSize, %rsp; // - lea SEHAllocationSize(%FramePtr), %rsp; //; // 'mov %FramePtr, %rsp' will not be recognized as an epilogue sequence.; // However, we may use this sequence if we have a frame pointer because the; // effects of the prologue can safely be undone.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:313,safe,safely,313,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['safe'],['safely']
Safety,"// There are particular cases where we can conclude no-alias between; // a non-addr-taken global and some other underlying object. Specifically,; // a non-addr-taken global is known to not be escaped from any function. It is; // also incorrect for a transformation to introduce an escape of a global in; // a way that is observable when it was not there previously. One function; // being transformed to introduce an escape which could possibly be observed; // (via loading from a global or the return value for example) within another; // function is never safe. If the observation is made through non-atomic; // operations on different threads, it is a data-race and UB. If the; // observation is well defined, by being observed the transformation would have; // changed program behavior by introducing the observed escape, making it an; // invalid transform.; //; // This property does require that transformations which *temporarily* escape; // a global that was not previously escaped, prior to restoring it, cannot rely; // on the results of GMR::alias. This seems a reasonable restriction, although; // currently there is no way to enforce it. There is also no realistic; // optimization pass that would make this mistake. The closest example is; // a transformation pass which does reg2mem of SSA values but stores them into; // global variables temporarily before restoring the global variable's value.; // This could be useful to expose ""benign"" races for example. However, it seems; // reasonable to require that a pass which introduces escapes of global; // variables in this way to either not trust AA results while the escape is; // active, or to be forced to operate as a module pass that cannot co-exist; // with an alias analysis such as GMR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp:558,safe,safe,558,interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/GlobalsModRef.cpp,1,['safe'],['safe']
Safety,"// There are quite a few FP16 instructions (e.g. VNMLA, VNMLS, etc.) that; // negate values directly (fneg is free). So, we don't want to let the DAG; // combiner rewrite fneg into xors and some other instructions. For f16 and; // FullFP16 argument passing, some bitcast nodes may be introduced,; // triggering this DAG combine rewrite, so we are avoiding that with this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:347,avoid,avoiding,347,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoiding']
Safety,"// There are several ways we can dereference things, and several inputs; // to consider:; // * NRVO variables will appear with IsIndirect set, but should have; // nothing else in their DIExpressions,; // * Variables with DW_OP_stack_value in their expr already need an; // explicit dereference of the stack location,; // * Values that don't match the variable size need DW_OP_deref_size,; // * Everything else can just become a simple location expression.; // We need to use deref_size whenever there's a mismatch between the; // size of value and the size of variable portion being read.; // Additionally, we should use it whenever dealing with stack_value; // fragments, to avoid the consumer having to determine the deref size; // from DW_OP_piece.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:676,avoid,avoid,676,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avoid'],['avoid']
Safety,"// There are some benefits to schedule the ADDI as early as possible post ra; // to avoid stalled by vector instructions which take up all the hw units.; // And ADDI is usually used to post inc the loop indvar, which matters the; // performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp:84,avoid,avoid,84,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMachineScheduler.cpp,1,['avoid'],['avoid']
Safety,"// There are some descendant classes that are not used as argument; // constraints, e.g. ComparisonConstraint. In that case we can safely; // ignore the implementation of this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp:131,safe,safely,131,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StdLibraryFunctionsChecker.cpp,1,['safe'],['safely']
Safety,"// There are two CPUID leafs which information associated with the pconfig; // instruction:; // EAX=0x7, ECX=0x0 indicates the availability of the instruction (via the 18th; // bit of EDX), while the EAX=0x1b leaf returns information on the; // availability of specific pconfig leafs.; // The target feature here only refers to the the first of these two.; // Users might need to check for the availability of specific pconfig; // leaves using cpuid, since that information is ignored while; // detecting features using the ""-march=native"" flag.; // For more info, see X86 ISA docs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:495,detect,detecting,495,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,1,['detect'],['detecting']
Safety,"// There are two types of string tables that can exist, dynamic and not dynamic.; // In the dynamic case the string table is allocated. Changing a dynamic string; // table would mean altering virtual addresses and thus the memory image. So; // dynamic string tables should not have an interface to modify them or; // reconstruct them. This type lets us reconstruct a string table. To avoid; // this class being used for dynamic string tables (which has happened) the; // classof method checks that the particular instance is not allocated. This; // then agrees with the makeSection method used to construct most sections.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h:384,avoid,avoid,384,interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/ELF/ELFObject.h,1,['avoid'],['avoid']
Safety,"// There are unresolved typos in Init, just drop them.; // FIXME: improve the recovery strategy to preserve the Init.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:78,recover,recovery,78,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery']
Safety,// There could be undef components of a spilled super register.; // TODO: Can we detect this and skip the spill?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:81,detect,detect,81,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,2,['detect'],['detect']
Safety,// There is a form of VFSGNJ which injects the negated sign of its second; // operand. Try and bubble any FNEG up after the extend/round to produce; // this optimized pattern. Avoid modifying cases where FP_ROUND and; // TRUNC=1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:176,Avoid,Avoid,176,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// There is a generic expand for FP_TO_FP16 with unsafe fast math.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:49,unsafe,unsafe,49,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['unsafe'],['unsafe']
Safety,"// There is a hardware bug on CI/SI where SMRD instruction may corrupt; // vccz bit, so when we detect that an instruction may read from a; // corrupt vccz bit, we need to:; // 1. Insert s_waitcnt lgkm(0) to wait for all outstanding SMRD; // operations to complete.; // 2. Restore the correct value of vccz by writing the current value; // of vcc back to vcc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:96,detect,detect,96,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['detect'],['detect']
Safety,"// There is a not-too-uncommon idiom; // where a block passed to dispatch_async captures a semaphore; // and then the thread (which called dispatch_async) is blocked on waiting; // for the completion of the execution of the block; // via dispatch_semaphore_wait. To avoid false-positives (for now); // we ignore all the blocks which have captured; // a variable of the type ""dispatch_semaphore_t"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp:266,avoid,avoid,266,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StackAddrEscapeChecker.cpp,1,['avoid'],['avoid']
Safety,"// There is a really nice hard cut-over between AVX1 and AVX2 that means we; // can check for those subtargets here and avoid much of the subtarget; // querying in the per-vector-type lowering routines. With AVX1 we have; // essentially *zero* ability to manipulate a 256-bit vector with integer; // types. Since we'll use floating point types there eventually, just; // immediately cast everything to a float and operate entirely in that domain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:120,avoid,avoid,120,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// There is a token to return.; // We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:138,avoid,avoid,138,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['avoid'],['avoid']
Safety,"// There is always a dominance between two recs that are used by one SCEV,; // so we can safely sort recs by loop header dominance. We require such; // order in getAddExpr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:89,safe,safely,89,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['safe'],['safely']
Safety,// There is no hazard if the instruction does not use vector regs; // (like wbinvl1),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:15,hazard,hazard,15,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// There is one unsafe defining instruction, which needs a fixup. It is; // generally good to hoist the fixup to be adjacent to the defining; // instruction rather than the using instruction, as the using; // instruction may be inside a loop when the defining instruction is; // not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp:16,unsafe,unsafe,16,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,1,['unsafe'],['unsafe']
Safety,"// There is only one HIP fat binary per linked module, however there are; // multiple constructor functions. Make sure the fat binary is registered; // only once. The constructor functions are executed by the dynamic loader; // before the program gains control. The dynamic loader cannot execute the; // constructor functions concurrently since doing that would not guarantee; // thread safety of the loaded program. Therefore we can assume sequential; // execution of constructor functions here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp:387,safe,safety,387,interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCUDANV.cpp,1,['safe'],['safety']
Safety,// There may be no interface context due to error in declaration; // of the interface (which has been reported). Recover gracefully.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp:113,Recover,Recover,113,interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/DeclObjC.cpp,1,['Recover'],['Recover']
Safety,"// There should be no symbol at this address, or, if there is,; // it should be a zero-sized symbol from an empty section (which; // we can safely override).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h:140,safe,safely,140,interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/JITLink/MachOLinkGraphBuilder.h,1,['safe'],['safely']
Safety,// There will be no VS if all copies are available_externally having no; // type metadata. In that case we can't safely perform WPD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:113,safe,safely,113,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['safe'],['safely']
Safety,// There're chances the MBB is sunk more than once. Record it to avoid; // multi insert.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp:65,avoid,avoid,65,interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PreTileConfig.cpp,1,['avoid'],['avoid']
Safety,"// There's an inconsistency regarding packed unwind info with homed; // parameters; according to the documentation, the epilog shouldn't have; // the same corresponding nops (and thus, to set the H bit, we should; // require an epilog which isn't exactly symmetrical - we shouldn't accept; // an exact mirrored epilog for those cases), but in practice,; // RtlVirtualUnwind behaves as if it does expect the epilogue to contain; // the same nops. See https://github.com/llvm/llvm-project/issues/54879.; // To play it safe, don't produce packed unwind info with homed parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:516,safe,safe,516,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,1,['safe'],['safe']
Safety,"// There's no clear preference between forms 3. and 4., try both. Avoid; // forming getNotSCEV of pointer values as the resulting subtract is; // not legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:66,Avoid,Avoid,66,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Avoid'],['Avoid']
Safety,"// There's no good way to insert into the high elements of a >128-bit; // vector, so use shuffles to avoid an extract/insert sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:101,avoid,avoid,101,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// These are like SALU instructions in terms of effects, so it's questionable; // whether we should return true for those.; //; // However, executing them with EXEC = 0 causes them to operate on undefined; // data, which we avoid by returning true here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:224,avoid,avoid,224,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// These are really only legal for ieee_mode functions. We should be avoiding; // them for functions that don't have ieee_mode enabled, so just say they are; // legal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:69,avoid,avoiding,69,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avoid'],['avoiding']
Safety,"// These bytes sort of have a hidden message, but it's not in; // little-endian this time, and it's a little redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:109,redund,redundant,109,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,1,['redund'],['redundant']
Safety,"// These can be scalar arguments or elements of an integer array type; // passed directly. Clang may use those instead of ""byval"" aggregate; // types to avoid forcing arguments to memory unnecessarily.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:153,avoid,avoid,153,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// These cases should be safe, even with strictfp.; // ldexp(0.0, x) -> 0.0; // ldexp(-0.0, x) -> -0.0; // ldexp(inf, x) -> inf; // ldexp(-inf, x) -> -inf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:25,safe,safe,25,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['safe'],['safe']
Safety,"// These correspond with the checker options. Looking at other checkers such; // as MallocChecker and CStringChecker, this is similar as to how they pull; // off having a modeling class, but emitting diagnostics under a smaller; // checker's name that can be safely disabled without disturbing the; // underlaying modeling engine.; // The reason behind having *checker options* rather then actual *checkers*; // here is that CallAndMessage is among the oldest checkers out there, and can; // be responsible for the majority of the reports on any given project. This; // is obviously not ideal, but changing checker name has the consequence of; // changing the issue hashes associated with the reports, and databases; // relying on this (CodeChecker, for instance) would suffer greatly.; // If we ever end up making changes to the issue hash generation algorithm, or; // the warning messages here, we should totally jump on the opportunity to; // convert these to actual checkers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp:259,safe,safely,259,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/CallAndMessageChecker.cpp,1,['safe'],['safely']
Safety,// These enumeration declarations were originally in MipsInstrInfo.h but; // had to be moved here to avoid circular dependencies between; // LLVMMipsCodeGen and LLVMMipsAsmPrinter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h:101,avoid,avoid,101,interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MCTargetDesc/MipsInstPrinter.h,1,['avoid'],['avoid']
Safety,"// These exist so that the builtin that takes an immediate can be bounds; // checked by clang to avoid passing bad immediates to the backend. Since; // AVX has a larger immediate than SSE we would need separate builtins to; // do the different bounds checking. Rather than create a clang specific; // SSE only builtin, this implements eight separate builtins to match gcc; // implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:97,avoid,avoid,97,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['avoid'],['avoid']
Safety,// These folds should be beneficial regardless of when this pass is run; // in the optimization pipeline.; // The type checking is for run-time efficiency. We can avoid wasting time; // dispatching to folding functions if there's no chance of matching.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:163,avoid,avoid,163,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['avoid'],['avoid']
Safety,// These instructions are sometimes used with an undef first or second; // source. Return true here so BreakFalseDeps will assign this source to the; // same register as the first source to avoid a false dependency.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:190,avoid,avoid,190,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['avoid'],['avoid']
Safety,// These instructions are sometimes used with an undef first or second; // source. Return true here so BreakFalseDeps will assign this source to the; // same register as the first source to avoid a false dependency.; // Operand 1 of these instructions is tied so they're separate from their; // VEX counterparts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:190,avoid,avoid,190,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['avoid'],['avoid']
Safety,// These instructions cannot not mitigate the hazard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:46,hazard,hazard,46,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// These instructions have hasUnmodeledSideEffects() returning true; // because they trap on overflow and invalid so they can't be arbitrarily; // moved, however in the specific case of register stackifying, it is safe; // to move them because overflow and invalid are Undefined Behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp:214,safe,safe,214,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyRegStackify.cpp,1,['safe'],['safe']
Safety,"// These kinds don't have assigned type IDs (they might be the resources; // of invalid kind, expand to many resource structures in .res files,; // or have variable type ID). In order to avoid ID clashes with IDs above,; // we assign the kinds the values 256 and larger.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptStmt.h:187,avoid,avoid,187,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptStmt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceScriptStmt.h,1,['avoid'],['avoid']
Safety,"// These live sets may contain state Value pointers, since we replaced calls; // with operand bundles with calls wrapped in gc.statepoint, and some of; // those calls may have been def'ing live gc pointers. Clear these out to; // avoid accidentally using them.; //; // TODO: We should create a separate data structure that does not contain; // these live sets, and migrate to using that data structure from this point; // onward.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:230,avoid,avoid,230,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['avoid'],['avoid']
Safety,"// These maps are usually stored once per checker, so let's make sure; // we don't do redundant copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h:86,redund,redundant,86,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CallDescription.h,1,['redund'],['redundant']
Safety,// These member variables below are used for avoiding being passed; // repeatedly in recursion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h:45,avoid,avoiding,45,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.h,1,['avoid'],['avoiding']
Safety,"// These methods allow access to the raw bitset underlying; // this object, breaking type safety. They are necessary for; // efficient interaction with TTree / TBranch / TBasket, but left; // private to prevent users from interacting with the raw bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx:90,safe,safety,90,tree/tree/inc/ROOT/TIOFeatures.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/ROOT/TIOFeatures.hxx,1,['safe'],['safety']
Safety,"// These methods are implemented in a separate translation unit;; // ""static""-ize them to avoid creating temporary QualTypes in the; // caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:90,avoid,avoid,90,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['avoid'],['avoid']
Safety,// These opcodes use indirect register addressing so; // they need special handling by codegen (currently missing).; // Therefore it is too risky to allow these opcodes; // to be selected by dpp combiner or sdwa peepholer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:140,risk,risky,140,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['risk'],['risky']
Safety,// These operations approximately do the following (while avoiding undefined; // shifts by BW):; // G_FSHL: (X << (Z % BW)) | (Y >> (BW - (Z % BW))); // G_FSHR: (X << (BW - (Z % BW))) | (Y >> (Z % BW)),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:58,avoid,avoiding,58,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['avoid'],['avoiding']
Safety,// These properties are detected only on the root node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:24,detect,detected,24,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['detect'],['detected']
Safety,"// These restrictions can modify the slot masks in the instructions; // in the Packet member, but they can also detect constraint failures; // which are fatal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp:112,detect,detect,112,interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/MCTargetDesc/HexagonShuffler.cpp,1,['detect'],['detect']
Safety,"// These symbols are internal in the Itanium ABI, so the names don't matter.; // Clang has traditionally used this symbol and allowed LLVM to adjust it to; // avoid duplicate symbols.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:159,avoid,avoid,159,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['avoid'],['avoid']
Safety,// These tokens have custom code in AvoidConcat.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:36,Avoid,AvoidConcat,36,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,1,['Avoid'],['AvoidConcat']
Safety,"// These two are somewhat redundant given the caller; // (ABIInfo::isHomogeneousAggregate) checks the bases and fields, but that; // caller doesn't consider empty bases/fields to be non-homogenous, but it; // looks like Microsoft's AArch64 ABI does care about these empty types &; // anything containing/derived from one is non-homogeneous.; // Instead we could add another CXXABI entry point to query this property and; // have ABIInfo::isHomogeneousAggregate use that property.; // I don't think any other of the features listed above could be true of a; // base/field while not true of the outer struct. For example, if you have a; // base/field that has an non-trivial copy assignment/dtor/default ctor, then; // the outer struct's corresponding operation must be non-trivial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:26,redund,redundant,26,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['redund'],['redundant']
Safety,"// These two computations may sign-overflow. Here is why that is okay:; //; // We know that the induction variable does not sign-overflow on any; // iteration except the last one, and it starts at `Start` and ends at; // `End`, decrementing by one every time.; //; // * if `Smallest` sign-overflows we know `End` is `INT_SMAX`. Since the; // induction variable is decreasing we know that the smallest value; // the loop body is actually executed with is `INT_SMIN` == `Smallest`.; //; // * if `Greatest` sign-overflows, we know it can only be `INT_SMIN`. In; // that case, `Clamp` will always return `Smallest` and; // [`Result.LowLimit`, `Result.HighLimit`) = [`Smallest`, `Smallest`); // will be an empty range. Returning an empty range is always safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:749,safe,safe,749,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['safe'],['safe']
Safety,"// These two structs share a common prefix, so we can safely rely on the fact; // that they overlap in the union.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h:54,safe,safely,54,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCTargetAsmParser.h,1,['safe'],['safely']
Safety,// These variables manage the list of processed object files.; // The mutex and condition variable are to ensure that this is thread safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp:133,safe,safe,133,interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Classic/DWARFLinker.cpp,1,['safe'],['safe']
Safety,"// This (complex pattern) function is meant to detect a sign-extension; // i32->i64 on a per-operand basis. This would allow writing single; // patterns that would cover a number of combinations of different ways; // a sign-extensions could be written. For example:; // (mul (DetectUseSxtw x) (DetectUseSxtw y)) -> (M2_dpmpyss_s0 x y); // could match either one of these:; // (mul (sext x) (sext_inreg y)); // (mul (sext-load *p) (sext_inreg y)); // (mul (sext_inreg x) (sext y)); // etc.; //; // The returned value will have type i64 and its low word will; // contain the value being extended. The high bits are not specified.; // The returned type is i64 because the original type of N was i64,; // but the users of this function should only use the low-word of the; // result, e.g.; // (mul sxtw:x, sxtw:y) -> (M2_dpmpyss_s0 (LoReg sxtw:x), (LoReg sxtw:y))",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp:47,detect,detect,47,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp,3,"['Detect', 'detect']","['DetectUseSxtw', 'detect']"
Safety,"// This DBG_VALUE would re-order assignments. If we can't copy-propagate; // it, it can't be recovered. Set it undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:93,recover,recovered,93,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['recover'],['recovered']
Safety,// This SMRD hazard only affects SI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:13,hazard,hazard,13,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,// This aborts the entire analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:8,abort,aborts,8,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['abort'],['aborts']
Safety,"// This algorithm has worst case complexity of O(3^n), where 'n' is the number; // of common loop levels. To avoid excessive compile-time, pessimize all the; // results and immediately return when the number of common levels is beyond; // the given threshold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp:109,avoid,avoid,109,interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceAnalysis.cpp,1,['avoid'],['avoid']
Safety,// This algorithm requires a reasonably low use count before finding a match; // to avoid uselessly blowing up compile time in large blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp:84,avoid,avoid,84,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGSDNodes.cpp,1,['avoid'],['avoid']
Safety,"// This analysis aims to remove redundant DBG_VALUEs by going backward; // in the basic block and removing all but the last DBG_VALUE for any; // given variable in a set of consecutive DBG_VALUE instructions.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) DBG_VALUE $esi, !""var2"", ...; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,redund,redundant,32,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,1,['redund'],['redundant']
Safety,"// This analysis aims to remove redundant DBG_VALUEs by going forward; // in the basic block by considering the first DBG_VALUE as a valid; // until its first (location) operand is not clobbered/modified.; // For example:; // (1) DBG_VALUE $edi, !""var1"", ...; // (2) <block of code that does affect $edi>; // (3) DBG_VALUE $edi, !""var1"", ...; // ...; // in this case, we can remove (3).; // TODO: Support DBG_VALUE_LIST and other debug instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:32,redund,redundant,32,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,1,['redund'],['redundant']
Safety,"// This assertion currently fails because of; // TClass *c1 = TClass::GetClass(""basic_iostream<char,char_traits<char> >"");; // TClass *c2 = TClass::GetClass(""std::iostream"");; // where the TClassEdit normalized name of iostream is basic_iostream<char>; // i.e missing the addition of the default parameter. This is because TClingLookupHelper; // uses only 'part' of TMetaUtils::GetNormalizedName.; // if (!cl) {; // TDataType* dataType = (TDataType*)gROOT->GetListOfTypes()->FindObject(name);; // TClass *altcl = dataType ? (TClass*)gROOT->GetListOfClasses()->FindObject(dataType->GetFullTypeName()) : 0;; // if (altcl && normalizedName != altcl->GetName()); // ::Fatal(""TClass::GetClass"",""The existing name (%s) for %s is different from the normalized name: %s\n"",; // altcl->GetName(), name, normalizedName.c_str());; // }; // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; // However, we don't need this special treatement in rootcling (there is no auto-parsing); // and we want to make that the TClass for the pair goes through the regular creation; // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; // kEmulated state) so that they have proper interpreter (ClassInfo) information which; // will be used to create the TProtoClass (if one is requested for the pair).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:840,avoid,avoid,840,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['avoid'],['avoid']
Safety,// This avoids allowing strings where the same flag bit appears twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:8,avoid,avoids,8,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['avoid'],['avoids']
Safety,"// This avoids any chances of creating a REPLICATE recipe during planning; // since that would result in generation of scalarized code during execution,; // which is not supported for scalable vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:8,avoid,avoids,8,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avoid'],['avoids']
Safety,// This avoids essentially the same error being reported multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp:8,avoid,avoids,8,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp,1,['avoid'],['avoids']
Safety,"// This avoids the complaint from RecursiveRemove about the file being deleted which is here; // spurrious. (see RecursiveRemove).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx:8,avoid,avoids,8,io/io/src/TFileMerger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileMerger.cxx,1,['avoid'],['avoids']
Safety,"// This becomes the new argv[0]. The value is used to detect libc++ include; // dirs on Mac, it isn't used for other platforms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp:54,detect,detect,54,interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/CompilationDatabase.cpp,1,['detect'],['detect']
Safety,// This can cause a redundant sltiu to be generated.; // FIXME: try and eliminate this in a future patch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp:20,redund,redundant,20,interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsFastISel.cpp,1,['redund'],['redundant']
Safety,"// This can happen if the declaration is merely mergeable and not; // actually redeclarable (we looked for redeclarations earlier).; //; // FIXME: We should be able to detect this more efficiently, without; // pulling in all of the members of CanonDef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:168,detect,detect,168,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['detect'],['detect']
Safety,// This can only happen along a recovery path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:32,recover,recovery,32,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recovery']
Safety,"// This case happens when EnableThreadSafety is first called from; // the interpreter function we just handled.; // Since thread safety was not enabled at the time we rewound, there was; // no lock taken and even-though we should be locking the rest of this; // interpreter handling/modifying code (since there might be threads in; // flight), we can't because there would not be any lock guard to release the; // locks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:129,safe,safety,129,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['safe'],['safety']
Safety,// This cast is safe because isSelfExpr is only true within; // methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:16,safe,safe,16,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,1,['safe'],['safe']
Safety,// This castAs is safe: methods that don't return an object; // pointer won't be inferred as inits and will reject an explicit; // objc_method_family(init).; // We ignore protocols here. Should we? What about Class?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:18,safe,safe,18,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['safe'],['safe']
Safety,"// This check is here to avoid asserts in debug mode (LLVMDEV env variable set)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:25,avoid,avoid,25,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['avoid'],['avoid']
Safety,// This check is redundant except for look ahead. This function is; // called for lookahead by isProfitableToTailDup when BB hasn't been; // placed yet.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:17,redund,redundant,17,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['redund'],['redundant']
Safety,// This check is redundant with one in visitLocalVariable().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:17,redund,redundant,17,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['redund'],['redundant']
Safety,// This checker detects the subtyping relationships using the assignment; // rules. In order to be able to do this the kindofness must be stripped; // first. The checker treats every type as kindof type anyways: when the; // tracked type is the subtype of the static type it tries to look up the; // methods in the tracked type first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:16,detect,detects,16,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,1,['detect'],['detects']
Safety,// This checker try not to assume anything about placement and overloaded; // new to avoid false positives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:85,avoid,avoid,85,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,1,['avoid'],['avoid']
Safety,"// This checks for hazards associated with inline asm statements.; // Since inline asms can contain just about anything, we use this; // to call/leverage other check*Hazard routines. Note that; // this function doesn't attempt to address all possible inline asm; // hazards (good luck), but is a collection of what has been; // problematic thus far.; // see checkVALUHazards()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:19,hazard,hazards,19,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,3,"['Hazard', 'hazard']","['Hazard', 'hazards']"
Safety,// This checks for the hazard where VMEM instructions that store more than; // 8 bytes can have there store data over written by the next instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:23,hazard,hazard,23,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,// This class clean up the erroneous/redundant code around the given ranges in; // file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:37,redund,redundant,37,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['redund'],['redundant']
Safety,"// This class doesn't know about the latency of a load instruction. So, it; // conservatively/pessimistically assumes that the latency of a load opcode; // matches the instruction latency.; //; // FIXME: In the absence of cache misses (i.e. L1I/L1D/iTLB/dTLB hits/misses),; // and load/store conflicts, the latency of a load is determined by the depth; // of the load pipeline. So, we could use field `LoadLatency` in the; // MCSchedModel to model that latency.; // Field `LoadLatency` often matches the so-called 'load-to-use' latency from; // L1D, and it usually already accounts for any extra latency due to data; // forwarding.; // When doing throughput analysis, `LoadLatency` is likely to; // be a better predictor of load latency than instruction latency. This is; // particularly true when simulating code with temporal/spatial locality of; // memory accesses.; // Using `LoadLatency` (instead of the instruction latency) is also expected; // to improve the load queue allocation for long latency instructions with; // folded memory operands (See PR39829).; //; // FIXME: On some processors, load/store operations are split into multiple; // uOps. For example, X86 AMD Jaguar natively supports 128-bit data types, but; // not 256-bit data types. So, a 256-bit load is effectively split into two; // 128-bit loads, and each split load consumes one 'LoadQueue' entry. For; // simplicity, this class optimistically assumes that a load instruction only; // consumes one entry in the LoadQueue. Similarly, store instructions only; // consume a single entry in the StoreQueue.; // In future, we should reassess the quality of this design, and consider; // alternative approaches that let instructions specify the number of; // load/store queue entries which they consume at dispatch stage (See; // PR39830).; //; // An instruction that both 'mayStore' and 'HasUnmodeledSideEffects' is; // conservatively treated as a store barrier. It forces older store to be; // executed before newer stores are is",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:711,predict,predictor,711,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h,1,['predict'],['predictor']
Safety,"// This class is used to manage RVVType, RVVType should only created by this; // class, also provided thread-safe cache capability.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h:109,safe,safe,109,interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h,1,['safe'],['safe']
Safety,"// This cleanupret isn't the only predecessor of this cleanuppad, it wouldn't; // be safe to merge without code duplication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:85,safe,safe,85,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,// This code avoids CallLowering fail inside getVectorTypeBreakdown; // on v3i1 arguments. Maybe we need to return 1 for all types.; // TODO: remove it once this case is supported by the default implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp:13,avoid,avoids,13,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp,1,['avoid'],['avoids']
Safety,// This code avoids CallLowering fail inside getVectorTypeBreakdown; // on v3i1 arguments. Maybe we need to return i32 for all types.; // TODO: remove it once this case is supported by the default implementation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp:13,avoid,avoids,13,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVISelLowering.cpp,1,['avoid'],['avoids']
Safety,// This code is only meant to handle reading undefined subregisters which; // we couldn't properly detect before.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp:99,detect,detect,99,interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VirtRegMap.cpp,1,['detect'],['detect']
Safety,"// This combine may end up running before ptrtoint/inttoptr combines; // manage to eliminate redundant conversions, so try to look through them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:93,redund,redundant,93,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['redund'],['redundant']
Safety,"// This combine needs to run after all reassociations/folds on pointer; // addressing have been done, specifically those that combine two G_PTR_ADDs; // with constant offsets into a single G_PTR_ADD with a combined offset.; // The goal of this optimization is to undo that combine in the case where; // doing so has prevented the formation of pair stores due to illegal; // addressing modes of STP. The reason that we do it here is because; // it's much easier to undo the transformation of a series consecutive; // mem ops, than it is to detect when doing it would be a bad idea looking; // at a single G_PTR_ADD in the reassociation/ptradd_immed_chain combine.; //; // An example:; // G_STORE %11:_(<2 x s64>), %base:_(p0) :: (store (<2 x s64>), align 1); // %off1:_(s64) = G_CONSTANT i64 4128; // %p1:_(p0) = G_PTR_ADD %0:_, %off1:_(s64); // G_STORE %11:_(<2 x s64>), %p1:_(p0) :: (store (<2 x s64>), align 1); // %off2:_(s64) = G_CONSTANT i64 4144; // %p2:_(p0) = G_PTR_ADD %0:_, %off2:_(s64); // G_STORE %11:_(<2 x s64>), %p2:_(p0) :: (store (<2 x s64>), align 1); // %off3:_(s64) = G_CONSTANT i64 4160; // %p3:_(p0) = G_PTR_ADD %0:_, %off3:_(s64); // G_STORE %11:_(<2 x s64>), %17:_(p0) :: (store (<2 x s64>), align 1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp:539,detect,detect,539,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64PostLegalizerCombiner.cpp,1,['detect'],['detect']
Safety,"// This configuration parameter is stored in the RooAbsOptTestStatistic.; // It would have been cleaner to move the member variable into RooAbsTestStatistic,; // but to avoid incrementing the class version we do the dynamic_cast trick.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsTestStatistic.cxx:169,avoid,avoid,169,roofit/roofitcore/src/RooAbsTestStatistic.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsTestStatistic.cxx,2,['avoid'],['avoid']
Safety,// This constructor is used in installing an empty BackendConsumer; // to use the clang diagnostic handler for IR input files. It avoids; // initializing the OS field.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h:130,avoid,avoids,130,interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendConsumer.h,2,['avoid'],['avoids']
Safety,"// This copies the contents of the string, however the next offset; // is at aligned length, the extra space that might be created due; // to alignment padding is not populated with any specific value; // here. This would be safe as long as runtime is sync with; // the offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:225,safe,safe,225,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,1,['safe'],['safe']
Safety,"// This could be avoided if CopyFromCache was used in SendFile",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:17,avoid,avoided,17,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['avoid'],['avoided']
Safety,"// This could be removed, sanity check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx:26,sanity check,sanity check,26,hist/hist/src/TSpline.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSpline.cxx,1,['sanity check'],['sanity check']
Safety,"// This counter in the sequential case collects errors coming also from; // different files (suppose to have a program reading f1.root, f2.root ...); // In the mt case, it is made atomic: it safely collects errors from; // different files processed simultaneously.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:191,safe,safely,191,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['safe'],['safely']
Safety,"// This counter is used to avoid same type names. e.g., there would be; // many i32 and i64 types in one coroutine. And we would use i32_0 and; // i32_1 to avoid the same type. Since it makes no sense the name of the; // fields confilicts with each other.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,2,['avoid'],['avoid']
Safety,// This division is eligible for optimization only if global unsafe math; // is enabled or if this division allows reciprocal formation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:61,unsafe,unsafe,61,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['unsafe'],['unsafe']
Safety,"// This duplicates some functionality from Darwin::AddDeploymentTarget; // but this function is well defined, so keep it decoupled from the driver; // and avoid unrelated complications.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp:155,avoid,avoid,155,interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/ARCMT.cpp,1,['avoid'],['avoid']
Safety,"// This estimate can be improved if we had harder guarantees about stack frame; // layout. With LocalStackAllocation we can estimate SP offset to any; // preallocated slot. AArch64FrameLowering::orderFrameObjects could put tagged; // objects ahead of non-tagged ones, but that's not always desirable.; //; // Underestimating SP offset here may require the use of LDG to materialize; // the tagged address of the stack slot, along with a scratch register; // allocation (post-regalloc!).; //; // For now we do the safe thing here and require that the entire stack frame; // is within range of the shortest of the unchecked instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTaggingPreRA.cpp:513,safe,safe,513,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTaggingPreRA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTaggingPreRA.cpp,1,['safe'],['safe']
Safety,// This explicit instantiation declaration is redundant (that's okay).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:46,redund,redundant,46,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['redund'],['redundant']
Safety,"// This flag tells the linker that no global symbols contain code that fall; // through to other global symbols (e.g. an implementation of multiple entry; // points). If this doesn't occur, the linker can safely perform dead code; // stripping. Since LLVM never generates code that does this, it is always; // safe to set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp:205,safe,safely,205,interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86AsmPrinter.cpp,2,['safe'],"['safe', 'safely']"
Safety,"// This flag will fully abort the analysis, so don't bother with anything; // else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:24,abort,abort,24,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['abort'],['abort']
Safety,// This form of the function only exists to avoid ambiguous overload; // warnings about whether to convert Idx to ArrayRef<Constant *> or; // ArrayRef<Value *>.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h:44,avoid,avoid,44,interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,2,['avoid'],['avoid']
Safety,"// This function calculates a penalty for executing Call in F.; //; // There are two ways this function can be called:; // (1) F:; // call from F -> G (the call here is Call); //; // For (1), Call.getCaller() == F, so it will always return a high cost if; // a streaming-mode change is required (thus promoting the need to inline the; // function); //; // (2) F:; // call from F -> G (the call here is not Call); // G:; // call from G -> H (the call here is Call); //; // For (2), if after inlining the body of G into F the call to H requires a; // streaming-mode change, and the call to G from F would also require a; // streaming-mode change, then there is benefit to do the streaming-mode; // change only once and avoid inlining of G into F.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:717,avoid,avoid,717,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['avoid'],['avoid']
Safety,"// This function can be called for the same register with different; // lane masks. If the def in this instruction was for the whole; // register, we can get here more than once. Avoid adding multiple; // implicit uses (or adding an implicit use when an explicit one is; // present).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:179,Avoid,Avoid,179,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['Avoid'],['Avoid']
Safety,"// This function does a whole lot of voodoo to determine if the tests are; // equivalent without and with a mask. Essentially what happens is that given a; // DAG resembling:; //; // +-------------+ +-------------+ +-------------+ +-------------+; // | Input | | AddConstant | | CompConstant| | CC |; // +-------------+ +-------------+ +-------------+ +-------------+; // | | | |; // V V | +----------+; // +-------------+ +----+ | |; // | ADD | |0xff| | |; // +-------------+ +----+ | |; // | | | |; // V V | |; // +-------------+ | |; // | AND | | |; // +-------------+ | |; // | | |; // +-----+ | |; // | | |; // V V V; // +-------------+; // | CMP |; // +-------------+; //; // The AND node may be safely removed for some combinations of inputs. In; // particular we need to take into account the extension type of the Input,; // the exact values of AddConstant, CompConstant, and CC, along with the nominal; // width of the input (this can work for any width inputs, the above graph is; // specific to 8 bits.; //; // The specific equations were worked out by generating output tables for each; // AArch64CC value in terms of and AddConstant (w1), CompConstant(w2). The; // problem was simplified by working with 4 bit inputs, which means we only; // needed to reason about 24 distinct bit patterns: 8 patterns unique to zero; // extension (8,15), 8 patterns unique to sign extensions (-8,-1), and 8; // patterns present in both extensions (0,7). For every distinct set of; // AddConstant and CompConstants bit patterns we can consider the masked and; // unmasked versions to be equivalent if the result of this function is true for; // all 16 distinct bit patterns of for the current extension type of Input (w0).; //; // sub w8, w0, w1; // and w10, w8, #0x0f; // cmp w8, w2; // cset w9, AArch64CC; // cmp w10, w2; // cset w11, AArch64CC; // cmp w9, w11; // cset w0, eq; // ret; //; // Since the above function shows when the outputs are equivalent it defines; // when it is safe to remove the A",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:702,safe,safely,702,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['safe'],['safely']
Safety,// This function has the unsafe stack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:25,unsafe,unsafe,25,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['unsafe'],['unsafe']
Safety,"// This function is basically a switch over the CFI failure kind, which is; // extracted from CFICheckFailData (1st function argument). Each case is either; // llvm.trap or a call to one of the two runtime handlers, based on; // -fsanitize-trap and -fsanitize-recover settings. Default case (invalid; // failure kind) traps, but this should really never happen. CFICheckFailData; // can be nullptr if the calling module has -fsanitize-trap behavior for this; // check kind; in this case __cfi_check_fail traps as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:260,recover,recover,260,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['recover'],['recover']
Safety,"// This function is called once ""New"" is essentially complete, but before a; // previous declaration is attached. We can't query the linkage of ""New"" in; // general, because attaching the previous declaration can change the; // linkage of New to match the previous declaration.; //; // However, because we've just determined that there is no *visible* prior; // declaration, we can compute the linkage here. There are two possibilities:; //; // * This is not a redeclaration; it's safe to compute the linkage now.; //; // * This is a redeclaration of a prior declaration that is externally; // redeclarable. In that case, the linkage of the declaration is not; // changed by attaching the prior declaration, because both are externally; // declarable (and thus ExternalLinkage or VisibleNoLinkage).; //; // FIXME: This is subtle and fragile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:481,safe,safe,481,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['safe'],['safe']
Safety,// This function is hot. Check whether the value has any metadata to avoid a; // DenseMap lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:69,avoid,avoid,69,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,3,['avoid'],['avoid']
Safety,// This function is strictly redundant to; // LLVMCountParamTypes(LLVMGlobalGetValueType(FnRef)),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:29,redund,redundant,29,interpreter/llvm-project/llvm/lib/IR/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp,1,['redund'],['redundant']
Safety,"// This function is used when removing elements: when a vector is compared; // to a non-vector or a scalable vector to any non-scalable MVT, it should; // return false (to avoid removal).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:172,avoid,avoid,172,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['avoid'],['avoid']
Safety,"// This function maintains a map for the pairs <TOC Save Instr, Keep>; // Each time a new TOC save is encountered, it checks if any of the existing; // ones are dominated by the new one. If so, it marks the existing one as; // redundant by setting it's entry in the map as false. It then adds the new; // instruction to the map with either true or false depending on if any; // existing instructions dominated the new one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:227,redund,redundant,227,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redund'],['redundant']
Safety,"// This function may be called only a small fixed amount of times per each; // invocation, otherwise we do actually have a leak which we want to report.; // If this function is called more than kGraveYardMaxSize times, the pointers; // will not be properly buried and a leak detector will report a leak, which; // is what we want in such case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BuryPointer.cpp:275,detect,detector,275,interpreter/llvm-project/llvm/lib/Support/BuryPointer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BuryPointer.cpp,1,['detect'],['detector']
Safety,"// This function only makes sense for postdominators.; // We define roots to be some set of CFG nodes where (reverse) DFS walks have; // to start in order to visit all the CFG nodes (including the; // reverse-unreachable ones).; // When the search for non-trivial roots is done it may happen that some of; // the non-trivial roots are reverse-reachable from other non-trivial roots,; // which makes them redundant. This function removes them from the set of; // input roots.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:404,redund,redundant,404,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['redund'],['redundant']
Safety,"// This function removes any redundant load immediates. It has two level; // loops - The outer loop finds the load immediates BBI that could be used; // to replace following redundancy. The inner loop scans instructions that; // after BBI to find redundancy and update kill/dead flags accordingly. If; // AfterBBI is the same as BBI, it is redundant, otherwise any instructions; // that modify the def register of BBI would break the scanning.; // DeadOrKillToUnset is a pointer to the previous operand that had the; // kill/dead flag set. It keeps track of the def register of BBI, the use; // registers of AfterBBIs and the def registers of AfterBBIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:29,redund,redundant,29,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,4,['redund'],"['redundancy', 'redundant']"
Safety,"// This function removes redundant pairs of accumulator prime/unprime; // instructions. In some situations, it's possible the compiler inserts an; // accumulator prime instruction followed by an unprime instruction (e.g.; // when we store an accumulator after restoring it from a spill). If the; // accumulator is not used between the two, they can be removed. This; // function removes these redundant pairs from basic blocks.; // The algorithm is quite straightforward - every time we encounter a prime; // instruction, the primed register is added to a candidate set. Any use; // other than a prime removes the candidate from the set and any de-prime; // of a current candidate marks both the prime and de-prime for removal.; // This way we ensure we only remove prime/de-prime *pairs* with no; // intervening uses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:25,redund,redundant,25,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,2,['redund'],['redundant']
Safety,"// This function safely closes a file descriptor. It is not safe to retry; // close(2) when it returns with errno equivalent to EINTR; this is because; // *nixen cannot agree if the file descriptor is, in fact, closed when this; // occurs.; //; // N.B. Some operating systems, due to thread cancellation, cannot properly; // guarantee that it will or will not be closed one way or the other!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:17,safe,safely,17,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,2,['safe'],"['safe', 'safely']"
Safety,// This function should be aligned with detectExtMul() in X86ISelLowering.cpp.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp:40,detect,detectExtMul,40,interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86PartialReduction.cpp,1,['detect'],['detectExtMul']
Safety,"// This function tries to collect a bunch of potentially interesting; // nodes to improve the chains of, all at once. This might seem; // redundant, as this function gets called when visiting every store; // node, so why not let the work be done on each store as it's visited?; //; // I believe this is mainly important because mergeConsecutiveStores; // is unable to deal with merging stores of different sizes, so unless; // we improve the chains of all the potential candidates up-front; // before running mergeConsecutiveStores, it might only see some of; // the nodes that will eventually be candidates, and then not be able; // to go from a partially-merged state to the desired final; // fully-merged state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:138,redund,redundant,138,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['redund'],['redundant']
Safety,// This function will iterate over the input map containing a pair of TOC save; // instruction and a flag. The flag will be set to false if the TOC save is; // proven redundant. This function will erase from the basic block all the TOC; // saves marked as redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:167,redund,redundant,167,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,2,['redund'],['redundant']
Safety,// This gets run a separate thread to avoid stack blowout.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:38,avoid,avoid,38,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['avoid'],['avoid']
Safety,"// This hoists/decomposes div/rem ops. It should run after other sink/hoist; // passes to avoid re-sinking, but before SimplifyCFG because it can allow; // flattening of blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:90,avoid,avoid,90,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,2,['avoid'],['avoid']
Safety,"// This implementation of bit_cast is different from the C++20 one in two ways:; // - It isn't constexpr because that requires compiler support.; // - It requires trivially-constructible To, to avoid UB in the implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h:194,avoid,avoid,194,interpreter/llvm-project/llvm/include/llvm/ADT/bit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/bit.h,1,['avoid'],['avoid']
Safety,"// This implements a variety of operations on a representation of; // arbitrary precision, two's-complement, bignum integer values.; // Assumed by lowHalf, highHalf, partMSB and partLSB. A fairly safe; // and unrestricting assumption.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:196,safe,safe,196,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['safe'],['safe']
Safety,"// This implements the loading of unaligned vectors as described in; // the venerable Apple Velocity Engine overview. Specifically:; // https://developer.apple.com/hardwaredrivers/ve/alignment.html; // https://developer.apple.com/hardwaredrivers/ve/code_optimization.html; //; // The general idea is to expand a sequence of one or more unaligned; // loads into an alignment-based permutation-control instruction (lvsl; // or lvsr), a series of regular vector loads (which always truncate; // their input address to an aligned address), and a series of; // permutations. The results of these permutations are the requested; // loaded values. The trick is that the last ""extra"" load is not taken; // from the address you might suspect (sizeof(vector) bytes after the; // last requested load), but rather sizeof(vector) - 1 bytes after the; // last requested vector. The point of this is to avoid a page fault if; // the base address happened to be aligned. This works because if the; // base address is aligned, then adding less than a full vector length; // will cause the last vector in the sequence to be (re)loaded.; // Otherwise, the next vector will be fetched as you might suspect was; // necessary.; // We might be able to reuse the permutation generation from; // a different base address offset from this one by an aligned amount.; // The INTRINSIC_WO_CHAIN DAG combine will attempt to perform this; // optimization later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:888,avoid,avoid,888,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avoid'],['avoid']
Safety,// This indirection exists so we can keep assertModuleIsMaterializedImpl(); // around in release builds of Value.cpp to be linked with other code built; // in debug mode. But this avoids calling it in any of the release built code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h:180,avoid,avoids,180,interpreter/llvm-project/llvm/include/llvm/IR/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h,1,['avoid'],['avoids']
Safety,"// This instruction reference will have been resolved to a machine; // location, and a nearby DBG_VALUE created. We can safely ignore; // the instruction reference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:120,safe,safely,120,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['safe'],['safely']
Safety,"// This is ""safe"" because we would have used a ConstantExpr otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:12,safe,safe,12,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['safe'],['safe']
Safety,"// This is a bit ugly, but for MemoryPHI's, unlike PHINodes, you can't get the; // block from the operand in constant time (In a PHINode, the uselist has; // both, so it's just subtraction). We provide it as part of the; // iterator to avoid callers having to linear walk to get the block.; // If the operation becomes constant time on MemoryPHI's, this bit of; // abstraction breaking should be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:236,avoid,avoid,236,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['avoid'],['avoid']
Safety,"// This is a complete miss. We want to avoid the background tasks; // to try unzipping this block in the future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:39,avoid,avoid,39,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['avoid'],['avoid']
Safety,"// This is a cunning lie. DiagnosticBuilder actually performs move; // construction in its copy constructor (but due to varied uses, it's not; // possible to conveniently express this as actual move construction). So; // the default copy ctor here is fine, because the base class disables the; // source anyway, so the user-defined ~ImmediateDiagBuilder is a safe no-op; // in that case anwyay.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:359,safe,safe,359,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['safe'],['safe']
Safety,"// This is a declaration, nothing to do. Must exit early to avoid crash in; // dom tree calculation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:60,avoid,avoid,60,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['avoid'],['avoid']
Safety,"// This is a doubleword splat if it is of the form; // XXPERMDI t, s, s, 0 or XXPERMDI t, s, s, 3. As above we; // must look through chains of copy-likes to find the source; // register. We turn off the marking for mention of a physical; // register, because splatting it is safe; the optimization; // will not swap the value in the physical register. Whether; // or not the two input registers are identical, we can handle; // these by adjusting the form of the XXPERMDI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:275,safe,safe,275,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['safe'],['safe']
Safety,// This is a funnel/rotate that avoids shift-by-bitwidth UB in a suboptimal way.; // Convert to funnel shift intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:32,avoid,avoids,32,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['avoid'],['avoids']
Safety,"// This is a generic virtual register.; // Do not allow undef uses for generic virtual registers. This ensures; // getVRegDef can never fail and return null on a generic register.; //; // FIXME: This restriction should probably be broadened to all SSA; // MIR. However, DetectDeadLanes/ProcessImplicitDefs technically still; // run on the SSA function just before phi elimination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp:270,Detect,DetectDeadLanes,270,interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineVerifier.cpp,1,['Detect'],['DetectDeadLanes']
Safety,// This is a high-level transform that might change the constant arguments; // of the init and dinit calls. We need to tell the Attributor about this; // to avoid other parts using the current constant value for simpliication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:157,avoid,avoid,157,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['avoid'],['avoid']
Safety,"// This is a lambda call operator that is being instantiated as a default; // initializer. DC must point to the enclosing class type, so we can recover; // the 'this' type from it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:144,recover,recover,144,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['recover'],['recover']
Safety,"// This is a linear algorithm that deduplicates adjacent repeated; // sequences of size I. The deduplication detection runs on a sliding; // window whose size is 2*I and it keeps sliding the window to deduplicate; // the data inside. Once duplication is detected, deduplicate it by; // skipping the right half part of the window, otherwise just copy back; // the new one by appending them at the back of End pointer(for the next; // iteration).; //; // For example:; // Input: [a1, a2, b1, b2]; // (Added index to distinguish the same char, the origin is [a, a, b,; // b], the size of the dedup window is 2(I = 1) at the beginning); //; // 1) The initial status is a dummy window[null, a1], then just copy the; // right half of the window(End = 0), then slide the window.; // Result: [a1], a2, b1, b2 (End points to the element right before ],; // after ] is the data of the previous iteration); //; // 2) Next window is [a1, a2]. Since a1 == a2, then skip the right half of; // the window i.e the duplication happen. Only slide the window.; // Result: [a1], a2, b1, b2; //; // 3) Next window is [a2, b1], copy the right half of the window(b1 is; // new) to the End and slide the window.; // Result: [a1, b1], b1, b2; //; // 4) Next window is [b1, b2], same to 2), skip b2.; // Result: [a1, b1], b1, b2; // After resize, it will be [a, b]; // Use pointers like below to do comparison inside the window; // [a b c a b c]; // | | | | |; // LeftBoundary Left Right Left+I Right+I; // A duplication found if Left < LeftBoundry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.h:109,detect,detection,109,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.h,2,['detect'],"['detected', 'detection']"
Safety,"// This is a new PHI/Select, check for an unsafe use of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,unsafe,unsafe,42,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['unsafe'],['unsafe']
Safety,"// This is a non-ARC instruction. If we're delaying an AutoreleaseRV,; // check if it's safe to skip over it; if not, optimize the AutoreleaseRV; // now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:88,safe,safe,88,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['safe'],['safe']
Safety,"// This is a non-MSVC compiler, probably mingw gcc or clang without; // -fms-extensions. Use vectored exception handling (VEH).; //; // On Windows, we can make use of vectored exception handling to catch most; // crashing situations. Note that this does mean we will be alerted of; // exceptions *before* structured exception handling has the opportunity to; // catch it. Unfortunately, this causes problems in practice with other code; // running on threads with LLVM crash recovery contexts, so we would like to; // eventually move away from VEH.; //; // Vectored works on a per-thread basis, which is an advantage over; // SetUnhandledExceptionFilter. SetUnhandledExceptionFilter also doesn't have; // any native support for chaining exception handlers, but VEH allows more than; // one.; //; // The vectored exception handler functionality was added in Windows; // XP, so if support for older versions of Windows is required,; // it will have to be added.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:475,recover,recovery,475,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['recover'],['recovery']
Safety,"// This is a redundant AND, it should get cleaned up elsewhere.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:13,redund,redundant,13,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['redund'],['redundant']
Safety,// This is a safe instruction we can look past.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,1,['safe'],['safe']
Safety,"// This is a temp of the PatFragPattern, prefix the name to avoid; // conflicts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:60,avoid,avoid,60,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['avoid'],['avoid']
Safety,// This is almost certainly an invalid type name. Let Sema emit a diagnostic; // and attempt to recover.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:96,recover,recover,96,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Safety,// This is effectively the intersection of isTrivialType and; // isStandardLayoutType. We implement it directly to avoid redundant; // conversions from a type to a CXXRecordDecl.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp:115,avoid,avoid,115,interpreter/llvm-project/clang/lib/AST/Type.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Type.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// This is emitted right before MorphNode/EmitNode.; // So it should be safe to assume that this node has been selected,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp:72,safe,safe,72,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp,1,['safe'],['safe']
Safety,"// This is here to avoid to use the plugin manager",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:19,avoid,avoid,19,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avoid'],['avoid']
Safety,"// This is ill-formed, but provide the context that we would have; // declared the function in, if we were permitted to, for error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:131,recover,recovery,131,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recovery']
Safety,// This is lame but unavoidable in a world without forward; // declarations of enums. The alternatives are to either pollute; // Sema.h (by including this file) or sacrifice type safety (by; // making Sema.h declare things as enums).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h:179,safe,safety,179,interpreter/llvm-project/clang/include/clang/Sema/Template.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Template.h,1,['safe'],['safety']
Safety,"// This is not a micro-optimization, it avoids UB, should Borrowed be an null; // buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp:40,avoid,avoids,40,interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Demangle/MicrosoftDemangle.cpp,1,['avoid'],['avoids']
Safety,// This is not a situation that we should recover from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:42,recover,recover,42,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recover']
Safety,// This is not safe to introduce undef when the operand is on; // the right hand side of a division-like instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:15,safe,safe,15,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['safe'],['safe']
Safety,"// This is only allowed to execute with 1 lane, so readfirstlane is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:68,safe,safe,68,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['safe'],['safe']
Safety,// This is recovered from gcc output.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp:11,recover,recovered,11,interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/PPC.cpp,3,['recover'],['recovered']
Safety,"// This is safe because if RHS.P is the empty or tombstone key, it will have; // length 0, so we'll never dereference its pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h:11,safe,safe,11,interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CachedHashString.h,1,['safe'],['safe']
Safety,// This is similar to detectLibcxxVersion(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp:22,detect,detectLibcxxVersion,22,interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/WebAssembly.cpp,1,['detect'],['detectLibcxxVersion']
Safety,// This is temporary solution to test performance. Float should be; // replaced with round independent type (based on integers) to avoid; // different results for different target builds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:131,avoid,avoid,131,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['avoid'],['avoid']
Safety,"// This is the initial block in the chain, in case this block does other; // work, we can try to split the block and move the irrelevant; // instructions to the predecessor.; //; // If this is not the initial block in the chain, splitting it wont; // work.; //; // As once split, there will still be instructions before the BCE cmp; // instructions that do other work in program order, i.e. within the; // chain before sorting. Unless we can abort the chain at this point; // and start anew.; //; // NOTE: we only handle blocks a with single predecessor for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:442,abort,abort,442,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['abort'],['abort']
Safety,"// This is the last template parameter in the template declaration; // but it is signaling that there can be an arbitrary number of arguments; // in the template instance. So to avoid inadvertenly dropping those; // arguments we just process all remaining argument and exit the main loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:178,avoid,avoid,178,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['avoid'],['avoid']
Safety,// This is the simple case where we are the outermost finally. All we; // have to do here is make sure we escape this and recover it in the; // outlined handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:122,recover,recover,122,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['recover'],['recover']
Safety,"// This is to avoid cases where branches called b1, b2, b3 are all matched by expression ""b""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:14,avoid,avoid,14,tree/dataframe/src/RDFInterfaceUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx,1,['avoid'],['avoid']
Safety,// This is unfortunately needed because ASTDeclWriter::VisitFunctionDecl; // need to access this bit but we want to avoid making ASTDeclWriter; // a friend of FunctionDeclBitfields just for this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:116,avoid,avoid,116,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['avoid'],['avoid']
Safety,// This is used on UImm5 operands that have a corresponding UImm5_32; // operand to avoid confusing the user.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:84,avoid,avoid,84,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['avoid'],['avoid']
Safety,"// This is used to avoid unwanted recursive call to Build and make sure; // that we record the execution of BuildOld.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:19,avoid,avoid,19,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['avoid'],['avoid']
Safety,"// This is used to avoid unwanted recursive call to Build or BuildOld.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:19,avoid,avoid,19,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,1,['avoid'],['avoid']
Safety,"// This is where all the tests are called. If the user wants to add; // new tests or avoid executing one of the existing ones, it is; // here where they should do it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/test/UnitTesting.cxx:85,avoid,avoid,85,gui/fitpanel/test/UnitTesting.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanel/test/UnitTesting.cxx,1,['avoid'],['avoid']
Safety,"// This isn't 100% accurate, but it's safe.; // It won't detect (as a kill) a case like this; // r0 = add r0, 1 <-- r0 should be ""killed""; // ... = r0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp:38,safe,safe,38,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonGenMux.cpp,2,"['detect', 'safe']","['detect', 'safe']"
Safety,"// This isn't particularly efficient, but is only for error-recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp:60,recover,recovery,60,interpreter/llvm-project/llvm/lib/Support/JSON.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp,1,['recover'],['recovery']
Safety,"// This isn't really legal, but this avoids the legalizer unrolling it (and; // allows matching fneg (fabs x) patterns)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:37,avoid,avoids,37,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// This isn't safe with signaling NaNs because in IEEE mode, min/max on a; // signaling NaN gives a quiet NaN. The quiet NaN input to the min would; // then give the other result, which is different from med3 with a NaN; // input.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:14,safe,safe,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['safe'],['safe']
Safety,"// This isn't strictly true. If the user were to provide exactly the same; // matchers as the original operand then we could allow it. However, it's; // simpler to not permit the redundant specification.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp:179,redund,redundant,179,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelEmitter.cpp,1,['redund'],['redundant']
Safety,// This leading byte is used by the reading code to detect the root node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp:52,detect,detect,52,interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/UnicodeData/UnicodeNameMappingGenerator.cpp,1,['detect'],['detect']
Safety,// This loop scans instructions after BBI to see if there is any; // redundant load immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:69,redund,redundant,69,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,1,['redund'],['redundant']
Safety,"// This map keeps track of the number of ""unsafe"" uses of a loaded function; // pointer. The key is the associated llvm.type.test intrinsic call generated; // by this pass. An unsafe use is one that calls the loaded function pointer; // directly. Every time we eliminate an unsafe use (for example, by; // devirtualizing it or by applying virtual constant propagation), we; // decrement the value stored in this map. If a value reaches zero, we can; // eliminate the type check by RAUWing the associated llvm.type.test call with; // true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:42,unsafe,unsafe,42,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,3,['unsafe'],['unsafe']
Safety,// This maps an original source AST to it's rewritten form. This allows; // us to avoid rewriting the same node twice (which is very uncommon).; // This is needed to support some of the exotic property rewriting.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:82,avoid,avoid,82,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['avoid'],['avoid']
Safety,"// This may not belong here. This function is effectively being overloaded; // to both detect an intrinsic which needs upgrading, and to provide the; // upgraded form of the intrinsic. We should perhaps have two separate; // functions for this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp:87,detect,detect,87,interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/AutoUpgrade.cpp,1,['detect'],['detect']
Safety,"// This might be a recursive call, and we might have DeadInsts already; // populated. To avoid bad things happening later with multiple vreg defs; // etc, process the dead instructions now if any.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h:89,avoid,avoid,89,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,1,['avoid'],['avoid']
Safety,"// This might seem conter-intuitive at first glance, but the functions are; // closely related. Reasoning about destructors depends only on the type; // of the expression that initialized the memory region, which is the; // CXXConstructExpr. So to avoid code repetition, the work is delegated; // to the function that reasons about destructor inlining. Also note that; // if the constructors of the array elements are inlined, the destructors; // can also be inlined and if the destructors can be inline, it's safe to; // inline the constructors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:248,avoid,avoid,248,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// This needs to be outside of the namespace, to avoid conflict with llvm-c; // decl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h:49,avoid,avoid,49,interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DataLayout.h,1,['avoid'],['avoid']
Safety,// This only judges whether it is a safe *stack* access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp:36,safe,safe,36,interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/StackSafetyAnalysis.cpp,1,['safe'],['safe']
Safety,"// This only seems to need to be movable (by ARMOperand) but ARMOperand has; // lots of members and MSVC doesn't support defaulted move ops, so to avoid; // that verbosity, just rely on defaulted copy ops. It's only the Constraint; // string member that would benefit from movement anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCParsedAsmOperand.h:147,avoid,avoid,147,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCParsedAsmOperand.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCParsedAsmOperand.h,1,['avoid'],['avoid']
Safety,// This operation also isn't safe when the operands aren't also booleans.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:29,safe,safe,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['safe'],['safe']
Safety,"// This operation also isn't safe with AND, OR, XOR when the boolean type is; // 0/1 and the select operands aren't also booleans, as we need an all-ones; // vector constant to mask with.; // FIXME: Sign extend 1 to all ones if that's legal on the target.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp:29,safe,safe,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorOps.cpp,1,['safe'],['safe']
Safety,// This overloads expiry testing with all the hazard detection,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:46,hazard,hazard,46,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,4,"['detect', 'hazard']","['detection', 'hazard']"
Safety,"// This pass expands branches and takes care about the forbidden slot hazards.; // Expanding branches may potentially create forbidden slot hazards for; // MIPSR6, and fixing such hazard may potentially break a branch by extending; // its offset out of range. That's why this pass combine these two tasks, and; // runs them alternately until one of them finishes without any changes. Only; // then we can be sure that all branches are expanded properly and no hazards; // exists.; // Any new pass should go before this pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp:70,hazard,hazards,70,interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsTargetMachine.cpp,4,['hazard'],"['hazard', 'hazards']"
Safety,// This pseudo-feature tells the linker whether shared memory would be safe,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp:71,safe,safe,71,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyAsmPrinter.cpp,1,['safe'],['safe']
Safety,"// This relies on two's complement wraparound when N == 64, so we convert to; // int64_t only at the very end to avoid UB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h:113,avoid,avoid,113,interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/MathExtras.h,1,['avoid'],['avoid']
Safety,// This required for .td selection patterns to work or we'd end up with RegClass; // checks being redundant as all the classes would be mapped to the same bank.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp:98,redund,redundant,98,interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SPIRV/SPIRVRegisterBankInfo.cpp,1,['redund'],['redundant']
Safety,"// This resets the lists to avoid the problem fixed in protocol 33",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofNodes.cxx:28,avoid,avoid,28,proof/proofbench/src/TProofNodes.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TProofNodes.cxx,1,['avoid'],['avoid']
Safety,// This scope can be safely ignored and eliminating it will reduce the; // size of the debug information. Be sure to collect any variable and scope; // information from the this scope or any of its children and collapse them; // into the parent scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:21,safe,safely,21,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['safe'],['safely']
Safety,// This section requires special OS-specific processing to avoid incorrect; // behavior.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:59,avoid,avoid,59,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,1,['avoid'],['avoid']
Safety,// This set contains poisoned defs. They can be safely ignored during; // verification too.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:48,safe,safely,48,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['safe'],['safely']
Safety,"// This set is used to record the generic mergeable section names seen.; // These are sections that are created as mergeable e.g. .debug_str. We need; // to avoid assigning non-mergeable symbols to these sections. It is used; // to prevent non-mergeable symbols being explicitly assigned to mergeable; // sections (e.g. via _attribute_((section(""myname"")))).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h:157,avoid,avoid,157,interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,1,['avoid'],['avoid']
